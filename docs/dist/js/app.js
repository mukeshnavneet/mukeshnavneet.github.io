/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scss_app_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scss/app.scss */ \"./src/scss/app.scss\");\n/* harmony import */ var _demo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./demo.js */ \"./src/js/demo.js\");\n/* harmony import */ var _rocket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rocket.js */ \"./src/js/rocket.js\");\n/* harmony import */ var _button_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./button.js */ \"./src/js/button.js\");\n\n/* Your JS Code goes here */\n\n/* Demo JS */\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHdlYXJlYXRobG9uL2Zyb250ZW5kLXdlYnBhY2stYm9pbGVycGxhdGUvLi9zcmMvanMvYXBwLmpzPzkwZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuLi9zY3NzL2FwcC5zY3NzJztcclxuLyogWW91ciBKUyBDb2RlIGdvZXMgaGVyZSAqL1xyXG5cclxuLyogRGVtbyBKUyAqL1xyXG5pbXBvcnQgJy4vZGVtby5qcyc7XHJcbmltcG9ydCAnLi9yb2NrZXQuanMnO1xyXG5pbXBvcnQgJy4vYnV0dG9uLmpzJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/app.js\n");

/***/ }),

/***/ "./src/js/button.js":
/*!**************************!*\
  !*** ./src/js/button.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/environment */ \"./src/js/utils/environment.js\");\n/* harmony import */ var rive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rive-js */ \"./node_modules/rive-js/dist/rive.dev.js\");\n/* harmony import */ var rive_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rive_js__WEBPACK_IMPORTED_MODULE_1__);\n // $.extend(verge);\n// console.log(\"$\",verge);\n// console.log(\"verge\",verge);\n// export var WIW = $.viewportW();\n// export var WIH = $.viewportH();\n// console.log(\"$document\", $document);\n\n\njQuery(document).ready(function () {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYnV0dG9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Q0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFFQUssTUFBTSxDQUFDQyxRQUFELENBQU4sQ0FBaUJDLEtBQWpCLENBQXVCLFlBQVcsQ0FFakMsQ0FGRCIsInNvdXJjZXMiOlsid2VicGFjazovL0B3ZWFyZWF0aGxvbi9mcm9udGVuZC13ZWJwYWNrLWJvaWxlcnBsYXRlLy4vc3JjL2pzL2J1dHRvbi5qcz8wNDEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ICRkb2N1bWVudCwgJHdpbmRvdywgJGh0bWwsICRib2R5IH0gZnJvbSAnLi91dGlscy9lbnZpcm9ubWVudCc7XHJcblxyXG4vLyAkLmV4dGVuZCh2ZXJnZSk7XHJcbi8vIGNvbnNvbGUubG9nKFwiJFwiLHZlcmdlKTtcclxuLy8gY29uc29sZS5sb2coXCJ2ZXJnZVwiLHZlcmdlKTtcclxuLy8gZXhwb3J0IHZhciBXSVcgPSAkLnZpZXdwb3J0VygpO1xyXG4vLyBleHBvcnQgdmFyIFdJSCA9ICQudmlld3BvcnRIKCk7XHJcblxyXG4vLyBjb25zb2xlLmxvZyhcIiRkb2N1bWVudFwiLCAkZG9jdW1lbnQpO1xyXG5pbXBvcnQgKiBhcyByaXZlIGZyb20gJ3JpdmUtanMnXHJcblxyXG5qUXVlcnkoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cclxufSk7Il0sIm5hbWVzIjpbIiRkb2N1bWVudCIsIiR3aW5kb3ciLCIkaHRtbCIsIiRib2R5Iiwicml2ZSIsImpRdWVyeSIsImRvY3VtZW50IiwicmVhZHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/button.js\n");

/***/ }),

/***/ "./src/js/demo.js":
/*!************************!*\
  !*** ./src/js/demo.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/environment */ \"./src/js/utils/environment.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var jquery_validation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery-validation */ \"./node_modules/jquery-validation/dist/jquery.validate.js\");\n/* harmony import */ var jquery_validation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_validation__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var rive_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rive-js */ \"./node_modules/rive-js/dist/rive.dev.js\");\n/* harmony import */ var rive_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(rive_js__WEBPACK_IMPORTED_MODULE_3__);\n\n\nvar imagesLoaded = __webpack_require__(/*! imagesloaded */ \"./node_modules/imagesloaded/imagesloaded.js\");\n\n\n // $.extend(verge);\n// console.log(\"$\",verge);\n// console.log(\"verge\",verge);\n// export var WIW = $.viewportW();\n// export var WIH = $.viewportH();\n// console.log(\"$document\", validate);\n\n\n\nif (document.getElementById('sample-canvas')) {\n  // Place code here\n  var animation = new rive_js__WEBPACK_IMPORTED_MODULE_3__.Rive({\n    src: 'https://cdn.rive.app/animations/off_road_car_v7.riv',\n    canvas: document.getElementById('sample-canvas') // autoplay: true,\n    // animations: ['idle', 'input_squares', 'output_squares']\n\n  });\n  animation.on('load', function () {\n    // only added animations can be scrubbed.\n    animation.pause(['green_gear']);\n    animation.scrub(['green_gear'], 0);\n\n    document.getElementsByTagName('body')[0].onscroll = function () {\n      var totalScroll = document.documentElement.scrollHeight - window.innerHeight;\n      var scrub = 1 * (window.scrollY / totalScroll).toFixed(3);\n      var scrubModifier = 3;\n      animation.scrub('green_gear', scrub * scrubModifier);\n    };\n  });\n}\n\njQuery(document).ready(function () {\n  var WIW = verge.viewportW();\n  var WIH = verge.viewportH(); // number of loaded images for preloader progress\n\n  var loadedCount = 0; //current number of images loaded\n\n  var imagesToLoad = jquery__WEBPACK_IMPORTED_MODULE_1___default()('.bcg').length; //number of slides with .bcg container\n\n  var loadingProgress = 0; //timeline progress - starts at 0\n\n  var LAUNCHER_OFFSET = 0;\n\n  if (WIW < 530) {\n    LAUNCHER_OFFSET = 0;\n  }\n\n  jquery__WEBPACK_IMPORTED_MODULE_1___default()('.bcg').imagesLoaded({\n    background: true\n  }).progress(function (instance, image) {\n    loadProgress();\n  });\n\n  function loadProgress(imgLoad, image) {\n    //one more image has been loaded\n    loadedCount++;\n    loadingProgress = loadedCount / imagesToLoad; //console.log(loadingProgress);\n    // GSAP timeline for our progress bar\n\n    TweenLite.to(progressTl, 0.7, {\n      progress: loadingProgress,\n      ease: Linear.easeNone\n    });\n  } //progress animation instance. the instance's time is irrelevant, can be anything but 0 to void  immediate render\n\n\n  var progressTl = new TimelineMax({\n    paused: true,\n    onUpdate: progressUpdate,\n    onComplete: loadComplete\n  });\n  progressTl //tween the progress bar width\n  .to(jquery__WEBPACK_IMPORTED_MODULE_1___default()('.progress span'), 1, {\n    width: 100,\n    ease: Linear.easeNone\n  });\n\n  function progressUpdate() {\n    //the percentage loaded based on the tween's progress\n    loadingProgress = Math.round(progressTl.progress() * 100); //we put the percentage in the screen\n\n    jquery__WEBPACK_IMPORTED_MODULE_1___default()(\".txt-perc\").text(loadingProgress + '%');\n  }\n\n  function loadComplete() {\n    // preloader out\n    var preloaderOutTl = new TimelineMax();\n    preloaderOutTl.to(jquery__WEBPACK_IMPORTED_MODULE_1___default()('.progress'), 0.3, {\n      y: 100,\n      autoAlpha: 0,\n      ease: Back.easeIn\n    }).to(jquery__WEBPACK_IMPORTED_MODULE_1___default()('.txt-perc'), 0.3, {\n      y: 100,\n      autoAlpha: 0,\n      ease: Back.easeIn\n    }, 0.1).set(jquery__WEBPACK_IMPORTED_MODULE_1___default()('body'), {\n      className: '-=is-loading',\n      onComplete: function onComplete() {\n        jquery__WEBPACK_IMPORTED_MODULE_1___default()('html, body').animate({\n          scrollTop: jquery__WEBPACK_IMPORTED_MODULE_1___default()(\"#land\").offset().top + LAUNCHER_OFFSET\n        }, 2000);\n      }\n    }).to(jquery__WEBPACK_IMPORTED_MODULE_1___default()('#preloader'), 0.7, {\n      yPercent: 100,\n      ease: Power4.easeInOut\n    }).set(jquery__WEBPACK_IMPORTED_MODULE_1___default()('#rocket'), {\n      scale: 1\n    }).set(jquery__WEBPACK_IMPORTED_MODULE_1___default()('#preloader'), {\n      className: '+=is-hidden' // onComplete: () => {\n      //     $('html, body').animate({\n      //         scrollTop: ($(\"#land\").offset().top) + LAUNCHER_OFFSET\n      //     }, 2000);\n      //     setTimeout(() => {\n      //         $('body').removeClass(\"is-loading\");\n      //         $('#preloader').addClass(\"is-hidden\");\n      //     }, 2000);\n      // },\n\n    });\n    return preloaderOutTl;\n  }\n\n  jquery__WEBPACK_IMPORTED_MODULE_1___default()('#myform').validate({\n    rules: {\n      field1: {\n        required: true,\n        minlength: 8,\n        maxlength: 8\n      }\n    },\n    messages: {\n      field1: {\n        required: \"Please enter your password\",\n        minlength: \"Your password must 8 characters long\"\n      }\n    },\n    submitHandler: function submitHandler(form) {\n      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(\"input\").first().val() === \"correct2\") {\n        console.log('valid form submitted');\n        document.cookie = \"isValidated=true\";\n        var wlo = window.location.origin;\n        console.log('NEW LOCs', wlo + '/intro.html');\n        window.location.href = wlo + '/intro.html';\n        return false;\n      } else {\n        console.log(\"FAIL\");\n      }\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFGUDtBQURGLEtBUlE7QUFjbEJHLElBQUFBLGFBQWEsRUFBRSx1QkFBU0MsSUFBVCxFQUFlO0FBQzFCLFVBQUk5RSw2Q0FBQyxDQUFDLE9BQUQsQ0FBRCxDQUFXK0UsS0FBWCxHQUFtQkMsR0FBbkIsT0FBNkIsVUFBakMsRUFBNkM7QUFDekNDLFFBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLHNCQUFaO0FBQ0EvRSxRQUFBQSxRQUFRLENBQUNnRixNQUFULEdBQWtCLGtCQUFsQjtBQUNBLFlBQUlDLEdBQUcsR0FBR25FLE1BQU0sQ0FBQ29FLFFBQVAsQ0FBZ0JDLE1BQTFCO0FBQ0FMLFFBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLFVBQVosRUFBd0JFLEdBQUcsR0FBRyxhQUE5QjtBQUNBbkUsUUFBQUEsTUFBTSxDQUFDb0UsUUFBUCxDQUFnQkUsSUFBaEIsR0FBdUJILEdBQUcsR0FBRyxhQUE3QjtBQUNBLGVBQU8sS0FBUDtBQUNILE9BUEQsTUFPTztBQUNISCxRQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSxNQUFaO0FBQ0g7QUFDSjtBQXpCaUIsR0FBdEI7QUE0QkgsQ0E5SEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2VhcmVhdGhsb24vZnJvbnRlbmQtd2VicGFjay1ib2lsZXJwbGF0ZS8uL3NyYy9qcy9kZW1vLmpzP2MzNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgJGRvY3VtZW50LCAkd2luZG93LCAkaHRtbCwgJGJvZHkgfSBmcm9tICcuL3V0aWxzL2Vudmlyb25tZW50JztcclxudmFyIGltYWdlc0xvYWRlZCA9IHJlcXVpcmUoJ2ltYWdlc2xvYWRlZCcpO1xyXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXHJcblxyXG5pbXBvcnQgdmFsaWRhdGUgZnJvbSAnanF1ZXJ5LXZhbGlkYXRpb24nXHJcblxyXG4vLyAkLmV4dGVuZCh2ZXJnZSk7XHJcbi8vIGNvbnNvbGUubG9nKFwiJFwiLHZlcmdlKTtcclxuLy8gY29uc29sZS5sb2coXCJ2ZXJnZVwiLHZlcmdlKTtcclxuLy8gZXhwb3J0IHZhciBXSVcgPSAkLnZpZXdwb3J0VygpO1xyXG4vLyBleHBvcnQgdmFyIFdJSCA9ICQudmlld3BvcnRIKCk7XHJcblxyXG4vLyBjb25zb2xlLmxvZyhcIiRkb2N1bWVudFwiLCB2YWxpZGF0ZSk7XHJcbmltcG9ydCAqIGFzIHJpdmUgZnJvbSAncml2ZS1qcydcclxuXHJcbmlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2FtcGxlLWNhbnZhcycpKSB7XHJcbiAgICAvLyBQbGFjZSBjb2RlIGhlcmVcclxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5ldyByaXZlLlJpdmUoe1xyXG4gICAgICAgIHNyYzogJ2h0dHBzOi8vY2RuLnJpdmUuYXBwL2FuaW1hdGlvbnMvb2ZmX3JvYWRfY2FyX3Y3LnJpdicsXHJcbiAgICAgICAgY2FudmFzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2FtcGxlLWNhbnZhcycpLFxyXG4gICAgICAgIC8vIGF1dG9wbGF5OiB0cnVlLFxyXG4gICAgICAgIC8vIGFuaW1hdGlvbnM6IFsnaWRsZScsICdpbnB1dF9zcXVhcmVzJywgJ291dHB1dF9zcXVhcmVzJ11cclxuICAgIH0pXHJcbiAgICBhbmltYXRpb24ub24oJ2xvYWQnLCAoKSA9PiB7XHJcbiAgICAgICAgLy8gb25seSBhZGRlZCBhbmltYXRpb25zIGNhbiBiZSBzY3J1YmJlZC5cclxuICAgICAgICBhbmltYXRpb24ucGF1c2UoWydncmVlbl9nZWFyJ10pXHJcbiAgICAgICAgYW5pbWF0aW9uLnNjcnViKFsnZ3JlZW5fZ2VhciddLCAwKVxyXG5cclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdLm9uc2Nyb2xsID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0b3RhbFNjcm9sbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHRcclxuICAgICAgICAgICAgY29uc3Qgc2NydWIgPSAxICogKHdpbmRvdy5zY3JvbGxZIC8gdG90YWxTY3JvbGwpLnRvRml4ZWQoMylcclxuICAgICAgICAgICAgY29uc3Qgc2NydWJNb2RpZmllciA9IDM7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbi5zY3J1YignZ3JlZW5fZ2VhcicsIHNjcnViICogc2NydWJNb2RpZmllcilcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5cclxuXHJcbmpRdWVyeShkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcbiAgICBsZXQgV0lXID0gdmVyZ2Uudmlld3BvcnRXKCk7XHJcbiAgICBsZXQgV0lIID0gdmVyZ2Uudmlld3BvcnRIKCk7XHJcblxyXG4gICAgLy8gbnVtYmVyIG9mIGxvYWRlZCBpbWFnZXMgZm9yIHByZWxvYWRlciBwcm9ncmVzc1xyXG4gICAgdmFyIGxvYWRlZENvdW50ID0gMDsgLy9jdXJyZW50IG51bWJlciBvZiBpbWFnZXMgbG9hZGVkXHJcbiAgICB2YXIgaW1hZ2VzVG9Mb2FkID0gJCgnLmJjZycpLmxlbmd0aDsgLy9udW1iZXIgb2Ygc2xpZGVzIHdpdGggLmJjZyBjb250YWluZXJcclxuICAgIHZhciBsb2FkaW5nUHJvZ3Jlc3MgPSAwOyAvL3RpbWVsaW5lIHByb2dyZXNzIC0gc3RhcnRzIGF0IDBcclxuICAgIHZhciBMQVVOQ0hFUl9PRkZTRVQgPSAwO1xyXG5cclxuICAgIGlmIChXSVcgPCA1MzApIHtcclxuICAgICAgICBMQVVOQ0hFUl9PRkZTRVQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgICQoJy5iY2cnKS5pbWFnZXNMb2FkZWQoe1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHRydWVcclxuICAgIH0pLnByb2dyZXNzKGZ1bmN0aW9uKGluc3RhbmNlLCBpbWFnZSkge1xyXG4gICAgICAgIGxvYWRQcm9ncmVzcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZFByb2dyZXNzKGltZ0xvYWQsIGltYWdlKSB7XHJcbiAgICAgICAgLy9vbmUgbW9yZSBpbWFnZSBoYXMgYmVlbiBsb2FkZWRcclxuICAgICAgICBsb2FkZWRDb3VudCsrO1xyXG4gICAgICAgIGxvYWRpbmdQcm9ncmVzcyA9IChsb2FkZWRDb3VudCAvIGltYWdlc1RvTG9hZCk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhsb2FkaW5nUHJvZ3Jlc3MpO1xyXG4gICAgICAgIC8vIEdTQVAgdGltZWxpbmUgZm9yIG91ciBwcm9ncmVzcyBiYXJcclxuICAgICAgICBUd2VlbkxpdGUudG8ocHJvZ3Jlc3NUbCwgMC43LCB7XHJcbiAgICAgICAgICAgIHByb2dyZXNzOiBsb2FkaW5nUHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgIGVhc2U6IExpbmVhci5lYXNlTm9uZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vcHJvZ3Jlc3MgYW5pbWF0aW9uIGluc3RhbmNlLiB0aGUgaW5zdGFuY2UncyB0aW1lIGlzIGlycmVsZXZhbnQsIGNhbiBiZSBhbnl0aGluZyBidXQgMCB0byB2b2lkICBpbW1lZGlhdGUgcmVuZGVyXHJcbiAgICB2YXIgcHJvZ3Jlc3NUbCA9IG5ldyBUaW1lbGluZU1heCh7XHJcbiAgICAgICAgcGF1c2VkOiB0cnVlLFxyXG4gICAgICAgIG9uVXBkYXRlOiBwcm9ncmVzc1VwZGF0ZSxcclxuICAgICAgICBvbkNvbXBsZXRlOiBsb2FkQ29tcGxldGVcclxuICAgIH0pO1xyXG5cclxuICAgIHByb2dyZXNzVGxcclxuICAgIC8vdHdlZW4gdGhlIHByb2dyZXNzIGJhciB3aWR0aFxyXG4gICAgICAgIC50bygkKCcucHJvZ3Jlc3Mgc3BhbicpLCAxLCB7XHJcbiAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICBlYXNlOiBMaW5lYXIuZWFzZU5vbmVcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKCkge1xyXG4gICAgICAgIC8vdGhlIHBlcmNlbnRhZ2UgbG9hZGVkIGJhc2VkIG9uIHRoZSB0d2VlbidzIHByb2dyZXNzXHJcbiAgICAgICAgbG9hZGluZ1Byb2dyZXNzID0gTWF0aC5yb3VuZChwcm9ncmVzc1RsLnByb2dyZXNzKCkgKiAxMDApO1xyXG4gICAgICAgIC8vd2UgcHV0IHRoZSBwZXJjZW50YWdlIGluIHRoZSBzY3JlZW5cclxuICAgICAgICAkKFwiLnR4dC1wZXJjXCIpLnRleHQobG9hZGluZ1Byb2dyZXNzICsgJyUnKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZENvbXBsZXRlKCkge1xyXG4gICAgICAgIC8vIHByZWxvYWRlciBvdXRcclxuICAgICAgICB2YXIgcHJlbG9hZGVyT3V0VGwgPSBuZXcgVGltZWxpbmVNYXgoKTtcclxuICAgICAgICBwcmVsb2FkZXJPdXRUbFxyXG4gICAgICAgICAgICAudG8oJCgnLnByb2dyZXNzJyksIDAuMywge1xyXG4gICAgICAgICAgICAgICAgeTogMTAwLFxyXG4gICAgICAgICAgICAgICAgYXV0b0FscGhhOiAwLFxyXG4gICAgICAgICAgICAgICAgZWFzZTogQmFjay5lYXNlSW5cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRvKCQoJy50eHQtcGVyYycpLCAwLjMsIHtcclxuICAgICAgICAgICAgICAgIHk6IDEwMCxcclxuICAgICAgICAgICAgICAgIGF1dG9BbHBoYTogMCxcclxuICAgICAgICAgICAgICAgIGVhc2U6IEJhY2suZWFzZUluXHJcbiAgICAgICAgICAgIH0sIDAuMSlcclxuICAgICAgICAgICAgLnNldCgkKCdib2R5JyksIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJy09aXMtbG9hZGluZycsXHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3A6ICgkKFwiI2xhbmRcIikub2Zmc2V0KCkudG9wKSArIExBVU5DSEVSX09GRlNFVFxyXG4gICAgICAgICAgICAgICAgICAgIH0sIDIwMDApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRvKCQoJyNwcmVsb2FkZXInKSwgMC43LCB7XHJcbiAgICAgICAgICAgICAgICB5UGVyY2VudDogMTAwLFxyXG4gICAgICAgICAgICAgICAgZWFzZTogUG93ZXI0LmVhc2VJbk91dFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc2V0KCQoJyNyb2NrZXQnKSwge1xyXG4gICAgICAgICAgICAgICAgc2NhbGU6IDFcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnNldCgkKCcjcHJlbG9hZGVyJyksIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJys9aXMtaGlkZGVuJyxcclxuICAgICAgICAgICAgICAgIC8vIG9uQ29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHNjcm9sbFRvcDogKCQoXCIjbGFuZFwiKS5vZmZzZXQoKS50b3ApICsgTEFVTkNIRVJfT0ZGU0VUXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgfSwgMjAwMCk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcyhcImlzLWxvYWRpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICQoJyNwcmVsb2FkZXInKS5hZGRDbGFzcyhcImlzLWhpZGRlblwiKTtcclxuICAgICAgICAgICAgICAgIC8vICAgICB9LCAyMDAwKTtcclxuICAgICAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcmVsb2FkZXJPdXRUbDtcclxuICAgIH1cclxuXHJcbiAgICAkKCcjbXlmb3JtJykudmFsaWRhdGUoe1xyXG4gICAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgICAgIGZpZWxkMToge1xyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtaW5sZW5ndGg6IDgsXHJcbiAgICAgICAgICAgICAgICBtYXhsZW5ndGg6IDgsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZXNzYWdlczoge1xyXG4gICAgICAgICAgICBmaWVsZDE6IHtcclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBcIlBsZWFzZSBlbnRlciB5b3VyIHBhc3N3b3JkXCIsXHJcbiAgICAgICAgICAgICAgICBtaW5sZW5ndGg6IFwiWW91ciBwYXNzd29yZCBtdXN0IDggY2hhcmFjdGVycyBsb25nXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN1Ym1pdEhhbmRsZXI6IGZ1bmN0aW9uKGZvcm0pIHtcclxuICAgICAgICAgICAgaWYgKCQoXCJpbnB1dFwiKS5maXJzdCgpLnZhbCgpID09PSBcImNvcnJlY3QyXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd2YWxpZCBmb3JtIHN1Ym1pdHRlZCcpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gXCJpc1ZhbGlkYXRlZD10cnVlXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2xvID0gd2luZG93LmxvY2F0aW9uLm9yaWdpblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05FVyBMT0NzJywgd2xvICsgJy9pbnRyby5odG1sJyk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHdsbyArICcvaW50cm8uaHRtbCc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZBSUxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbn0pOyJdLCJuYW1lcyI6WyIkZG9jdW1lbnQiLCIkd2luZG93IiwiJGh0bWwiLCIkYm9keSIsImltYWdlc0xvYWRlZCIsInJlcXVpcmUiLCIkIiwidmFsaWRhdGUiLCJyaXZlIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImFuaW1hdGlvbiIsIlJpdmUiLCJzcmMiLCJjYW52YXMiLCJvbiIsInBhdXNlIiwic2NydWIiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIm9uc2Nyb2xsIiwidG90YWxTY3JvbGwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxIZWlnaHQiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsInNjcm9sbFkiLCJ0b0ZpeGVkIiwic2NydWJNb2RpZmllciIsImpRdWVyeSIsInJlYWR5IiwiV0lXIiwidmVyZ2UiLCJ2aWV3cG9ydFciLCJXSUgiLCJ2aWV3cG9ydEgiLCJsb2FkZWRDb3VudCIsImltYWdlc1RvTG9hZCIsImxlbmd0aCIsImxvYWRpbmdQcm9ncmVzcyIsIkxBVU5DSEVSX09GRlNFVCIsImJhY2tncm91bmQiLCJwcm9ncmVzcyIsImluc3RhbmNlIiwiaW1hZ2UiLCJsb2FkUHJvZ3Jlc3MiLCJpbWdMb2FkIiwiVHdlZW5MaXRlIiwidG8iLCJwcm9ncmVzc1RsIiwiZWFzZSIsIkxpbmVhciIsImVhc2VOb25lIiwiVGltZWxpbmVNYXgiLCJwYXVzZWQiLCJvblVwZGF0ZSIsInByb2dyZXNzVXBkYXRlIiwib25Db21wbGV0ZSIsImxvYWRDb21wbGV0ZSIsIndpZHRoIiwiTWF0aCIsInJvdW5kIiwidGV4dCIsInByZWxvYWRlck91dFRsIiwieSIsImF1dG9BbHBoYSIsIkJhY2siLCJlYXNlSW4iLCJzZXQiLCJjbGFzc05hbWUiLCJhbmltYXRlIiwic2Nyb2xsVG9wIiwib2Zmc2V0IiwidG9wIiwieVBlcmNlbnQiLCJQb3dlcjQiLCJlYXNlSW5PdXQiLCJzY2FsZSIsInJ1bGVzIiwiZmllbGQxIiwicmVxdWlyZWQiLCJtaW5sZW5ndGgiLCJtYXhsZW5ndGgiLCJtZXNzYWdlcyIsInN1Ym1pdEhhbmRsZXIiLCJmb3JtIiwiZmlyc3QiLCJ2YWwiLCJjb25zb2xlIiwibG9nIiwiY29va2llIiwid2xvIiwibG9jYXRpb24iLCJvcmlnaW4iLCJocmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/demo.js\n");

/***/ }),

/***/ "./src/js/rocket.js":
/*!**************************!*\
  !*** ./src/js/rocket.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _assets_earth_pipe_bot_empty_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assets/earth/pipe-bot-empty.svg */ \"./src/assets/earth/pipe-bot-empty.svg\");\n/* harmony import */ var _assets_earth_pipe_bot_filled_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../assets/earth/pipe-bot-filled.svg */ \"./src/assets/earth/pipe-bot-filled.svg\");\n/* harmony import */ var _assets_medow_submarine_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../assets/medow/submarine.svg */ \"./src/assets/medow/submarine.svg\");\n/* harmony import */ var _assets_medow_spaceship_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../assets/medow/spaceship.svg */ \"./src/assets/medow/spaceship.svg\");\n/* harmony import */ var _assets_sky_star_yellow_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../assets/sky/star-yellow.svg */ \"./src/assets/sky/star-yellow.svg\");\n/* harmony import */ var _assets_sky_star_grey_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../assets/sky/star-grey.svg */ \"./src/assets/sky/star-grey.svg\");\n/* harmony import */ var _assets_sky_star_white_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../assets/sky/star-white.svg */ \"./src/assets/sky/star-white.svg\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// import Scrollbar from 'smooth-scrollbar';\n\n\n\n\n\n\n // Scrollbar.init(document.querySelector('#scroll-container') );\n\n$(function () {\n  // VARS\n  var WIW = verge.viewportW();\n  var WIH = verge.viewportH();\n  var Rocket_Width = 200;\n  var Rocket_Height = 160;\n  var launchpad_Height = 30;\n  var rocket_base_offset = 0;\n  var SECTION = $(\"section\");\n  var ELM = $(\".elm\");\n  var EARTH_LAYER = $(\".earth-layer\");\n  var PIPE = $(\".pipe\");\n  var LOGO_RES_Y_OFFSET = 50;\n\n  if (WIW < 530) {\n    Rocket_Height = 369 / 2;\n    Rocket_Width = 200 / 2;\n    rocket_base_offset = 0;\n    LOGO_RES_Y_OFFSET = 100;\n  }\n\n  var STARS_COUNT = 100; // Set Section Height\n\n  if (WIW > 480) {\n    SECTION.css('height', WIH + \"px\");\n    ELM.css('height', WIH + \"px\");\n  }\n\n  EARTH_LAYER.css('height', WIH / 2 + \"px\");\n  EARTH_LAYER.css('margin-top', -(WIH / 4) + \"px\");\n  PIPE.css('height', WIH / 1.5 + \"px\");\n  PIPE.css('margin-top', -(WIH / 1.5) / 2 + \"px\");\n  $('.space-bg-img').css('height', WIH + \"px\");\n  $(\".rays\").css('height', WIH + \"px\");\n\n  if (WIW < 480) {\n    STARS_COUNT = 25;\n    PIPE.css('height', WIH / 1.5 + \"px\");\n  }\n\n  var isMob = false;\n\n  if (WIW < 480) {\n    STARS_COUNT = 25;\n    PIPE.css('height', WIH / 1.5 + \"px\");\n    isMob = true;\n  } // var STARS_ARRAY = [\"star-yellow\", \"star-grey\", \"star-whitet\"];\n\n\n  var STARS_ARRAY = [_assets_sky_star_yellow_svg__WEBPACK_IMPORTED_MODULE_4__, _assets_sky_star_grey_svg__WEBPACK_IMPORTED_MODULE_5__, _assets_sky_star_white_svg__WEBPACK_IMPORTED_MODULE_6__];\n  var STARS_SIZE_ARRAY = [\"tiny\", \"small\", \"medium\", \"big\"];\n\n  for (var i = 0; i < STARS_COUNT; i++) {\n    var randomStar = Math.floor(Math.random() * STARS_ARRAY.length);\n    var randomStarSize = Math.floor(Math.random() * STARS_SIZE_ARRAY.length);\n    var star = '<div class=\"star ' + STARS_SIZE_ARRAY[randomStarSize] + '\" style=\"z-index: 9; opacity:' + Math.random(0.5, 1) + '; animation: twinkle ' + (Math.random() * 5 + 5) + 's linear ' + (Math.random() * 5 + 5) + 's infinite; top: ' + Math.random() * ($(window).height() - 50) + 'px; left: ' + Math.random() * $(window).width() + 'px;\"><img src=\"' + STARS_ARRAY[randomStar] + '\"/></div>';\n    $('#space').append(star);\n  } ////////////////////////////////////////////////////// HORIZONTAL SCROll\n\n\n  for (var i = 0; i < 30; i++) {\n    var randomStar = Math.floor(Math.random() * STARS_ARRAY.length);\n    var randomStarSize = Math.floor(Math.random() * STARS_SIZE_ARRAY.length);\n    var star = '<div class=\"star ' + STARS_SIZE_ARRAY[randomStarSize] + '\" style=\"z-index: 9; opacity:' + Math.random(0.5, 1) + '; animation: twinkle ' + (Math.random() * 5 + 5) + 's linear ' + (Math.random() * 5 + 5) + 's infinite; top: ' + Math.random() * ($(window).height() / 2) + 'px; left: ' + Math.random() * $(window).width() + 'px;\"><img src=\"' + STARS_ARRAY[randomStar] + '\"/></div>';\n    $('#sky').append(star);\n  } // var controller_h = new ScrollMagic.Controller({vertical: false});\n  // var tween_ROCKET_H = new TimelineMax()\n  //     .to(\"#rocket\", 0.5, {\n  //         // rotation: 40,\n  //      })\n  // // build scene\n  // var scene_h = new ScrollMagic.Scene({duration: \"100%\"})\n  // \t\t\t\t.setTween(tween_ROCKET_H)\n  // \t\t\t\t// .setPin(\"#rocket\")\n  // \t\t\t\t.addIndicators({name: \"rotate_h\"}) // add indicators (requires plugin)\n  // \t\t\t\t.addTo(controller_h);\n  ////////////////////////////////////////////////////// BUBBLES\n\n\n  for (var b = 0; b < 50; b++) {\n    var bubbles = '<div class=\"bubble\" style=\"z-index: 9;animation: moveBubbles ' + (Math.random() * 3 + 3) + 's linear ' + (Math.random() * 5 + 5) + 's infinite; top: ' + Math.random() * $(window).height() + 'px; left: ' + Math.random() * $(window).width() + 'px; transform:scale(' + Math.random() + ')\"> </div>';\n    $('.bubbles').append(bubbles);\n  } ////////////////////////////////////////////////////// POPUP\n  // for (var p = 0; p < 25; p++) {\n  //     var pop_ups = '<div class=\"popup_bubble\" style=\"z-index: 200; top: ' + Math.random() * ($(window).height() / 2) + 'px; left: ' + Math.random() * ($(window).width() / 2) + 'px;  \"> </div>';\n  //     $('.text_pop_up').append(pop_ups);\n  // }\n  ////////////////////////////////////////////////////// FLAMES\n\n\n  var oldValue = 0;\n  var newValue = 0;\n  window.addEventListener('scroll', function (e) {\n    newValue = window.pageYOffset;\n\n    if (oldValue < newValue) {\n      // if (oldValue > WIH * 3) {\n      //     $('#rocket img').attr(\"src\", './assets/medow/submarine.svg');\n      // } else {\n      //     $('#rocket img').attr(\"src\", './assets/medow/rocket_red_down.svg');\n      // }\n      // $(\"#rocket\").addClass('go-down');\n      // console.log(\"scrolling page Up\", newValue, WIH * 4);\n      if (newValue >= WIH * 4 - 100) {\n        $('.diractions button:nth-child(3)').hide();\n      }\n\n      if (newValue >= 100) {\n        $('.diractions button:nth-child(1)').show();\n      }\n    } else if (oldValue > newValue) {\n      // if (oldValue < WIH * 2.5) {\n      //     $('#rocket img').attr(\"src\", './assets/medow/rocket-2.svg');\n      //     $('#rocket').addClass(\"addSmoke\");\n      //     $('#rocket').removeClass(\"submarine\");\n      // } else {\n      //     $('#rocket img').attr(\"src\", './assets/medow/submarine.svg');\n      //     $('#rocket').removeClass(\"addSmoke\");\n      //     $('#rocket').addClass(\"submarine\");\n      // }\n      // $(\"#rocket\").removeClass('go-down');\n      // console.log(\"scrolling page Down\", newValue);\n      if (newValue <= 100) {\n        $('.diractions button:nth-child(1)').hide();\n      }\n\n      if (newValue <= WIH * 4 - 100) {\n        $('.diractions button:nth-child(3)').show();\n      }\n    }\n\n    oldValue = newValue;\n  }); // ROCKET\n\n  var controller_ROCKET = new ScrollMagic.Controller();\n  var tween_ROCKET = new TimelineMax().to(\"#rocket\", 1, {\n    x: 0,\n    y: WIH / 2 - Rocket_Height,\n    ease: 'EaseIn'\n  }).to(\"#rocket\", 0.5, {\n    x: 0,\n    onComplete: function onComplete() {// console.log(\"STEP - 2\")\n    },\n    ease: 'Power4.out'\n  }).to(\"#rocket\", 0.5, {\n    x: -100,\n    onComplete: function onComplete() {// console.log(\"STEP - 3\")\n    },\n    ease: 'Power4.out'\n  }).to(\"#rocket\", 0.5, {\n    x: 0,\n    y: WIH / 2 - Rocket_Height,\n    onComplete: function onComplete() {},\n    ease: 'Power4.out'\n  }).to(\"#rocket\", 1, {\n    x: 0,\n    y: WIH / 2 - Rocket_Height / 2 - rocket_base_offset,\n    onComplete: function onComplete() {},\n    ease: 'Power4.out'\n  }); // tween_ROCKET.call(function() {\n  //     $('#rocket').toggleClass(\"addSmoke\");\n  // }, null, null, 0);\n  // build scene\n\n  var scene_ROCKET = new ScrollMagic.Scene({\n    triggerElement: \"#rocket_trigger\",\n    // duration: 3000,\n    duration: \"200%\",\n    offset: WIH - 5\n  }).setTween(tween_ROCKET) // .addIndicators({ name: \"ROCKET\" })\n  .addTo(controller_ROCKET).triggerHook(\"1\");\n  scene_ROCKET.on(\"start\", function (event) {\n    $('#rocket').addClass(\"addSmoke\"); // $('.launcher-base').show();\n    // $('.launcher-base').show();\n    // console.log(\"STARTED....\");\n  });\n  scene_ROCKET.on(\"progress\", function (event) {// console.log(\"Scene progress changed to \" + event.progress);\n  }); //  bind scroll to anchor links\n  // change behaviour of controller to animate scroll instead of jump\n\n  controller_ROCKET.scrollTo(function (newpos) {\n    TweenMax.to(window, 1, {\n      scrollTo: {\n        y: newpos\n      }\n    });\n  }); // ROCKET END controller_ROCKET\n\n  var controller_SPACE = new ScrollMagic.Controller();\n  var controller_SKY = new ScrollMagic.Controller();\n  var controller_LAND = new ScrollMagic.Controller();\n  var controller_EARTH = new ScrollMagic.Controller();\n  var controller_UNDERWATER = new ScrollMagic.Controller();\n  var controller_SUB_2 = new ScrollMagic.Controller();\n  var controller_BUTTON = new ScrollMagic.Controller();\n  var controller_BUTTON2 = new ScrollMagic.Controller(); // AUDIO\n\n  var audio = document.getElementById(\"audio\");\n  var splashAudio = document.getElementById(\"splash-audio\");\n  var metalHitAudio = document.getElementById(\"metal-hit-audio\"); // ------------------- SPACE ----------------------\n\n  var scene_BUTTON = new ScrollMagic.Scene({\n    triggerElement: \"#land\",\n    duration: \"60%\",\n    offset: 0\n  }) // .setClassToggle(\".go-up\", \"animate\")\n  // .addIndicators({ name: \"scene_BUTTON\" })\n  .addTo(controller_SPACE).triggerHook(0.5);\n  var scene_BUTTON2 = new ScrollMagic.Scene({\n    triggerElement: \"#earth\",\n    duration: \"100%\",\n    offset: WIH / 3.5 - 20\n  }).setClassToggle(\".go-down\", \"show\") // .addIndicators({ name: \"scene_BUTTON2\" })\n  .addTo(controller_EARTH).triggerHook(0.5);\n  var tween_SPACE_btn = new TimelineMax().to(\"#space_btn\", 0.5, {\n    x: 0\n  }).to(\"#space_btn\", 0.5, {\n    x: 120\n  });\n  var scene_SPACE = new ScrollMagic.Scene({\n    triggerElement: \"#space\",\n    duration: \"50%\",\n    offset: WIH / 4\n  }).setClassToggle(\".space-cta\", \"visible\") // .addIndicators({ name: \"SPACE_NAV\" })\n  .addTo(controller_SPACE).triggerHook(0.5); // ------------------- SPACE NAV ----------------------\n\n  var scene_SPACE_NAV = new ScrollMagic.Scene({\n    triggerElement: \"#space\",\n    duration: \"50%\",\n    offset: WIH / 4\n  }).setClassToggle(\".in-space\", \"visible\") // .addIndicators({ name: \"SPACE\" })\n  .addTo(controller_SPACE).triggerHook(0.5); // ------------------- SPACE NAV END ----------------------\n  // ------------------- SPACE ----------------------\n\n  var tween_SPACE_btn = new TimelineMax().to(\"#space_btn\", 0.5, {\n    x: 0\n  }).to(\"#space_btn\", 0.5, {\n    x: 120\n  });\n  var scene_SKY = new ScrollMagic.Scene({\n    triggerElement: \"#space\",\n    // duration: 500,\n    duration: \"25%\",\n    offset: WIH / 4\n  }) // .setTween([tween_LAND_btn])\n  .setClassToggle(\"#space_pop_up\", \"visible\") // .addIndicators({ name: \"SPACE_TEXT\" })\n  .addTo(controller_SPACE).triggerHook(0.25); // ------------------- SKY ----------------------\n\n  var tween_SKY_btn = new TimelineMax().to(\"#sky_btn\", 0.5, {\n    x: 0\n  }).to(\"#sky_btn\", 0.5, {\n    x: 120\n  });\n  var scene_SKY = new ScrollMagic.Scene({\n    triggerElement: \"#sky\",\n    // duration: 500,\n    duration: \"100%\",\n    offset: 0\n  }) // .setTween([tween_LAND_btn])\n  .setClassToggle(\"#sky_pop_up\", \"visible\") // .addIndicators({ name: \"SKY_TEXT\" })\n  .addTo(controller_SKY).triggerHook(0.5); // ------------------- SKY NAV ----------------------\n\n  var scene_SKY_NAV = new ScrollMagic.Scene({\n    triggerElement: \"#sky\",\n    duration: \"50%\",\n    offset: WIH / 4\n  }).setClassToggle(\".in-sky\", \"visible\") // .addIndicators({ name: \"SKY_NAV\" })\n  .addTo(controller_SKY).triggerHook(0.5); // ------------------- SKY NAV END ----------------------\n  // ------------------- LAND ----------------------\n\n  var tween_LAND_btn = new TimelineMax().to(\"#land_btn\", 0.5, {\n    x: 0\n  }).to(\"#land_btn\", 0.5, {\n    x: 120\n  });\n  var scene_LAND = new ScrollMagic.Scene({\n    triggerElement: \"#land\",\n    // duration: 500,\n    duration: \"50%\",\n    offset: WIH / 4\n  }) // .setTween([tween_LAND_btn])\n  .setClassToggle(\"#land_pop_up\", \"visible\") // .addIndicators({ name: \"LAND_TEXT\" })\n  .addTo(controller_LAND).triggerHook(0.3); // ------------------- LOGO SCENE ----------------------\n\n  var tween_LOGO = TweenMax.fromTo(\"#logo\", 1, {\n    y: 0,\n    autoAlpha: 0\n  }, {\n    y: LOGO_RES_Y_OFFSET,\n    autoAlpha: 1\n  });\n  var scene_LOGO = new ScrollMagic.Scene({\n    triggerElement: \"#trigger_LOGO\",\n    duration: \"50%\",\n    offset: -WIH / 2\n  }).setTween([tween_LOGO]) // .addIndicators({  name: \"LOGO\" })\n  .triggerHook(0) // .on(\"start\", function(event) {})\n  // .on(\"end\", function(event) {})\n  // .on(\"enter\", function(event) {})\n  // .on(\"progress\", function(event) {})\n  // .on(\"remove\", function(event) {})\n  // .on(\"update\", function(event) {})\n  // .on(\"leave\", function(event) {}).on(\"enter\", callback).on(\"leave\", callback)\n  .addTo(controller_ROCKET); // ------------------- EARTH ----------------------\n  // global vars\n  // var viewer = document.querySelector(\".viewer\"),\n  //     frame_count = 9,\n  //     offset_value = 100;\n  // init controller\n  // var controller_pipe = new ScrollMagic.Controller({\n  //     globalSceneOptions: {\n  //         triggerHook: 0,\n  //         reverse: true\n  //     }\n  // });\n  // build step frame scene\n  // for (var i = 1, l = frame_count; i <= l; i++) {\n  //     new ScrollMagic.Scene({\n  //             duration: frame_count * offset_value + \"px\",\n  //             triggerElement: \"#earth\",\n  //             offset: i * offset_value\n  //         })\n  //         .setClassToggle(viewer, \"frame\" + i)\n  //         .addIndicators(\"PIPE_STICKEY\")\n  //         .addTo(controller_pipe);\n  // }\n  // ------------------- EARTH TEXT ----------------------\n  // var tween_LAND_btn = new TimelineMax()\n  //     .to(\"#earth_btn\", 0.5, {\n  //         x: 0,\n  //     })\n  //     .to(\"#earth_btn\", 0.5, {\n  //         x: 120,\n  //     });\n\n  var scene_EARTH_PIPE = new ScrollMagic.Scene({\n    triggerElement: \"#earth\",\n    duration: \"33%\",\n    offset: WIH / 3\n  }) // .setPin(\"#earth\")\n  .setClassToggle(\"#pipe-sequence\", \"visible\") // .addIndicators({ name: \"EARTH_PIPE\" })\n  .addTo(controller_EARTH).triggerHook(0.5);\n  scene_EARTH_PIPE.on(\"enter\", function (event) {// $('#pipe-sequence').attr(\"src\", pipeFilledImg);\n  });\n  scene_EARTH_PIPE.on(\"leave\", function (event) {// $('#pipe-sequence').attr(\"src\", pipeEmptyImg);\n  });\n  var scene_EARTH_TEXT = new ScrollMagic.Scene({\n    triggerElement: \"#earth\",\n    duration: \"100%\",\n    offset: 0\n  }) // .setPin(\"#earth\")\n  .setClassToggle(\"#earth_pop_up\", \"visible\") // .addIndicators({ name: \"EARTH_TEXT\" })\n  .addTo(controller_EARTH).triggerHook(0.5); // ------------------- LAND NAV ----------------------\n\n  var scene_SKY_NAV = new ScrollMagic.Scene({\n    triggerElement: \"#land\",\n    duration: \"50%\",\n    offset: WIH / 4\n  }).setClassToggle(\".in-land\", \"visible\") // .addIndicators({ name: \"LAND_NAV\" })\n  .addTo(controller_LAND).triggerHook(0.5); // ------------------- SKY NAV END ----------------------\n  // https://mukeshnavneet.github.io/docs/assets/earth/pipe-5.svg\n\n  var images = [\"https://mukeshnavneet.github.io/docs/assets/earth/pipe-0.svg\", \"https://mukeshnavneet.github.io/docs/assets/earth/pipe-1.svg\", \"https://mukeshnavneet.github.io/docs/assets/earth/pipe-2.svg\", \"https://mukeshnavneet.github.io/docs/assets/earth/pipe-3.svg\", \"https://mukeshnavneet.github.io/docs/assets/earth/pipe-bot.svg\", \"https://mukeshnavneet.github.io/docs/assets/earth/pipe-bot.svg\", \"https://mukeshnavneet.github.io/docs/assets/earth/pipe-4.svg\", \"https://mukeshnavneet.github.io/docs/assets/earth/pipe-5.svg\", \"https://mukeshnavneet.github.io/docs/assets/earth/pipe-6.svg\", \"https://mukeshnavneet.github.io/docs/assets/earth/pipe-0.svg\"];\n  var obj22 = {\n    curImg: 0\n  }; // create tween\n\n  var tween_pipe_sequence = TweenMax.to(obj22, 0.5, {\n    curImg: images.length - 1,\n    // animate propery curImg to number of images\n    roundProps: \"curImg\",\n    // only integers so it can be used as an array index\n    repeat: 0,\n    // repeat 3 times\n    immediateRender: true,\n    // load first image automatically\n    ease: Linear.easeNone,\n    // show every image the same ammount of time\n    onUpdate: function onUpdate() {\n      // var str = \"<img class='bcg' src=\"+ images[obj.curImg] +\"/>\"\n      //  $(\".pipe\").html(str)\n      $(\"#pipe-sequence\").attr(\"src\", images[obj22.curImg]); // set the image source\n    }\n  });\n  var tween_EARTH_btn = new TimelineMax().to(\"#earth_btn\", 1, {\n    x: 0\n  }).to(\"#earth_btn\", 1, {\n    x: 120\n  }).to(\"#earth_btn\", 1, {\n    x: 0\n  });\n  var scene_tween_pipe_sequence = new ScrollMagic.Scene({\n    triggerElement: \"#earth\",\n    // duration: 500,\n    duration: \"80%\",\n    offset: \"10%\"\n  }).setTween([tween_pipe_sequence]) // .addIndicators({ name: \"scene_tween_pipe_sequence\" })\n  .addTo(controller_EARTH).triggerHook(0.5);\n  var scene_EARTH = new ScrollMagic.Scene({\n    triggerElement: \"#earth\",\n    // duration: 500,\n    duration: \"20%\",\n    offset: \"0px\"\n  }).setTween([tween_EARTH_btn]) // .addIndicators({ name: \"EARTH\" })\n  .addTo(controller_EARTH).triggerHook(1);\n  scene_EARTH.on(\"start\", function (event) {\n    $('#rocket').removeClass(\"addSmoke\");\n  });\n  scene_EARTH.on(\"leave\", function (event) {\n    $('#rocket').addClass(\"addSmoke\");\n  });\n  var tween_EARTH_rocket = new TimelineMax().to(\"#rocket\", 0.5, {\n    scale: 0.5 // y: (WIH / 2) - (Rocket_Height / 2)\n\n  }).to(\"#rocket\", 0.5, {\n    scale: 0.5 // y: (WIH / 2) - (Rocket_Height / 2)\n\n  }).to(\"#rocket\", 0.5, {\n    scale: 0 // y: (WIH / 2) - (Rocket_Height / 2)\n\n  });\n  var scene_EARTH_ROCKET = new ScrollMagic.Scene({\n    triggerElement: \"#earth\",\n    // duration: 500,\n    duration: \"50%\",\n    offset: \"0px\"\n  }).setTween([tween_EARTH_rocket]) // .addIndicators({ name: \"scene_EARTH_ROCKET\" })\n  .addTo(controller_EARTH).triggerHook(1); //////////////////////////SMOKEEEEEEEEEEEEEEEEE/////////\n\n  var controller_SMOKE = new ScrollMagic.Controller(); // var tween_SMOKE = new TimelineMax()\n  //     .to('.smoke-to-left', 1, {\n  //         scale: 0.5,\n  //         y: 10,\n  //     })\n  //     .to('.smoke-to-left', 1, {\n  //         scale: 0,\n  //         y: 0\n  //     });\n\n  var scene_SMOKE = new ScrollMagic.Scene({\n    triggerElement: \"#earth\",\n    // duration: 500,\n    duration: WIH * 2 + 50,\n    offset: \"-100px\"\n  }) // .setTween([tween_SMOKE])\n  // .addIndicators({ name: \"scene_SMOKE\" })\n  .addTo(controller_SMOKE).triggerHook(0.9);\n  scene_SMOKE.on(\"start\", function (event) {\n    $('.smoke-to-left').hide();\n    $('.smoke-to-right').hide();\n  });\n  scene_SMOKE.on(\"leave\", function (event) {\n    $('.smoke-to-left').show();\n    $('.smoke-to-right').show();\n  }); //////////////////////////SMOKEEEEEEEEEEEEEEEEE/////////\n  // ------------------- PIPE FOR ROCKET ----------------------\n  // ------------------- EARTH NAV ----------------------\n\n  var scene_SKY_NAV = new ScrollMagic.Scene({\n    triggerElement: \"#earth\",\n    duration: \"50%\",\n    offset: WIH / 4\n  }).setClassToggle(\".in-earth\", \"visible\") // .addIndicators({ name: \"SKY_NAV\" })\n  .addTo(controller_EARTH).triggerHook(0.5); // ------------------- EARTH NAV END ----------------------\n\n  var scene_PIPE = new ScrollMagic.Scene({\n    triggerElement: \".pipe-start\",\n    // duration: 500,\n    duration: \"100%\",\n    offset: -(WIH / 2 - Rocket_Height)\n  }) // .addIndicators({ name: \"PIPE\" })\n  // .setTween([tween_PIPE_MOVE])\n  .addTo(controller_ROCKET).triggerHook(0.5);\n  scene_PIPE.on(\"start\", function (event) {// $('#rocket').hide();\n  });\n  scene_PIPE.on(\"leave\", function (event) {// $('#rocket').show();\n  }); // ------------------- UNDERWATER ----------------------\n\n  var scene_UNDERWATER = new ScrollMagic.Scene({\n    triggerElement: \"#underwater\",\n    // duration: 500,\n    duration: \"150%\",\n    offset: -WIH / 2\n  }) // .setTween([tween_LAND_btn, ])\n  // .addIndicators({ name: \"UNDERWATER\" })\n  .addTo(controller_UNDERWATER).triggerHook(0.5); // ------------------- EARTH TEXT ----------------------\n  // var tween_LAND_btn = new TimelineMax()\n  //     .to(\"#earth_btn\", 0.5, {\n  //         x: 0,\n  //     })\n  //     .to(\"#earth_btn\", 0.5, {\n  //         x: 120,\n  //     });\n\n  var scene_UNDERWATER_TEXT = new ScrollMagic.Scene({\n    triggerElement: \"#underwater\",\n    duration: \"100%\",\n    offset: 0\n  }).setClassToggle(\"#sea_pop_up\", \"visible\") // .addIndicators({ name: \"UNDERWATER_TEXT\" })\n  .addTo(controller_UNDERWATER).triggerHook(0.5);\n  var tween_UNDERWATER_btn = new TimelineMax().to(\"#sea_btn\", 1, {\n    x: 0\n  }).to(\"#sea_btn\", 1, {\n    x: 120\n  }).to(\"#sea_btn\", 1, {\n    x: 0\n  });\n  var tween_UNDERWATER_rocket = new TimelineMax().to(\"#rocket\", 1, {\n    scale: 0.2,\n    y: 100\n  }).to(\"#rocket\", 1, {\n    scale: 1,\n    rotation: -90,\n    x: 0,\n    y: 100\n  });\n  var scene_UNDERWATER_ROCKET = new ScrollMagic.Scene({\n    triggerElement: \"#underwater\",\n    // duration: 500,\n    duration: \"50%\",\n    offset: \"0px\"\n  }).setTween([tween_UNDERWATER_rocket]) // .addIndicators({ name: \"scene_UNDERWATER_ROCKET\" })\n  .addTo(controller_UNDERWATER).triggerHook(1);\n  scene_UNDERWATER_ROCKET.on(\"start\", function (event) {// $('#rocket img').attr(\"src\", './assets/medow/submarine.svg');\n  });\n  scene_UNDERWATER.on(\"start\", function (event) {\n    $('#rocket').removeClass(\"addSmoke\");\n    $('#rocket').addClass(\"submarine\");\n    $('#rocket img').attr(\"src\", _assets_medow_submarine_svg__WEBPACK_IMPORTED_MODULE_2__);\n  });\n  scene_UNDERWATER.on(\"leave\", function (event) {\n    $('#rocket img').attr(\"src\", _assets_medow_spaceship_svg__WEBPACK_IMPORTED_MODULE_3__);\n    $('#rocket').removeClass(\"addSmoke\");\n    $('#rocket').removeClass(\"submarine\");\n  }); /////;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;/////////////\n\n  var controller_UNDERWATER2 = new ScrollMagic.Controller();\n  var tween_UNDERWATER_rocket2 = new TimelineMax().fromTo(\"#rocket2\", 0.2, {\n    scale: 1,\n    y: 0,\n    x: 25 // rotation:-180\n\n  }, {\n    scale: 1,\n    y: 0,\n    x: 25 // rotation:-180\n\n  });\n  var scene_UNDERWATER_ROCKET2 = new ScrollMagic.Scene({\n    triggerElement: \"#underwater\",\n    // duration: 500,\n    duration: \"100%\",\n    offset: \"0px\"\n  }).setPin(\"#rocket2\").setTween([tween_UNDERWATER_rocket2]) // .addIndicators({ name: \"scene_UNDERWATER_ROCKET2\" })\n  .addTo(controller_UNDERWATER2).triggerHook(1); /////;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;/////////////\n  /////;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;/////////////\n\n  var controller_UNDERWATER3 = new ScrollMagic.Controller();\n  var tween_UNDERWATER_rocket3 = new TimelineMax().to(\"#rocket2\", 0.2, {\n    scale: 1,\n    rotation: -90,\n    y: 0\n  }).to(\"#rocket2\", 0.2, {\n    scale: 1.75,\n    y: 100,\n    x: -50,\n    rotation: -90\n  });\n  var scene_UNDERWATER_ROCKET3 = new ScrollMagic.Scene({\n    triggerElement: \"#underwater\",\n    // duration: 500,\n    duration: \"50%\",\n    offset: 0\n  }).setTween([tween_UNDERWATER_rocket3]) // .addIndicators({ name: \"scene_UNDERWATER_ROCKET22\" })\n  .addTo(controller_UNDERWATER3).triggerHook(0.5); /////;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;/////////////\n  // ------------------- EARTH NAV ----------------------\n\n  var scene_SEA_NAV = new ScrollMagic.Scene({\n    triggerElement: \"#underwater\",\n    duration: \"50%\",\n    offset: WIH / 4\n  }) // .setClassToggle(\".in-sea\", \"visible\")\n  // .addIndicators({ name: \"SKY_NAV\" })\n  .addTo(controller_EARTH).triggerHook(0.5); // ------------------- EARTH NAV END ----------------------\n  // var tween_SUB_2 = new TimelineMax()\n  //     .to(\"#sea_btn\", 1, {\n  //         x: 0,\n  //     })\n  //     .to(\"#sea_btn\", 1, {\n  //         x: 120,\n  //     })\n  //     .to(\"#sea_btn\", 1, {\n  //         x: 0,\n  //     });\n  // var scene_SUB2 = new ScrollMagic.Scene({\n  //         triggerElement: \"#underwater\",\n  //         duration: \"60%\",\n  //         offset: 0\n  //     })\n  //     .setTween([tween_SUB_2])\n  //     // .addIndicators({ name: \"SEA_SUB2\" })\n  //     .addTo(controller_SUB_2)\n  //     .triggerHook(1);\n  // var cloudTl = new TimelineMax({ repeat: -1, force3D: true });\n  // cloudTl.to(\".fish-center-top\", 10, { x: WIW + 100, ease: Linear.easeInOut }, 1)\n  // .to(\"#cloud02\", 5, { x: WIW, ease: Linear.easeNone }, 0.9)\n  // .to(\"#cloud03\", 9, { x: WIW, ease: Linear.easeNone }, 1)\n  // .to(\"#cloud04\", 4, { x: WIW, ease: Linear.easeNone }, 1.5);\n  /////////////////////////////////////////////////// POPUP\n\n  var $space_pop_up = $(\"#space_pop_up\");\n  var $space_btn = $(\"#space_btn\"); // SKY BTN\n\n  var $sky_pop_up = $(\"#sky_pop_up\");\n  var $sky_btn = $(\"#sky_btn\");\n  var $touch_me_not_popup = $(\"#touch-me-not-popup\");\n  var $touch_me_not = $(\"#touch-me-not\");\n  var $back_btn = $(\".back-btn\"); // LAND BTN\n\n  var $land_pop_up = $(\"#land_pop_up\");\n  var $land_btn = $(\"#land_btn\"); //EARTH BTN\n\n  var $earth_pop_up = $(\"#earth_pop_up\");\n  var $earth_btn = $(\"#earth_btn\"); //SEA BTN\n\n  var $sea_pop_up = $(\"#sea_pop_up\");\n  var $sea_btn = $(\"#sea_btn\");\n  $space_btn.on(\"click\", function name(params) {\n    $space_pop_up.addClass(\"animate__bounceIn\");\n    $space_pop_up.show();\n    setTimeout(function () {\n      $space_pop_up.hide();\n    }, 4000);\n  });\n  var $touch_me_not_IMG = $(\"#touch-me-not img\");\n  var $cloud_text = $(\".cloud-text\");\n  $sky_btn.on(\"click\", function name(params) {\n    $(\"#touch-me-not\").removeClass(\"hide-btn\");\n    TweenMax.to($touch_me_not_IMG, 0.5, {\n      width: \"200px\"\n    });\n    TweenMax.to($cloud_text, 0.5, {\n      autoAlpha: 0,\n      scale: 0\n    });\n    $sky_pop_up.addClass(\"animate__bounceIn\");\n    $sky_pop_up.show();\n    setTimeout(function () {\n      $sky_pop_up.hide();\n    }, 4000);\n  });\n  $touch_me_not.on(\"click\", function name(params) {\n    // alert();\n    $touch_me_not.toggleClass(\"zoom\");\n  }); // $touch_me_not_IMG.hover(over, null);\n  // $touch_me_not.hover(null, out);\n  // TweenMax.to($touch_me_not_IMG, 0.5, {\n  //     x: \"0%\",\n  //     width: \"200px\",\n  // })\n  // TweenMax.to($cloud_text, 0.5, {\n  //     autoAlpha: 1,\n  //     scale: 0\n  // })\n\n  var res_SIZE = isMob == true ? WIW * 2 : \"200px\";\n  $land_btn.on(\"click\", function name(params) {\n    $land_pop_up.addClass(\"animate__bounceIn\");\n    $land_pop_up.show();\n    setTimeout(function () {\n      $land_pop_up.hide();\n    }, 4000);\n  });\n  $earth_btn.on(\"click\", function name(params) {\n    $earth_pop_up.addClass(\"animate__bounceIn\");\n    $earth_pop_up.show();\n    setTimeout(function () {\n      $earth_pop_up.hide();\n    }, 4000);\n  });\n  $sea_btn.on(\"click\", function name(params) {\n    $sea_pop_up.addClass(\"animate__bounceIn\");\n    $sea_pop_up.show();\n    setTimeout(function () {\n      $sea_pop_up.hide();\n    }, 4000);\n  });\n  $('.text_btn').hover(function () {\n    $(this).addClass('animate__wobble');\n  }, function () {\n    $(this).removeClass('animate__wobble');\n  }); //////////////////////////// MODAL ////////////////////////////////\n\n  $(\".close-button\").click(function () {\n    TweenMax.to(\".actual-message\", 0.5, {\n      marginTop: 50,\n      opacity: 0,\n      ease: \"ease-in\"\n    });\n    TweenMax.to(\".modal\", 0.5, {\n      opacity: 0,\n      y: \"-100%\"\n    });\n  });\n  $(\".register-btn\").click(function () {\n    // console.log(\"REG\");\n    TweenMax.fromTo(\".actual-message\", 0.5, {\n      marginTop: 50,\n      opacity: 0,\n      ease: Back.easeOut,\n      delay: 1.5\n    }, {\n      marginTop: 50,\n      opacity: 1,\n      ease: \"ease-in\"\n    });\n    TweenMax.fromTo(\".modal\", 0.5, {\n      opacity: 0,\n      y: \"-100%\"\n    }, {\n      opacity: 1,\n      y: \"0%\"\n    });\n  }); // Init controller\n\n  var window_controller = new ScrollMagic.Controller({\n    globalSceneOptions: {\n      duration: \"100%\",\n      triggerHook: .025,\n      reverse: true\n    }\n  });\n  var scenes = {\n    'scene1': {\n      'space': 'space_link'\n    },\n    'scene2': {\n      'sky': 'sky_link'\n    },\n    'scene3': {\n      'land': 'land_link'\n    },\n    'scene4': {\n      'earth': 'earth_link'\n    },\n    'scene5': {\n      'underwater': 'underwater_link'\n    }\n  };\n\n  for (var key in scenes) {\n    // skip loop if the property is from prototype\n    if (!scenes.hasOwnProperty(key)) continue;\n    var obj = scenes[key];\n\n    for (var prop in obj) {\n      // skip loop if the property is from prototype\n      if (!obj.hasOwnProperty(prop)) continue;\n      new ScrollMagic.Scene({\n        triggerElement: '#' + prop\n      }).setClassToggle('#' + obj[prop], 'active').addTo(window_controller);\n      new ScrollMagic.Scene({\n        triggerElement: '#' + prop\n      }).setClassToggle('#' + prop, 'active').addTo(window_controller);\n    }\n  } // Change behaviour of controller\n  // to animate scroll instead of jump\n\n\n  window_controller.scrollTo(function (target) {\n    TweenMax.to(window, 2, {\n      scrollTo: {\n        y: target,\n        autoKill: true // Allow scroll position to change outside itself\n\n      },\n      ease: Cubic.easeInOut\n    });\n  });\n\n  if (Modernizr.touch) {\n    // callback\n    var onScroll = function onScroll() {\n      if ($(window).scrollTop() + window.innerHeight >= document.body.scrollHeight) {\n        track_page++;\n        load_contents(track_page);\n      }\n    };\n\n    console.log('Touch Screen');\n\n    if (typeof Modernizr != \"undefined\" && Modernizr.mq('(orientation: landscape)')) {\n      console.log('you are in landscape mode, please use Portrait Mode');\n      $(\".orientationchange\").addClass(\"show\");\n    } else {\n      $(\".orientationchange\").removeClass(\"show\");\n    }\n\n    $(document.body).on('touchmove', onScroll); // for mobile\n\n    $(window).on('scroll', onScroll);\n  } else {\n    console.log('No Touch Screen');\n  }\n\n  if (typeof Modernizr != \"undefined\" && Modernizr.mq('(orientation: portrait)')) {\n    console.log('portrait');\n  } else if (typeof Modernizr != \"undefined\" && Modernizr.mq('(orientation: landscape)')) {\n    console.log('landscape');\n  } // Init controller\n\n\n  var win_controller = new ScrollMagic.Controller(); // Change behavior of controller\n  // to animate scroll instead of jump\n\n  win_controller.scrollTo(function (target) {\n    TweenMax.to($(\"html\"), 2, {\n      scrollTo: {\n        y: target,\n        // scroll position of the target along y axis\n        autoKill: true // allows user to kill scroll action smoothly\n\n      },\n      ease: Cubic.easeOut\n    });\n  }); //  Bind scroll to anchor links\n\n  $(document).on(\"click\", \".navs a\", function (e) {\n    var id = $(this).attr(\"href\");\n\n    if ($(id).length > 0) {\n      e.preventDefault();\n      win_controller.scrollTo(id);\n\n      if (window.history && window.history.pushState) {\n        history.pushState(\"\", document.title, id);\n      }\n    }\n  });\n  $(document).on(\"click\", \"a.replay-btn\", function (e) {\n    var id = $(this).attr(\"href\");\n    audio.play();\n\n    if ($(id).length > 0) {\n      e.preventDefault(); // trigger scroll\n\n      win_controller.scrollTo(id); // If supported by the browser we can also update the URL\n\n      if (window.history && window.history.pushState) {\n        history.pushState(\"\", document.title, id);\n      }\n    }\n  });\n  orientationChange();\n  windowResize(); // configure iScroll\n  // var myScroll = new IScroll('#example-wrapper', {\n  //     // don't scroll horizontal\n  //     scrollX: false,\n  //     // but do scroll vertical\n  //     scrollY: true,\n  //     // show scrollbars\n  //     scrollbars: true,\n  //     // deactivating -webkit-transform because pin wouldn't work because of a webkit bug: https://code.google.com/p/chromium/issues/detail?id=20574\n  //     // if you dont use pinning, keep \"useTransform\" set to true, as it is far better in terms of performance.\n  //     useTransform: false,\n  //     // deativate css-transition to force requestAnimationFrame (implicit with probeType 3)\n  //     useTransition: false,\n  //     // set to highest probing level to get scroll events even during momentum and bounce\n  //     // requires inclusion of iscroll-probe.js\n  //     probeType: 3\n  // });\n  // if (Modernizr.touch && myScroll) { // when using iscroll\n  //     controller_ROCKET.scrollTo(function(newpos) {\n  //         myScroll.scrollTo(0, -newpos - myScroll.y, 1000, IScroll.utils.ease.quadratic)\n  //     });\n  // } else {\n  //     controller_ROCKET.scrollTo(function(newpos) {\n  //         TweenMax.to(\"#example-wrapper\", 1, { scrollTo: { y: newpos } });\n  //     });\n  // }\n\n  var oldValue1 = 0;\n  var newValue1 = 0;\n  var dir = \"\";\n  window.addEventListener('scroll', function (e) {\n    newValue1 = window.pageYOffset;\n\n    if (oldValue1 < newValue1) {\n      // console.log(\"scrolling page Up\", newValue1, WIH * 4);\n      if (newValue1 > WIH / 2) {//$('.go-up').show();\n      }\n\n      if (newValue1 >= WIH * 3.5) {//$('.go-down').hide();\n        // $('.go-down').removeClass(\"animate\");\n      }\n    } else {\n      if (newValue1 < 2) {// $('.go-up').hide();\n        // $('.go-down').hide();\n      }\n\n      if (newValue1 < WIH * 4) {// $('.go-down').show();\n        // $('.go-down').addClass(\"animate\");\n      } // console.log(\"scrolling page Down\", newValue1);\n\n    }\n\n    if (newValue1 > WIH * 3) {\n      $('.go-down').show();\n      $('.go-up').hide();\n\n      if (newValue1 >= WIH * 3.5) {\n        $('.go-down').hide();\n      }\n    } else {\n      $('.go-down').hide();\n      $('.go-up').show();\n\n      if (newValue1 < WIH / 2) {\n        $('.go-up').hide();\n      }\n    }\n\n    oldValue1 = newValue1;\n  });\n  var sec_elm = $('section');\n  var anyActive = false;\n\n  function getSectionId() {\n    var section_id = $(document).find('section.active').prev().attr(\"id\");\n    return section_id;\n  }\n\n  function setScroll(dir) {\n    if (dir == \"up\") {\n      //window.scrollTo({ top: window.pageYOffset - WIH, behavior: 'smooth' });\n      var section_id = $(document).find('section.active').prev().attr(\"id\");\n      console.log(\"section_id\", section_id);\n      $('#' + section_id + '_link').get(0).click(); // var prev_id = $(document).find('section.active').prev().attr(\"id\");\n      // win_controller.scrollTo(prev_id);\n\n      audio.play();\n    } else {\n      // window.scrollTo({ top: window.pageYOffset + WIH, behavior: 'smooth' });\n      var section_id = $(document).find('section.active').next().attr(\"id\");\n      $('#' + section_id + '_link').get(0).click(); // var next_id = $(document).find('section.active').next().attr(\"id\");\n      // win_controller.scrollTo(next_id);\n\n      splashAudio.play();\n    }\n  }\n\n  $('.go-down').on(\"click\", function () {\n    dir = \"down\";\n    setScroll(dir);\n  });\n  $('.go-up').on(\"click\", function () {\n    dir = \"up\";\n    setScroll(dir);\n  }); //SOUND\n\n  var mute = document.getElementById('mute'),\n      text = mute.firstChild;\n  var isPlaying = true;\n  var elems = document.querySelectorAll(\"video, audio\");\n  mute.addEventListener('click', function () {\n    isPlaying = !isPlaying;\n    $(this).toggleClass('mute');\n\n    if (isPlaying === false) {\n      var _iterator = _createForOfIteratorHelper(elems),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var el = _step.value;\n          el.muted = true;\n          el.pause();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else {\n      var _iterator2 = _createForOfIteratorHelper(elems),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _el = _step2.value;\n          _el.muted = false;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, false);\n});\n\nfunction orientationChange() {\n  if (window.addEventListener) {\n    window.addEventListener(\"orientationchange\", function () {\n      location.reload();\n    });\n  }\n}\n\nfunction windowResize() {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUEsU0FBUyxHQUFHLENBQUNBLFNBQWI7QUFFQTdNLElBQUFBLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUW9KLFdBQVIsQ0FBb0IsTUFBcEI7O0FBRUEsUUFBSXlELFNBQVMsS0FBSyxLQUFsQixFQUF5QjtBQUFBLGlEQUNKQyxLQURJO0FBQUE7O0FBQUE7QUFDckIsNERBQXdCO0FBQUEsY0FBYkUsRUFBYTtBQUNwQkEsVUFBQUEsRUFBRSxDQUFDQyxLQUFILEdBQVcsSUFBWDtBQUNBRCxVQUFBQSxFQUFFLENBQUNFLEtBQUg7QUFDSDtBQUpvQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS3hCLEtBTEQsTUFLTztBQUFBLGtEQUNjSixLQURkO0FBQUE7O0FBQUE7QUFDSCwrREFBd0I7QUFBQSxjQUFiRSxHQUFhO0FBQ3BCQSxVQUFBQSxHQUFFLENBQUNDLEtBQUgsR0FBVyxLQUFYO0FBQ0g7QUFIRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSU47QUFDSixHQWZELEVBZUcsS0FmSDtBQWlCSCxDQWxwQ0EsQ0FBRDs7QUFvcENBLFNBQVNyQixpQkFBVCxHQUE2QjtBQUN6QixNQUFJaEssTUFBTSxDQUFDUSxnQkFBWCxFQUE2QjtBQUN6QlIsSUFBQUEsTUFBTSxDQUFDUSxnQkFBUCxDQUF3QixtQkFBeEIsRUFBNkMsWUFBVztBQUNwRCtLLE1BQUFBLFFBQVEsQ0FBQ0MsTUFBVDtBQUNILEtBRkQ7QUFHSDtBQUNKOztBQUVELFNBQVN2QixZQUFULEdBQXdCLENBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2VhcmVhdGhsb24vZnJvbnRlbmQtd2VicGFjay1ib2lsZXJwbGF0ZS8uL3NyYy9qcy9yb2NrZXQuanM/NjJhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgU2Nyb2xsYmFyIGZyb20gJ3Ntb290aC1zY3JvbGxiYXInO1xyXG5cclxuaW1wb3J0IHBpcGVFbXB0eUltZyBmcm9tICcuLi9hc3NldHMvZWFydGgvcGlwZS1ib3QtZW1wdHkuc3ZnJztcclxuaW1wb3J0IHBpcGVGaWxsZWRJbWcgZnJvbSAnLi4vYXNzZXRzL2VhcnRoL3BpcGUtYm90LWZpbGxlZC5zdmcnO1xyXG5pbXBvcnQgc3VibWFyaW5lSW1nIGZyb20gJy4uL2Fzc2V0cy9tZWRvdy9zdWJtYXJpbmUuc3ZnJztcclxuaW1wb3J0IHNwYWNlc2hpcEltZyBmcm9tICcuLi9hc3NldHMvbWVkb3cvc3BhY2VzaGlwLnN2Zyc7XHJcblxyXG5pbXBvcnQgc3Rhcl95ZWxsb3cgZnJvbSAnLi4vYXNzZXRzL3NreS9zdGFyLXllbGxvdy5zdmcnO1xyXG5pbXBvcnQgc3Rhcl9ncmV5IGZyb20gJy4uL2Fzc2V0cy9za3kvc3Rhci1ncmV5LnN2Zyc7XHJcbmltcG9ydCBzdGFyX3doaXRlIGZyb20gJy4uL2Fzc2V0cy9za3kvc3Rhci13aGl0ZS5zdmcnO1xyXG5cclxuLy8gU2Nyb2xsYmFyLmluaXQoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Njcm9sbC1jb250YWluZXInKSApO1xyXG5cclxuXHJcbiQoZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBWQVJTXHJcbiAgICBsZXQgV0lXID0gdmVyZ2Uudmlld3BvcnRXKCk7XHJcbiAgICBsZXQgV0lIID0gdmVyZ2Uudmlld3BvcnRIKCk7XHJcblxyXG4gICAgbGV0IFJvY2tldF9XaWR0aCA9IDIwMDtcclxuICAgIGxldCBSb2NrZXRfSGVpZ2h0ID0gMTYwO1xyXG4gICAgbGV0IGxhdW5jaHBhZF9IZWlnaHQgPSAzMDtcclxuICAgIGxldCByb2NrZXRfYmFzZV9vZmZzZXQgPSAwO1xyXG5cclxuICAgIHZhciBTRUNUSU9OID0gJChcInNlY3Rpb25cIilcclxuICAgIHZhciBFTE0gPSAkKFwiLmVsbVwiKVxyXG4gICAgdmFyIEVBUlRIX0xBWUVSID0gJChcIi5lYXJ0aC1sYXllclwiKVxyXG4gICAgdmFyIFBJUEUgPSAkKFwiLnBpcGVcIilcclxuICAgIHZhciBMT0dPX1JFU19ZX09GRlNFVCA9IDUwO1xyXG5cclxuICAgIGlmIChXSVcgPCA1MzApIHtcclxuICAgICAgICBSb2NrZXRfSGVpZ2h0ID0gMzY5IC8gMjtcclxuICAgICAgICBSb2NrZXRfV2lkdGggPSAyMDAgLyAyO1xyXG4gICAgICAgIHJvY2tldF9iYXNlX29mZnNldCA9IDBcclxuICAgICAgICBMT0dPX1JFU19ZX09GRlNFVCA9IDEwMDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgU1RBUlNfQ09VTlQgPSAxMDA7XHJcbiAgICAvLyBTZXQgU2VjdGlvbiBIZWlnaHRcclxuICAgIGlmIChXSVcgPiA0ODApIHtcclxuICAgICAgICBTRUNUSU9OLmNzcygnaGVpZ2h0JywgV0lIICsgXCJweFwiKTtcclxuICAgICAgICBFTE0uY3NzKCdoZWlnaHQnLCBXSUggKyBcInB4XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIEVBUlRIX0xBWUVSLmNzcygnaGVpZ2h0JywgKFdJSCAvIDIpICsgXCJweFwiKVxyXG4gICAgRUFSVEhfTEFZRVIuY3NzKCdtYXJnaW4tdG9wJywgLShXSUggLyA0KSArIFwicHhcIilcclxuICAgIFBJUEUuY3NzKCdoZWlnaHQnLCAoV0lIIC8gMS41KSArIFwicHhcIilcclxuICAgIFBJUEUuY3NzKCdtYXJnaW4tdG9wJywgLShXSUggLyAxLjUpIC8gMiArIFwicHhcIilcclxuXHJcbiAgICAkKCcuc3BhY2UtYmctaW1nJykuY3NzKCdoZWlnaHQnLCBXSUggKyBcInB4XCIpXHJcbiAgICAkKFwiLnJheXNcIikuY3NzKCdoZWlnaHQnLCBXSUggKyBcInB4XCIpXHJcblxyXG4gICAgaWYgKFdJVyA8IDQ4MCkge1xyXG4gICAgICAgIFNUQVJTX0NPVU5UID0gMjU7XHJcbiAgICAgICAgUElQRS5jc3MoJ2hlaWdodCcsIChXSUggLyAxLjUpICsgXCJweFwiKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc01vYiA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChXSVcgPCA0ODApIHtcclxuICAgICAgICBTVEFSU19DT1VOVCA9IDI1O1xyXG4gICAgICAgIFBJUEUuY3NzKCdoZWlnaHQnLCAoV0lIIC8gMS41KSArIFwicHhcIilcclxuICAgICAgICBpc01vYiA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdmFyIFNUQVJTX0FSUkFZID0gW1wic3Rhci15ZWxsb3dcIiwgXCJzdGFyLWdyZXlcIiwgXCJzdGFyLXdoaXRldFwiXTtcclxuICAgIHZhciBTVEFSU19BUlJBWSA9IFtzdGFyX3llbGxvdywgc3Rhcl9ncmV5LCBzdGFyX3doaXRlXTtcclxuXHJcbiAgICB2YXIgU1RBUlNfU0laRV9BUlJBWSA9IFtcInRpbnlcIiwgXCJzbWFsbFwiLCBcIm1lZGl1bVwiLCBcImJpZ1wiXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUQVJTX0NPVU5UOyBpKyspIHtcclxuICAgICAgICB2YXIgcmFuZG9tU3RhciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFNUQVJTX0FSUkFZLmxlbmd0aCk7XHJcbiAgICAgICAgdmFyIHJhbmRvbVN0YXJTaXplID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogU1RBUlNfU0laRV9BUlJBWS5sZW5ndGgpO1xyXG4gICAgICAgIHZhciBzdGFyID0gJzxkaXYgY2xhc3M9XCJzdGFyICcgKyBTVEFSU19TSVpFX0FSUkFZW3JhbmRvbVN0YXJTaXplXSArICdcIiBzdHlsZT1cInotaW5kZXg6IDk7IG9wYWNpdHk6JyArIE1hdGgucmFuZG9tKDAuNSwgMSkgKyAnOyBhbmltYXRpb246IHR3aW5rbGUgJyArICgoTWF0aC5yYW5kb20oKSAqIDUpICsgNSkgKyAncyBsaW5lYXIgJyArICgoTWF0aC5yYW5kb20oKSAqIDUpICsgNSkgKyAncyBpbmZpbml0ZTsgdG9wOiAnICsgTWF0aC5yYW5kb20oKSAqICgkKHdpbmRvdykuaGVpZ2h0KCkgLSA1MCkgKyAncHg7IGxlZnQ6ICcgKyBNYXRoLnJhbmRvbSgpICogJCh3aW5kb3cpLndpZHRoKCkgKyAncHg7XCI+PGltZyBzcmM9XCInICsgU1RBUlNfQVJSQVlbcmFuZG9tU3Rhcl0gKyAnXCIvPjwvZGl2Pic7XHJcbiAgICAgICAgJCgnI3NwYWNlJykuYXBwZW5kKHN0YXIpO1xyXG4gICAgfVxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEhPUklaT05UQUwgU0NST2xsXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMwOyBpKyspIHtcclxuICAgICAgICB2YXIgcmFuZG9tU3RhciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFNUQVJTX0FSUkFZLmxlbmd0aCk7XHJcbiAgICAgICAgdmFyIHJhbmRvbVN0YXJTaXplID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogU1RBUlNfU0laRV9BUlJBWS5sZW5ndGgpO1xyXG4gICAgICAgIHZhciBzdGFyID0gJzxkaXYgY2xhc3M9XCJzdGFyICcgKyBTVEFSU19TSVpFX0FSUkFZW3JhbmRvbVN0YXJTaXplXSArICdcIiBzdHlsZT1cInotaW5kZXg6IDk7IG9wYWNpdHk6JyArIE1hdGgucmFuZG9tKDAuNSwgMSkgKyAnOyBhbmltYXRpb246IHR3aW5rbGUgJyArICgoTWF0aC5yYW5kb20oKSAqIDUpICsgNSkgKyAncyBsaW5lYXIgJyArICgoTWF0aC5yYW5kb20oKSAqIDUpICsgNSkgKyAncyBpbmZpbml0ZTsgdG9wOiAnICsgTWF0aC5yYW5kb20oKSAqICgkKHdpbmRvdykuaGVpZ2h0KCkgLyAyKSArICdweDsgbGVmdDogJyArIE1hdGgucmFuZG9tKCkgKiAkKHdpbmRvdykud2lkdGgoKSArICdweDtcIj48aW1nIHNyYz1cIicgKyBTVEFSU19BUlJBWVtyYW5kb21TdGFyXSArICdcIi8+PC9kaXY+JztcclxuICAgICAgICAkKCcjc2t5JykuYXBwZW5kKHN0YXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHZhciBjb250cm9sbGVyX2ggPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcih7dmVydGljYWw6IGZhbHNlfSk7XHJcbiAgICAvLyB2YXIgdHdlZW5fUk9DS0VUX0ggPSBuZXcgVGltZWxpbmVNYXgoKVxyXG4gICAgLy8gICAgIC50byhcIiNyb2NrZXRcIiwgMC41LCB7XHJcbiAgICAvLyAgICAgICAgIC8vIHJvdGF0aW9uOiA0MCxcclxuICAgIC8vICAgICAgfSlcclxuICAgIC8vIC8vIGJ1aWxkIHNjZW5lXHJcbiAgICAvLyB2YXIgc2NlbmVfaCA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7ZHVyYXRpb246IFwiMTAwJVwifSlcclxuICAgIC8vIFx0XHRcdFx0LnNldFR3ZWVuKHR3ZWVuX1JPQ0tFVF9IKVxyXG4gICAgLy8gXHRcdFx0XHQvLyAuc2V0UGluKFwiI3JvY2tldFwiKVxyXG4gICAgLy8gXHRcdFx0XHQuYWRkSW5kaWNhdG9ycyh7bmFtZTogXCJyb3RhdGVfaFwifSkgLy8gYWRkIGluZGljYXRvcnMgKHJlcXVpcmVzIHBsdWdpbilcclxuICAgIC8vIFx0XHRcdFx0LmFkZFRvKGNvbnRyb2xsZXJfaCk7XHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gQlVCQkxFU1xyXG5cclxuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgNTA7IGIrKykge1xyXG4gICAgICAgIHZhciBidWJibGVzID0gJzxkaXYgY2xhc3M9XCJidWJibGVcIiBzdHlsZT1cInotaW5kZXg6IDk7YW5pbWF0aW9uOiBtb3ZlQnViYmxlcyAnICsgKChNYXRoLnJhbmRvbSgpICogMykgKyAzKSArICdzIGxpbmVhciAnICsgKChNYXRoLnJhbmRvbSgpICogNSkgKyA1KSArICdzIGluZmluaXRlOyB0b3A6ICcgKyBNYXRoLnJhbmRvbSgpICogJCh3aW5kb3cpLmhlaWdodCgpICsgJ3B4OyBsZWZ0OiAnICsgTWF0aC5yYW5kb20oKSAqICQod2luZG93KS53aWR0aCgpICsgJ3B4OyB0cmFuc2Zvcm06c2NhbGUoJyArIE1hdGgucmFuZG9tKCkgKyAnKVwiPiA8L2Rpdj4nO1xyXG4gICAgICAgICQoJy5idWJibGVzJykuYXBwZW5kKGJ1YmJsZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBQT1BVUFxyXG4gICAgLy8gZm9yICh2YXIgcCA9IDA7IHAgPCAyNTsgcCsrKSB7XHJcbiAgICAvLyAgICAgdmFyIHBvcF91cHMgPSAnPGRpdiBjbGFzcz1cInBvcHVwX2J1YmJsZVwiIHN0eWxlPVwiei1pbmRleDogMjAwOyB0b3A6ICcgKyBNYXRoLnJhbmRvbSgpICogKCQod2luZG93KS5oZWlnaHQoKSAvIDIpICsgJ3B4OyBsZWZ0OiAnICsgTWF0aC5yYW5kb20oKSAqICgkKHdpbmRvdykud2lkdGgoKSAvIDIpICsgJ3B4OyAgXCI+IDwvZGl2Pic7XHJcbiAgICAvLyAgICAgJCgnLnRleHRfcG9wX3VwJykuYXBwZW5kKHBvcF91cHMpO1xyXG4gICAgLy8gfVxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIEZMQU1FU1xyXG5cclxuICAgIGxldCBvbGRWYWx1ZSA9IDBcclxuICAgIGxldCBuZXdWYWx1ZSA9IDBcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoZSkgPT4ge1xyXG4gICAgICAgIG5ld1ZhbHVlID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG4gICAgICAgIGlmIChvbGRWYWx1ZSA8IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIChvbGRWYWx1ZSA+IFdJSCAqIDMpIHtcclxuICAgICAgICAgICAgLy8gICAgICQoJyNyb2NrZXQgaW1nJykuYXR0cihcInNyY1wiLCAnLi9hc3NldHMvbWVkb3cvc3VibWFyaW5lLnN2ZycpO1xyXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAgICAgJCgnI3JvY2tldCBpbWcnKS5hdHRyKFwic3JjXCIsICcuL2Fzc2V0cy9tZWRvdy9yb2NrZXRfcmVkX2Rvd24uc3ZnJyk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgLy8gJChcIiNyb2NrZXRcIikuYWRkQ2xhc3MoJ2dvLWRvd24nKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJzY3JvbGxpbmcgcGFnZSBVcFwiLCBuZXdWYWx1ZSwgV0lIICogNCk7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA+PSAoV0lIICogNCAtIDEwMCkpIHtcclxuICAgICAgICAgICAgICAgICQoJy5kaXJhY3Rpb25zIGJ1dHRvbjpudGgtY2hpbGQoMyknKS5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID49IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgJCgnLmRpcmFjdGlvbnMgYnV0dG9uOm50aC1jaGlsZCgxKScpLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlID4gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gaWYgKG9sZFZhbHVlIDwgV0lIICogMi41KSB7XHJcbiAgICAgICAgICAgIC8vICAgICAkKCcjcm9ja2V0IGltZycpLmF0dHIoXCJzcmNcIiwgJy4vYXNzZXRzL21lZG93L3JvY2tldC0yLnN2ZycpO1xyXG4gICAgICAgICAgICAvLyAgICAgJCgnI3JvY2tldCcpLmFkZENsYXNzKFwiYWRkU21va2VcIik7XHJcbiAgICAgICAgICAgIC8vICAgICAkKCcjcm9ja2V0JykucmVtb3ZlQ2xhc3MoXCJzdWJtYXJpbmVcIik7XHJcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vICAgICAkKCcjcm9ja2V0IGltZycpLmF0dHIoXCJzcmNcIiwgJy4vYXNzZXRzL21lZG93L3N1Ym1hcmluZS5zdmcnKTtcclxuICAgICAgICAgICAgLy8gICAgICQoJyNyb2NrZXQnKS5yZW1vdmVDbGFzcyhcImFkZFNtb2tlXCIpO1xyXG4gICAgICAgICAgICAvLyAgICAgJCgnI3JvY2tldCcpLmFkZENsYXNzKFwic3VibWFyaW5lXCIpO1xyXG4gICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICAvLyAkKFwiI3JvY2tldFwiKS5yZW1vdmVDbGFzcygnZ28tZG93bicpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInNjcm9sbGluZyBwYWdlIERvd25cIiwgbmV3VmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlIDw9IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgJCgnLmRpcmFjdGlvbnMgYnV0dG9uOm50aC1jaGlsZCgxKScpLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlIDw9IChXSUggKiA0IC0gMTAwKSkge1xyXG4gICAgICAgICAgICAgICAgJCgnLmRpcmFjdGlvbnMgYnV0dG9uOm50aC1jaGlsZCgzKScpLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUk9DS0VUXHJcbiAgICB2YXIgY29udHJvbGxlcl9ST0NLRVQgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcigpO1xyXG4gICAgdmFyIHR3ZWVuX1JPQ0tFVCA9IG5ldyBUaW1lbGluZU1heCgpXHJcbiAgICAgICAgLnRvKFwiI3JvY2tldFwiLCAxLCB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IChXSUggLyAyKSAtIChSb2NrZXRfSGVpZ2h0KSxcclxuICAgICAgICAgICAgZWFzZTogJ0Vhc2VJbidcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50byhcIiNyb2NrZXRcIiwgMC41LCB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiU1RFUCAtIDJcIilcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZWFzZTogJ1Bvd2VyNC5vdXQnXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudG8oXCIjcm9ja2V0XCIsIDAuNSwge1xyXG4gICAgICAgICAgICB4OiAtMTAwLFxyXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlNURVAgLSAzXCIpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVhc2U6ICdQb3dlcjQub3V0J1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRvKFwiI3JvY2tldFwiLCAwLjUsIHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogKFdJSCAvIDIgLSBSb2NrZXRfSGVpZ2h0KSxcclxuICAgICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge30sXHJcbiAgICAgICAgICAgIGVhc2U6ICdQb3dlcjQub3V0J1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRvKFwiI3JvY2tldFwiLCAxLCB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IChXSUggLyAyKSAtIChSb2NrZXRfSGVpZ2h0IC8gMikgLSByb2NrZXRfYmFzZV9vZmZzZXQsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHt9LFxyXG4gICAgICAgICAgICBlYXNlOiAnUG93ZXI0Lm91dCdcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vIHR3ZWVuX1JPQ0tFVC5jYWxsKGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gICAgICQoJyNyb2NrZXQnKS50b2dnbGVDbGFzcyhcImFkZFNtb2tlXCIpO1xyXG4gICAgLy8gfSwgbnVsbCwgbnVsbCwgMCk7XHJcblxyXG4gICAgLy8gYnVpbGQgc2NlbmVcclxuICAgIHZhciBzY2VuZV9ST0NLRVQgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjcm9ja2V0X3RyaWdnZXJcIixcclxuICAgICAgICAgICAgLy8gZHVyYXRpb246IDMwMDAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBcIjIwMCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBXSUggLSA1XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0VHdlZW4odHdlZW5fUk9DS0VUKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJST0NLRVRcIiB9KVxyXG4gICAgICAgIC5hZGRUbyhjb250cm9sbGVyX1JPQ0tFVClcclxuICAgICAgICAudHJpZ2dlckhvb2soXCIxXCIpO1xyXG4gICAgc2NlbmVfUk9DS0VULm9uKFwic3RhcnRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAkKCcjcm9ja2V0JykuYWRkQ2xhc3MoXCJhZGRTbW9rZVwiKTtcclxuICAgICAgICAvLyAkKCcubGF1bmNoZXItYmFzZScpLnNob3coKTtcclxuICAgICAgICAvLyAkKCcubGF1bmNoZXItYmFzZScpLnNob3coKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlNUQVJURUQuLi4uXCIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc2NlbmVfUk9DS0VULm9uKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlNjZW5lIHByb2dyZXNzIGNoYW5nZWQgdG8gXCIgKyBldmVudC5wcm9ncmVzcyk7XHJcbiAgICB9KTtcclxuICAgIC8vICBiaW5kIHNjcm9sbCB0byBhbmNob3IgbGlua3NcclxuXHJcbiAgICAvLyBjaGFuZ2UgYmVoYXZpb3VyIG9mIGNvbnRyb2xsZXIgdG8gYW5pbWF0ZSBzY3JvbGwgaW5zdGVhZCBvZiBqdW1wXHJcbiAgICBjb250cm9sbGVyX1JPQ0tFVC5zY3JvbGxUbyhmdW5jdGlvbihuZXdwb3MpIHtcclxuICAgICAgICBUd2Vlbk1heC50byh3aW5kb3csIDEsIHtcclxuICAgICAgICAgICAgc2Nyb2xsVG86IHtcclxuICAgICAgICAgICAgICAgIHk6IG5ld3Bvc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIC8vIFJPQ0tFVCBFTkQgY29udHJvbGxlcl9ST0NLRVRcclxuICAgIHZhciBjb250cm9sbGVyX1NQQUNFID0gbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoKTtcclxuICAgIHZhciBjb250cm9sbGVyX1NLWSA9IG5ldyBTY3JvbGxNYWdpYy5Db250cm9sbGVyKCk7XHJcbiAgICB2YXIgY29udHJvbGxlcl9MQU5EID0gbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoKTtcclxuICAgIHZhciBjb250cm9sbGVyX0VBUlRIID0gbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoKTtcclxuICAgIHZhciBjb250cm9sbGVyX1VOREVSV0FURVIgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcigpO1xyXG4gICAgdmFyIGNvbnRyb2xsZXJfU1VCXzIgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcigpO1xyXG4gICAgdmFyIGNvbnRyb2xsZXJfQlVUVE9OID0gbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoKTtcclxuICAgIHZhciBjb250cm9sbGVyX0JVVFRPTjIgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcigpO1xyXG5cclxuICAgIC8vIEFVRElPXHJcbiAgICB2YXIgYXVkaW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImF1ZGlvXCIpO1xyXG4gICAgdmFyIHNwbGFzaEF1ZGlvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzcGxhc2gtYXVkaW9cIik7XHJcbiAgICB2YXIgbWV0YWxIaXRBdWRpbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWV0YWwtaGl0LWF1ZGlvXCIpO1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gU1BBQ0UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIHZhciBzY2VuZV9CVVRUT04gPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjbGFuZFwiLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCI2MCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAvLyAuc2V0Q2xhc3NUb2dnbGUoXCIuZ28tdXBcIiwgXCJhbmltYXRlXCIpXHJcbiAgICAgICAgLy8gLmFkZEluZGljYXRvcnMoeyBuYW1lOiBcInNjZW5lX0JVVFRPTlwiIH0pXHJcbiAgICAgICAgLmFkZFRvKGNvbnRyb2xsZXJfU1BBQ0UpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDAuNSk7XHJcblxyXG4gICAgdmFyIHNjZW5lX0JVVFRPTjIgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjZWFydGhcIixcclxuICAgICAgICAgICAgZHVyYXRpb246IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IChXSUggLyAzLjUpIC0gMjBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zZXRDbGFzc1RvZ2dsZShcIi5nby1kb3duXCIsIFwic2hvd1wiKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJzY2VuZV9CVVRUT04yXCIgfSlcclxuICAgICAgICAuYWRkVG8oY29udHJvbGxlcl9FQVJUSClcclxuICAgICAgICAudHJpZ2dlckhvb2soMC41KTtcclxuXHJcbiAgICB2YXIgdHdlZW5fU1BBQ0VfYnRuID0gbmV3IFRpbWVsaW5lTWF4KClcclxuICAgICAgICAudG8oXCIjc3BhY2VfYnRuXCIsIDAuNSwge1xyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRvKFwiI3NwYWNlX2J0blwiLCAwLjUsIHtcclxuICAgICAgICAgICAgeDogMTIwLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIHZhciBzY2VuZV9TUEFDRSA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFbGVtZW50OiBcIiNzcGFjZVwiLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCI1MCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBXSUggLyA0XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0Q2xhc3NUb2dnbGUoXCIuc3BhY2UtY3RhXCIsIFwidmlzaWJsZVwiKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJTUEFDRV9OQVZcIiB9KVxyXG4gICAgICAgIC5hZGRUbyhjb250cm9sbGVyX1NQQUNFKVxyXG4gICAgICAgIC50cmlnZ2VySG9vaygwLjUpO1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBTUEFDRSBOQVYgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIHNjZW5lX1NQQUNFX05BViA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFbGVtZW50OiBcIiNzcGFjZVwiLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCI1MCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBXSUggLyA0XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0Q2xhc3NUb2dnbGUoXCIuaW4tc3BhY2VcIiwgXCJ2aXNpYmxlXCIpXHJcbiAgICAgICAgLy8gLmFkZEluZGljYXRvcnMoeyBuYW1lOiBcIlNQQUNFXCIgfSlcclxuICAgICAgICAuYWRkVG8oY29udHJvbGxlcl9TUEFDRSlcclxuICAgICAgICAudHJpZ2dlckhvb2soMC41KTtcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gU1BBQ0UgTkFWIEVORCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBTUEFDRSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgdHdlZW5fU1BBQ0VfYnRuID0gbmV3IFRpbWVsaW5lTWF4KClcclxuICAgICAgICAudG8oXCIjc3BhY2VfYnRuXCIsIDAuNSwge1xyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRvKFwiI3NwYWNlX2J0blwiLCAwLjUsIHtcclxuICAgICAgICAgICAgeDogMTIwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgdmFyIHNjZW5lX1NLWSA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFbGVtZW50OiBcIiNzcGFjZVwiLFxyXG4gICAgICAgICAgICAvLyBkdXJhdGlvbjogNTAwLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCIyNSVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBXSUggLyA0XHJcbiAgICAgICAgfSlcclxuICAgICAgICAvLyAuc2V0VHdlZW4oW3R3ZWVuX0xBTkRfYnRuXSlcclxuICAgICAgICAuc2V0Q2xhc3NUb2dnbGUoXCIjc3BhY2VfcG9wX3VwXCIsIFwidmlzaWJsZVwiKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJTUEFDRV9URVhUXCIgfSlcclxuICAgICAgICAuYWRkVG8oY29udHJvbGxlcl9TUEFDRSlcclxuICAgICAgICAudHJpZ2dlckhvb2soMC4yNSk7XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tIFNLWSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgdHdlZW5fU0tZX2J0biA9IG5ldyBUaW1lbGluZU1heCgpXHJcbiAgICAgICAgLnRvKFwiI3NreV9idG5cIiwgMC41LCB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudG8oXCIjc2t5X2J0blwiLCAwLjUsIHtcclxuICAgICAgICAgICAgeDogMTIwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgdmFyIHNjZW5lX1NLWSA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFbGVtZW50OiBcIiNza3lcIixcclxuICAgICAgICAgICAgLy8gZHVyYXRpb246IDUwMCxcclxuICAgICAgICAgICAgZHVyYXRpb246IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC8vIC5zZXRUd2VlbihbdHdlZW5fTEFORF9idG5dKVxyXG4gICAgICAgIC5zZXRDbGFzc1RvZ2dsZShcIiNza3lfcG9wX3VwXCIsIFwidmlzaWJsZVwiKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJTS1lfVEVYVFwiIH0pXHJcbiAgICAgICAgLmFkZFRvKGNvbnRyb2xsZXJfU0tZKVxyXG4gICAgICAgIC50cmlnZ2VySG9vaygwLjUpO1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBTS1kgTkFWIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHZhciBzY2VuZV9TS1lfTkFWID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcclxuICAgICAgICAgICAgdHJpZ2dlckVsZW1lbnQ6IFwiI3NreVwiLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCI1MCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBXSUggLyA0XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0Q2xhc3NUb2dnbGUoXCIuaW4tc2t5XCIsIFwidmlzaWJsZVwiKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJTS1lfTkFWXCIgfSlcclxuICAgICAgICAuYWRkVG8oY29udHJvbGxlcl9TS1kpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDAuNSk7XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tIFNLWSBOQVYgRU5EIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tIExBTkQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIHR3ZWVuX0xBTkRfYnRuID0gbmV3IFRpbWVsaW5lTWF4KClcclxuICAgICAgICAudG8oXCIjbGFuZF9idG5cIiwgMC41LCB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudG8oXCIjbGFuZF9idG5cIiwgMC41LCB7XHJcbiAgICAgICAgICAgIHg6IDEyMCxcclxuICAgICAgICB9KTtcclxuICAgIHZhciBzY2VuZV9MQU5EID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcclxuICAgICAgICAgICAgdHJpZ2dlckVsZW1lbnQ6IFwiI2xhbmRcIixcclxuICAgICAgICAgICAgLy8gZHVyYXRpb246IDUwMCxcclxuICAgICAgICAgICAgZHVyYXRpb246IFwiNTAlXCIsXHJcbiAgICAgICAgICAgIG9mZnNldDogV0lIIC8gNFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy8gLnNldFR3ZWVuKFt0d2Vlbl9MQU5EX2J0bl0pXHJcbiAgICAgICAgLnNldENsYXNzVG9nZ2xlKFwiI2xhbmRfcG9wX3VwXCIsIFwidmlzaWJsZVwiKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJMQU5EX1RFWFRcIiB9KVxyXG4gICAgICAgIC5hZGRUbyhjb250cm9sbGVyX0xBTkQpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDAuMyk7XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tIExPR08gU0NFTkUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIHR3ZWVuX0xPR08gPSBUd2Vlbk1heC5mcm9tVG8oXCIjbG9nb1wiLCAxLCB7XHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICBhdXRvQWxwaGE6IDBcclxuICAgIH0sIHtcclxuICAgICAgICB5OiBMT0dPX1JFU19ZX09GRlNFVCxcclxuICAgICAgICBhdXRvQWxwaGE6IDFcclxuICAgIH0pO1xyXG4gICAgdmFyIHNjZW5lX0xPR08gPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjdHJpZ2dlcl9MT0dPXCIsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBcIjUwJVwiLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IC1XSUggLyAyXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0VHdlZW4oW3R3ZWVuX0xPR09dKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgIG5hbWU6IFwiTE9HT1wiIH0pXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDApXHJcbiAgICAgICAgLy8gLm9uKFwic3RhcnRcIiwgZnVuY3Rpb24oZXZlbnQpIHt9KVxyXG4gICAgICAgIC8vIC5vbihcImVuZFwiLCBmdW5jdGlvbihldmVudCkge30pXHJcbiAgICAgICAgLy8gLm9uKFwiZW50ZXJcIiwgZnVuY3Rpb24oZXZlbnQpIHt9KVxyXG4gICAgICAgIC8vIC5vbihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKGV2ZW50KSB7fSlcclxuICAgICAgICAvLyAub24oXCJyZW1vdmVcIiwgZnVuY3Rpb24oZXZlbnQpIHt9KVxyXG4gICAgICAgIC8vIC5vbihcInVwZGF0ZVwiLCBmdW5jdGlvbihldmVudCkge30pXHJcbiAgICAgICAgLy8gLm9uKFwibGVhdmVcIiwgZnVuY3Rpb24oZXZlbnQpIHt9KS5vbihcImVudGVyXCIsIGNhbGxiYWNrKS5vbihcImxlYXZlXCIsIGNhbGxiYWNrKVxyXG4gICAgICAgIC5hZGRUbyhjb250cm9sbGVyX1JPQ0tFVCk7XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBFQVJUSCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLy8gZ2xvYmFsIHZhcnNcclxuICAgIC8vIHZhciB2aWV3ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnZpZXdlclwiKSxcclxuICAgIC8vICAgICBmcmFtZV9jb3VudCA9IDksXHJcbiAgICAvLyAgICAgb2Zmc2V0X3ZhbHVlID0gMTAwO1xyXG4gICAgLy8gaW5pdCBjb250cm9sbGVyXHJcbiAgICAvLyB2YXIgY29udHJvbGxlcl9waXBlID0gbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoe1xyXG4gICAgLy8gICAgIGdsb2JhbFNjZW5lT3B0aW9uczoge1xyXG4gICAgLy8gICAgICAgICB0cmlnZ2VySG9vazogMCxcclxuICAgIC8vICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH0pO1xyXG5cclxuICAgIC8vIGJ1aWxkIHN0ZXAgZnJhbWUgc2NlbmVcclxuICAgIC8vIGZvciAodmFyIGkgPSAxLCBsID0gZnJhbWVfY291bnQ7IGkgPD0gbDsgaSsrKSB7XHJcbiAgICAvLyAgICAgbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcclxuICAgIC8vICAgICAgICAgICAgIGR1cmF0aW9uOiBmcmFtZV9jb3VudCAqIG9mZnNldF92YWx1ZSArIFwicHhcIixcclxuICAgIC8vICAgICAgICAgICAgIHRyaWdnZXJFbGVtZW50OiBcIiNlYXJ0aFwiLFxyXG4gICAgLy8gICAgICAgICAgICAgb2Zmc2V0OiBpICogb2Zmc2V0X3ZhbHVlXHJcbiAgICAvLyAgICAgICAgIH0pXHJcbiAgICAvLyAgICAgICAgIC5zZXRDbGFzc1RvZ2dsZSh2aWV3ZXIsIFwiZnJhbWVcIiArIGkpXHJcbiAgICAvLyAgICAgICAgIC5hZGRJbmRpY2F0b3JzKFwiUElQRV9TVElDS0VZXCIpXHJcbiAgICAvLyAgICAgICAgIC5hZGRUbyhjb250cm9sbGVyX3BpcGUpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gRUFSVEggVEVYVCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyB2YXIgdHdlZW5fTEFORF9idG4gPSBuZXcgVGltZWxpbmVNYXgoKVxyXG4gICAgLy8gICAgIC50byhcIiNlYXJ0aF9idG5cIiwgMC41LCB7XHJcbiAgICAvLyAgICAgICAgIHg6IDAsXHJcbiAgICAvLyAgICAgfSlcclxuICAgIC8vICAgICAudG8oXCIjZWFydGhfYnRuXCIsIDAuNSwge1xyXG4gICAgLy8gICAgICAgICB4OiAxMjAsXHJcbiAgICAvLyAgICAgfSk7XHJcblxyXG4gICAgdmFyIHNjZW5lX0VBUlRIX1BJUEUgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjZWFydGhcIixcclxuICAgICAgICAgICAgZHVyYXRpb246IFwiMzMlXCIsXHJcbiAgICAgICAgICAgIG9mZnNldDogV0lIIC8gM1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy8gLnNldFBpbihcIiNlYXJ0aFwiKVxyXG4gICAgICAgIC5zZXRDbGFzc1RvZ2dsZShcIiNwaXBlLXNlcXVlbmNlXCIsIFwidmlzaWJsZVwiKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJFQVJUSF9QSVBFXCIgfSlcclxuICAgICAgICAuYWRkVG8oY29udHJvbGxlcl9FQVJUSClcclxuICAgICAgICAudHJpZ2dlckhvb2soMC41KTtcclxuXHJcbiAgICBzY2VuZV9FQVJUSF9QSVBFLm9uKFwiZW50ZXJcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAvLyAkKCcjcGlwZS1zZXF1ZW5jZScpLmF0dHIoXCJzcmNcIiwgcGlwZUZpbGxlZEltZyk7XHJcbiAgICB9KTtcclxuICAgIHNjZW5lX0VBUlRIX1BJUEUub24oXCJsZWF2ZVwiLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIC8vICQoJyNwaXBlLXNlcXVlbmNlJykuYXR0cihcInNyY1wiLCBwaXBlRW1wdHlJbWcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHNjZW5lX0VBUlRIX1RFWFQgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjZWFydGhcIixcclxuICAgICAgICAgICAgZHVyYXRpb246IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgIC8vIC5zZXRQaW4oXCIjZWFydGhcIilcclxuICAgICAgICAuc2V0Q2xhc3NUb2dnbGUoXCIjZWFydGhfcG9wX3VwXCIsIFwidmlzaWJsZVwiKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJFQVJUSF9URVhUXCIgfSlcclxuICAgICAgICAuYWRkVG8oY29udHJvbGxlcl9FQVJUSClcclxuICAgICAgICAudHJpZ2dlckhvb2soMC41KTtcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gTEFORCBOQVYgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIHNjZW5lX1NLWV9OQVYgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjbGFuZFwiLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCI1MCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBXSUggLyA0XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0Q2xhc3NUb2dnbGUoXCIuaW4tbGFuZFwiLCBcInZpc2libGVcIilcclxuICAgICAgICAvLyAuYWRkSW5kaWNhdG9ycyh7IG5hbWU6IFwiTEFORF9OQVZcIiB9KVxyXG4gICAgICAgIC5hZGRUbyhjb250cm9sbGVyX0xBTkQpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDAuNSk7XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tIFNLWSBOQVYgRU5EIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGh0dHBzOi8vbXVrZXNobmF2bmVldC5naXRodWIuaW8vZG9jcy9hc3NldHMvZWFydGgvcGlwZS01LnN2Z1xyXG4gICAgdmFyIGltYWdlcyA9IFtcclxuICAgICAgICBcImh0dHBzOi8vbXVrZXNobmF2bmVldC5naXRodWIuaW8vZG9jcy9hc3NldHMvZWFydGgvcGlwZS0wLnN2Z1wiLFxyXG4gICAgICAgIFwiaHR0cHM6Ly9tdWtlc2huYXZuZWV0LmdpdGh1Yi5pby9kb2NzL2Fzc2V0cy9lYXJ0aC9waXBlLTEuc3ZnXCIsXHJcbiAgICAgICAgXCJodHRwczovL211a2VzaG5hdm5lZXQuZ2l0aHViLmlvL2RvY3MvYXNzZXRzL2VhcnRoL3BpcGUtMi5zdmdcIixcclxuICAgICAgICBcImh0dHBzOi8vbXVrZXNobmF2bmVldC5naXRodWIuaW8vZG9jcy9hc3NldHMvZWFydGgvcGlwZS0zLnN2Z1wiLFxyXG4gICAgICAgIFwiaHR0cHM6Ly9tdWtlc2huYXZuZWV0LmdpdGh1Yi5pby9kb2NzL2Fzc2V0cy9lYXJ0aC9waXBlLWJvdC5zdmdcIixcclxuICAgICAgICBcImh0dHBzOi8vbXVrZXNobmF2bmVldC5naXRodWIuaW8vZG9jcy9hc3NldHMvZWFydGgvcGlwZS1ib3Quc3ZnXCIsXHJcbiAgICAgICAgXCJodHRwczovL211a2VzaG5hdm5lZXQuZ2l0aHViLmlvL2RvY3MvYXNzZXRzL2VhcnRoL3BpcGUtNC5zdmdcIixcclxuICAgICAgICBcImh0dHBzOi8vbXVrZXNobmF2bmVldC5naXRodWIuaW8vZG9jcy9hc3NldHMvZWFydGgvcGlwZS01LnN2Z1wiLFxyXG4gICAgICAgIFwiaHR0cHM6Ly9tdWtlc2huYXZuZWV0LmdpdGh1Yi5pby9kb2NzL2Fzc2V0cy9lYXJ0aC9waXBlLTYuc3ZnXCIsXHJcbiAgICAgICAgXCJodHRwczovL211a2VzaG5hdm5lZXQuZ2l0aHViLmlvL2RvY3MvYXNzZXRzL2VhcnRoL3BpcGUtMC5zdmdcIixcclxuICAgIF07XHJcbiAgICB2YXIgb2JqMjIgPSB7IGN1ckltZzogMCB9O1xyXG4gICAgLy8gY3JlYXRlIHR3ZWVuXHJcbiAgICB2YXIgdHdlZW5fcGlwZV9zZXF1ZW5jZSA9IFR3ZWVuTWF4LnRvKG9iajIyLCAwLjUsIHtcclxuICAgICAgICBjdXJJbWc6IGltYWdlcy5sZW5ndGggLSAxLCAvLyBhbmltYXRlIHByb3BlcnkgY3VySW1nIHRvIG51bWJlciBvZiBpbWFnZXNcclxuICAgICAgICByb3VuZFByb3BzOiBcImN1ckltZ1wiLCAvLyBvbmx5IGludGVnZXJzIHNvIGl0IGNhbiBiZSB1c2VkIGFzIGFuIGFycmF5IGluZGV4XHJcbiAgICAgICAgcmVwZWF0OiAwLCAvLyByZXBlYXQgMyB0aW1lc1xyXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlcjogdHJ1ZSwgLy8gbG9hZCBmaXJzdCBpbWFnZSBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgZWFzZTogTGluZWFyLmVhc2VOb25lLCAvLyBzaG93IGV2ZXJ5IGltYWdlIHRoZSBzYW1lIGFtbW91bnQgb2YgdGltZVxyXG4gICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gdmFyIHN0ciA9IFwiPGltZyBjbGFzcz0nYmNnJyBzcmM9XCIrIGltYWdlc1tvYmouY3VySW1nXSArXCIvPlwiXHJcbiAgICAgICAgICAgIC8vICAkKFwiLnBpcGVcIikuaHRtbChzdHIpXHJcbiAgICAgICAgICAgICQoXCIjcGlwZS1zZXF1ZW5jZVwiKS5hdHRyKFwic3JjXCIsIGltYWdlc1tvYmoyMi5jdXJJbWddKTtcclxuICAgICAgICAgICAgLy8gc2V0IHRoZSBpbWFnZSBzb3VyY2VcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgdHdlZW5fRUFSVEhfYnRuID0gbmV3IFRpbWVsaW5lTWF4KClcclxuICAgICAgICAudG8oXCIjZWFydGhfYnRuXCIsIDEsIHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50byhcIiNlYXJ0aF9idG5cIiwgMSwge1xyXG4gICAgICAgICAgICB4OiAxMjAsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudG8oXCIjZWFydGhfYnRuXCIsIDEsIHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB2YXIgc2NlbmVfdHdlZW5fcGlwZV9zZXF1ZW5jZSA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFbGVtZW50OiBcIiNlYXJ0aFwiLFxyXG4gICAgICAgICAgICAvLyBkdXJhdGlvbjogNTAwLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCI4MCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBcIjEwJVwiXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0VHdlZW4oW3R3ZWVuX3BpcGVfc2VxdWVuY2VdKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJzY2VuZV90d2Vlbl9waXBlX3NlcXVlbmNlXCIgfSlcclxuICAgICAgICAuYWRkVG8oY29udHJvbGxlcl9FQVJUSClcclxuICAgICAgICAudHJpZ2dlckhvb2soMC41KTtcclxuXHJcbiAgICB2YXIgc2NlbmVfRUFSVEggPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjZWFydGhcIixcclxuICAgICAgICAgICAgLy8gZHVyYXRpb246IDUwMCxcclxuICAgICAgICAgICAgZHVyYXRpb246IFwiMjAlXCIsXHJcbiAgICAgICAgICAgIG9mZnNldDogXCIwcHhcIlxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnNldFR3ZWVuKFt0d2Vlbl9FQVJUSF9idG5dKVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJFQVJUSFwiIH0pXHJcbiAgICAgICAgLmFkZFRvKGNvbnRyb2xsZXJfRUFSVEgpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDEpO1xyXG5cclxuICAgIHNjZW5lX0VBUlRILm9uKFwic3RhcnRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAkKCcjcm9ja2V0JykucmVtb3ZlQ2xhc3MoXCJhZGRTbW9rZVwiKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHNjZW5lX0VBUlRILm9uKFwibGVhdmVcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAkKCcjcm9ja2V0JykuYWRkQ2xhc3MoXCJhZGRTbW9rZVwiKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciB0d2Vlbl9FQVJUSF9yb2NrZXQgPSBuZXcgVGltZWxpbmVNYXgoKVxyXG4gICAgICAgIC50byhcIiNyb2NrZXRcIiwgMC41LCB7XHJcbiAgICAgICAgICAgIHNjYWxlOiAwLjUsXHJcbiAgICAgICAgICAgIC8vIHk6IChXSUggLyAyKSAtIChSb2NrZXRfSGVpZ2h0IC8gMilcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50byhcIiNyb2NrZXRcIiwgMC41LCB7XHJcbiAgICAgICAgICAgIHNjYWxlOiAwLjUsXHJcbiAgICAgICAgICAgIC8vIHk6IChXSUggLyAyKSAtIChSb2NrZXRfSGVpZ2h0IC8gMilcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50byhcIiNyb2NrZXRcIiwgMC41LCB7XHJcbiAgICAgICAgICAgIHNjYWxlOiAwLFxyXG4gICAgICAgICAgICAvLyB5OiAoV0lIIC8gMikgLSAoUm9ja2V0X0hlaWdodCAvIDIpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgdmFyIHNjZW5lX0VBUlRIX1JPQ0tFVCA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFbGVtZW50OiBcIiNlYXJ0aFwiLFxyXG4gICAgICAgICAgICAvLyBkdXJhdGlvbjogNTAwLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCI1MCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBcIjBweFwiXHJcbiAgICAgICAgfSkuc2V0VHdlZW4oW3R3ZWVuX0VBUlRIX3JvY2tldF0pXHJcbiAgICAgICAgLy8gLmFkZEluZGljYXRvcnMoeyBuYW1lOiBcInNjZW5lX0VBUlRIX1JPQ0tFVFwiIH0pXHJcbiAgICAgICAgLmFkZFRvKGNvbnRyb2xsZXJfRUFSVEgpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDEpO1xyXG5cclxuXHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9TTU9LRUVFRUVFRUVFRUVFRUVFRUUvLy8vLy8vLy9cclxuICAgIHZhciBjb250cm9sbGVyX1NNT0tFID0gbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoKTtcclxuICAgIC8vIHZhciB0d2Vlbl9TTU9LRSA9IG5ldyBUaW1lbGluZU1heCgpXHJcbiAgICAvLyAgICAgLnRvKCcuc21va2UtdG8tbGVmdCcsIDEsIHtcclxuICAgIC8vICAgICAgICAgc2NhbGU6IDAuNSxcclxuICAgIC8vICAgICAgICAgeTogMTAsXHJcbiAgICAvLyAgICAgfSlcclxuICAgIC8vICAgICAudG8oJy5zbW9rZS10by1sZWZ0JywgMSwge1xyXG4gICAgLy8gICAgICAgICBzY2FsZTogMCxcclxuICAgIC8vICAgICAgICAgeTogMFxyXG4gICAgLy8gICAgIH0pO1xyXG4gICAgdmFyIHNjZW5lX1NNT0tFID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcclxuICAgICAgICAgICAgdHJpZ2dlckVsZW1lbnQ6IFwiI2VhcnRoXCIsXHJcbiAgICAgICAgICAgIC8vIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBXSUggKiAyICsgNTAsXHJcbiAgICAgICAgICAgIG9mZnNldDogXCItMTAwcHhcIlxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy8gLnNldFR3ZWVuKFt0d2Vlbl9TTU9LRV0pXHJcbiAgICAgICAgLy8gLmFkZEluZGljYXRvcnMoeyBuYW1lOiBcInNjZW5lX1NNT0tFXCIgfSlcclxuICAgICAgICAuYWRkVG8oY29udHJvbGxlcl9TTU9LRSlcclxuICAgICAgICAudHJpZ2dlckhvb2soMC45KTtcclxuXHJcbiAgICBzY2VuZV9TTU9LRS5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgJCgnLnNtb2tlLXRvLWxlZnQnKS5oaWRlKCk7XHJcbiAgICAgICAgJCgnLnNtb2tlLXRvLXJpZ2h0JykuaGlkZSgpO1xyXG4gICAgfSk7XHJcbiAgICBzY2VuZV9TTU9LRS5vbihcImxlYXZlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgJCgnLnNtb2tlLXRvLWxlZnQnKS5zaG93KCk7XHJcbiAgICAgICAgJCgnLnNtb2tlLXRvLXJpZ2h0Jykuc2hvdygpO1xyXG4gICAgfSk7XHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1NNT0tFRUVFRUVFRUVFRUVFRUVFRS8vLy8vLy8vL1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gUElQRSBGT1IgUk9DS0VUIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gRUFSVEggTkFWIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHZhciBzY2VuZV9TS1lfTkFWID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcclxuICAgICAgICAgICAgdHJpZ2dlckVsZW1lbnQ6IFwiI2VhcnRoXCIsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBcIjUwJVwiLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IFdJSCAvIDRcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zZXRDbGFzc1RvZ2dsZShcIi5pbi1lYXJ0aFwiLCBcInZpc2libGVcIilcclxuICAgICAgICAvLyAuYWRkSW5kaWNhdG9ycyh7IG5hbWU6IFwiU0tZX05BVlwiIH0pXHJcbiAgICAgICAgLmFkZFRvKGNvbnRyb2xsZXJfRUFSVEgpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDAuNSk7XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tIEVBUlRIIE5BViBFTkQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIHNjZW5lX1BJUEUgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIucGlwZS1zdGFydFwiLFxyXG4gICAgICAgICAgICAvLyBkdXJhdGlvbjogNTAwLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIG9mZnNldDogLShXSUggLyAyIC0gUm9ja2V0X0hlaWdodClcclxuICAgICAgICB9KVxyXG4gICAgICAgIC8vIC5hZGRJbmRpY2F0b3JzKHsgbmFtZTogXCJQSVBFXCIgfSlcclxuICAgICAgICAvLyAuc2V0VHdlZW4oW3R3ZWVuX1BJUEVfTU9WRV0pXHJcbiAgICAgICAgLmFkZFRvKGNvbnRyb2xsZXJfUk9DS0VUKVxyXG4gICAgICAgIC50cmlnZ2VySG9vaygwLjUpO1xyXG4gICAgc2NlbmVfUElQRS5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gJCgnI3JvY2tldCcpLmhpZGUoKTtcclxuICAgIH0pO1xyXG4gICAgc2NlbmVfUElQRS5vbihcImxlYXZlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gJCgnI3JvY2tldCcpLnNob3coKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gVU5ERVJXQVRFUiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgdmFyIHNjZW5lX1VOREVSV0FURVIgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjdW5kZXJ3YXRlclwiLFxyXG4gICAgICAgICAgICAvLyBkdXJhdGlvbjogNTAwLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCIxNTAlXCIsXHJcbiAgICAgICAgICAgIG9mZnNldDogLVdJSCAvIDJcclxuICAgICAgICB9KVxyXG4gICAgICAgIC8vIC5zZXRUd2VlbihbdHdlZW5fTEFORF9idG4sIF0pXHJcbiAgICAgICAgLy8gLmFkZEluZGljYXRvcnMoeyBuYW1lOiBcIlVOREVSV0FURVJcIiB9KVxyXG4gICAgICAgIC5hZGRUbyhjb250cm9sbGVyX1VOREVSV0FURVIpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDAuNSk7XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBFQVJUSCBURVhUIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAvLyB2YXIgdHdlZW5fTEFORF9idG4gPSBuZXcgVGltZWxpbmVNYXgoKVxyXG4gICAgLy8gICAgIC50byhcIiNlYXJ0aF9idG5cIiwgMC41LCB7XHJcbiAgICAvLyAgICAgICAgIHg6IDAsXHJcbiAgICAvLyAgICAgfSlcclxuICAgIC8vICAgICAudG8oXCIjZWFydGhfYnRuXCIsIDAuNSwge1xyXG4gICAgLy8gICAgICAgICB4OiAxMjAsXHJcbiAgICAvLyAgICAgfSk7XHJcblxyXG4gICAgdmFyIHNjZW5lX1VOREVSV0FURVJfVEVYVCA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFbGVtZW50OiBcIiN1bmRlcndhdGVyXCIsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0Q2xhc3NUb2dnbGUoXCIjc2VhX3BvcF91cFwiLCBcInZpc2libGVcIilcclxuICAgICAgICAvLyAuYWRkSW5kaWNhdG9ycyh7IG5hbWU6IFwiVU5ERVJXQVRFUl9URVhUXCIgfSlcclxuICAgICAgICAuYWRkVG8oY29udHJvbGxlcl9VTkRFUldBVEVSKVxyXG4gICAgICAgIC50cmlnZ2VySG9vaygwLjUpO1xyXG5cclxuICAgIHZhciB0d2Vlbl9VTkRFUldBVEVSX2J0biA9IG5ldyBUaW1lbGluZU1heCgpXHJcbiAgICAgICAgLnRvKFwiI3NlYV9idG5cIiwgMSwge1xyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRvKFwiI3NlYV9idG5cIiwgMSwge1xyXG4gICAgICAgICAgICB4OiAxMjAsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudG8oXCIjc2VhX2J0blwiLCAxLCB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgdmFyIHR3ZWVuX1VOREVSV0FURVJfcm9ja2V0ID0gbmV3IFRpbWVsaW5lTWF4KClcclxuICAgICAgICAudG8oXCIjcm9ja2V0XCIsIDEsIHtcclxuICAgICAgICAgICAgc2NhbGU6IDAuMixcclxuICAgICAgICAgICAgeTogMTAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudG8oXCIjcm9ja2V0XCIsIDEsIHtcclxuICAgICAgICAgICAgc2NhbGU6IDEsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiAtOTAsXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDEwMFxyXG4gICAgICAgIH0pXHJcbiAgICB2YXIgc2NlbmVfVU5ERVJXQVRFUl9ST0NLRVQgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjdW5kZXJ3YXRlclwiLFxyXG4gICAgICAgICAgICAvLyBkdXJhdGlvbjogNTAwLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCI1MCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBcIjBweFwiXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0VHdlZW4oW3R3ZWVuX1VOREVSV0FURVJfcm9ja2V0XSlcclxuICAgICAgICAvLyAuYWRkSW5kaWNhdG9ycyh7IG5hbWU6IFwic2NlbmVfVU5ERVJXQVRFUl9ST0NLRVRcIiB9KVxyXG4gICAgICAgIC5hZGRUbyhjb250cm9sbGVyX1VOREVSV0FURVIpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDEpO1xyXG5cclxuICAgIHNjZW5lX1VOREVSV0FURVJfUk9DS0VULm9uKFwic3RhcnRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAvLyAkKCcjcm9ja2V0IGltZycpLmF0dHIoXCJzcmNcIiwgJy4vYXNzZXRzL21lZG93L3N1Ym1hcmluZS5zdmcnKTtcclxuICAgIH0pO1xyXG4gICAgc2NlbmVfVU5ERVJXQVRFUi5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgJCgnI3JvY2tldCcpLnJlbW92ZUNsYXNzKFwiYWRkU21va2VcIik7XHJcbiAgICAgICAgJCgnI3JvY2tldCcpLmFkZENsYXNzKFwic3VibWFyaW5lXCIpO1xyXG4gICAgICAgICQoJyNyb2NrZXQgaW1nJykuYXR0cihcInNyY1wiLCBzdWJtYXJpbmVJbWcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc2NlbmVfVU5ERVJXQVRFUi5vbihcImxlYXZlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgJCgnI3JvY2tldCBpbWcnKS5hdHRyKFwic3JjXCIsIHNwYWNlc2hpcEltZyk7XHJcbiAgICAgICAgJCgnI3JvY2tldCcpLnJlbW92ZUNsYXNzKFwiYWRkU21va2VcIik7XHJcbiAgICAgICAgJCgnI3JvY2tldCcpLnJlbW92ZUNsYXNzKFwic3VibWFyaW5lXCIpO1xyXG4gICAgfSk7XHJcbiAgICAvLy8vLzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ly8vLy8vLy8vLy8vL1xyXG4gICAgdmFyIGNvbnRyb2xsZXJfVU5ERVJXQVRFUjIgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcigpO1xyXG5cclxuICAgIHZhciB0d2Vlbl9VTkRFUldBVEVSX3JvY2tldDIgPSBuZXcgVGltZWxpbmVNYXgoKVxyXG4gICAgICAgIC5mcm9tVG8oXCIjcm9ja2V0MlwiLCAwLjIsIHtcclxuICAgICAgICAgICAgc2NhbGU6IDEsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHg6IDI1XHJcbiAgICAgICAgICAgICAgICAvLyByb3RhdGlvbjotMTgwXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBzY2FsZTogMSxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgeDogMjVcclxuICAgICAgICAgICAgICAgIC8vIHJvdGF0aW9uOi0xODBcclxuICAgICAgICB9KVxyXG4gICAgdmFyIHNjZW5lX1VOREVSV0FURVJfUk9DS0VUMiA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFbGVtZW50OiBcIiN1bmRlcndhdGVyXCIsXHJcbiAgICAgICAgICAgIC8vIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiBcIjBweFwiXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0UGluKFwiI3JvY2tldDJcIilcclxuICAgICAgICAuc2V0VHdlZW4oW3R3ZWVuX1VOREVSV0FURVJfcm9ja2V0Ml0pXHJcbiAgICAgICAgLy8gLmFkZEluZGljYXRvcnMoeyBuYW1lOiBcInNjZW5lX1VOREVSV0FURVJfUk9DS0VUMlwiIH0pXHJcbiAgICAgICAgLmFkZFRvKGNvbnRyb2xsZXJfVU5ERVJXQVRFUjIpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDEpO1xyXG4gICAgLy8vLy87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Oy8vLy8vLy8vLy8vLy9cclxuICAgIC8vLy8vOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsvLy8vLy8vLy8vLy8vXHJcbiAgICB2YXIgY29udHJvbGxlcl9VTkRFUldBVEVSMyA9IG5ldyBTY3JvbGxNYWdpYy5Db250cm9sbGVyKCk7XHJcblxyXG4gICAgdmFyIHR3ZWVuX1VOREVSV0FURVJfcm9ja2V0MyA9IG5ldyBUaW1lbGluZU1heCgpXHJcbiAgICAgICAgLnRvKFwiI3JvY2tldDJcIiwgMC4yLCB7XHJcbiAgICAgICAgICAgIHNjYWxlOiAxLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogLTkwLFxyXG4gICAgICAgICAgICB5OiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudG8oXCIjcm9ja2V0MlwiLCAwLjIsIHtcclxuICAgICAgICAgICAgc2NhbGU6IDEuNzUsXHJcbiAgICAgICAgICAgIHk6IDEwMCxcclxuICAgICAgICAgICAgeDogLTUwLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogLTkwXHJcbiAgICAgICAgfSlcclxuICAgIHZhciBzY2VuZV9VTkRFUldBVEVSX1JPQ0tFVDMgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWxlbWVudDogXCIjdW5kZXJ3YXRlclwiLFxyXG4gICAgICAgICAgICAvLyBkdXJhdGlvbjogNTAwLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCI1MCVcIixcclxuICAgICAgICAgICAgb2Zmc2V0OiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc2V0VHdlZW4oW3R3ZWVuX1VOREVSV0FURVJfcm9ja2V0M10pXHJcbiAgICAgICAgLy8gLmFkZEluZGljYXRvcnMoeyBuYW1lOiBcInNjZW5lX1VOREVSV0FURVJfUk9DS0VUMjJcIiB9KVxyXG4gICAgICAgIC5hZGRUbyhjb250cm9sbGVyX1VOREVSV0FURVIzKVxyXG4gICAgICAgIC50cmlnZ2VySG9vaygwLjUpO1xyXG4gICAgLy8vLy87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Oy8vLy8vLy8vLy8vLy9cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gRUFSVEggTkFWIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHZhciBzY2VuZV9TRUFfTkFWID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcclxuICAgICAgICAgICAgdHJpZ2dlckVsZW1lbnQ6IFwiI3VuZGVyd2F0ZXJcIixcclxuICAgICAgICAgICAgZHVyYXRpb246IFwiNTAlXCIsXHJcbiAgICAgICAgICAgIG9mZnNldDogV0lIIC8gNFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy8gLnNldENsYXNzVG9nZ2xlKFwiLmluLXNlYVwiLCBcInZpc2libGVcIilcclxuICAgICAgICAvLyAuYWRkSW5kaWNhdG9ycyh7IG5hbWU6IFwiU0tZX05BVlwiIH0pXHJcbiAgICAgICAgLmFkZFRvKGNvbnRyb2xsZXJfRUFSVEgpXHJcbiAgICAgICAgLnRyaWdnZXJIb29rKDAuNSk7XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tIEVBUlRIIE5BViBFTkQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gdmFyIHR3ZWVuX1NVQl8yID0gbmV3IFRpbWVsaW5lTWF4KClcclxuICAgIC8vICAgICAudG8oXCIjc2VhX2J0blwiLCAxLCB7XHJcbiAgICAvLyAgICAgICAgIHg6IDAsXHJcbiAgICAvLyAgICAgfSlcclxuICAgIC8vICAgICAudG8oXCIjc2VhX2J0blwiLCAxLCB7XHJcbiAgICAvLyAgICAgICAgIHg6IDEyMCxcclxuICAgIC8vICAgICB9KVxyXG4gICAgLy8gICAgIC50byhcIiNzZWFfYnRuXCIsIDEsIHtcclxuICAgIC8vICAgICAgICAgeDogMCxcclxuICAgIC8vICAgICB9KTtcclxuICAgIC8vIHZhciBzY2VuZV9TVUIyID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcclxuICAgIC8vICAgICAgICAgdHJpZ2dlckVsZW1lbnQ6IFwiI3VuZGVyd2F0ZXJcIixcclxuICAgIC8vICAgICAgICAgZHVyYXRpb246IFwiNjAlXCIsXHJcbiAgICAvLyAgICAgICAgIG9mZnNldDogMFxyXG4gICAgLy8gICAgIH0pXHJcbiAgICAvLyAgICAgLnNldFR3ZWVuKFt0d2Vlbl9TVUJfMl0pXHJcbiAgICAvLyAgICAgLy8gLmFkZEluZGljYXRvcnMoeyBuYW1lOiBcIlNFQV9TVUIyXCIgfSlcclxuICAgIC8vICAgICAuYWRkVG8oY29udHJvbGxlcl9TVUJfMilcclxuICAgIC8vICAgICAudHJpZ2dlckhvb2soMSk7XHJcblxyXG4gICAgLy8gdmFyIGNsb3VkVGwgPSBuZXcgVGltZWxpbmVNYXgoeyByZXBlYXQ6IC0xLCBmb3JjZTNEOiB0cnVlIH0pO1xyXG4gICAgLy8gY2xvdWRUbC50byhcIi5maXNoLWNlbnRlci10b3BcIiwgMTAsIHsgeDogV0lXICsgMTAwLCBlYXNlOiBMaW5lYXIuZWFzZUluT3V0IH0sIDEpXHJcbiAgICAvLyAudG8oXCIjY2xvdWQwMlwiLCA1LCB7IHg6IFdJVywgZWFzZTogTGluZWFyLmVhc2VOb25lIH0sIDAuOSlcclxuICAgIC8vIC50byhcIiNjbG91ZDAzXCIsIDksIHsgeDogV0lXLCBlYXNlOiBMaW5lYXIuZWFzZU5vbmUgfSwgMSlcclxuICAgIC8vIC50byhcIiNjbG91ZDA0XCIsIDQsIHsgeDogV0lXLCBlYXNlOiBMaW5lYXIuZWFzZU5vbmUgfSwgMS41KTtcclxuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gUE9QVVBcclxuICAgIHZhciAkc3BhY2VfcG9wX3VwID0gJChcIiNzcGFjZV9wb3BfdXBcIilcclxuICAgIHZhciAkc3BhY2VfYnRuID0gJChcIiNzcGFjZV9idG5cIilcclxuICAgICAgICAvLyBTS1kgQlROXHJcbiAgICB2YXIgJHNreV9wb3BfdXAgPSAkKFwiI3NreV9wb3BfdXBcIilcclxuICAgIHZhciAkc2t5X2J0biA9ICQoXCIjc2t5X2J0blwiKVxyXG4gICAgdmFyICR0b3VjaF9tZV9ub3RfcG9wdXAgPSAkKFwiI3RvdWNoLW1lLW5vdC1wb3B1cFwiKVxyXG4gICAgdmFyICR0b3VjaF9tZV9ub3QgPSAkKFwiI3RvdWNoLW1lLW5vdFwiKVxyXG4gICAgdmFyICRiYWNrX2J0biA9ICQoXCIuYmFjay1idG5cIilcclxuICAgICAgICAvLyBMQU5EIEJUTlxyXG4gICAgdmFyICRsYW5kX3BvcF91cCA9ICQoXCIjbGFuZF9wb3BfdXBcIilcclxuICAgIHZhciAkbGFuZF9idG4gPSAkKFwiI2xhbmRfYnRuXCIpXHJcbiAgICAgICAgLy9FQVJUSCBCVE5cclxuICAgIHZhciAkZWFydGhfcG9wX3VwID0gJChcIiNlYXJ0aF9wb3BfdXBcIilcclxuICAgIHZhciAkZWFydGhfYnRuID0gJChcIiNlYXJ0aF9idG5cIilcclxuICAgICAgICAvL1NFQSBCVE5cclxuICAgIHZhciAkc2VhX3BvcF91cCA9ICQoXCIjc2VhX3BvcF91cFwiKVxyXG4gICAgdmFyICRzZWFfYnRuID0gJChcIiNzZWFfYnRuXCIpXHJcblxyXG4gICAgJHNwYWNlX2J0bi5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIG5hbWUocGFyYW1zKSB7XHJcbiAgICAgICAgJHNwYWNlX3BvcF91cC5hZGRDbGFzcyhcImFuaW1hdGVfX2JvdW5jZUluXCIpO1xyXG4gICAgICAgICRzcGFjZV9wb3BfdXAuc2hvdygpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAkc3BhY2VfcG9wX3VwLmhpZGUoKTtcclxuICAgICAgICB9LCA0MDAwKTtcclxuICAgIH0pXHJcblxyXG4gICAgdmFyICR0b3VjaF9tZV9ub3RfSU1HID0gJChcIiN0b3VjaC1tZS1ub3QgaW1nXCIpXHJcblxyXG4gICAgdmFyICRjbG91ZF90ZXh0ID0gJChcIi5jbG91ZC10ZXh0XCIpXHJcblxyXG4gICAgJHNreV9idG4ub24oXCJjbGlja1wiLCBmdW5jdGlvbiBuYW1lKHBhcmFtcykge1xyXG4gICAgICAgICQoXCIjdG91Y2gtbWUtbm90XCIpLnJlbW92ZUNsYXNzKFwiaGlkZS1idG5cIik7XHJcbiAgICAgICAgVHdlZW5NYXgudG8oJHRvdWNoX21lX25vdF9JTUcsIDAuNSwge1xyXG4gICAgICAgICAgICB3aWR0aDogXCIyMDBweFwiXHJcbiAgICAgICAgfSlcclxuICAgICAgICBUd2Vlbk1heC50bygkY2xvdWRfdGV4dCwgMC41LCB7XHJcbiAgICAgICAgICAgIGF1dG9BbHBoYTogMCxcclxuICAgICAgICAgICAgc2NhbGU6IDAsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAkc2t5X3BvcF91cC5hZGRDbGFzcyhcImFuaW1hdGVfX2JvdW5jZUluXCIpO1xyXG4gICAgICAgICRza3lfcG9wX3VwLnNob3coKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgJHNreV9wb3BfdXAuaGlkZSgpO1xyXG4gICAgICAgIH0sIDQwMDApO1xyXG4gICAgfSlcclxuXHJcbiAgICAkdG91Y2hfbWVfbm90Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gbmFtZShwYXJhbXMpIHtcclxuICAgICAgICAvLyBhbGVydCgpO1xyXG4gICAgICAgICR0b3VjaF9tZV9ub3QudG9nZ2xlQ2xhc3MoXCJ6b29tXCIpO1xyXG4gICAgfSlcclxuXHJcblxyXG5cclxuICAgIC8vICR0b3VjaF9tZV9ub3RfSU1HLmhvdmVyKG92ZXIsIG51bGwpO1xyXG4gICAgLy8gJHRvdWNoX21lX25vdC5ob3ZlcihudWxsLCBvdXQpO1xyXG5cclxuICAgIC8vIFR3ZWVuTWF4LnRvKCR0b3VjaF9tZV9ub3RfSU1HLCAwLjUsIHtcclxuICAgIC8vICAgICB4OiBcIjAlXCIsXHJcbiAgICAvLyAgICAgd2lkdGg6IFwiMjAwcHhcIixcclxuICAgIC8vIH0pXHJcbiAgICAvLyBUd2Vlbk1heC50bygkY2xvdWRfdGV4dCwgMC41LCB7XHJcbiAgICAvLyAgICAgYXV0b0FscGhhOiAxLFxyXG4gICAgLy8gICAgIHNjYWxlOiAwXHJcbiAgICAvLyB9KVxyXG5cclxuICAgIGxldCByZXNfU0laRSA9IChpc01vYiA9PSB0cnVlKSA/IFdJVyAqIDIgOiBcIjIwMHB4XCI7XHJcblxyXG5cclxuICAgICRsYW5kX2J0bi5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIG5hbWUocGFyYW1zKSB7XHJcbiAgICAgICAgJGxhbmRfcG9wX3VwLmFkZENsYXNzKFwiYW5pbWF0ZV9fYm91bmNlSW5cIik7XHJcbiAgICAgICAgJGxhbmRfcG9wX3VwLnNob3coKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgJGxhbmRfcG9wX3VwLmhpZGUoKTtcclxuICAgICAgICB9LCA0MDAwKTtcclxuICAgIH0pXHJcblxyXG4gICAgJGVhcnRoX2J0bi5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIG5hbWUocGFyYW1zKSB7XHJcbiAgICAgICAgJGVhcnRoX3BvcF91cC5hZGRDbGFzcyhcImFuaW1hdGVfX2JvdW5jZUluXCIpO1xyXG4gICAgICAgICRlYXJ0aF9wb3BfdXAuc2hvdygpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAkZWFydGhfcG9wX3VwLmhpZGUoKTtcclxuICAgICAgICB9LCA0MDAwKTtcclxuICAgIH0pXHJcblxyXG4gICAgJHNlYV9idG4ub24oXCJjbGlja1wiLCBmdW5jdGlvbiBuYW1lKHBhcmFtcykge1xyXG4gICAgICAgICRzZWFfcG9wX3VwLmFkZENsYXNzKFwiYW5pbWF0ZV9fYm91bmNlSW5cIik7XHJcbiAgICAgICAgJHNlYV9wb3BfdXAuc2hvdygpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAkc2VhX3BvcF91cC5oaWRlKCk7XHJcbiAgICAgICAgfSwgNDAwMCk7XHJcbiAgICB9KVxyXG5cclxuICAgICQoJy50ZXh0X2J0bicpLmhvdmVyKFxyXG4gICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdhbmltYXRlX193b2JibGUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdhbmltYXRlX193b2JibGUnKTtcclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gTU9EQUwgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgICAkKFwiLmNsb3NlLWJ1dHRvblwiKS5jbGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICBUd2Vlbk1heC50byhcIi5hY3R1YWwtbWVzc2FnZVwiLCAwLjUsIHtcclxuICAgICAgICAgICAgbWFyZ2luVG9wOiA1MCxcclxuICAgICAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgICAgICAgZWFzZTogXCJlYXNlLWluXCJcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgVHdlZW5NYXgudG8oXCIubW9kYWxcIiwgMC41LCB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgIHk6IFwiLTEwMCVcIixcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgICQoXCIucmVnaXN0ZXItYnRuXCIpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiUkVHXCIpO1xyXG4gICAgICAgIFR3ZWVuTWF4LmZyb21UbyhcIi5hY3R1YWwtbWVzc2FnZVwiLCAwLjUsIHtcclxuICAgICAgICAgICAgbWFyZ2luVG9wOiA1MCxcclxuICAgICAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgICAgICAgZWFzZTogQmFjay5lYXNlT3V0LFxyXG4gICAgICAgICAgICBkZWxheTogMS41XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDUwLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICBlYXNlOiBcImVhc2UtaW5cIlxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBUd2Vlbk1heC5mcm9tVG8oXCIubW9kYWxcIiwgMC41LCB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgIHk6IFwiLTEwMCVcIixcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgIHk6IFwiMCVcIixcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluaXQgY29udHJvbGxlclxyXG4gICAgdmFyIHdpbmRvd19jb250cm9sbGVyID0gbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoe1xyXG4gICAgICAgIGdsb2JhbFNjZW5lT3B0aW9uczoge1xyXG4gICAgICAgICAgICBkdXJhdGlvbjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIHRyaWdnZXJIb29rOiAuMDI1LFxyXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHNjZW5lcyA9IHtcclxuICAgICAgICAnc2NlbmUxJzoge1xyXG4gICAgICAgICAgICAnc3BhY2UnOiAnc3BhY2VfbGluaydcclxuICAgICAgICB9LFxyXG4gICAgICAgICdzY2VuZTInOiB7XHJcbiAgICAgICAgICAgICdza3knOiAnc2t5X2xpbmsnXHJcbiAgICAgICAgfSxcclxuICAgICAgICAnc2NlbmUzJzoge1xyXG4gICAgICAgICAgICAnbGFuZCc6ICdsYW5kX2xpbmsnXHJcbiAgICAgICAgfSxcclxuICAgICAgICAnc2NlbmU0Jzoge1xyXG4gICAgICAgICAgICAnZWFydGgnOiAnZWFydGhfbGluaydcclxuICAgICAgICB9LFxyXG4gICAgICAgICdzY2VuZTUnOiB7XHJcbiAgICAgICAgICAgICd1bmRlcndhdGVyJzogJ3VuZGVyd2F0ZXJfbGluaydcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIHNjZW5lcykge1xyXG4gICAgICAgIC8vIHNraXAgbG9vcCBpZiB0aGUgcHJvcGVydHkgaXMgZnJvbSBwcm90b3R5cGVcclxuICAgICAgICBpZiAoIXNjZW5lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcclxuICAgICAgICB2YXIgb2JqID0gc2NlbmVzW2tleV07XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgLy8gc2tpcCBsb29wIGlmIHRoZSBwcm9wZXJ0eSBpcyBmcm9tIHByb3RvdHlwZVxyXG4gICAgICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XHJcbiAgICAgICAgICAgIG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7IHRyaWdnZXJFbGVtZW50OiAnIycgKyBwcm9wIH0pXHJcbiAgICAgICAgICAgICAgICAuc2V0Q2xhc3NUb2dnbGUoJyMnICsgb2JqW3Byb3BdLCAnYWN0aXZlJylcclxuICAgICAgICAgICAgICAgIC5hZGRUbyh3aW5kb3dfY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7IHRyaWdnZXJFbGVtZW50OiAnIycgKyBwcm9wIH0pXHJcbiAgICAgICAgICAgICAgICAuc2V0Q2xhc3NUb2dnbGUoJyMnICsgcHJvcCwgJ2FjdGl2ZScpXHJcbiAgICAgICAgICAgICAgICAuYWRkVG8od2luZG93X2NvbnRyb2xsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGFuZ2UgYmVoYXZpb3VyIG9mIGNvbnRyb2xsZXJcclxuICAgIC8vIHRvIGFuaW1hdGUgc2Nyb2xsIGluc3RlYWQgb2YganVtcFxyXG4gICAgd2luZG93X2NvbnRyb2xsZXIuc2Nyb2xsVG8oZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgVHdlZW5NYXgudG8od2luZG93LCAyLCB7XHJcbiAgICAgICAgICAgIHNjcm9sbFRvOiB7XHJcbiAgICAgICAgICAgICAgICB5OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBhdXRvS2lsbDogdHJ1ZSAvLyBBbGxvdyBzY3JvbGwgcG9zaXRpb24gdG8gY2hhbmdlIG91dHNpZGUgaXRzZWxmXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVhc2U6IEN1YmljLmVhc2VJbk91dFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKE1vZGVybml6ci50b3VjaCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUb3VjaCBTY3JlZW4nKTtcclxuICAgICAgICBpZiAodHlwZW9mIE1vZGVybml6ciAhPSBcInVuZGVmaW5lZFwiICYmIE1vZGVybml6ci5tcSgnKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3lvdSBhcmUgaW4gbGFuZHNjYXBlIG1vZGUsIHBsZWFzZSB1c2UgUG9ydHJhaXQgTW9kZScpO1xyXG4gICAgICAgICAgICAkKFwiLm9yaWVudGF0aW9uY2hhbmdlXCIpLmFkZENsYXNzKFwic2hvd1wiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkKFwiLm9yaWVudGF0aW9uY2hhbmdlXCIpLnJlbW92ZUNsYXNzKFwic2hvd1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJChkb2N1bWVudC5ib2R5KS5vbigndG91Y2htb3ZlJywgb25TY3JvbGwpOyAvLyBmb3IgbW9iaWxlXHJcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdzY3JvbGwnLCBvblNjcm9sbCk7XHJcblxyXG4gICAgICAgIC8vIGNhbGxiYWNrXHJcbiAgICAgICAgZnVuY3Rpb24gb25TY3JvbGwoKSB7XHJcbiAgICAgICAgICAgIGlmICgkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyB3aW5kb3cuaW5uZXJIZWlnaHQgPj0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrX3BhZ2UrKztcclxuICAgICAgICAgICAgICAgIGxvYWRfY29udGVudHModHJhY2tfcGFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBUb3VjaCBTY3JlZW4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIE1vZGVybml6ciAhPSBcInVuZGVmaW5lZFwiICYmIE1vZGVybml6ci5tcSgnKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdwb3J0cmFpdCcpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgTW9kZXJuaXpyICE9IFwidW5kZWZpbmVkXCIgJiYgTW9kZXJuaXpyLm1xKCcob3JpZW50YXRpb246IGxhbmRzY2FwZSknKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdsYW5kc2NhcGUnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0IGNvbnRyb2xsZXJcclxuICAgIHZhciB3aW5fY29udHJvbGxlciA9IG5ldyBTY3JvbGxNYWdpYy5Db250cm9sbGVyKCk7XHJcblxyXG4gICAgLy8gQ2hhbmdlIGJlaGF2aW9yIG9mIGNvbnRyb2xsZXJcclxuICAgIC8vIHRvIGFuaW1hdGUgc2Nyb2xsIGluc3RlYWQgb2YganVtcFxyXG4gICAgd2luX2NvbnRyb2xsZXIuc2Nyb2xsVG8oZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgVHdlZW5NYXgudG8oJChcImh0bWxcIiksIDIsIHtcclxuICAgICAgICAgICAgc2Nyb2xsVG86IHtcclxuICAgICAgICAgICAgICAgIHk6IHRhcmdldCwgLy8gc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgYWxvbmcgeSBheGlzXHJcbiAgICAgICAgICAgICAgICBhdXRvS2lsbDogdHJ1ZSAvLyBhbGxvd3MgdXNlciB0byBraWxsIHNjcm9sbCBhY3Rpb24gc21vb3RobHlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZWFzZTogQ3ViaWMuZWFzZU91dFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gIEJpbmQgc2Nyb2xsIHRvIGFuY2hvciBsaW5rc1xyXG4gICAgJChkb2N1bWVudCkub24oXCJjbGlja1wiLCBcIi5uYXZzIGFcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHZhciBpZCA9ICQodGhpcykuYXR0cihcImhyZWZcIik7XHJcbiAgICAgICAgaWYgKCQoaWQpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB3aW5fY29udHJvbGxlci5zY3JvbGxUbyhpZCk7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKFwiXCIsIGRvY3VtZW50LnRpdGxlLCBpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKGRvY3VtZW50KS5vbihcImNsaWNrXCIsIFwiYS5yZXBsYXktYnRuXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB2YXIgaWQgPSAkKHRoaXMpLmF0dHIoXCJocmVmXCIpO1xyXG4gICAgICAgIGF1ZGlvLnBsYXkoKTtcclxuICAgICAgICBpZiAoJChpZCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgc2Nyb2xsXHJcbiAgICAgICAgICAgIHdpbl9jb250cm9sbGVyLnNjcm9sbFRvKGlkKTtcclxuICAgICAgICAgICAgLy8gSWYgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIHdlIGNhbiBhbHNvIHVwZGF0ZSB0aGUgVVJMXHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKFwiXCIsIGRvY3VtZW50LnRpdGxlLCBpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBvcmllbnRhdGlvbkNoYW5nZSgpO1xyXG4gICAgd2luZG93UmVzaXplKCk7XHJcblxyXG4gICAgLy8gY29uZmlndXJlIGlTY3JvbGxcclxuICAgIC8vIHZhciBteVNjcm9sbCA9IG5ldyBJU2Nyb2xsKCcjZXhhbXBsZS13cmFwcGVyJywge1xyXG4gICAgLy8gICAgIC8vIGRvbid0IHNjcm9sbCBob3Jpem9udGFsXHJcbiAgICAvLyAgICAgc2Nyb2xsWDogZmFsc2UsXHJcbiAgICAvLyAgICAgLy8gYnV0IGRvIHNjcm9sbCB2ZXJ0aWNhbFxyXG4gICAgLy8gICAgIHNjcm9sbFk6IHRydWUsXHJcbiAgICAvLyAgICAgLy8gc2hvdyBzY3JvbGxiYXJzXHJcbiAgICAvLyAgICAgc2Nyb2xsYmFyczogdHJ1ZSxcclxuICAgIC8vICAgICAvLyBkZWFjdGl2YXRpbmcgLXdlYmtpdC10cmFuc2Zvcm0gYmVjYXVzZSBwaW4gd291bGRuJ3Qgd29yayBiZWNhdXNlIG9mIGEgd2Via2l0IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIwNTc0XHJcbiAgICAvLyAgICAgLy8gaWYgeW91IGRvbnQgdXNlIHBpbm5pbmcsIGtlZXAgXCJ1c2VUcmFuc2Zvcm1cIiBzZXQgdG8gdHJ1ZSwgYXMgaXQgaXMgZmFyIGJldHRlciBpbiB0ZXJtcyBvZiBwZXJmb3JtYW5jZS5cclxuICAgIC8vICAgICB1c2VUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgLy8gICAgIC8vIGRlYXRpdmF0ZSBjc3MtdHJhbnNpdGlvbiB0byBmb3JjZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKGltcGxpY2l0IHdpdGggcHJvYmVUeXBlIDMpXHJcbiAgICAvLyAgICAgdXNlVHJhbnNpdGlvbjogZmFsc2UsXHJcbiAgICAvLyAgICAgLy8gc2V0IHRvIGhpZ2hlc3QgcHJvYmluZyBsZXZlbCB0byBnZXQgc2Nyb2xsIGV2ZW50cyBldmVuIGR1cmluZyBtb21lbnR1bSBhbmQgYm91bmNlXHJcbiAgICAvLyAgICAgLy8gcmVxdWlyZXMgaW5jbHVzaW9uIG9mIGlzY3JvbGwtcHJvYmUuanNcclxuICAgIC8vICAgICBwcm9iZVR5cGU6IDNcclxuICAgIC8vIH0pO1xyXG5cclxuICAgIC8vIGlmIChNb2Rlcm5penIudG91Y2ggJiYgbXlTY3JvbGwpIHsgLy8gd2hlbiB1c2luZyBpc2Nyb2xsXHJcbiAgICAvLyAgICAgY29udHJvbGxlcl9ST0NLRVQuc2Nyb2xsVG8oZnVuY3Rpb24obmV3cG9zKSB7XHJcbiAgICAvLyAgICAgICAgIG15U2Nyb2xsLnNjcm9sbFRvKDAsIC1uZXdwb3MgLSBteVNjcm9sbC55LCAxMDAwLCBJU2Nyb2xsLnV0aWxzLmVhc2UucXVhZHJhdGljKVxyXG4gICAgLy8gICAgIH0pO1xyXG4gICAgLy8gfSBlbHNlIHtcclxuICAgIC8vICAgICBjb250cm9sbGVyX1JPQ0tFVC5zY3JvbGxUbyhmdW5jdGlvbihuZXdwb3MpIHtcclxuICAgIC8vICAgICAgICAgVHdlZW5NYXgudG8oXCIjZXhhbXBsZS13cmFwcGVyXCIsIDEsIHsgc2Nyb2xsVG86IHsgeTogbmV3cG9zIH0gfSk7XHJcbiAgICAvLyAgICAgfSk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgbGV0IG9sZFZhbHVlMSA9IDBcclxuICAgIGxldCBuZXdWYWx1ZTEgPSAwXHJcbiAgICBsZXQgZGlyID0gXCJcIjtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKGUpID0+IHtcclxuICAgICAgICBuZXdWYWx1ZTEgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XHJcbiAgICAgICAgaWYgKG9sZFZhbHVlMSA8IG5ld1ZhbHVlMSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInNjcm9sbGluZyBwYWdlIFVwXCIsIG5ld1ZhbHVlMSwgV0lIICogNCk7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZTEgPiBXSUggLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyQoJy5nby11cCcpLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUxID49IFdJSCAqIDMuNSkge1xyXG4gICAgICAgICAgICAgICAgLy8kKCcuZ28tZG93bicpLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIC8vICQoJy5nby1kb3duJykucmVtb3ZlQ2xhc3MoXCJhbmltYXRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlMSA8IDIpIHtcclxuICAgICAgICAgICAgICAgIC8vICQoJy5nby11cCcpLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIC8vICQoJy5nby1kb3duJykuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZTEgPCBXSUggKiA0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyAkKCcuZ28tZG93bicpLnNob3coKTtcclxuICAgICAgICAgICAgICAgIC8vICQoJy5nby1kb3duJykuYWRkQ2xhc3MoXCJhbmltYXRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic2Nyb2xsaW5nIHBhZ2UgRG93blwiLCBuZXdWYWx1ZTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV3VmFsdWUxID4gKFdJSCAqIDMpKSB7XHJcbiAgICAgICAgICAgICQoJy5nby1kb3duJykuc2hvdygpO1xyXG4gICAgICAgICAgICAkKCcuZ28tdXAnKS5oaWRlKCk7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZTEgPj0gV0lIICogMy41KSB7XHJcbiAgICAgICAgICAgICAgICAkKCcuZ28tZG93bicpLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQoJy5nby1kb3duJykuaGlkZSgpO1xyXG4gICAgICAgICAgICAkKCcuZ28tdXAnKS5zaG93KCk7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZTEgPCBXSUggLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAkKCcuZ28tdXAnKS5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9sZFZhbHVlMSA9IG5ld1ZhbHVlMTtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBzZWNfZWxtID0gJCgnc2VjdGlvbicpXHJcbiAgICBsZXQgYW55QWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2VjdGlvbklkKCkge1xyXG4gICAgICAgIHZhciBzZWN0aW9uX2lkID0gJChkb2N1bWVudCkuZmluZCgnc2VjdGlvbi5hY3RpdmUnKS5wcmV2KCkuYXR0cihcImlkXCIpO1xyXG4gICAgICAgIHJldHVybiBzZWN0aW9uX2lkXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHNldFNjcm9sbChkaXIpIHtcclxuICAgICAgICBpZiAoZGlyID09IFwidXBcIikge1xyXG4gICAgICAgICAgICAvL3dpbmRvdy5zY3JvbGxUbyh7IHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0IC0gV0lILCBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XHJcbiAgICAgICAgICAgIHZhciBzZWN0aW9uX2lkID0gJChkb2N1bWVudCkuZmluZCgnc2VjdGlvbi5hY3RpdmUnKS5wcmV2KCkuYXR0cihcImlkXCIpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJzZWN0aW9uX2lkXCIsIHNlY3Rpb25faWQpO1xyXG5cclxuICAgICAgICAgICAgJCgnIycgKyBzZWN0aW9uX2lkICsgJ19saW5rJykuZ2V0KDApLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIC8vIHZhciBwcmV2X2lkID0gJChkb2N1bWVudCkuZmluZCgnc2VjdGlvbi5hY3RpdmUnKS5wcmV2KCkuYXR0cihcImlkXCIpO1xyXG4gICAgICAgICAgICAvLyB3aW5fY29udHJvbGxlci5zY3JvbGxUbyhwcmV2X2lkKTtcclxuICAgICAgICAgICAgYXVkaW8ucGxheSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdpbmRvdy5zY3JvbGxUbyh7IHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0ICsgV0lILCBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XHJcbiAgICAgICAgICAgIHZhciBzZWN0aW9uX2lkID0gJChkb2N1bWVudCkuZmluZCgnc2VjdGlvbi5hY3RpdmUnKS5uZXh0KCkuYXR0cihcImlkXCIpO1xyXG4gICAgICAgICAgICAkKCcjJyArIHNlY3Rpb25faWQgKyAnX2xpbmsnKS5nZXQoMCkuY2xpY2soKTtcclxuICAgICAgICAgICAgLy8gdmFyIG5leHRfaWQgPSAkKGRvY3VtZW50KS5maW5kKCdzZWN0aW9uLmFjdGl2ZScpLm5leHQoKS5hdHRyKFwiaWRcIik7XHJcbiAgICAgICAgICAgIC8vIHdpbl9jb250cm9sbGVyLnNjcm9sbFRvKG5leHRfaWQpO1xyXG4gICAgICAgICAgICBzcGxhc2hBdWRpby5wbGF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICQoJy5nby1kb3duJykub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBkaXIgPSBcImRvd25cIjtcclxuICAgICAgICBzZXRTY3JvbGwoZGlyKTtcclxuICAgIH0pXHJcblxyXG4gICAgJCgnLmdvLXVwJykub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBkaXIgPSBcInVwXCI7XHJcbiAgICAgICAgc2V0U2Nyb2xsKGRpcilcclxuICAgIH0pXHJcblxyXG4gICAgLy9TT1VORFxyXG4gICAgY29uc3QgbXV0ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdXRlJyksXHJcbiAgICAgICAgdGV4dCA9IG11dGUuZmlyc3RDaGlsZDtcclxuICAgIGxldCBpc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgbGV0IGVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInZpZGVvLCBhdWRpb1wiKTtcclxuXHJcbiAgICBtdXRlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaXNQbGF5aW5nID0gIWlzUGxheWluZztcclxuXHJcbiAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnbXV0ZScpO1xyXG5cclxuICAgICAgICBpZiAoaXNQbGF5aW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGVsZW1zKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5tdXRlZCA9IHRydWVcclxuICAgICAgICAgICAgICAgIGVsLnBhdXNlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgZWxlbXMpIHtcclxuICAgICAgICAgICAgICAgIGVsLm11dGVkID0gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gb3JpZW50YXRpb25DaGFuZ2UoKSB7XHJcbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gd2luZG93UmVzaXplKCkge30iXSwibmFtZXMiOlsicGlwZUVtcHR5SW1nIiwicGlwZUZpbGxlZEltZyIsInN1Ym1hcmluZUltZyIsInNwYWNlc2hpcEltZyIsInN0YXJfeWVsbG93Iiwic3Rhcl9ncmV5Iiwic3Rhcl93aGl0ZSIsIiQiLCJXSVciLCJ2ZXJnZSIsInZpZXdwb3J0VyIsIldJSCIsInZpZXdwb3J0SCIsIlJvY2tldF9XaWR0aCIsIlJvY2tldF9IZWlnaHQiLCJsYXVuY2hwYWRfSGVpZ2h0Iiwicm9ja2V0X2Jhc2Vfb2Zmc2V0IiwiU0VDVElPTiIsIkVMTSIsIkVBUlRIX0xBWUVSIiwiUElQRSIsIkxPR09fUkVTX1lfT0ZGU0VUIiwiU1RBUlNfQ09VTlQiLCJjc3MiLCJpc01vYiIsIlNUQVJTX0FSUkFZIiwiU1RBUlNfU0laRV9BUlJBWSIsImkiLCJyYW5kb21TdGFyIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwicmFuZG9tU3RhclNpemUiLCJzdGFyIiwid2luZG93IiwiaGVpZ2h0Iiwid2lkdGgiLCJhcHBlbmQiLCJiIiwiYnViYmxlcyIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInBhZ2VZT2Zmc2V0IiwiaGlkZSIsInNob3ciLCJjb250cm9sbGVyX1JPQ0tFVCIsIlNjcm9sbE1hZ2ljIiwiQ29udHJvbGxlciIsInR3ZWVuX1JPQ0tFVCIsIlRpbWVsaW5lTWF4IiwidG8iLCJ4IiwieSIsImVhc2UiLCJvbkNvbXBsZXRlIiwic2NlbmVfUk9DS0VUIiwiU2NlbmUiLCJ0cmlnZ2VyRWxlbWVudCIsImR1cmF0aW9uIiwib2Zmc2V0Iiwic2V0VHdlZW4iLCJhZGRUbyIsInRyaWdnZXJIb29rIiwib24iLCJldmVudCIsImFkZENsYXNzIiwic2Nyb2xsVG8iLCJuZXdwb3MiLCJUd2Vlbk1heCIsImNvbnRyb2xsZXJfU1BBQ0UiLCJjb250cm9sbGVyX1NLWSIsImNvbnRyb2xsZXJfTEFORCIsImNvbnRyb2xsZXJfRUFSVEgiLCJjb250cm9sbGVyX1VOREVSV0FURVIiLCJjb250cm9sbGVyX1NVQl8yIiwiY29udHJvbGxlcl9CVVRUT04iLCJjb250cm9sbGVyX0JVVFRPTjIiLCJhdWRpbyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzcGxhc2hBdWRpbyIsIm1ldGFsSGl0QXVkaW8iLCJzY2VuZV9CVVRUT04iLCJzY2VuZV9CVVRUT04yIiwic2V0Q2xhc3NUb2dnbGUiLCJ0d2Vlbl9TUEFDRV9idG4iLCJzY2VuZV9TUEFDRSIsInNjZW5lX1NQQUNFX05BViIsInNjZW5lX1NLWSIsInR3ZWVuX1NLWV9idG4iLCJzY2VuZV9TS1lfTkFWIiwidHdlZW5fTEFORF9idG4iLCJzY2VuZV9MQU5EIiwidHdlZW5fTE9HTyIsImZyb21UbyIsImF1dG9BbHBoYSIsInNjZW5lX0xPR08iLCJzY2VuZV9FQVJUSF9QSVBFIiwic2NlbmVfRUFSVEhfVEVYVCIsImltYWdlcyIsIm9iajIyIiwiY3VySW1nIiwidHdlZW5fcGlwZV9zZXF1ZW5jZSIsInJvdW5kUHJvcHMiLCJyZXBlYXQiLCJpbW1lZGlhdGVSZW5kZXIiLCJMaW5lYXIiLCJlYXNlTm9uZSIsIm9uVXBkYXRlIiwiYXR0ciIsInR3ZWVuX0VBUlRIX2J0biIsInNjZW5lX3R3ZWVuX3BpcGVfc2VxdWVuY2UiLCJzY2VuZV9FQVJUSCIsInJlbW92ZUNsYXNzIiwidHdlZW5fRUFSVEhfcm9ja2V0Iiwic2NhbGUiLCJzY2VuZV9FQVJUSF9ST0NLRVQiLCJjb250cm9sbGVyX1NNT0tFIiwic2NlbmVfU01PS0UiLCJzY2VuZV9QSVBFIiwic2NlbmVfVU5ERVJXQVRFUiIsInNjZW5lX1VOREVSV0FURVJfVEVYVCIsInR3ZWVuX1VOREVSV0FURVJfYnRuIiwidHdlZW5fVU5ERVJXQVRFUl9yb2NrZXQiLCJyb3RhdGlvbiIsInNjZW5lX1VOREVSV0FURVJfUk9DS0VUIiwiY29udHJvbGxlcl9VTkRFUldBVEVSMiIsInR3ZWVuX1VOREVSV0FURVJfcm9ja2V0MiIsInNjZW5lX1VOREVSV0FURVJfUk9DS0VUMiIsInNldFBpbiIsImNvbnRyb2xsZXJfVU5ERVJXQVRFUjMiLCJ0d2Vlbl9VTkRFUldBVEVSX3JvY2tldDMiLCJzY2VuZV9VTkRFUldBVEVSX1JPQ0tFVDMiLCJzY2VuZV9TRUFfTkFWIiwiJHNwYWNlX3BvcF91cCIsIiRzcGFjZV9idG4iLCIkc2t5X3BvcF91cCIsIiRza3lfYnRuIiwiJHRvdWNoX21lX25vdF9wb3B1cCIsIiR0b3VjaF9tZV9ub3QiLCIkYmFja19idG4iLCIkbGFuZF9wb3BfdXAiLCIkbGFuZF9idG4iLCIkZWFydGhfcG9wX3VwIiwiJGVhcnRoX2J0biIsIiRzZWFfcG9wX3VwIiwiJHNlYV9idG4iLCJuYW1lIiwicGFyYW1zIiwic2V0VGltZW91dCIsIiR0b3VjaF9tZV9ub3RfSU1HIiwiJGNsb3VkX3RleHQiLCJ0b2dnbGVDbGFzcyIsInJlc19TSVpFIiwiaG92ZXIiLCJjbGljayIsIm1hcmdpblRvcCIsIm9wYWNpdHkiLCJCYWNrIiwiZWFzZU91dCIsImRlbGF5Iiwid2luZG93X2NvbnRyb2xsZXIiLCJnbG9iYWxTY2VuZU9wdGlvbnMiLCJyZXZlcnNlIiwic2NlbmVzIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJvYmoiLCJwcm9wIiwidGFyZ2V0IiwiYXV0b0tpbGwiLCJDdWJpYyIsImVhc2VJbk91dCIsIk1vZGVybml6ciIsInRvdWNoIiwib25TY3JvbGwiLCJzY3JvbGxUb3AiLCJpbm5lckhlaWdodCIsImJvZHkiLCJzY3JvbGxIZWlnaHQiLCJ0cmFja19wYWdlIiwibG9hZF9jb250ZW50cyIsImNvbnNvbGUiLCJsb2ciLCJtcSIsIndpbl9jb250cm9sbGVyIiwiaWQiLCJwcmV2ZW50RGVmYXVsdCIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJ0aXRsZSIsInBsYXkiLCJvcmllbnRhdGlvbkNoYW5nZSIsIndpbmRvd1Jlc2l6ZSIsIm9sZFZhbHVlMSIsIm5ld1ZhbHVlMSIsImRpciIsInNlY19lbG0iLCJhbnlBY3RpdmUiLCJnZXRTZWN0aW9uSWQiLCJzZWN0aW9uX2lkIiwiZmluZCIsInByZXYiLCJzZXRTY3JvbGwiLCJnZXQiLCJuZXh0IiwibXV0ZSIsInRleHQiLCJmaXJzdENoaWxkIiwiaXNQbGF5aW5nIiwiZWxlbXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZWwiLCJtdXRlZCIsInBhdXNlIiwibG9jYXRpb24iLCJyZWxvYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/rocket.js\n");

/***/ }),

/***/ "./src/js/utils/environment.js":
/*!*************************************!*\
  !*** ./src/js/utils/environment.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$document\": () => (/* binding */ $document),\n/* harmony export */   \"$window\": () => (/* binding */ $window),\n/* harmony export */   \"$html\": () => (/* binding */ $html),\n/* harmony export */   \"$body\": () => (/* binding */ $body)\n/* harmony export */ });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n// console.log(\"Environment\");\n\nwindow.jQuery = (jquery__WEBPACK_IMPORTED_MODULE_0___default());\nwindow.$ = (jquery__WEBPACK_IMPORTED_MODULE_0___default());\nvar $document = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document);\nvar $window = jquery__WEBPACK_IMPORTED_MODULE_0___default()(window);\nvar $html = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.documentElement);\nvar $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body);\nvar minWidth = 1024;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdXRpbHMvZW52aXJvbm1lbnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFFQTtBQUNBQyxNQUFNLENBQUNDLE1BQVAsR0FBZ0JGLCtDQUFoQjtBQUNBQyxNQUFNLENBQUNELENBQVAsR0FBV0EsK0NBQVg7QUFFQSxJQUFNRyxTQUFTLEdBQUdILDZDQUFDLENBQUNJLFFBQUQsQ0FBbkI7QUFDQSxJQUFNQyxPQUFPLEdBQUdMLDZDQUFDLENBQUNDLE1BQUQsQ0FBakI7QUFDQSxJQUFNSyxLQUFLLEdBQUdOLDZDQUFDLENBQUNJLFFBQVEsQ0FBQ0csZUFBVixDQUFmO0FBQ0EsSUFBTUMsS0FBSyxHQUFHUiw2Q0FBQyxDQUFDSSxRQUFRLENBQUNLLElBQVYsQ0FBZjtBQUVBLElBQU1DLFFBQVEsR0FBRyxJQUFqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0B3ZWFyZWF0aGxvbi9mcm9udGVuZC13ZWJwYWNrLWJvaWxlcnBsYXRlLy4vc3JjL2pzL3V0aWxzL2Vudmlyb25tZW50LmpzPzlkMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29uc29sZS5sb2coXCJFbnZpcm9ubWVudFwiKTtcclxuXHJcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XHJcbndpbmRvdy5qUXVlcnkgPSAkO1xyXG53aW5kb3cuJCA9ICQ7XHJcblxyXG5jb25zdCAkZG9jdW1lbnQgPSAkKGRvY3VtZW50KTtcclxuY29uc3QgJHdpbmRvdyA9ICQod2luZG93KTtcclxuY29uc3QgJGh0bWwgPSAkKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XHJcbmNvbnN0ICRib2R5ID0gJChkb2N1bWVudC5ib2R5KTtcclxuXHJcbmNvbnN0IG1pbldpZHRoID0gMTAyNDtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICAkZG9jdW1lbnQsXHJcbiAgICAkd2luZG93LFxyXG4gICAgJGh0bWwsXHJcbiAgICAkYm9keVxyXG59O1xyXG4iXSwibmFtZXMiOlsiJCIsIndpbmRvdyIsImpRdWVyeSIsIiRkb2N1bWVudCIsImRvY3VtZW50IiwiJHdpbmRvdyIsIiRodG1sIiwiZG9jdW1lbnRFbGVtZW50IiwiJGJvZHkiLCJib2R5IiwibWluV2lkdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/utils/environment.js\n");

/***/ }),

/***/ "./node_modules/ev-emitter/ev-emitter.js":
/*!***********************************************!*\
  !*** ./node_modules/ev-emitter/ev-emitter.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n( function( global, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, window */\n  if ( true ) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( typeof window != 'undefined' ? window : this, function() {\n\n\"use strict\";\n\nfunction EvEmitter() {}\n\nvar proto = EvEmitter.prototype;\n\nproto.on = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // set events hash\n  var events = this._events = this._events || {};\n  // set listeners array\n  var listeners = events[ eventName ] = events[ eventName ] || [];\n  // only add once\n  if ( listeners.indexOf( listener ) == -1 ) {\n    listeners.push( listener );\n  }\n\n  return this;\n};\n\nproto.once = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // add event\n  this.on( eventName, listener );\n  // set once flag\n  // set onceEvents hash\n  var onceEvents = this._onceEvents = this._onceEvents || {};\n  // set onceListeners object\n  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\n  // set flag\n  onceListeners[ listener ] = true;\n\n  return this;\n};\n\nproto.off = function( eventName, listener ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  var index = listeners.indexOf( listener );\n  if ( index != -1 ) {\n    listeners.splice( index, 1 );\n  }\n\n  return this;\n};\n\nproto.emitEvent = function( eventName, args ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  // copy over to avoid interference if .off() in listener\n  listeners = listeners.slice(0);\n  args = args || [];\n  // once stuff\n  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];\n\n  for ( var i=0; i < listeners.length; i++ ) {\n    var listener = listeners[i]\n    var isOnce = onceListeners && onceListeners[ listener ];\n    if ( isOnce ) {\n      // remove listener\n      // remove before trigger to prevent recursion\n      this.off( eventName, listener );\n      // unset once flag\n      delete onceListeners[ listener ];\n    }\n    // trigger listener\n    listener.apply( this, args );\n  }\n\n  return this;\n};\n\nproto.allOff = function() {\n  delete this._events;\n  delete this._onceEvents;\n};\n\nreturn EvEmitter;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXYtZW1pdHRlci9ldi1lbWl0dGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUF5QztBQUNoRDtBQUNBLElBQUksb0NBQVEsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFFO0FBQ3JCLElBQUksS0FBSyxFQU1OOztBQUVILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2VhcmVhdGhsb24vZnJvbnRlbmQtd2VicGFjay1ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9ldi1lbWl0dGVyL2V2LWVtaXR0ZXIuanM/MDk0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV2RW1pdHRlciB2MS4xLjBcbiAqIExpbCcgZXZlbnQgZW1pdHRlclxuICogTUlUIExpY2Vuc2VcbiAqL1xuXG4vKiBqc2hpbnQgdW51c2VkOiB0cnVlLCB1bmRlZjogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHdpbmRvdyAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgIGRlZmluZSggZmFjdG9yeSApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTIC0gQnJvd3NlcmlmeSwgV2VicGFja1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGdsb2JhbC5FdkVtaXR0ZXIgPSBmYWN0b3J5KCk7XG4gIH1cblxufSggdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gRXZFbWl0dGVyKCkge31cblxudmFyIHByb3RvID0gRXZFbWl0dGVyLnByb3RvdHlwZTtcblxucHJvdG8ub24gPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgaWYgKCAhZXZlbnROYW1lIHx8ICFsaXN0ZW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc2V0IGV2ZW50cyBoYXNoXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIC8vIHNldCBsaXN0ZW5lcnMgYXJyYXlcbiAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1sgZXZlbnROYW1lIF0gPSBldmVudHNbIGV2ZW50TmFtZSBdIHx8IFtdO1xuICAvLyBvbmx5IGFkZCBvbmNlXG4gIGlmICggbGlzdGVuZXJzLmluZGV4T2YoIGxpc3RlbmVyICkgPT0gLTEgKSB7XG4gICAgbGlzdGVuZXJzLnB1c2goIGxpc3RlbmVyICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLm9uY2UgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgaWYgKCAhZXZlbnROYW1lIHx8ICFsaXN0ZW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gYWRkIGV2ZW50XG4gIHRoaXMub24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgLy8gc2V0IG9uY2UgZmxhZ1xuICAvLyBzZXQgb25jZUV2ZW50cyBoYXNoXG4gIHZhciBvbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyA9IHRoaXMuX29uY2VFdmVudHMgfHwge307XG4gIC8vIHNldCBvbmNlTGlzdGVuZXJzIG9iamVjdFxuICB2YXIgb25jZUxpc3RlbmVycyA9IG9uY2VFdmVudHNbIGV2ZW50TmFtZSBdID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gfHwge307XG4gIC8vIHNldCBmbGFnXG4gIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF0gPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub2ZmID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgaWYgKCBpbmRleCAhPSAtMSApIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBhcmdzICkge1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1sgZXZlbnROYW1lIF07XG4gIGlmICggIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gY29weSBvdmVyIHRvIGF2b2lkIGludGVyZmVyZW5jZSBpZiAub2ZmKCkgaW4gbGlzdGVuZXJcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKDApO1xuICBhcmdzID0gYXJncyB8fCBbXTtcbiAgLy8gb25jZSBzdHVmZlxuICB2YXIgb25jZUxpc3RlbmVycyA9IHRoaXMuX29uY2VFdmVudHMgJiYgdGhpcy5fb25jZUV2ZW50c1sgZXZlbnROYW1lIF07XG5cbiAgZm9yICggdmFyIGk9MDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV1cbiAgICB2YXIgaXNPbmNlID0gb25jZUxpc3RlbmVycyAmJiBvbmNlTGlzdGVuZXJzWyBsaXN0ZW5lciBdO1xuICAgIGlmICggaXNPbmNlICkge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAvLyByZW1vdmUgYmVmb3JlIHRyaWdnZXIgdG8gcHJldmVudCByZWN1cnNpb25cbiAgICAgIHRoaXMub2ZmKCBldmVudE5hbWUsIGxpc3RlbmVyICk7XG4gICAgICAvLyB1bnNldCBvbmNlIGZsYWdcbiAgICAgIGRlbGV0ZSBvbmNlTGlzdGVuZXJzWyBsaXN0ZW5lciBdO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIGxpc3RlbmVyXG4gICAgbGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3MgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uYWxsT2ZmID0gZnVuY3Rpb24oKSB7XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gIGRlbGV0ZSB0aGlzLl9vbmNlRXZlbnRzO1xufTtcblxucmV0dXJuIEV2RW1pdHRlcjtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ev-emitter/ev-emitter.js\n");

/***/ }),

/***/ "./node_modules/imagesloaded/imagesloaded.js":
/*!***************************************************!*\
  !*** ./node_modules/imagesloaded/imagesloaded.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * imagesLoaded v4.1.4\n * JavaScript is all like \"You images are done yet or what?\"\n * MIT License\n */\n\n( function( window, factory ) { 'use strict';\n  // universal module definition\n\n  /*global define: false, module: false, require: false */\n\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( EvEmitter ) {\n      return factory( window, EvEmitter );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})( typeof window !== 'undefined' ? window : this,\n\n// --------------------------  factory -------------------------- //\n\nfunction factory( window, EvEmitter ) {\n\n'use strict';\n\nvar $ = window.jQuery;\nvar console = window.console;\n\n// -------------------------- helpers -------------------------- //\n\n// extend objects\nfunction extend( a, b ) {\n  for ( var prop in b ) {\n    a[ prop ] = b[ prop ];\n  }\n  return a;\n}\n\nvar arraySlice = Array.prototype.slice;\n\n// turn element or nodeList into an array\nfunction makeArray( obj ) {\n  if ( Array.isArray( obj ) ) {\n    // use object if already an array\n    return obj;\n  }\n\n  var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';\n  if ( isArrayLike ) {\n    // convert nodeList to array\n    return arraySlice.call( obj );\n  }\n\n  // array of single index\n  return [ obj ];\n}\n\n// -------------------------- imagesLoaded -------------------------- //\n\n/**\n * @param {Array, Element, NodeList, String} elem\n * @param {Object or Function} options - if function, use as callback\n * @param {Function} onAlways - callback function\n */\nfunction ImagesLoaded( elem, options, onAlways ) {\n  // coerce ImagesLoaded() without new, to be new ImagesLoaded()\n  if ( !( this instanceof ImagesLoaded ) ) {\n    return new ImagesLoaded( elem, options, onAlways );\n  }\n  // use elem as selector string\n  var queryElem = elem;\n  if ( typeof elem == 'string' ) {\n    queryElem = document.querySelectorAll( elem );\n  }\n  // bail if bad element\n  if ( !queryElem ) {\n    console.error( 'Bad element for imagesLoaded ' + ( queryElem || elem ) );\n    return;\n  }\n\n  this.elements = makeArray( queryElem );\n  this.options = extend( {}, this.options );\n  // shift arguments if no options set\n  if ( typeof options == 'function' ) {\n    onAlways = options;\n  } else {\n    extend( this.options, options );\n  }\n\n  if ( onAlways ) {\n    this.on( 'always', onAlways );\n  }\n\n  this.getImages();\n\n  if ( $ ) {\n    // add jQuery Deferred object\n    this.jqDeferred = new $.Deferred();\n  }\n\n  // HACK check async to allow time to bind listeners\n  setTimeout( this.check.bind( this ) );\n}\n\nImagesLoaded.prototype = Object.create( EvEmitter.prototype );\n\nImagesLoaded.prototype.options = {};\n\nImagesLoaded.prototype.getImages = function() {\n  this.images = [];\n\n  // filter & find items if we have an item selector\n  this.elements.forEach( this.addElementImages, this );\n};\n\n/**\n * @param {Node} element\n */\nImagesLoaded.prototype.addElementImages = function( elem ) {\n  // filter siblings\n  if ( elem.nodeName == 'IMG' ) {\n    this.addImage( elem );\n  }\n  // get background image on element\n  if ( this.options.background === true ) {\n    this.addElementBackgroundImages( elem );\n  }\n\n  // find children\n  // no non-element nodes, #143\n  var nodeType = elem.nodeType;\n  if ( !nodeType || !elementNodeTypes[ nodeType ] ) {\n    return;\n  }\n  var childImgs = elem.querySelectorAll('img');\n  // concat childElems to filterFound array\n  for ( var i=0; i < childImgs.length; i++ ) {\n    var img = childImgs[i];\n    this.addImage( img );\n  }\n\n  // get child background images\n  if ( typeof this.options.background == 'string' ) {\n    var children = elem.querySelectorAll( this.options.background );\n    for ( i=0; i < children.length; i++ ) {\n      var child = children[i];\n      this.addElementBackgroundImages( child );\n    }\n  }\n};\n\nvar elementNodeTypes = {\n  1: true,\n  9: true,\n  11: true\n};\n\nImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {\n  var style = getComputedStyle( elem );\n  if ( !style ) {\n    // Firefox returns null if in a hidden iframe https://bugzil.la/548397\n    return;\n  }\n  // get url inside url(\"...\")\n  var reURL = /url\\((['\"])?(.*?)\\1\\)/gi;\n  var matches = reURL.exec( style.backgroundImage );\n  while ( matches !== null ) {\n    var url = matches && matches[2];\n    if ( url ) {\n      this.addBackground( url, elem );\n    }\n    matches = reURL.exec( style.backgroundImage );\n  }\n};\n\n/**\n * @param {Image} img\n */\nImagesLoaded.prototype.addImage = function( img ) {\n  var loadingImage = new LoadingImage( img );\n  this.images.push( loadingImage );\n};\n\nImagesLoaded.prototype.addBackground = function( url, elem ) {\n  var background = new Background( url, elem );\n  this.images.push( background );\n};\n\nImagesLoaded.prototype.check = function() {\n  var _this = this;\n  this.progressedCount = 0;\n  this.hasAnyBroken = false;\n  // complete if no images\n  if ( !this.images.length ) {\n    this.complete();\n    return;\n  }\n\n  function onProgress( image, elem, message ) {\n    // HACK - Chrome triggers event before object properties have changed. #83\n    setTimeout( function() {\n      _this.progress( image, elem, message );\n    });\n  }\n\n  this.images.forEach( function( loadingImage ) {\n    loadingImage.once( 'progress', onProgress );\n    loadingImage.check();\n  });\n};\n\nImagesLoaded.prototype.progress = function( image, elem, message ) {\n  this.progressedCount++;\n  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;\n  // progress event\n  this.emitEvent( 'progress', [ this, image, elem ] );\n  if ( this.jqDeferred && this.jqDeferred.notify ) {\n    this.jqDeferred.notify( this, image );\n  }\n  // check if completed\n  if ( this.progressedCount == this.images.length ) {\n    this.complete();\n  }\n\n  if ( this.options.debug && console ) {\n    console.log( 'progress: ' + message, image, elem );\n  }\n};\n\nImagesLoaded.prototype.complete = function() {\n  var eventName = this.hasAnyBroken ? 'fail' : 'done';\n  this.isComplete = true;\n  this.emitEvent( eventName, [ this ] );\n  this.emitEvent( 'always', [ this ] );\n  if ( this.jqDeferred ) {\n    var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';\n    this.jqDeferred[ jqMethod ]( this );\n  }\n};\n\n// --------------------------  -------------------------- //\n\nfunction LoadingImage( img ) {\n  this.img = img;\n}\n\nLoadingImage.prototype = Object.create( EvEmitter.prototype );\n\nLoadingImage.prototype.check = function() {\n  // If complete is true and browser supports natural sizes,\n  // try to check for image status manually.\n  var isComplete = this.getIsImageComplete();\n  if ( isComplete ) {\n    // report based on naturalWidth\n    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );\n    return;\n  }\n\n  // If none of the checks above matched, simulate loading on detached element.\n  this.proxyImage = new Image();\n  this.proxyImage.addEventListener( 'load', this );\n  this.proxyImage.addEventListener( 'error', this );\n  // bind to image as well for Firefox. #191\n  this.img.addEventListener( 'load', this );\n  this.img.addEventListener( 'error', this );\n  this.proxyImage.src = this.img.src;\n};\n\nLoadingImage.prototype.getIsImageComplete = function() {\n  // check for non-zero, non-undefined naturalWidth\n  // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671\n  return this.img.complete && this.img.naturalWidth;\n};\n\nLoadingImage.prototype.confirm = function( isLoaded, message ) {\n  this.isLoaded = isLoaded;\n  this.emitEvent( 'progress', [ this, this.img, message ] );\n};\n\n// ----- events ----- //\n\n// trigger specified handler for event type\nLoadingImage.prototype.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\nLoadingImage.prototype.onload = function() {\n  this.confirm( true, 'onload' );\n  this.unbindEvents();\n};\n\nLoadingImage.prototype.onerror = function() {\n  this.confirm( false, 'onerror' );\n  this.unbindEvents();\n};\n\nLoadingImage.prototype.unbindEvents = function() {\n  this.proxyImage.removeEventListener( 'load', this );\n  this.proxyImage.removeEventListener( 'error', this );\n  this.img.removeEventListener( 'load', this );\n  this.img.removeEventListener( 'error', this );\n};\n\n// -------------------------- Background -------------------------- //\n\nfunction Background( url, element ) {\n  this.url = url;\n  this.element = element;\n  this.img = new Image();\n}\n\n// inherit LoadingImage prototype\nBackground.prototype = Object.create( LoadingImage.prototype );\n\nBackground.prototype.check = function() {\n  this.img.addEventListener( 'load', this );\n  this.img.addEventListener( 'error', this );\n  this.img.src = this.url;\n  // check if image is already complete\n  var isComplete = this.getIsImageComplete();\n  if ( isComplete ) {\n    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );\n    this.unbindEvents();\n  }\n};\n\nBackground.prototype.unbindEvents = function() {\n  this.img.removeEventListener( 'load', this );\n  this.img.removeEventListener( 'error', this );\n};\n\nBackground.prototype.confirm = function( isLoaded, message ) {\n  this.isLoaded = isLoaded;\n  this.emitEvent( 'progress', [ this, this.element, message ] );\n};\n\n// -------------------------- jQuery -------------------------- //\n\nImagesLoaded.makeJQueryPlugin = function( jQuery ) {\n  jQuery = jQuery || window.jQuery;\n  if ( !jQuery ) {\n    return;\n  }\n  // set local variable\n  $ = jQuery;\n  // $().imagesLoaded()\n  $.fn.imagesLoaded = function( options, callback ) {\n    var instance = new ImagesLoaded( this, options, callback );\n    return instance.jqDeferred.promise( $(this) );\n  };\n};\n// try making plugin\nImagesLoaded.makeJQueryPlugin();\n\n// --------------------------  -------------------------- //\n\nreturn ImagesLoaded;\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW1hZ2VzbG9hZGVkL2ltYWdlc2xvYWRlZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQSxPQUFPLElBQXlDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBUTtBQUNaLE1BQU0sMkZBQXVCO0FBQzdCLEtBQUssbUNBQUU7QUFDUDtBQUNBLEtBQUs7QUFBQSxrR0FBQztBQUNOLElBQUksS0FBSyxFQVlOOztBQUVILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0B3ZWFyZWF0aGxvbi9mcm9udGVuZC13ZWJwYWNrLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL2ltYWdlc2xvYWRlZC9pbWFnZXNsb2FkZWQuanM/YmQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGltYWdlc0xvYWRlZCB2NC4xLjRcbiAqIEphdmFTY3JpcHQgaXMgYWxsIGxpa2UgXCJZb3UgaW1hZ2VzIGFyZSBkb25lIHlldCBvciB3aGF0P1wiXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHsgJ3VzZSBzdHJpY3QnO1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cblxuICAvKmdsb2JhbCBkZWZpbmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlLCByZXF1aXJlOiBmYWxzZSAqL1xuXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJ1xuICAgIF0sIGZ1bmN0aW9uKCBFdkVtaXR0ZXIgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuaW1hZ2VzTG9hZGVkID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5FdkVtaXR0ZXJcbiAgICApO1xuICB9XG5cbn0pKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBmYWN0b3J5IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkID0gd2luZG93LmpRdWVyeTtcbnZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZXh0ZW5kIG9iamVjdHNcbmZ1bmN0aW9uIGV4dGVuZCggYSwgYiApIHtcbiAgZm9yICggdmFyIHByb3AgaW4gYiApIHtcbiAgICBhWyBwcm9wIF0gPSBiWyBwcm9wIF07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbnZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vLyB0dXJuIGVsZW1lbnQgb3Igbm9kZUxpc3QgaW50byBhbiBhcnJheVxuZnVuY3Rpb24gbWFrZUFycmF5KCBvYmogKSB7XG4gIGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG4gICAgLy8gdXNlIG9iamVjdCBpZiBhbHJlYWR5IGFuIGFycmF5XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBpc0FycmF5TGlrZSA9IHR5cGVvZiBvYmogPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5sZW5ndGggPT0gJ251bWJlcic7XG4gIGlmICggaXNBcnJheUxpa2UgKSB7XG4gICAgLy8gY29udmVydCBub2RlTGlzdCB0byBhcnJheVxuICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwoIG9iaiApO1xuICB9XG5cbiAgLy8gYXJyYXkgb2Ygc2luZ2xlIGluZGV4XG4gIHJldHVybiBbIG9iaiBdO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBpbWFnZXNMb2FkZWQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LCBFbGVtZW50LCBOb2RlTGlzdCwgU3RyaW5nfSBlbGVtXG4gKiBAcGFyYW0ge09iamVjdCBvciBGdW5jdGlvbn0gb3B0aW9ucyAtIGlmIGZ1bmN0aW9uLCB1c2UgYXMgY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQWx3YXlzIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gSW1hZ2VzTG9hZGVkKCBlbGVtLCBvcHRpb25zLCBvbkFsd2F5cyApIHtcbiAgLy8gY29lcmNlIEltYWdlc0xvYWRlZCgpIHdpdGhvdXQgbmV3LCB0byBiZSBuZXcgSW1hZ2VzTG9hZGVkKClcbiAgaWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgSW1hZ2VzTG9hZGVkICkgKSB7XG4gICAgcmV0dXJuIG5ldyBJbWFnZXNMb2FkZWQoIGVsZW0sIG9wdGlvbnMsIG9uQWx3YXlzICk7XG4gIH1cbiAgLy8gdXNlIGVsZW0gYXMgc2VsZWN0b3Igc3RyaW5nXG4gIHZhciBxdWVyeUVsZW0gPSBlbGVtO1xuICBpZiAoIHR5cGVvZiBlbGVtID09ICdzdHJpbmcnICkge1xuICAgIHF1ZXJ5RWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIGVsZW0gKTtcbiAgfVxuICAvLyBiYWlsIGlmIGJhZCBlbGVtZW50XG4gIGlmICggIXF1ZXJ5RWxlbSApIHtcbiAgICBjb25zb2xlLmVycm9yKCAnQmFkIGVsZW1lbnQgZm9yIGltYWdlc0xvYWRlZCAnICsgKCBxdWVyeUVsZW0gfHwgZWxlbSApICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lbGVtZW50cyA9IG1ha2VBcnJheSggcXVlcnlFbGVtICk7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCgge30sIHRoaXMub3B0aW9ucyApO1xuICAvLyBzaGlmdCBhcmd1bWVudHMgaWYgbm8gb3B0aW9ucyBzZXRcbiAgaWYgKCB0eXBlb2Ygb3B0aW9ucyA9PSAnZnVuY3Rpb24nICkge1xuICAgIG9uQWx3YXlzID0gb3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQoIHRoaXMub3B0aW9ucywgb3B0aW9ucyApO1xuICB9XG5cbiAgaWYgKCBvbkFsd2F5cyApIHtcbiAgICB0aGlzLm9uKCAnYWx3YXlzJywgb25BbHdheXMgKTtcbiAgfVxuXG4gIHRoaXMuZ2V0SW1hZ2VzKCk7XG5cbiAgaWYgKCAkICkge1xuICAgIC8vIGFkZCBqUXVlcnkgRGVmZXJyZWQgb2JqZWN0XG4gICAgdGhpcy5qcURlZmVycmVkID0gbmV3ICQuRGVmZXJyZWQoKTtcbiAgfVxuXG4gIC8vIEhBQ0sgY2hlY2sgYXN5bmMgdG8gYWxsb3cgdGltZSB0byBiaW5kIGxpc3RlbmVyc1xuICBzZXRUaW1lb3V0KCB0aGlzLmNoZWNrLmJpbmQoIHRoaXMgKSApO1xufVxuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLm9wdGlvbnMgPSB7fTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5nZXRJbWFnZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbWFnZXMgPSBbXTtcblxuICAvLyBmaWx0ZXIgJiBmaW5kIGl0ZW1zIGlmIHdlIGhhdmUgYW4gaXRlbSBzZWxlY3RvclxuICB0aGlzLmVsZW1lbnRzLmZvckVhY2goIHRoaXMuYWRkRWxlbWVudEltYWdlcywgdGhpcyApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IGVsZW1lbnRcbiAqL1xuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5hZGRFbGVtZW50SW1hZ2VzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIC8vIGZpbHRlciBzaWJsaW5nc1xuICBpZiAoIGVsZW0ubm9kZU5hbWUgPT0gJ0lNRycgKSB7XG4gICAgdGhpcy5hZGRJbWFnZSggZWxlbSApO1xuICB9XG4gIC8vIGdldCBiYWNrZ3JvdW5kIGltYWdlIG9uIGVsZW1lbnRcbiAgaWYgKCB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZCA9PT0gdHJ1ZSApIHtcbiAgICB0aGlzLmFkZEVsZW1lbnRCYWNrZ3JvdW5kSW1hZ2VzKCBlbGVtICk7XG4gIH1cblxuICAvLyBmaW5kIGNoaWxkcmVuXG4gIC8vIG5vIG5vbi1lbGVtZW50IG5vZGVzLCAjMTQzXG4gIHZhciBub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG4gIGlmICggIW5vZGVUeXBlIHx8ICFlbGVtZW50Tm9kZVR5cGVzWyBub2RlVHlwZSBdICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRJbWdzID0gZWxlbS5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKTtcbiAgLy8gY29uY2F0IGNoaWxkRWxlbXMgdG8gZmlsdGVyRm91bmQgYXJyYXlcbiAgZm9yICggdmFyIGk9MDsgaSA8IGNoaWxkSW1ncy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgaW1nID0gY2hpbGRJbWdzW2ldO1xuICAgIHRoaXMuYWRkSW1hZ2UoIGltZyApO1xuICB9XG5cbiAgLy8gZ2V0IGNoaWxkIGJhY2tncm91bmQgaW1hZ2VzXG4gIGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kID09ICdzdHJpbmcnICkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZW0ucXVlcnlTZWxlY3RvckFsbCggdGhpcy5vcHRpb25zLmJhY2tncm91bmQgKTtcbiAgICBmb3IgKCBpPTA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKyApIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdGhpcy5hZGRFbGVtZW50QmFja2dyb3VuZEltYWdlcyggY2hpbGQgKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBlbGVtZW50Tm9kZVR5cGVzID0ge1xuICAxOiB0cnVlLFxuICA5OiB0cnVlLFxuICAxMTogdHJ1ZVxufTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5hZGRFbGVtZW50QmFja2dyb3VuZEltYWdlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG4gIGlmICggIXN0eWxlICkge1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBudWxsIGlmIGluIGEgaGlkZGVuIGlmcmFtZSBodHRwczovL2J1Z3ppbC5sYS81NDgzOTdcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZ2V0IHVybCBpbnNpZGUgdXJsKFwiLi4uXCIpXG4gIHZhciByZVVSTCA9IC91cmxcXCgoWydcIl0pPyguKj8pXFwxXFwpL2dpO1xuICB2YXIgbWF0Y2hlcyA9IHJlVVJMLmV4ZWMoIHN0eWxlLmJhY2tncm91bmRJbWFnZSApO1xuICB3aGlsZSAoIG1hdGNoZXMgIT09IG51bGwgKSB7XG4gICAgdmFyIHVybCA9IG1hdGNoZXMgJiYgbWF0Y2hlc1syXTtcbiAgICBpZiAoIHVybCApIHtcbiAgICAgIHRoaXMuYWRkQmFja2dyb3VuZCggdXJsLCBlbGVtICk7XG4gICAgfVxuICAgIG1hdGNoZXMgPSByZVVSTC5leGVjKCBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWdcbiAqL1xuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5hZGRJbWFnZSA9IGZ1bmN0aW9uKCBpbWcgKSB7XG4gIHZhciBsb2FkaW5nSW1hZ2UgPSBuZXcgTG9hZGluZ0ltYWdlKCBpbWcgKTtcbiAgdGhpcy5pbWFnZXMucHVzaCggbG9hZGluZ0ltYWdlICk7XG59O1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmFkZEJhY2tncm91bmQgPSBmdW5jdGlvbiggdXJsLCBlbGVtICkge1xuICB2YXIgYmFja2dyb3VuZCA9IG5ldyBCYWNrZ3JvdW5kKCB1cmwsIGVsZW0gKTtcbiAgdGhpcy5pbWFnZXMucHVzaCggYmFja2dyb3VuZCApO1xufTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB0aGlzLnByb2dyZXNzZWRDb3VudCA9IDA7XG4gIHRoaXMuaGFzQW55QnJva2VuID0gZmFsc2U7XG4gIC8vIGNvbXBsZXRlIGlmIG5vIGltYWdlc1xuICBpZiAoICF0aGlzLmltYWdlcy5sZW5ndGggKSB7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoIGltYWdlLCBlbGVtLCBtZXNzYWdlICkge1xuICAgIC8vIEhBQ0sgLSBDaHJvbWUgdHJpZ2dlcnMgZXZlbnQgYmVmb3JlIG9iamVjdCBwcm9wZXJ0aWVzIGhhdmUgY2hhbmdlZC4gIzgzXG4gICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5wcm9ncmVzcyggaW1hZ2UsIGVsZW0sIG1lc3NhZ2UgKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuaW1hZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBsb2FkaW5nSW1hZ2UgKSB7XG4gICAgbG9hZGluZ0ltYWdlLm9uY2UoICdwcm9ncmVzcycsIG9uUHJvZ3Jlc3MgKTtcbiAgICBsb2FkaW5nSW1hZ2UuY2hlY2soKTtcbiAgfSk7XG59O1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24oIGltYWdlLCBlbGVtLCBtZXNzYWdlICkge1xuICB0aGlzLnByb2dyZXNzZWRDb3VudCsrO1xuICB0aGlzLmhhc0FueUJyb2tlbiA9IHRoaXMuaGFzQW55QnJva2VuIHx8ICFpbWFnZS5pc0xvYWRlZDtcbiAgLy8gcHJvZ3Jlc3MgZXZlbnRcbiAgdGhpcy5lbWl0RXZlbnQoICdwcm9ncmVzcycsIFsgdGhpcywgaW1hZ2UsIGVsZW0gXSApO1xuICBpZiAoIHRoaXMuanFEZWZlcnJlZCAmJiB0aGlzLmpxRGVmZXJyZWQubm90aWZ5ICkge1xuICAgIHRoaXMuanFEZWZlcnJlZC5ub3RpZnkoIHRoaXMsIGltYWdlICk7XG4gIH1cbiAgLy8gY2hlY2sgaWYgY29tcGxldGVkXG4gIGlmICggdGhpcy5wcm9ncmVzc2VkQ291bnQgPT0gdGhpcy5pbWFnZXMubGVuZ3RoICkge1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgfVxuXG4gIGlmICggdGhpcy5vcHRpb25zLmRlYnVnICYmIGNvbnNvbGUgKSB7XG4gICAgY29uc29sZS5sb2coICdwcm9ncmVzczogJyArIG1lc3NhZ2UsIGltYWdlLCBlbGVtICk7XG4gIH1cbn07XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV2ZW50TmFtZSA9IHRoaXMuaGFzQW55QnJva2VuID8gJ2ZhaWwnIDogJ2RvbmUnO1xuICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICB0aGlzLmVtaXRFdmVudCggZXZlbnROYW1lLCBbIHRoaXMgXSApO1xuICB0aGlzLmVtaXRFdmVudCggJ2Fsd2F5cycsIFsgdGhpcyBdICk7XG4gIGlmICggdGhpcy5qcURlZmVycmVkICkge1xuICAgIHZhciBqcU1ldGhvZCA9IHRoaXMuaGFzQW55QnJva2VuID8gJ3JlamVjdCcgOiAncmVzb2x2ZSc7XG4gICAgdGhpcy5qcURlZmVycmVkWyBqcU1ldGhvZCBdKCB0aGlzICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBMb2FkaW5nSW1hZ2UoIGltZyApIHtcbiAgdGhpcy5pbWcgPSBpbWc7XG59XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgLy8gSWYgY29tcGxldGUgaXMgdHJ1ZSBhbmQgYnJvd3NlciBzdXBwb3J0cyBuYXR1cmFsIHNpemVzLFxuICAvLyB0cnkgdG8gY2hlY2sgZm9yIGltYWdlIHN0YXR1cyBtYW51YWxseS5cbiAgdmFyIGlzQ29tcGxldGUgPSB0aGlzLmdldElzSW1hZ2VDb21wbGV0ZSgpO1xuICBpZiAoIGlzQ29tcGxldGUgKSB7XG4gICAgLy8gcmVwb3J0IGJhc2VkIG9uIG5hdHVyYWxXaWR0aFxuICAgIHRoaXMuY29uZmlybSggdGhpcy5pbWcubmF0dXJhbFdpZHRoICE9PSAwLCAnbmF0dXJhbFdpZHRoJyApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIG5vbmUgb2YgdGhlIGNoZWNrcyBhYm92ZSBtYXRjaGVkLCBzaW11bGF0ZSBsb2FkaW5nIG9uIGRldGFjaGVkIGVsZW1lbnQuXG4gIHRoaXMucHJveHlJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICB0aGlzLnByb3h5SW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMucHJveHlJbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG4gIC8vIGJpbmQgdG8gaW1hZ2UgYXMgd2VsbCBmb3IgRmlyZWZveC4gIzE5MVxuICB0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICB0aGlzLnByb3h5SW1hZ2Uuc3JjID0gdGhpcy5pbWcuc3JjO1xufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5nZXRJc0ltYWdlQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gY2hlY2sgZm9yIG5vbi16ZXJvLCBub24tdW5kZWZpbmVkIG5hdHVyYWxXaWR0aFxuICAvLyBmaXhlcyBTYWZhcmkrSW5maW5pdGVTY3JvbGwrTWFzb25yeSBidWcgaW5maW5pdGUtc2Nyb2xsIzY3MVxuICByZXR1cm4gdGhpcy5pbWcuY29tcGxldGUgJiYgdGhpcy5pbWcubmF0dXJhbFdpZHRoO1xufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24oIGlzTG9hZGVkLCBtZXNzYWdlICkge1xuICB0aGlzLmlzTG9hZGVkID0gaXNMb2FkZWQ7XG4gIHRoaXMuZW1pdEV2ZW50KCAncHJvZ3Jlc3MnLCBbIHRoaXMsIHRoaXMuaW1nLCBtZXNzYWdlIF0gKTtcbn07XG5cbi8vIC0tLS0tIGV2ZW50cyAtLS0tLSAvL1xuXG4vLyB0cmlnZ2VyIHNwZWNpZmllZCBoYW5kbGVyIGZvciBldmVudCB0eXBlXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB2YXIgbWV0aG9kID0gJ29uJyArIGV2ZW50LnR5cGU7XG4gIGlmICggdGhpc1sgbWV0aG9kIF0gKSB7XG4gICAgdGhpc1sgbWV0aG9kIF0oIGV2ZW50ICk7XG4gIH1cbn07XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29uZmlybSggdHJ1ZSwgJ29ubG9hZCcgKTtcbiAgdGhpcy51bmJpbmRFdmVudHMoKTtcbn07XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbmZpcm0oIGZhbHNlLCAnb25lcnJvcicgKTtcbiAgdGhpcy51bmJpbmRFdmVudHMoKTtcbn07XG5cbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUudW5iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucHJveHlJbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5wcm94eUltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbiAgdGhpcy5pbWcucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEJhY2tncm91bmQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gQmFja2dyb3VuZCggdXJsLCBlbGVtZW50ICkge1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5pbWcgPSBuZXcgSW1hZ2UoKTtcbn1cblxuLy8gaW5oZXJpdCBMb2FkaW5nSW1hZ2UgcHJvdG90eXBlXG5CYWNrZ3JvdW5kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExvYWRpbmdJbWFnZS5wcm90b3R5cGUgKTtcblxuQmFja2dyb3VuZC5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMuaW1nLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbiAgdGhpcy5pbWcuc3JjID0gdGhpcy51cmw7XG4gIC8vIGNoZWNrIGlmIGltYWdlIGlzIGFscmVhZHkgY29tcGxldGVcbiAgdmFyIGlzQ29tcGxldGUgPSB0aGlzLmdldElzSW1hZ2VDb21wbGV0ZSgpO1xuICBpZiAoIGlzQ29tcGxldGUgKSB7XG4gICAgdGhpcy5jb25maXJtKCB0aGlzLmltZy5uYXR1cmFsV2lkdGggIT09IDAsICduYXR1cmFsV2lkdGgnICk7XG4gICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgfVxufTtcblxuQmFja2dyb3VuZC5wcm90b3R5cGUudW5iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLmltZy5yZW1vdmVFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG59O1xuXG5CYWNrZ3JvdW5kLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24oIGlzTG9hZGVkLCBtZXNzYWdlICkge1xuICB0aGlzLmlzTG9hZGVkID0gaXNMb2FkZWQ7XG4gIHRoaXMuZW1pdEV2ZW50KCAncHJvZ3Jlc3MnLCBbIHRoaXMsIHRoaXMuZWxlbWVudCwgbWVzc2FnZSBdICk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBqUXVlcnkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuSW1hZ2VzTG9hZGVkLm1ha2VKUXVlcnlQbHVnaW4gPSBmdW5jdGlvbiggalF1ZXJ5ICkge1xuICBqUXVlcnkgPSBqUXVlcnkgfHwgd2luZG93LmpRdWVyeTtcbiAgaWYgKCAhalF1ZXJ5ICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzZXQgbG9jYWwgdmFyaWFibGVcbiAgJCA9IGpRdWVyeTtcbiAgLy8gJCgpLmltYWdlc0xvYWRlZCgpXG4gICQuZm4uaW1hZ2VzTG9hZGVkID0gZnVuY3Rpb24oIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBJbWFnZXNMb2FkZWQoIHRoaXMsIG9wdGlvbnMsIGNhbGxiYWNrICk7XG4gICAgcmV0dXJuIGluc3RhbmNlLmpxRGVmZXJyZWQucHJvbWlzZSggJCh0aGlzKSApO1xuICB9O1xufTtcbi8vIHRyeSBtYWtpbmcgcGx1Z2luXG5JbWFnZXNMb2FkZWQubWFrZUpRdWVyeVBsdWdpbigpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxucmV0dXJuIEltYWdlc0xvYWRlZDtcblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/imagesloaded/imagesloaded.js\n");

/***/ }),

/***/ "./node_modules/jquery-validation/dist/jquery.validate.js":
/*!****************************************************************!*\
  !*** ./node_modules/jquery-validation/dist/jquery.validate.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * jQuery Validation Plugin v1.19.3\r\n *\r\n * https://jqueryvalidation.org/\r\n *\r\n * Copyright (c) 2021 Jrn Zaefferer\r\n * Released under the MIT license\r\n */\r\n(function( factory ) {\r\n\tif ( true ) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else {}\r\n}(function( $ ) {\r\n\r\n$.extend( $.fn, {\n\n\t// https://jqueryvalidation.org/validate/\n\tvalidate: function( options ) {\n\n\t\t// If nothing is selected, return nothing; can't chain anyway\n\t\tif ( !this.length ) {\n\t\t\tif ( options && options.debug && window.console ) {\n\t\t\t\tconsole.warn( \"Nothing selected, can't validate, returning nothing.\" );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if a validator for this form was already created\n\t\tvar validator = $.data( this[ 0 ], \"validator\" );\n\t\tif ( validator ) {\n\t\t\treturn validator;\n\t\t}\n\n\t\t// Add novalidate tag if HTML5.\n\t\tthis.attr( \"novalidate\", \"novalidate\" );\n\n\t\tvalidator = new $.validator( options, this[ 0 ] );\n\t\t$.data( this[ 0 ], \"validator\", validator );\n\n\t\tif ( validator.settings.onsubmit ) {\n\n\t\t\tthis.on( \"click.validate\", \":submit\", function( event ) {\n\n\t\t\t\t// Track the used submit button to properly handle scripted\n\t\t\t\t// submits later.\n\t\t\t\tvalidator.submitButton = event.currentTarget;\n\n\t\t\t\t// Allow suppressing validation by adding a cancel class to the submit button\n\t\t\t\tif ( $( this ).hasClass( \"cancel\" ) ) {\n\t\t\t\t\tvalidator.cancelSubmit = true;\n\t\t\t\t}\n\n\t\t\t\t// Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button\n\t\t\t\tif ( $( this ).attr( \"formnovalidate\" ) !== undefined ) {\n\t\t\t\t\tvalidator.cancelSubmit = true;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Validate the form on submit\n\t\t\tthis.on( \"submit.validate\", function( event ) {\n\t\t\t\tif ( validator.settings.debug ) {\n\n\t\t\t\t\t// Prevent form submit to be able to see console output\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\tfunction handle() {\n\t\t\t\t\tvar hidden, result;\n\n\t\t\t\t\t// Insert a hidden input as a replacement for the missing submit button\n\t\t\t\t\t// The hidden input is inserted in two cases:\n\t\t\t\t\t//   - A user defined a `submitHandler`\n\t\t\t\t\t//   - There was a pending request due to `remote` method and `stopRequest()`\n\t\t\t\t\t//     was called to submit the form in case it's valid\n\t\t\t\t\tif ( validator.submitButton && ( validator.settings.submitHandler || validator.formSubmitted ) ) {\n\t\t\t\t\t\thidden = $( \"<input type='hidden'/>\" )\n\t\t\t\t\t\t\t.attr( \"name\", validator.submitButton.name )\n\t\t\t\t\t\t\t.val( $( validator.submitButton ).val() )\n\t\t\t\t\t\t\t.appendTo( validator.currentForm );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( validator.settings.submitHandler && !validator.settings.debug ) {\n\t\t\t\t\t\tresult = validator.settings.submitHandler.call( validator, validator.currentForm, event );\n\t\t\t\t\t\tif ( hidden ) {\n\n\t\t\t\t\t\t\t// And clean up afterwards; thanks to no-block-scope, hidden can be referenced\n\t\t\t\t\t\t\thidden.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( result !== undefined ) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Prevent submit for invalid forms or custom submit handlers\n\t\t\t\tif ( validator.cancelSubmit ) {\n\t\t\t\t\tvalidator.cancelSubmit = false;\n\t\t\t\t\treturn handle();\n\t\t\t\t}\n\t\t\t\tif ( validator.form() ) {\n\t\t\t\t\tif ( validator.pendingRequest ) {\n\t\t\t\t\t\tvalidator.formSubmitted = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn handle();\n\t\t\t\t} else {\n\t\t\t\t\tvalidator.focusInvalid();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\treturn validator;\n\t},\n\n\t// https://jqueryvalidation.org/valid/\n\tvalid: function() {\n\t\tvar valid, validator, errorList;\n\n\t\tif ( $( this[ 0 ] ).is( \"form\" ) ) {\n\t\t\tvalid = this.validate().form();\n\t\t} else {\n\t\t\terrorList = [];\n\t\t\tvalid = true;\n\t\t\tvalidator = $( this[ 0 ].form ).validate();\n\t\t\tthis.each( function() {\n\t\t\t\tvalid = validator.element( this ) && valid;\n\t\t\t\tif ( !valid ) {\n\t\t\t\t\terrorList = errorList.concat( validator.errorList );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tvalidator.errorList = errorList;\n\t\t}\n\t\treturn valid;\n\t},\n\n\t// https://jqueryvalidation.org/rules/\n\trules: function( command, argument ) {\n\t\tvar element = this[ 0 ],\n\t\t\tisContentEditable = typeof this.attr( \"contenteditable\" ) !== \"undefined\" && this.attr( \"contenteditable\" ) !== \"false\",\n\t\t\tsettings, staticRules, existingRules, data, param, filtered;\n\n\t\t// If nothing is selected, return empty object; can't chain anyway\n\t\tif ( element == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !element.form && isContentEditable ) {\n\t\t\telement.form = this.closest( \"form\" )[ 0 ];\n\t\t\telement.name = this.attr( \"name\" );\n\t\t}\n\n\t\tif ( element.form == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( command ) {\n\t\t\tsettings = $.data( element.form, \"validator\" ).settings;\n\t\t\tstaticRules = settings.rules;\n\t\t\texistingRules = $.validator.staticRules( element );\n\t\t\tswitch ( command ) {\n\t\t\tcase \"add\":\n\t\t\t\t$.extend( existingRules, $.validator.normalizeRule( argument ) );\n\n\t\t\t\t// Remove messages from rules, but allow them to be set separately\n\t\t\t\tdelete existingRules.messages;\n\t\t\t\tstaticRules[ element.name ] = existingRules;\n\t\t\t\tif ( argument.messages ) {\n\t\t\t\t\tsettings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"remove\":\n\t\t\t\tif ( !argument ) {\n\t\t\t\t\tdelete staticRules[ element.name ];\n\t\t\t\t\treturn existingRules;\n\t\t\t\t}\n\t\t\t\tfiltered = {};\n\t\t\t\t$.each( argument.split( /\\s/ ), function( index, method ) {\n\t\t\t\t\tfiltered[ method ] = existingRules[ method ];\n\t\t\t\t\tdelete existingRules[ method ];\n\t\t\t\t} );\n\t\t\t\treturn filtered;\n\t\t\t}\n\t\t}\n\n\t\tdata = $.validator.normalizeRules(\n\t\t$.extend(\n\t\t\t{},\n\t\t\t$.validator.classRules( element ),\n\t\t\t$.validator.attributeRules( element ),\n\t\t\t$.validator.dataRules( element ),\n\t\t\t$.validator.staticRules( element )\n\t\t), element );\n\n\t\t// Make sure required is at front\n\t\tif ( data.required ) {\n\t\t\tparam = data.required;\n\t\t\tdelete data.required;\n\t\t\tdata = $.extend( { required: param }, data );\n\t\t}\n\n\t\t// Make sure remote is at back\n\t\tif ( data.remote ) {\n\t\t\tparam = data.remote;\n\t\t\tdelete data.remote;\n\t\t\tdata = $.extend( data, { remote: param } );\n\t\t}\n\n\t\treturn data;\n\t}\n} );\n\n// JQuery trim is deprecated, provide a trim method based on String.prototype.trim\nvar trim = function( str ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim#Polyfill\n\treturn str.replace( /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\" );\n};\n\n// Custom selectors\n$.extend( $.expr.pseudos || $.expr[ \":\" ], {\t\t// '|| $.expr[ \":\" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support\n\n\t// https://jqueryvalidation.org/blank-selector/\n\tblank: function( a ) {\n\t\treturn !trim( \"\" + $( a ).val() );\n\t},\n\n\t// https://jqueryvalidation.org/filled-selector/\n\tfilled: function( a ) {\n\t\tvar val = $( a ).val();\n\t\treturn val !== null && !!trim( \"\" + val );\n\t},\n\n\t// https://jqueryvalidation.org/unchecked-selector/\n\tunchecked: function( a ) {\n\t\treturn !$( a ).prop( \"checked\" );\n\t}\n} );\n\n// Constructor for validator\n$.validator = function( options, form ) {\n\tthis.settings = $.extend( true, {}, $.validator.defaults, options );\n\tthis.currentForm = form;\n\tthis.init();\n};\n\n// https://jqueryvalidation.org/jQuery.validator.format/\n$.validator.format = function( source, params ) {\n\tif ( arguments.length === 1 ) {\n\t\treturn function() {\n\t\t\tvar args = $.makeArray( arguments );\n\t\t\targs.unshift( source );\n\t\t\treturn $.validator.format.apply( this, args );\n\t\t};\n\t}\n\tif ( params === undefined ) {\n\t\treturn source;\n\t}\n\tif ( arguments.length > 2 && params.constructor !== Array  ) {\n\t\tparams = $.makeArray( arguments ).slice( 1 );\n\t}\n\tif ( params.constructor !== Array ) {\n\t\tparams = [ params ];\n\t}\n\t$.each( params, function( i, n ) {\n\t\tsource = source.replace( new RegExp( \"\\\\{\" + i + \"\\\\}\", \"g\" ), function() {\n\t\t\treturn n;\n\t\t} );\n\t} );\n\treturn source;\n};\n\n$.extend( $.validator, {\n\n\tdefaults: {\n\t\tmessages: {},\n\t\tgroups: {},\n\t\trules: {},\n\t\terrorClass: \"error\",\n\t\tpendingClass: \"pending\",\n\t\tvalidClass: \"valid\",\n\t\terrorElement: \"label\",\n\t\tfocusCleanup: false,\n\t\tfocusInvalid: true,\n\t\terrorContainer: $( [] ),\n\t\terrorLabelContainer: $( [] ),\n\t\tonsubmit: true,\n\t\tignore: \":hidden\",\n\t\tignoreTitle: false,\n\t\tonfocusin: function( element ) {\n\t\t\tthis.lastActive = element;\n\n\t\t\t// Hide error label and remove error class on focus if enabled\n\t\t\tif ( this.settings.focusCleanup ) {\n\t\t\t\tif ( this.settings.unhighlight ) {\n\t\t\t\t\tthis.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );\n\t\t\t\t}\n\t\t\t\tthis.hideThese( this.errorsFor( element ) );\n\t\t\t}\n\t\t},\n\t\tonfocusout: function( element ) {\n\t\t\tif ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {\n\t\t\t\tthis.element( element );\n\t\t\t}\n\t\t},\n\t\tonkeyup: function( element, event ) {\n\n\t\t\t// Avoid revalidate the field when pressing one of the following keys\n\t\t\t// Shift       => 16\n\t\t\t// Ctrl        => 17\n\t\t\t// Alt         => 18\n\t\t\t// Caps lock   => 20\n\t\t\t// End         => 35\n\t\t\t// Home        => 36\n\t\t\t// Left arrow  => 37\n\t\t\t// Up arrow    => 38\n\t\t\t// Right arrow => 39\n\t\t\t// Down arrow  => 40\n\t\t\t// Insert      => 45\n\t\t\t// Num lock    => 144\n\t\t\t// AltGr key   => 225\n\t\t\tvar excludedKeys = [\n\t\t\t\t16, 17, 18, 20, 35, 36, 37,\n\t\t\t\t38, 39, 40, 45, 144, 225\n\t\t\t];\n\n\t\t\tif ( event.which === 9 && this.elementValue( element ) === \"\" || $.inArray( event.keyCode, excludedKeys ) !== -1 ) {\n\t\t\t\treturn;\n\t\t\t} else if ( element.name in this.submitted || element.name in this.invalid ) {\n\t\t\t\tthis.element( element );\n\t\t\t}\n\t\t},\n\t\tonclick: function( element ) {\n\n\t\t\t// Click on selects, radiobuttons and checkboxes\n\t\t\tif ( element.name in this.submitted ) {\n\t\t\t\tthis.element( element );\n\n\t\t\t// Or option elements, check parent select in that case\n\t\t\t} else if ( element.parentNode.name in this.submitted ) {\n\t\t\t\tthis.element( element.parentNode );\n\t\t\t}\n\t\t},\n\t\thighlight: function( element, errorClass, validClass ) {\n\t\t\tif ( element.type === \"radio\" ) {\n\t\t\t\tthis.findByName( element.name ).addClass( errorClass ).removeClass( validClass );\n\t\t\t} else {\n\t\t\t\t$( element ).addClass( errorClass ).removeClass( validClass );\n\t\t\t}\n\t\t},\n\t\tunhighlight: function( element, errorClass, validClass ) {\n\t\t\tif ( element.type === \"radio\" ) {\n\t\t\t\tthis.findByName( element.name ).removeClass( errorClass ).addClass( validClass );\n\t\t\t} else {\n\t\t\t\t$( element ).removeClass( errorClass ).addClass( validClass );\n\t\t\t}\n\t\t}\n\t},\n\n\t// https://jqueryvalidation.org/jQuery.validator.setDefaults/\n\tsetDefaults: function( settings ) {\n\t\t$.extend( $.validator.defaults, settings );\n\t},\n\n\tmessages: {\n\t\trequired: \"This field is required.\",\n\t\tremote: \"Please fix this field.\",\n\t\temail: \"Please enter a valid email address.\",\n\t\turl: \"Please enter a valid URL.\",\n\t\tdate: \"Please enter a valid date.\",\n\t\tdateISO: \"Please enter a valid date (ISO).\",\n\t\tnumber: \"Please enter a valid number.\",\n\t\tdigits: \"Please enter only digits.\",\n\t\tequalTo: \"Please enter the same value again.\",\n\t\tmaxlength: $.validator.format( \"Please enter no more than {0} characters.\" ),\n\t\tminlength: $.validator.format( \"Please enter at least {0} characters.\" ),\n\t\trangelength: $.validator.format( \"Please enter a value between {0} and {1} characters long.\" ),\n\t\trange: $.validator.format( \"Please enter a value between {0} and {1}.\" ),\n\t\tmax: $.validator.format( \"Please enter a value less than or equal to {0}.\" ),\n\t\tmin: $.validator.format( \"Please enter a value greater than or equal to {0}.\" ),\n\t\tstep: $.validator.format( \"Please enter a multiple of {0}.\" )\n\t},\n\n\tautoCreateRanges: false,\n\n\tprototype: {\n\n\t\tinit: function() {\n\t\t\tthis.labelContainer = $( this.settings.errorLabelContainer );\n\t\t\tthis.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );\n\t\t\tthis.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );\n\t\t\tthis.submitted = {};\n\t\t\tthis.valueCache = {};\n\t\t\tthis.pendingRequest = 0;\n\t\t\tthis.pending = {};\n\t\t\tthis.invalid = {};\n\t\t\tthis.reset();\n\n\t\t\tvar currentForm = this.currentForm,\n\t\t\t\tgroups = ( this.groups = {} ),\n\t\t\t\trules;\n\t\t\t$.each( this.settings.groups, function( key, value ) {\n\t\t\t\tif ( typeof value === \"string\" ) {\n\t\t\t\t\tvalue = value.split( /\\s/ );\n\t\t\t\t}\n\t\t\t\t$.each( value, function( index, name ) {\n\t\t\t\t\tgroups[ name ] = key;\n\t\t\t\t} );\n\t\t\t} );\n\t\t\trules = this.settings.rules;\n\t\t\t$.each( rules, function( key, value ) {\n\t\t\t\trules[ key ] = $.validator.normalizeRule( value );\n\t\t\t} );\n\n\t\t\tfunction delegate( event ) {\n\t\t\t\tvar isContentEditable = typeof $( this ).attr( \"contenteditable\" ) !== \"undefined\" && $( this ).attr( \"contenteditable\" ) !== \"false\";\n\n\t\t\t\t// Set form expando on contenteditable\n\t\t\t\tif ( !this.form && isContentEditable ) {\n\t\t\t\t\tthis.form = $( this ).closest( \"form\" )[ 0 ];\n\t\t\t\t\tthis.name = $( this ).attr( \"name\" );\n\t\t\t\t}\n\n\t\t\t\t// Ignore the element if it belongs to another form. This will happen mainly\n\t\t\t\t// when setting the `form` attribute of an input to the id of another form.\n\t\t\t\tif ( currentForm !== this.form ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar validator = $.data( this.form, \"validator\" ),\n\t\t\t\t\teventType = \"on\" + event.type.replace( /^validate/, \"\" ),\n\t\t\t\t\tsettings = validator.settings;\n\t\t\t\tif ( settings[ eventType ] && !$( this ).is( settings.ignore ) ) {\n\t\t\t\t\tsettings[ eventType ].call( validator, this, event );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$( this.currentForm )\n\t\t\t\t.on( \"focusin.validate focusout.validate keyup.validate\",\n\t\t\t\t\t\":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], \" +\n\t\t\t\t\t\"[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], \" +\n\t\t\t\t\t\"[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], \" +\n\t\t\t\t\t\"[type='radio'], [type='checkbox'], [contenteditable], [type='button']\", delegate )\n\n\t\t\t\t// Support: Chrome, oldIE\n\t\t\t\t// \"select\" is provided as event.target when clicking a option\n\t\t\t\t.on( \"click.validate\", \"select, option, [type='radio'], [type='checkbox']\", delegate );\n\n\t\t\tif ( this.settings.invalidHandler ) {\n\t\t\t\t$( this.currentForm ).on( \"invalid-form.validate\", this.settings.invalidHandler );\n\t\t\t}\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.form/\n\t\tform: function() {\n\t\t\tthis.checkForm();\n\t\t\t$.extend( this.submitted, this.errorMap );\n\t\t\tthis.invalid = $.extend( {}, this.errorMap );\n\t\t\tif ( !this.valid() ) {\n\t\t\t\t$( this.currentForm ).triggerHandler( \"invalid-form\", [ this ] );\n\t\t\t}\n\t\t\tthis.showErrors();\n\t\t\treturn this.valid();\n\t\t},\n\n\t\tcheckForm: function() {\n\t\t\tthis.prepareForm();\n\t\t\tfor ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {\n\t\t\t\tthis.check( elements[ i ] );\n\t\t\t}\n\t\t\treturn this.valid();\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.element/\n\t\telement: function( element ) {\n\t\t\tvar cleanElement = this.clean( element ),\n\t\t\t\tcheckElement = this.validationTargetFor( cleanElement ),\n\t\t\t\tv = this,\n\t\t\t\tresult = true,\n\t\t\t\trs, group;\n\n\t\t\tif ( checkElement === undefined ) {\n\t\t\t\tdelete this.invalid[ cleanElement.name ];\n\t\t\t} else {\n\t\t\t\tthis.prepareElement( checkElement );\n\t\t\t\tthis.currentElements = $( checkElement );\n\n\t\t\t\t// If this element is grouped, then validate all group elements already\n\t\t\t\t// containing a value\n\t\t\t\tgroup = this.groups[ checkElement.name ];\n\t\t\t\tif ( group ) {\n\t\t\t\t\t$.each( this.groups, function( name, testgroup ) {\n\t\t\t\t\t\tif ( testgroup === group && name !== checkElement.name ) {\n\t\t\t\t\t\t\tcleanElement = v.validationTargetFor( v.clean( v.findByName( name ) ) );\n\t\t\t\t\t\t\tif ( cleanElement && cleanElement.name in v.invalid ) {\n\t\t\t\t\t\t\t\tv.currentElements.push( cleanElement );\n\t\t\t\t\t\t\t\tresult = v.check( cleanElement ) && result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\trs = this.check( checkElement ) !== false;\n\t\t\t\tresult = result && rs;\n\t\t\t\tif ( rs ) {\n\t\t\t\t\tthis.invalid[ checkElement.name ] = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.invalid[ checkElement.name ] = true;\n\t\t\t\t}\n\n\t\t\t\tif ( !this.numberOfInvalids() ) {\n\n\t\t\t\t\t// Hide error containers on last error\n\t\t\t\t\tthis.toHide = this.toHide.add( this.containers );\n\t\t\t\t}\n\t\t\t\tthis.showErrors();\n\n\t\t\t\t// Add aria-invalid status for screen readers\n\t\t\t\t$( element ).attr( \"aria-invalid\", !rs );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.showErrors/\n\t\tshowErrors: function( errors ) {\n\t\t\tif ( errors ) {\n\t\t\t\tvar validator = this;\n\n\t\t\t\t// Add items to error list and map\n\t\t\t\t$.extend( this.errorMap, errors );\n\t\t\t\tthis.errorList = $.map( this.errorMap, function( message, name ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmessage: message,\n\t\t\t\t\t\telement: validator.findByName( name )[ 0 ]\n\t\t\t\t\t};\n\t\t\t\t} );\n\n\t\t\t\t// Remove items from success list\n\t\t\t\tthis.successList = $.grep( this.successList, function( element ) {\n\t\t\t\t\treturn !( element.name in errors );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( this.settings.showErrors ) {\n\t\t\t\tthis.settings.showErrors.call( this, this.errorMap, this.errorList );\n\t\t\t} else {\n\t\t\t\tthis.defaultShowErrors();\n\t\t\t}\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.resetForm/\n\t\tresetForm: function() {\n\t\t\tif ( $.fn.resetForm ) {\n\t\t\t\t$( this.currentForm ).resetForm();\n\t\t\t}\n\t\t\tthis.invalid = {};\n\t\t\tthis.submitted = {};\n\t\t\tthis.prepareForm();\n\t\t\tthis.hideErrors();\n\t\t\tvar elements = this.elements()\n\t\t\t\t.removeData( \"previousValue\" )\n\t\t\t\t.removeAttr( \"aria-invalid\" );\n\n\t\t\tthis.resetElements( elements );\n\t\t},\n\n\t\tresetElements: function( elements ) {\n\t\t\tvar i;\n\n\t\t\tif ( this.settings.unhighlight ) {\n\t\t\t\tfor ( i = 0; elements[ i ]; i++ ) {\n\t\t\t\t\tthis.settings.unhighlight.call( this, elements[ i ],\n\t\t\t\t\t\tthis.settings.errorClass, \"\" );\n\t\t\t\t\tthis.findByName( elements[ i ].name ).removeClass( this.settings.validClass );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telements\n\t\t\t\t\t.removeClass( this.settings.errorClass )\n\t\t\t\t\t.removeClass( this.settings.validClass );\n\t\t\t}\n\t\t},\n\n\t\tnumberOfInvalids: function() {\n\t\t\treturn this.objectLength( this.invalid );\n\t\t},\n\n\t\tobjectLength: function( obj ) {\n\t\t\t/* jshint unused: false */\n\t\t\tvar count = 0,\n\t\t\t\ti;\n\t\t\tfor ( i in obj ) {\n\n\t\t\t\t// This check allows counting elements with empty error\n\t\t\t\t// message as invalid elements\n\t\t\t\tif ( obj[ i ] !== undefined && obj[ i ] !== null && obj[ i ] !== false ) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\thideErrors: function() {\n\t\t\tthis.hideThese( this.toHide );\n\t\t},\n\n\t\thideThese: function( errors ) {\n\t\t\terrors.not( this.containers ).text( \"\" );\n\t\t\tthis.addWrapper( errors ).hide();\n\t\t},\n\n\t\tvalid: function() {\n\t\t\treturn this.size() === 0;\n\t\t},\n\n\t\tsize: function() {\n\t\t\treturn this.errorList.length;\n\t\t},\n\n\t\tfocusInvalid: function() {\n\t\t\tif ( this.settings.focusInvalid ) {\n\t\t\t\ttry {\n\t\t\t\t\t$( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [] )\n\t\t\t\t\t.filter( \":visible\" )\n\t\t\t\t\t.trigger( \"focus\" )\n\n\t\t\t\t\t// Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find\n\t\t\t\t\t.trigger( \"focusin\" );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// Ignore IE throwing errors when focusing hidden elements\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tfindLastActive: function() {\n\t\t\tvar lastActive = this.lastActive;\n\t\t\treturn lastActive && $.grep( this.errorList, function( n ) {\n\t\t\t\treturn n.element.name === lastActive.name;\n\t\t\t} ).length === 1 && lastActive;\n\t\t},\n\n\t\telements: function() {\n\t\t\tvar validator = this,\n\t\t\t\trulesCache = {};\n\n\t\t\t// Select all valid inputs inside the form (no submit or reset buttons)\n\t\t\treturn $( this.currentForm )\n\t\t\t.find( \"input, select, textarea, [contenteditable]\" )\n\t\t\t.not( \":submit, :reset, :image, :disabled\" )\n\t\t\t.not( this.settings.ignore )\n\t\t\t.filter( function() {\n\t\t\t\tvar name = this.name || $( this ).attr( \"name\" ); // For contenteditable\n\t\t\t\tvar isContentEditable = typeof $( this ).attr( \"contenteditable\" ) !== \"undefined\" && $( this ).attr( \"contenteditable\" ) !== \"false\";\n\n\t\t\t\tif ( !name && validator.settings.debug && window.console ) {\n\t\t\t\t\tconsole.error( \"%o has no name assigned\", this );\n\t\t\t\t}\n\n\t\t\t\t// Set form expando on contenteditable\n\t\t\t\tif ( isContentEditable ) {\n\t\t\t\t\tthis.form = $( this ).closest( \"form\" )[ 0 ];\n\t\t\t\t\tthis.name = name;\n\t\t\t\t}\n\n\t\t\t\t// Ignore elements that belong to other/nested forms\n\t\t\t\tif ( this.form !== validator.currentForm ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Select only the first element for each name, and only those with rules specified\n\t\t\t\tif ( name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\trulesCache[ name ] = true;\n\t\t\t\treturn true;\n\t\t\t} );\n\t\t},\n\n\t\tclean: function( selector ) {\n\t\t\treturn $( selector )[ 0 ];\n\t\t},\n\n\t\terrors: function() {\n\t\t\tvar errorClass = this.settings.errorClass.split( \" \" ).join( \".\" );\n\t\t\treturn $( this.settings.errorElement + \".\" + errorClass, this.errorContext );\n\t\t},\n\n\t\tresetInternals: function() {\n\t\t\tthis.successList = [];\n\t\t\tthis.errorList = [];\n\t\t\tthis.errorMap = {};\n\t\t\tthis.toShow = $( [] );\n\t\t\tthis.toHide = $( [] );\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.resetInternals();\n\t\t\tthis.currentElements = $( [] );\n\t\t},\n\n\t\tprepareForm: function() {\n\t\t\tthis.reset();\n\t\t\tthis.toHide = this.errors().add( this.containers );\n\t\t},\n\n\t\tprepareElement: function( element ) {\n\t\t\tthis.reset();\n\t\t\tthis.toHide = this.errorsFor( element );\n\t\t},\n\n\t\telementValue: function( element ) {\n\t\t\tvar $element = $( element ),\n\t\t\t\ttype = element.type,\n\t\t\t\tisContentEditable = typeof $element.attr( \"contenteditable\" ) !== \"undefined\" && $element.attr( \"contenteditable\" ) !== \"false\",\n\t\t\t\tval, idx;\n\n\t\t\tif ( type === \"radio\" || type === \"checkbox\" ) {\n\t\t\t\treturn this.findByName( element.name ).filter( \":checked\" ).val();\n\t\t\t} else if ( type === \"number\" && typeof element.validity !== \"undefined\" ) {\n\t\t\t\treturn element.validity.badInput ? \"NaN\" : $element.val();\n\t\t\t}\n\n\t\t\tif ( isContentEditable ) {\n\t\t\t\tval = $element.text();\n\t\t\t} else {\n\t\t\t\tval = $element.val();\n\t\t\t}\n\n\t\t\tif ( type === \"file\" ) {\n\n\t\t\t\t// Modern browser (chrome & safari)\n\t\t\t\tif ( val.substr( 0, 12 ) === \"C:\\\\fakepath\\\\\" ) {\n\t\t\t\t\treturn val.substr( 12 );\n\t\t\t\t}\n\n\t\t\t\t// Legacy browsers\n\t\t\t\t// Unix-based path\n\t\t\t\tidx = val.lastIndexOf( \"/\" );\n\t\t\t\tif ( idx >= 0 ) {\n\t\t\t\t\treturn val.substr( idx + 1 );\n\t\t\t\t}\n\n\t\t\t\t// Windows-based path\n\t\t\t\tidx = val.lastIndexOf( \"\\\\\" );\n\t\t\t\tif ( idx >= 0 ) {\n\t\t\t\t\treturn val.substr( idx + 1 );\n\t\t\t\t}\n\n\t\t\t\t// Just the file name\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\tif ( typeof val === \"string\" ) {\n\t\t\t\treturn val.replace( /\\r/g, \"\" );\n\t\t\t}\n\t\t\treturn val;\n\t\t},\n\n\t\tcheck: function( element ) {\n\t\t\telement = this.validationTargetFor( this.clean( element ) );\n\n\t\t\tvar rules = $( element ).rules(),\n\t\t\t\trulesCount = $.map( rules, function( n, i ) {\n\t\t\t\t\treturn i;\n\t\t\t\t} ).length,\n\t\t\t\tdependencyMismatch = false,\n\t\t\t\tval = this.elementValue( element ),\n\t\t\t\tresult, method, rule, normalizer;\n\n\t\t\t// Prioritize the local normalizer defined for this element over the global one\n\t\t\t// if the former exists, otherwise user the global one in case it exists.\n\t\t\tif ( typeof rules.normalizer === \"function\" ) {\n\t\t\t\tnormalizer = rules.normalizer;\n\t\t\t} else if (\ttypeof this.settings.normalizer === \"function\" ) {\n\t\t\t\tnormalizer = this.settings.normalizer;\n\t\t\t}\n\n\t\t\t// If normalizer is defined, then call it to retreive the changed value instead\n\t\t\t// of using the real one.\n\t\t\t// Note that `this` in the normalizer is `element`.\n\t\t\tif ( normalizer ) {\n\t\t\t\tval = normalizer.call( element, val );\n\n\t\t\t\t// Delete the normalizer from rules to avoid treating it as a pre-defined method.\n\t\t\t\tdelete rules.normalizer;\n\t\t\t}\n\n\t\t\tfor ( method in rules ) {\n\t\t\t\trule = { method: method, parameters: rules[ method ] };\n\t\t\t\ttry {\n\t\t\t\t\tresult = $.validator.methods[ method ].call( this, val, element, rule.parameters );\n\n\t\t\t\t\t// If a method indicates that the field is optional and therefore valid,\n\t\t\t\t\t// don't mark it as valid when there are no other rules\n\t\t\t\t\tif ( result === \"dependency-mismatch\" && rulesCount === 1 ) {\n\t\t\t\t\t\tdependencyMismatch = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdependencyMismatch = false;\n\n\t\t\t\t\tif ( result === \"pending\" ) {\n\t\t\t\t\t\tthis.toHide = this.toHide.not( this.errorsFor( element ) );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !result ) {\n\t\t\t\t\t\tthis.formatAndAdd( element, rule );\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tif ( this.settings.debug && window.console ) {\n\t\t\t\t\t\tconsole.log( \"Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\", e );\n\t\t\t\t\t}\n\t\t\t\t\tif ( e instanceof TypeError ) {\n\t\t\t\t\t\te.message += \".  Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\";\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( dependencyMismatch ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( this.objectLength( rules ) ) {\n\t\t\t\tthis.successList.push( element );\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t// Return the custom message for the given element and validation method\n\t\t// specified in the element's HTML5 data attribute\n\t\t// return the generic message if present and no method specific message is present\n\t\tcustomDataMessage: function( element, method ) {\n\t\t\treturn $( element ).data( \"msg\" + method.charAt( 0 ).toUpperCase() +\n\t\t\t\tmethod.substring( 1 ).toLowerCase() ) || $( element ).data( \"msg\" );\n\t\t},\n\n\t\t// Return the custom message for the given element name and validation method\n\t\tcustomMessage: function( name, method ) {\n\t\t\tvar m = this.settings.messages[ name ];\n\t\t\treturn m && ( m.constructor === String ? m : m[ method ] );\n\t\t},\n\n\t\t// Return the first defined argument, allowing empty strings\n\t\tfindDefined: function() {\n\t\t\tfor ( var i = 0; i < arguments.length; i++ ) {\n\t\t\t\tif ( arguments[ i ] !== undefined ) {\n\t\t\t\t\treturn arguments[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\n\t\t// The second parameter 'rule' used to be a string, and extended to an object literal\n\t\t// of the following form:\n\t\t// rule = {\n\t\t//     method: \"method name\",\n\t\t//     parameters: \"the given method parameters\"\n\t\t// }\n\t\t//\n\t\t// The old behavior still supported, kept to maintain backward compatibility with\n\t\t// old code, and will be removed in the next major release.\n\t\tdefaultMessage: function( element, rule ) {\n\t\t\tif ( typeof rule === \"string\" ) {\n\t\t\t\trule = { method: rule };\n\t\t\t}\n\n\t\t\tvar message = this.findDefined(\n\t\t\t\t\tthis.customMessage( element.name, rule.method ),\n\t\t\t\t\tthis.customDataMessage( element, rule.method ),\n\n\t\t\t\t\t// 'title' is never undefined, so handle empty string as undefined\n\t\t\t\t\t!this.settings.ignoreTitle && element.title || undefined,\n\t\t\t\t\t$.validator.messages[ rule.method ],\n\t\t\t\t\t\"<strong>Warning: No message defined for \" + element.name + \"</strong>\"\n\t\t\t\t),\n\t\t\t\ttheregex = /\\$?\\{(\\d+)\\}/g;\n\t\t\tif ( typeof message === \"function\" ) {\n\t\t\t\tmessage = message.call( this, rule.parameters, element );\n\t\t\t} else if ( theregex.test( message ) ) {\n\t\t\t\tmessage = $.validator.format( message.replace( theregex, \"{$1}\" ), rule.parameters );\n\t\t\t}\n\n\t\t\treturn message;\n\t\t},\n\n\t\tformatAndAdd: function( element, rule ) {\n\t\t\tvar message = this.defaultMessage( element, rule );\n\n\t\t\tthis.errorList.push( {\n\t\t\t\tmessage: message,\n\t\t\t\telement: element,\n\t\t\t\tmethod: rule.method\n\t\t\t} );\n\n\t\t\tthis.errorMap[ element.name ] = message;\n\t\t\tthis.submitted[ element.name ] = message;\n\t\t},\n\n\t\taddWrapper: function( toToggle ) {\n\t\t\tif ( this.settings.wrapper ) {\n\t\t\t\ttoToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );\n\t\t\t}\n\t\t\treturn toToggle;\n\t\t},\n\n\t\tdefaultShowErrors: function() {\n\t\t\tvar i, elements, error;\n\t\t\tfor ( i = 0; this.errorList[ i ]; i++ ) {\n\t\t\t\terror = this.errorList[ i ];\n\t\t\t\tif ( this.settings.highlight ) {\n\t\t\t\t\tthis.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );\n\t\t\t\t}\n\t\t\t\tthis.showLabel( error.element, error.message );\n\t\t\t}\n\t\t\tif ( this.errorList.length ) {\n\t\t\t\tthis.toShow = this.toShow.add( this.containers );\n\t\t\t}\n\t\t\tif ( this.settings.success ) {\n\t\t\t\tfor ( i = 0; this.successList[ i ]; i++ ) {\n\t\t\t\t\tthis.showLabel( this.successList[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( this.settings.unhighlight ) {\n\t\t\t\tfor ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {\n\t\t\t\t\tthis.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.toHide = this.toHide.not( this.toShow );\n\t\t\tthis.hideErrors();\n\t\t\tthis.addWrapper( this.toShow ).show();\n\t\t},\n\n\t\tvalidElements: function() {\n\t\t\treturn this.currentElements.not( this.invalidElements() );\n\t\t},\n\n\t\tinvalidElements: function() {\n\t\t\treturn $( this.errorList ).map( function() {\n\t\t\t\treturn this.element;\n\t\t\t} );\n\t\t},\n\n\t\tshowLabel: function( element, message ) {\n\t\t\tvar place, group, errorID, v,\n\t\t\t\terror = this.errorsFor( element ),\n\t\t\t\telementID = this.idOrName( element ),\n\t\t\t\tdescribedBy = $( element ).attr( \"aria-describedby\" );\n\n\t\t\tif ( error.length ) {\n\n\t\t\t\t// Refresh error/success class\n\t\t\t\terror.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );\n\n\t\t\t\t// Replace message on existing label\n\t\t\t\terror.html( message );\n\t\t\t} else {\n\n\t\t\t\t// Create error element\n\t\t\t\terror = $( \"<\" + this.settings.errorElement + \">\" )\n\t\t\t\t\t.attr( \"id\", elementID + \"-error\" )\n\t\t\t\t\t.addClass( this.settings.errorClass )\n\t\t\t\t\t.html( message || \"\" );\n\n\t\t\t\t// Maintain reference to the element to be placed into the DOM\n\t\t\t\tplace = error;\n\t\t\t\tif ( this.settings.wrapper ) {\n\n\t\t\t\t\t// Make sure the element is visible, even in IE\n\t\t\t\t\t// actually showing the wrapped element is handled elsewhere\n\t\t\t\t\tplace = error.hide().show().wrap( \"<\" + this.settings.wrapper + \"/>\" ).parent();\n\t\t\t\t}\n\t\t\t\tif ( this.labelContainer.length ) {\n\t\t\t\t\tthis.labelContainer.append( place );\n\t\t\t\t} else if ( this.settings.errorPlacement ) {\n\t\t\t\t\tthis.settings.errorPlacement.call( this, place, $( element ) );\n\t\t\t\t} else {\n\t\t\t\t\tplace.insertAfter( element );\n\t\t\t\t}\n\n\t\t\t\t// Link error back to the element\n\t\t\t\tif ( error.is( \"label\" ) ) {\n\n\t\t\t\t\t// If the error is a label, then associate using 'for'\n\t\t\t\t\terror.attr( \"for\", elementID );\n\n\t\t\t\t\t// If the element is not a child of an associated label, then it's necessary\n\t\t\t\t\t// to explicitly apply aria-describedby\n\t\t\t\t} else if ( error.parents( \"label[for='\" + this.escapeCssMeta( elementID ) + \"']\" ).length === 0 ) {\n\t\t\t\t\terrorID = error.attr( \"id\" );\n\n\t\t\t\t\t// Respect existing non-error aria-describedby\n\t\t\t\t\tif ( !describedBy ) {\n\t\t\t\t\t\tdescribedBy = errorID;\n\t\t\t\t\t} else if ( !describedBy.match( new RegExp( \"\\\\b\" + this.escapeCssMeta( errorID ) + \"\\\\b\" ) ) ) {\n\n\t\t\t\t\t\t// Add to end of list if not already present\n\t\t\t\t\t\tdescribedBy += \" \" + errorID;\n\t\t\t\t\t}\n\t\t\t\t\t$( element ).attr( \"aria-describedby\", describedBy );\n\n\t\t\t\t\t// If this element is grouped, then assign to all elements in the same group\n\t\t\t\t\tgroup = this.groups[ element.name ];\n\t\t\t\t\tif ( group ) {\n\t\t\t\t\t\tv = this;\n\t\t\t\t\t\t$.each( v.groups, function( name, testgroup ) {\n\t\t\t\t\t\t\tif ( testgroup === group ) {\n\t\t\t\t\t\t\t\t$( \"[name='\" + v.escapeCssMeta( name ) + \"']\", v.currentForm )\n\t\t\t\t\t\t\t\t\t.attr( \"aria-describedby\", error.attr( \"id\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !message && this.settings.success ) {\n\t\t\t\terror.text( \"\" );\n\t\t\t\tif ( typeof this.settings.success === \"string\" ) {\n\t\t\t\t\terror.addClass( this.settings.success );\n\t\t\t\t} else {\n\t\t\t\t\tthis.settings.success( error, element );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.toShow = this.toShow.add( error );\n\t\t},\n\n\t\terrorsFor: function( element ) {\n\t\t\tvar name = this.escapeCssMeta( this.idOrName( element ) ),\n\t\t\t\tdescriber = $( element ).attr( \"aria-describedby\" ),\n\t\t\t\tselector = \"label[for='\" + name + \"'], label[for='\" + name + \"'] *\";\n\n\t\t\t// 'aria-describedby' should directly reference the error element\n\t\t\tif ( describer ) {\n\t\t\t\tselector = selector + \", #\" + this.escapeCssMeta( describer )\n\t\t\t\t\t.replace( /\\s+/g, \", #\" );\n\t\t\t}\n\n\t\t\treturn this\n\t\t\t\t.errors()\n\t\t\t\t.filter( selector );\n\t\t},\n\n\t\t// See https://api.jquery.com/category/selectors/, for CSS\n\t\t// meta-characters that should be escaped in order to be used with JQuery\n\t\t// as a literal part of a name/id or any selector.\n\t\tescapeCssMeta: function( string ) {\n\t\t\treturn string.replace( /([\\\\!\"#$%&'()*+,./:;<=>?@\\[\\]^`{|}~])/g, \"\\\\$1\" );\n\t\t},\n\n\t\tidOrName: function( element ) {\n\t\t\treturn this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );\n\t\t},\n\n\t\tvalidationTargetFor: function( element ) {\n\n\t\t\t// If radio/checkbox, validate first element in group instead\n\t\t\tif ( this.checkable( element ) ) {\n\t\t\t\telement = this.findByName( element.name );\n\t\t\t}\n\n\t\t\t// Always apply ignore filter\n\t\t\treturn $( element ).not( this.settings.ignore )[ 0 ];\n\t\t},\n\n\t\tcheckable: function( element ) {\n\t\t\treturn ( /radio|checkbox/i ).test( element.type );\n\t\t},\n\n\t\tfindByName: function( name ) {\n\t\t\treturn $( this.currentForm ).find( \"[name='\" + this.escapeCssMeta( name ) + \"']\" );\n\t\t},\n\n\t\tgetLength: function( value, element ) {\n\t\t\tswitch ( element.nodeName.toLowerCase() ) {\n\t\t\tcase \"select\":\n\t\t\t\treturn $( \"option:selected\", element ).length;\n\t\t\tcase \"input\":\n\t\t\t\tif ( this.checkable( element ) ) {\n\t\t\t\t\treturn this.findByName( element.name ).filter( \":checked\" ).length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value.length;\n\t\t},\n\n\t\tdepend: function( param, element ) {\n\t\t\treturn this.dependTypes[ typeof param ] ? this.dependTypes[ typeof param ]( param, element ) : true;\n\t\t},\n\n\t\tdependTypes: {\n\t\t\t\"boolean\": function( param ) {\n\t\t\t\treturn param;\n\t\t\t},\n\t\t\t\"string\": function( param, element ) {\n\t\t\t\treturn !!$( param, element.form ).length;\n\t\t\t},\n\t\t\t\"function\": function( param, element ) {\n\t\t\t\treturn param( element );\n\t\t\t}\n\t\t},\n\n\t\toptional: function( element ) {\n\t\t\tvar val = this.elementValue( element );\n\t\t\treturn !$.validator.methods.required.call( this, val, element ) && \"dependency-mismatch\";\n\t\t},\n\n\t\tstartRequest: function( element ) {\n\t\t\tif ( !this.pending[ element.name ] ) {\n\t\t\t\tthis.pendingRequest++;\n\t\t\t\t$( element ).addClass( this.settings.pendingClass );\n\t\t\t\tthis.pending[ element.name ] = true;\n\t\t\t}\n\t\t},\n\n\t\tstopRequest: function( element, valid ) {\n\t\t\tthis.pendingRequest--;\n\n\t\t\t// Sometimes synchronization fails, make sure pendingRequest is never < 0\n\t\t\tif ( this.pendingRequest < 0 ) {\n\t\t\t\tthis.pendingRequest = 0;\n\t\t\t}\n\t\t\tdelete this.pending[ element.name ];\n\t\t\t$( element ).removeClass( this.settings.pendingClass );\n\t\t\tif ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {\n\t\t\t\t$( this.currentForm ).submit();\n\n\t\t\t\t// Remove the hidden input that was used as a replacement for the\n\t\t\t\t// missing submit button. The hidden input is added by `handle()`\n\t\t\t\t// to ensure that the value of the used submit button is passed on\n\t\t\t\t// for scripted submits triggered by this method\n\t\t\t\tif ( this.submitButton ) {\n\t\t\t\t\t$( \"input:hidden[name='\" + this.submitButton.name + \"']\", this.currentForm ).remove();\n\t\t\t\t}\n\n\t\t\t\tthis.formSubmitted = false;\n\t\t\t} else if ( !valid && this.pendingRequest === 0 && this.formSubmitted ) {\n\t\t\t\t$( this.currentForm ).triggerHandler( \"invalid-form\", [ this ] );\n\t\t\t\tthis.formSubmitted = false;\n\t\t\t}\n\t\t},\n\n\t\tpreviousValue: function( element, method ) {\n\t\t\tmethod = typeof method === \"string\" && method || \"remote\";\n\n\t\t\treturn $.data( element, \"previousValue\" ) || $.data( element, \"previousValue\", {\n\t\t\t\told: null,\n\t\t\t\tvalid: true,\n\t\t\t\tmessage: this.defaultMessage( element, { method: method } )\n\t\t\t} );\n\t\t},\n\n\t\t// Cleans up all forms and elements, removes validator-specific events\n\t\tdestroy: function() {\n\t\t\tthis.resetForm();\n\n\t\t\t$( this.currentForm )\n\t\t\t\t.off( \".validate\" )\n\t\t\t\t.removeData( \"validator\" )\n\t\t\t\t.find( \".validate-equalTo-blur\" )\n\t\t\t\t\t.off( \".validate-equalTo\" )\n\t\t\t\t\t.removeClass( \"validate-equalTo-blur\" )\n\t\t\t\t.find( \".validate-lessThan-blur\" )\n\t\t\t\t\t.off( \".validate-lessThan\" )\n\t\t\t\t\t.removeClass( \"validate-lessThan-blur\" )\n\t\t\t\t.find( \".validate-lessThanEqual-blur\" )\n\t\t\t\t\t.off( \".validate-lessThanEqual\" )\n\t\t\t\t\t.removeClass( \"validate-lessThanEqual-blur\" )\n\t\t\t\t.find( \".validate-greaterThanEqual-blur\" )\n\t\t\t\t\t.off( \".validate-greaterThanEqual\" )\n\t\t\t\t\t.removeClass( \"validate-greaterThanEqual-blur\" )\n\t\t\t\t.find( \".validate-greaterThan-blur\" )\n\t\t\t\t\t.off( \".validate-greaterThan\" )\n\t\t\t\t\t.removeClass( \"validate-greaterThan-blur\" );\n\t\t}\n\n\t},\n\n\tclassRuleSettings: {\n\t\trequired: { required: true },\n\t\temail: { email: true },\n\t\turl: { url: true },\n\t\tdate: { date: true },\n\t\tdateISO: { dateISO: true },\n\t\tnumber: { number: true },\n\t\tdigits: { digits: true },\n\t\tcreditcard: { creditcard: true }\n\t},\n\n\taddClassRules: function( className, rules ) {\n\t\tif ( className.constructor === String ) {\n\t\t\tthis.classRuleSettings[ className ] = rules;\n\t\t} else {\n\t\t\t$.extend( this.classRuleSettings, className );\n\t\t}\n\t},\n\n\tclassRules: function( element ) {\n\t\tvar rules = {},\n\t\t\tclasses = $( element ).attr( \"class\" );\n\n\t\tif ( classes ) {\n\t\t\t$.each( classes.split( \" \" ), function() {\n\t\t\t\tif ( this in $.validator.classRuleSettings ) {\n\t\t\t\t\t$.extend( rules, $.validator.classRuleSettings[ this ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\treturn rules;\n\t},\n\n\tnormalizeAttributeRule: function( rules, type, method, value ) {\n\n\t\t// Convert the value to a number for number inputs, and for text for backwards compability\n\t\t// allows type=\"date\" and others to be compared as strings\n\t\tif ( /min|max|step/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {\n\t\t\tvalue = Number( value );\n\n\t\t\t// Support Opera Mini, which returns NaN for undefined minlength\n\t\t\tif ( isNaN( value ) ) {\n\t\t\t\tvalue = undefined;\n\t\t\t}\n\t\t}\n\n\t\tif ( value || value === 0 ) {\n\t\t\trules[ method ] = value;\n\t\t} else if ( type === method && type !== \"range\" ) {\n\n\t\t\t// Exception: the jquery validate 'range' method\n\t\t\t// does not test for the html5 'range' type\n\t\t\trules[ method ] = true;\n\t\t}\n\t},\n\n\tattributeRules: function( element ) {\n\t\tvar rules = {},\n\t\t\t$element = $( element ),\n\t\t\ttype = element.getAttribute( \"type\" ),\n\t\t\tmethod, value;\n\n\t\tfor ( method in $.validator.methods ) {\n\n\t\t\t// Support for <input required> in both html5 and older browsers\n\t\t\tif ( method === \"required\" ) {\n\t\t\t\tvalue = element.getAttribute( method );\n\n\t\t\t\t// Some browsers return an empty string for the required attribute\n\t\t\t\t// and non-HTML5 browsers might have required=\"\" markup\n\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\tvalue = true;\n\t\t\t\t}\n\n\t\t\t\t// Force non-HTML5 browsers to return bool\n\t\t\t\tvalue = !!value;\n\t\t\t} else {\n\t\t\t\tvalue = $element.attr( method );\n\t\t\t}\n\n\t\t\tthis.normalizeAttributeRule( rules, type, method, value );\n\t\t}\n\n\t\t// 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs\n\t\tif ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {\n\t\t\tdelete rules.maxlength;\n\t\t}\n\n\t\treturn rules;\n\t},\n\n\tdataRules: function( element ) {\n\t\tvar rules = {},\n\t\t\t$element = $( element ),\n\t\t\ttype = element.getAttribute( \"type\" ),\n\t\t\tmethod, value;\n\n\t\tfor ( method in $.validator.methods ) {\n\t\t\tvalue = $element.data( \"rule\" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );\n\n\t\t\t// Cast empty attributes like `data-rule-required` to `true`\n\t\t\tif ( value === \"\" ) {\n\t\t\t\tvalue = true;\n\t\t\t}\n\n\t\t\tthis.normalizeAttributeRule( rules, type, method, value );\n\t\t}\n\t\treturn rules;\n\t},\n\n\tstaticRules: function( element ) {\n\t\tvar rules = {},\n\t\t\tvalidator = $.data( element.form, \"validator\" );\n\n\t\tif ( validator.settings.rules ) {\n\t\t\trules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};\n\t\t}\n\t\treturn rules;\n\t},\n\n\tnormalizeRules: function( rules, element ) {\n\n\t\t// Handle dependency check\n\t\t$.each( rules, function( prop, val ) {\n\n\t\t\t// Ignore rule when param is explicitly false, eg. required:false\n\t\t\tif ( val === false ) {\n\t\t\t\tdelete rules[ prop ];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( val.param || val.depends ) {\n\t\t\t\tvar keepRule = true;\n\t\t\t\tswitch ( typeof val.depends ) {\n\t\t\t\tcase \"string\":\n\t\t\t\t\tkeepRule = !!$( val.depends, element.form ).length;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tkeepRule = val.depends.call( element, element );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( keepRule ) {\n\t\t\t\t\trules[ prop ] = val.param !== undefined ? val.param : true;\n\t\t\t\t} else {\n\t\t\t\t\t$.data( element.form, \"validator\" ).resetElements( $( element ) );\n\t\t\t\t\tdelete rules[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// Evaluate parameters\n\t\t$.each( rules, function( rule, parameter ) {\n\t\t\trules[ rule ] = typeof parameter === \"function\" && rule !== \"normalizer\" ? parameter( element ) : parameter;\n\t\t} );\n\n\t\t// Clean number parameters\n\t\t$.each( [ \"minlength\", \"maxlength\" ], function() {\n\t\t\tif ( rules[ this ] ) {\n\t\t\t\trules[ this ] = Number( rules[ this ] );\n\t\t\t}\n\t\t} );\n\t\t$.each( [ \"rangelength\", \"range\" ], function() {\n\t\t\tvar parts;\n\t\t\tif ( rules[ this ] ) {\n\t\t\t\tif ( Array.isArray( rules[ this ] ) ) {\n\t\t\t\t\trules[ this ] = [ Number( rules[ this ][ 0 ] ), Number( rules[ this ][ 1 ] ) ];\n\t\t\t\t} else if ( typeof rules[ this ] === \"string\" ) {\n\t\t\t\t\tparts = rules[ this ].replace( /[\\[\\]]/g, \"\" ).split( /[\\s,]+/ );\n\t\t\t\t\trules[ this ] = [ Number( parts[ 0 ] ), Number( parts[ 1 ] ) ];\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\tif ( $.validator.autoCreateRanges ) {\n\n\t\t\t// Auto-create ranges\n\t\t\tif ( rules.min != null && rules.max != null ) {\n\t\t\t\trules.range = [ rules.min, rules.max ];\n\t\t\t\tdelete rules.min;\n\t\t\t\tdelete rules.max;\n\t\t\t}\n\t\t\tif ( rules.minlength != null && rules.maxlength != null ) {\n\t\t\t\trules.rangelength = [ rules.minlength, rules.maxlength ];\n\t\t\t\tdelete rules.minlength;\n\t\t\t\tdelete rules.maxlength;\n\t\t\t}\n\t\t}\n\n\t\treturn rules;\n\t},\n\n\t// Converts a simple string to a {string: true} rule, e.g., \"required\" to {required:true}\n\tnormalizeRule: function( data ) {\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tvar transformed = {};\n\t\t\t$.each( data.split( /\\s/ ), function() {\n\t\t\t\ttransformed[ this ] = true;\n\t\t\t} );\n\t\t\tdata = transformed;\n\t\t}\n\t\treturn data;\n\t},\n\n\t// https://jqueryvalidation.org/jQuery.validator.addMethod/\n\taddMethod: function( name, method, message ) {\n\t\t$.validator.methods[ name ] = method;\n\t\t$.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];\n\t\tif ( method.length < 3 ) {\n\t\t\t$.validator.addClassRules( name, $.validator.normalizeRule( name ) );\n\t\t}\n\t},\n\n\t// https://jqueryvalidation.org/jQuery.validator.methods/\n\tmethods: {\n\n\t\t// https://jqueryvalidation.org/required-method/\n\t\trequired: function( value, element, param ) {\n\n\t\t\t// Check if dependency is met\n\t\t\tif ( !this.depend( param, element ) ) {\n\t\t\t\treturn \"dependency-mismatch\";\n\t\t\t}\n\t\t\tif ( element.nodeName.toLowerCase() === \"select\" ) {\n\n\t\t\t\t// Could be an array for select-multiple or a string, both are fine this way\n\t\t\t\tvar val = $( element ).val();\n\t\t\t\treturn val && val.length > 0;\n\t\t\t}\n\t\t\tif ( this.checkable( element ) ) {\n\t\t\t\treturn this.getLength( value, element ) > 0;\n\t\t\t}\n\t\t\treturn value !== undefined && value !== null && value.length > 0;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/email-method/\n\t\temail: function( value, element ) {\n\n\t\t\t// From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\n\t\t\t// Retrieved 2014-01-14\n\t\t\t// If you have a problem with this implementation, report a bug against the above spec\n\t\t\t// Or use custom methods to implement your own email validation\n\t\t\treturn this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/url-method/\n\t\turl: function( value, element ) {\n\n\t\t\t// Copyright (c) 2010-2013 Diego Perini, MIT licensed\n\t\t\t// https://gist.github.com/dperini/729294\n\t\t\t// see also https://mathiasbynens.be/demo/url-regex\n\t\t\t// modified to allow protocol-relative URLs\n\t\t\treturn this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/date-method/\n\t\tdate: ( function() {\n\t\t\tvar called = false;\n\n\t\t\treturn function( value, element ) {\n\t\t\t\tif ( !called ) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tif ( this.settings.debug && window.console ) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"The `date` method is deprecated and will be removed in version '2.0.0'.\\n\" +\n\t\t\t\t\t\t\t\"Please don't use it, since it relies on the Date constructor, which\\n\" +\n\t\t\t\t\t\t\t\"behaves very differently across browsers and locales. Use `dateISO`\\n\" +\n\t\t\t\t\t\t\t\"instead or one of the locale specific methods in `localizations/`\\n\" +\n\t\t\t\t\t\t\t\"and `additional-methods.js`.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );\n\t\t\t};\n\t\t}() ),\n\n\t\t// https://jqueryvalidation.org/dateISO-method/\n\t\tdateISO: function( value, element ) {\n\t\t\treturn this.optional( element ) || /^\\d{4}[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/number-method/\n\t\tnumber: function( value, element ) {\n\t\t\treturn this.optional( element ) || /^(?:-?\\d+|-?\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/digits-method/\n\t\tdigits: function( value, element ) {\n\t\t\treturn this.optional( element ) || /^\\d+$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/minlength-method/\n\t\tminlength: function( value, element, param ) {\n\t\t\tvar length = Array.isArray( value ) ? value.length : this.getLength( value, element );\n\t\t\treturn this.optional( element ) || length >= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/maxlength-method/\n\t\tmaxlength: function( value, element, param ) {\n\t\t\tvar length = Array.isArray( value ) ? value.length : this.getLength( value, element );\n\t\t\treturn this.optional( element ) || length <= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/rangelength-method/\n\t\trangelength: function( value, element, param ) {\n\t\t\tvar length = Array.isArray( value ) ? value.length : this.getLength( value, element );\n\t\t\treturn this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/min-method/\n\t\tmin: function( value, element, param ) {\n\t\t\treturn this.optional( element ) || value >= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/max-method/\n\t\tmax: function( value, element, param ) {\n\t\t\treturn this.optional( element ) || value <= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/range-method/\n\t\trange: function( value, element, param ) {\n\t\t\treturn this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/step-method/\n\t\tstep: function( value, element, param ) {\n\t\t\tvar type = $( element ).attr( \"type\" ),\n\t\t\t\terrorMessage = \"Step attribute on input type \" + type + \" is not supported.\",\n\t\t\t\tsupportedTypes = [ \"text\", \"number\", \"range\" ],\n\t\t\t\tre = new RegExp( \"\\\\b\" + type + \"\\\\b\" ),\n\t\t\t\tnotSupported = type && !re.test( supportedTypes.join() ),\n\t\t\t\tdecimalPlaces = function( num ) {\n\t\t\t\t\tvar match = ( \"\" + num ).match( /(?:\\.(\\d+))?$/ );\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Number of digits right of decimal point.\n\t\t\t\t\treturn match[ 1 ] ? match[ 1 ].length : 0;\n\t\t\t\t},\n\t\t\t\ttoInt = function( num ) {\n\t\t\t\t\treturn Math.round( num * Math.pow( 10, decimals ) );\n\t\t\t\t},\n\t\t\t\tvalid = true,\n\t\t\t\tdecimals;\n\n\t\t\t// Works only for text, number and range input types\n\t\t\t// TODO find a way to support input types date, datetime, datetime-local, month, time and week\n\t\t\tif ( notSupported ) {\n\t\t\t\tthrow new Error( errorMessage );\n\t\t\t}\n\n\t\t\tdecimals = decimalPlaces( param );\n\n\t\t\t// Value can't have too many decimals\n\t\t\tif ( decimalPlaces( value ) > decimals || toInt( value ) % toInt( param ) !== 0 ) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\n\t\t\treturn this.optional( element ) || valid;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/equalTo-method/\n\t\tequalTo: function( value, element, param ) {\n\n\t\t\t// Bind to the blur event of the target in order to revalidate whenever the target field is updated\n\t\t\tvar target = $( param );\n\t\t\tif ( this.settings.onfocusout && target.not( \".validate-equalTo-blur\" ).length ) {\n\t\t\t\ttarget.addClass( \"validate-equalTo-blur\" ).on( \"blur.validate-equalTo\", function() {\n\t\t\t\t\t$( element ).valid();\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn value === target.val();\n\t\t},\n\n\t\t// https://jqueryvalidation.org/remote-method/\n\t\tremote: function( value, element, param, method ) {\n\t\t\tif ( this.optional( element ) ) {\n\t\t\t\treturn \"dependency-mismatch\";\n\t\t\t}\n\n\t\t\tmethod = typeof method === \"string\" && method || \"remote\";\n\n\t\t\tvar previous = this.previousValue( element, method ),\n\t\t\t\tvalidator, data, optionDataString;\n\n\t\t\tif ( !this.settings.messages[ element.name ] ) {\n\t\t\t\tthis.settings.messages[ element.name ] = {};\n\t\t\t}\n\t\t\tprevious.originalMessage = previous.originalMessage || this.settings.messages[ element.name ][ method ];\n\t\t\tthis.settings.messages[ element.name ][ method ] = previous.message;\n\n\t\t\tparam = typeof param === \"string\" && { url: param } || param;\n\t\t\toptionDataString = $.param( $.extend( { data: value }, param.data ) );\n\t\t\tif ( previous.old === optionDataString ) {\n\t\t\t\treturn previous.valid;\n\t\t\t}\n\n\t\t\tprevious.old = optionDataString;\n\t\t\tvalidator = this;\n\t\t\tthis.startRequest( element );\n\t\t\tdata = {};\n\t\t\tdata[ element.name ] = value;\n\t\t\t$.ajax( $.extend( true, {\n\t\t\t\tmode: \"abort\",\n\t\t\t\tport: \"validate\" + element.name,\n\t\t\t\tdataType: \"json\",\n\t\t\t\tdata: data,\n\t\t\t\tcontext: validator.currentForm,\n\t\t\t\tsuccess: function( response ) {\n\t\t\t\t\tvar valid = response === true || response === \"true\",\n\t\t\t\t\t\terrors, message, submitted;\n\n\t\t\t\t\tvalidator.settings.messages[ element.name ][ method ] = previous.originalMessage;\n\t\t\t\t\tif ( valid ) {\n\t\t\t\t\t\tsubmitted = validator.formSubmitted;\n\t\t\t\t\t\tvalidator.resetInternals();\n\t\t\t\t\t\tvalidator.toHide = validator.errorsFor( element );\n\t\t\t\t\t\tvalidator.formSubmitted = submitted;\n\t\t\t\t\t\tvalidator.successList.push( element );\n\t\t\t\t\t\tvalidator.invalid[ element.name ] = false;\n\t\t\t\t\t\tvalidator.showErrors();\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors = {};\n\t\t\t\t\t\tmessage = response || validator.defaultMessage( element, { method: method, parameters: value } );\n\t\t\t\t\t\terrors[ element.name ] = previous.message = message;\n\t\t\t\t\t\tvalidator.invalid[ element.name ] = true;\n\t\t\t\t\t\tvalidator.showErrors( errors );\n\t\t\t\t\t}\n\t\t\t\t\tprevious.valid = valid;\n\t\t\t\t\tvalidator.stopRequest( element, valid );\n\t\t\t\t}\n\t\t\t}, param ) );\n\t\t\treturn \"pending\";\n\t\t}\n\t}\n\n} );\n\r\n// Ajax mode: abort\n// usage: $.ajax({ mode: \"abort\"[, port: \"uniqueport\"]});\n// if mode:\"abort\" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()\n\nvar pendingRequests = {},\n\tajax;\n\n// Use a prefilter if available (1.5+)\nif ( $.ajaxPrefilter ) {\n\t$.ajaxPrefilter( function( settings, _, xhr ) {\n\t\tvar port = settings.port;\n\t\tif ( settings.mode === \"abort\" ) {\n\t\t\tif ( pendingRequests[ port ] ) {\n\t\t\t\tpendingRequests[ port ].abort();\n\t\t\t}\n\t\t\tpendingRequests[ port ] = xhr;\n\t\t}\n\t} );\n} else {\n\n\t// Proxy ajax\n\tajax = $.ajax;\n\t$.ajax = function( settings ) {\n\t\tvar mode = ( \"mode\" in settings ? settings : $.ajaxSettings ).mode,\n\t\t\tport = ( \"port\" in settings ? settings : $.ajaxSettings ).port;\n\t\tif ( mode === \"abort\" ) {\n\t\t\tif ( pendingRequests[ port ] ) {\n\t\t\t\tpendingRequests[ port ].abort();\n\t\t\t}\n\t\t\tpendingRequests[ port ] = ajax.apply( this, arguments );\n\t\t\treturn pendingRequests[ port ];\n\t\t}\n\t\treturn ajax.apply( this, arguments );\n\t};\n}\nreturn $;\r\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXZhbGlkYXRpb24vZGlzdC9qcXVlcnkudmFsaWRhdGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUEwQztBQUNoRCxFQUFFLGlDQUFRLENBQUMseUVBQVEsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFFO0FBQy9CLEdBQUcsS0FBSyxFQUlOO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2VhcmVhdGhsb24vZnJvbnRlbmQtd2VicGFjay1ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9qcXVlcnktdmFsaWRhdGlvbi9kaXN0L2pxdWVyeS52YWxpZGF0ZS5qcz9hYzgyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBqUXVlcnkgVmFsaWRhdGlvbiBQbHVnaW4gdjEuMTkuM1xyXG4gKlxyXG4gKiBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgSsO2cm4gWmFlZmZlcmVyXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xyXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XHJcblx0XHRkZWZpbmUoIFtcImpxdWVyeVwiXSwgZmFjdG9yeSApO1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImpxdWVyeVwiICkgKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XHJcblx0fVxyXG59KGZ1bmN0aW9uKCAkICkge1xyXG5cclxuJC5leHRlbmQoICQuZm4sIHtcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3ZhbGlkYXRlL1xuXHR2YWxpZGF0ZTogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiBub3RoaW5nIGlzIHNlbGVjdGVkLCByZXR1cm4gbm90aGluZzsgY2FuJ3QgY2hhaW4gYW55d2F5XG5cdFx0aWYgKCAhdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSApIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCBcIk5vdGhpbmcgc2VsZWN0ZWQsIGNhbid0IHZhbGlkYXRlLCByZXR1cm5pbmcgbm90aGluZy5cIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIGEgdmFsaWRhdG9yIGZvciB0aGlzIGZvcm0gd2FzIGFscmVhZHkgY3JlYXRlZFxuXHRcdHZhciB2YWxpZGF0b3IgPSAkLmRhdGEoIHRoaXNbIDAgXSwgXCJ2YWxpZGF0b3JcIiApO1xuXHRcdGlmICggdmFsaWRhdG9yICkge1xuXHRcdFx0cmV0dXJuIHZhbGlkYXRvcjtcblx0XHR9XG5cblx0XHQvLyBBZGQgbm92YWxpZGF0ZSB0YWcgaWYgSFRNTDUuXG5cdFx0dGhpcy5hdHRyKCBcIm5vdmFsaWRhdGVcIiwgXCJub3ZhbGlkYXRlXCIgKTtcblxuXHRcdHZhbGlkYXRvciA9IG5ldyAkLnZhbGlkYXRvciggb3B0aW9ucywgdGhpc1sgMCBdICk7XG5cdFx0JC5kYXRhKCB0aGlzWyAwIF0sIFwidmFsaWRhdG9yXCIsIHZhbGlkYXRvciApO1xuXG5cdFx0aWYgKCB2YWxpZGF0b3Iuc2V0dGluZ3Mub25zdWJtaXQgKSB7XG5cblx0XHRcdHRoaXMub24oIFwiY2xpY2sudmFsaWRhdGVcIiwgXCI6c3VibWl0XCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBUcmFjayB0aGUgdXNlZCBzdWJtaXQgYnV0dG9uIHRvIHByb3Blcmx5IGhhbmRsZSBzY3JpcHRlZFxuXHRcdFx0XHQvLyBzdWJtaXRzIGxhdGVyLlxuXHRcdFx0XHR2YWxpZGF0b3Iuc3VibWl0QnV0dG9uID0gZXZlbnQuY3VycmVudFRhcmdldDtcblxuXHRcdFx0XHQvLyBBbGxvdyBzdXBwcmVzc2luZyB2YWxpZGF0aW9uIGJ5IGFkZGluZyBhIGNhbmNlbCBjbGFzcyB0byB0aGUgc3VibWl0IGJ1dHRvblxuXHRcdFx0XHRpZiAoICQoIHRoaXMgKS5oYXNDbGFzcyggXCJjYW5jZWxcIiApICkge1xuXHRcdFx0XHRcdHZhbGlkYXRvci5jYW5jZWxTdWJtaXQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWxsb3cgc3VwcHJlc3NpbmcgdmFsaWRhdGlvbiBieSBhZGRpbmcgdGhlIGh0bWw1IGZvcm1ub3ZhbGlkYXRlIGF0dHJpYnV0ZSB0byB0aGUgc3VibWl0IGJ1dHRvblxuXHRcdFx0XHRpZiAoICQoIHRoaXMgKS5hdHRyKCBcImZvcm1ub3ZhbGlkYXRlXCIgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHZhbGlkYXRvci5jYW5jZWxTdWJtaXQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIFZhbGlkYXRlIHRoZSBmb3JtIG9uIHN1Ym1pdFxuXHRcdFx0dGhpcy5vbiggXCJzdWJtaXQudmFsaWRhdGVcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHZhbGlkYXRvci5zZXR0aW5ncy5kZWJ1ZyApIHtcblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgZm9ybSBzdWJtaXQgdG8gYmUgYWJsZSB0byBzZWUgY29uc29sZSBvdXRwdXRcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gaGFuZGxlKCkge1xuXHRcdFx0XHRcdHZhciBoaWRkZW4sIHJlc3VsdDtcblxuXHRcdFx0XHRcdC8vIEluc2VydCBhIGhpZGRlbiBpbnB1dCBhcyBhIHJlcGxhY2VtZW50IGZvciB0aGUgbWlzc2luZyBzdWJtaXQgYnV0dG9uXG5cdFx0XHRcdFx0Ly8gVGhlIGhpZGRlbiBpbnB1dCBpcyBpbnNlcnRlZCBpbiB0d28gY2FzZXM6XG5cdFx0XHRcdFx0Ly8gICAtIEEgdXNlciBkZWZpbmVkIGEgYHN1Ym1pdEhhbmRsZXJgXG5cdFx0XHRcdFx0Ly8gICAtIFRoZXJlIHdhcyBhIHBlbmRpbmcgcmVxdWVzdCBkdWUgdG8gYHJlbW90ZWAgbWV0aG9kIGFuZCBgc3RvcFJlcXVlc3QoKWBcblx0XHRcdFx0XHQvLyAgICAgd2FzIGNhbGxlZCB0byBzdWJtaXQgdGhlIGZvcm0gaW4gY2FzZSBpdCdzIHZhbGlkXG5cdFx0XHRcdFx0aWYgKCB2YWxpZGF0b3Iuc3VibWl0QnV0dG9uICYmICggdmFsaWRhdG9yLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIgfHwgdmFsaWRhdG9yLmZvcm1TdWJtaXR0ZWQgKSApIHtcblx0XHRcdFx0XHRcdGhpZGRlbiA9ICQoIFwiPGlucHV0IHR5cGU9J2hpZGRlbicvPlwiIClcblx0XHRcdFx0XHRcdFx0LmF0dHIoIFwibmFtZVwiLCB2YWxpZGF0b3Iuc3VibWl0QnV0dG9uLm5hbWUgKVxuXHRcdFx0XHRcdFx0XHQudmFsKCAkKCB2YWxpZGF0b3Iuc3VibWl0QnV0dG9uICkudmFsKCkgKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHZhbGlkYXRvci5jdXJyZW50Rm9ybSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdmFsaWRhdG9yLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIgJiYgIXZhbGlkYXRvci5zZXR0aW5ncy5kZWJ1ZyApIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHZhbGlkYXRvci5zZXR0aW5ncy5zdWJtaXRIYW5kbGVyLmNhbGwoIHZhbGlkYXRvciwgdmFsaWRhdG9yLmN1cnJlbnRGb3JtLCBldmVudCApO1xuXHRcdFx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQW5kIGNsZWFuIHVwIGFmdGVyd2FyZHM7IHRoYW5rcyB0byBuby1ibG9jay1zY29wZSwgaGlkZGVuIGNhbiBiZSByZWZlcmVuY2VkXG5cdFx0XHRcdFx0XHRcdGhpZGRlbi5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggcmVzdWx0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJldmVudCBzdWJtaXQgZm9yIGludmFsaWQgZm9ybXMgb3IgY3VzdG9tIHN1Ym1pdCBoYW5kbGVyc1xuXHRcdFx0XHRpZiAoIHZhbGlkYXRvci5jYW5jZWxTdWJtaXQgKSB7XG5cdFx0XHRcdFx0dmFsaWRhdG9yLmNhbmNlbFN1Ym1pdCA9IGZhbHNlO1xuXHRcdFx0XHRcdHJldHVybiBoYW5kbGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHZhbGlkYXRvci5mb3JtKCkgKSB7XG5cdFx0XHRcdFx0aWYgKCB2YWxpZGF0b3IucGVuZGluZ1JlcXVlc3QgKSB7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IuZm9ybVN1Ym1pdHRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBoYW5kbGUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWxpZGF0b3IuZm9jdXNJbnZhbGlkKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbGlkYXRvcjtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3ZhbGlkL1xuXHR2YWxpZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbGlkLCB2YWxpZGF0b3IsIGVycm9yTGlzdDtcblxuXHRcdGlmICggJCggdGhpc1sgMCBdICkuaXMoIFwiZm9ybVwiICkgKSB7XG5cdFx0XHR2YWxpZCA9IHRoaXMudmFsaWRhdGUoKS5mb3JtKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVycm9yTGlzdCA9IFtdO1xuXHRcdFx0dmFsaWQgPSB0cnVlO1xuXHRcdFx0dmFsaWRhdG9yID0gJCggdGhpc1sgMCBdLmZvcm0gKS52YWxpZGF0ZSgpO1xuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFsaWQgPSB2YWxpZGF0b3IuZWxlbWVudCggdGhpcyApICYmIHZhbGlkO1xuXHRcdFx0XHRpZiAoICF2YWxpZCApIHtcblx0XHRcdFx0XHRlcnJvckxpc3QgPSBlcnJvckxpc3QuY29uY2F0KCB2YWxpZGF0b3IuZXJyb3JMaXN0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHZhbGlkYXRvci5lcnJvckxpc3QgPSBlcnJvckxpc3Q7XG5cdFx0fVxuXHRcdHJldHVybiB2YWxpZDtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3J1bGVzL1xuXHRydWxlczogZnVuY3Rpb24oIGNvbW1hbmQsIGFyZ3VtZW50ICkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpc1sgMCBdLFxuXHRcdFx0aXNDb250ZW50RWRpdGFibGUgPSB0eXBlb2YgdGhpcy5hdHRyKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5hdHRyKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgIT09IFwiZmFsc2VcIixcblx0XHRcdHNldHRpbmdzLCBzdGF0aWNSdWxlcywgZXhpc3RpbmdSdWxlcywgZGF0YSwgcGFyYW0sIGZpbHRlcmVkO1xuXG5cdFx0Ly8gSWYgbm90aGluZyBpcyBzZWxlY3RlZCwgcmV0dXJuIGVtcHR5IG9iamVjdDsgY2FuJ3QgY2hhaW4gYW55d2F5XG5cdFx0aWYgKCBlbGVtZW50ID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCAhZWxlbWVudC5mb3JtICYmIGlzQ29udGVudEVkaXRhYmxlICkge1xuXHRcdFx0ZWxlbWVudC5mb3JtID0gdGhpcy5jbG9zZXN0KCBcImZvcm1cIiApWyAwIF07XG5cdFx0XHRlbGVtZW50Lm5hbWUgPSB0aGlzLmF0dHIoIFwibmFtZVwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBlbGVtZW50LmZvcm0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGNvbW1hbmQgKSB7XG5cdFx0XHRzZXR0aW5ncyA9ICQuZGF0YSggZWxlbWVudC5mb3JtLCBcInZhbGlkYXRvclwiICkuc2V0dGluZ3M7XG5cdFx0XHRzdGF0aWNSdWxlcyA9IHNldHRpbmdzLnJ1bGVzO1xuXHRcdFx0ZXhpc3RpbmdSdWxlcyA9ICQudmFsaWRhdG9yLnN0YXRpY1J1bGVzKCBlbGVtZW50ICk7XG5cdFx0XHRzd2l0Y2ggKCBjb21tYW5kICkge1xuXHRcdFx0Y2FzZSBcImFkZFwiOlxuXHRcdFx0XHQkLmV4dGVuZCggZXhpc3RpbmdSdWxlcywgJC52YWxpZGF0b3Iubm9ybWFsaXplUnVsZSggYXJndW1lbnQgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBtZXNzYWdlcyBmcm9tIHJ1bGVzLCBidXQgYWxsb3cgdGhlbSB0byBiZSBzZXQgc2VwYXJhdGVseVxuXHRcdFx0XHRkZWxldGUgZXhpc3RpbmdSdWxlcy5tZXNzYWdlcztcblx0XHRcdFx0c3RhdGljUnVsZXNbIGVsZW1lbnQubmFtZSBdID0gZXhpc3RpbmdSdWxlcztcblx0XHRcdFx0aWYgKCBhcmd1bWVudC5tZXNzYWdlcyApIHtcblx0XHRcdFx0XHRzZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF0gPSAkLmV4dGVuZCggc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdLCBhcmd1bWVudC5tZXNzYWdlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInJlbW92ZVwiOlxuXHRcdFx0XHRpZiAoICFhcmd1bWVudCApIHtcblx0XHRcdFx0XHRkZWxldGUgc3RhdGljUnVsZXNbIGVsZW1lbnQubmFtZSBdO1xuXHRcdFx0XHRcdHJldHVybiBleGlzdGluZ1J1bGVzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpbHRlcmVkID0ge307XG5cdFx0XHRcdCQuZWFjaCggYXJndW1lbnQuc3BsaXQoIC9cXHMvICksIGZ1bmN0aW9uKCBpbmRleCwgbWV0aG9kICkge1xuXHRcdFx0XHRcdGZpbHRlcmVkWyBtZXRob2QgXSA9IGV4aXN0aW5nUnVsZXNbIG1ldGhvZCBdO1xuXHRcdFx0XHRcdGRlbGV0ZSBleGlzdGluZ1J1bGVzWyBtZXRob2QgXTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gZmlsdGVyZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGF0YSA9ICQudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGVzKFxuXHRcdCQuZXh0ZW5kKFxuXHRcdFx0e30sXG5cdFx0XHQkLnZhbGlkYXRvci5jbGFzc1J1bGVzKCBlbGVtZW50ICksXG5cdFx0XHQkLnZhbGlkYXRvci5hdHRyaWJ1dGVSdWxlcyggZWxlbWVudCApLFxuXHRcdFx0JC52YWxpZGF0b3IuZGF0YVJ1bGVzKCBlbGVtZW50ICksXG5cdFx0XHQkLnZhbGlkYXRvci5zdGF0aWNSdWxlcyggZWxlbWVudCApXG5cdFx0KSwgZWxlbWVudCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHJlcXVpcmVkIGlzIGF0IGZyb250XG5cdFx0aWYgKCBkYXRhLnJlcXVpcmVkICkge1xuXHRcdFx0cGFyYW0gPSBkYXRhLnJlcXVpcmVkO1xuXHRcdFx0ZGVsZXRlIGRhdGEucmVxdWlyZWQ7XG5cdFx0XHRkYXRhID0gJC5leHRlbmQoIHsgcmVxdWlyZWQ6IHBhcmFtIH0sIGRhdGEgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgcmVtb3RlIGlzIGF0IGJhY2tcblx0XHRpZiAoIGRhdGEucmVtb3RlICkge1xuXHRcdFx0cGFyYW0gPSBkYXRhLnJlbW90ZTtcblx0XHRcdGRlbGV0ZSBkYXRhLnJlbW90ZTtcblx0XHRcdGRhdGEgPSAkLmV4dGVuZCggZGF0YSwgeyByZW1vdGU6IHBhcmFtIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxufSApO1xuXG4vLyBKUXVlcnkgdHJpbSBpcyBkZXByZWNhdGVkLCBwcm92aWRlIGEgdHJpbSBtZXRob2QgYmFzZWQgb24gU3RyaW5nLnByb3RvdHlwZS50cmltXG52YXIgdHJpbSA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RyaW0jUG9seWZpbGxcblx0cmV0dXJuIHN0ci5yZXBsYWNlKCAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csIFwiXCIgKTtcbn07XG5cbi8vIEN1c3RvbSBzZWxlY3RvcnNcbiQuZXh0ZW5kKCAkLmV4cHIucHNldWRvcyB8fCAkLmV4cHJbIFwiOlwiIF0sIHtcdFx0Ly8gJ3x8ICQuZXhwclsgXCI6XCIgXScgaGVyZSBlbmFibGVzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIGpRdWVyeSAxLjcuIENhbiBiZSByZW1vdmVkIHdoZW4gZHJvcHBpbmcgalEgMS43Lnggc3VwcG9ydFxuXG5cdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvYmxhbmstc2VsZWN0b3IvXG5cdGJsYW5rOiBmdW5jdGlvbiggYSApIHtcblx0XHRyZXR1cm4gIXRyaW0oIFwiXCIgKyAkKCBhICkudmFsKCkgKTtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2ZpbGxlZC1zZWxlY3Rvci9cblx0ZmlsbGVkOiBmdW5jdGlvbiggYSApIHtcblx0XHR2YXIgdmFsID0gJCggYSApLnZhbCgpO1xuXHRcdHJldHVybiB2YWwgIT09IG51bGwgJiYgISF0cmltKCBcIlwiICsgdmFsICk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy91bmNoZWNrZWQtc2VsZWN0b3IvXG5cdHVuY2hlY2tlZDogZnVuY3Rpb24oIGEgKSB7XG5cdFx0cmV0dXJuICEkKCBhICkucHJvcCggXCJjaGVja2VkXCIgKTtcblx0fVxufSApO1xuXG4vLyBDb25zdHJ1Y3RvciBmb3IgdmFsaWRhdG9yXG4kLnZhbGlkYXRvciA9IGZ1bmN0aW9uKCBvcHRpb25zLCBmb3JtICkge1xuXHR0aGlzLnNldHRpbmdzID0gJC5leHRlbmQoIHRydWUsIHt9LCAkLnZhbGlkYXRvci5kZWZhdWx0cywgb3B0aW9ucyApO1xuXHR0aGlzLmN1cnJlbnRGb3JtID0gZm9ybTtcblx0dGhpcy5pbml0KCk7XG59O1xuXG4vLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2pRdWVyeS52YWxpZGF0b3IuZm9ybWF0L1xuJC52YWxpZGF0b3IuZm9ybWF0ID0gZnVuY3Rpb24oIHNvdXJjZSwgcGFyYW1zICkge1xuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSAkLm1ha2VBcnJheSggYXJndW1lbnRzICk7XG5cdFx0XHRhcmdzLnVuc2hpZnQoIHNvdXJjZSApO1xuXHRcdFx0cmV0dXJuICQudmFsaWRhdG9yLmZvcm1hdC5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdH07XG5cdH1cblx0aWYgKCBwYXJhbXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gc291cmNlO1xuXHR9XG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgcGFyYW1zLmNvbnN0cnVjdG9yICE9PSBBcnJheSAgKSB7XG5cdFx0cGFyYW1zID0gJC5tYWtlQXJyYXkoIGFyZ3VtZW50cyApLnNsaWNlKCAxICk7XG5cdH1cblx0aWYgKCBwYXJhbXMuY29uc3RydWN0b3IgIT09IEFycmF5ICkge1xuXHRcdHBhcmFtcyA9IFsgcGFyYW1zIF07XG5cdH1cblx0JC5lYWNoKCBwYXJhbXMsIGZ1bmN0aW9uKCBpLCBuICkge1xuXHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKCBuZXcgUmVnRXhwKCBcIlxcXFx7XCIgKyBpICsgXCJcXFxcfVwiLCBcImdcIiApLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuO1xuXHRcdH0gKTtcblx0fSApO1xuXHRyZXR1cm4gc291cmNlO1xufTtcblxuJC5leHRlbmQoICQudmFsaWRhdG9yLCB7XG5cblx0ZGVmYXVsdHM6IHtcblx0XHRtZXNzYWdlczoge30sXG5cdFx0Z3JvdXBzOiB7fSxcblx0XHRydWxlczoge30sXG5cdFx0ZXJyb3JDbGFzczogXCJlcnJvclwiLFxuXHRcdHBlbmRpbmdDbGFzczogXCJwZW5kaW5nXCIsXG5cdFx0dmFsaWRDbGFzczogXCJ2YWxpZFwiLFxuXHRcdGVycm9yRWxlbWVudDogXCJsYWJlbFwiLFxuXHRcdGZvY3VzQ2xlYW51cDogZmFsc2UsXG5cdFx0Zm9jdXNJbnZhbGlkOiB0cnVlLFxuXHRcdGVycm9yQ29udGFpbmVyOiAkKCBbXSApLFxuXHRcdGVycm9yTGFiZWxDb250YWluZXI6ICQoIFtdICksXG5cdFx0b25zdWJtaXQ6IHRydWUsXG5cdFx0aWdub3JlOiBcIjpoaWRkZW5cIixcblx0XHRpZ25vcmVUaXRsZTogZmFsc2UsXG5cdFx0b25mb2N1c2luOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHRoaXMubGFzdEFjdGl2ZSA9IGVsZW1lbnQ7XG5cblx0XHRcdC8vIEhpZGUgZXJyb3IgbGFiZWwgYW5kIHJlbW92ZSBlcnJvciBjbGFzcyBvbiBmb2N1cyBpZiBlbmFibGVkXG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MuZm9jdXNDbGVhbnVwICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKCB0aGlzLCBlbGVtZW50LCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MsIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuaGlkZVRoZXNlKCB0aGlzLmVycm9yc0ZvciggZWxlbWVudCApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbmZvY3Vzb3V0OiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdGlmICggIXRoaXMuY2hlY2thYmxlKCBlbGVtZW50ICkgJiYgKCBlbGVtZW50Lm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgfHwgIXRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSApICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9ua2V5dXA6IGZ1bmN0aW9uKCBlbGVtZW50LCBldmVudCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgcmV2YWxpZGF0ZSB0aGUgZmllbGQgd2hlbiBwcmVzc2luZyBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXlzXG5cdFx0XHQvLyBTaGlmdCAgICAgICA9PiAxNlxuXHRcdFx0Ly8gQ3RybCAgICAgICAgPT4gMTdcblx0XHRcdC8vIEFsdCAgICAgICAgID0+IDE4XG5cdFx0XHQvLyBDYXBzIGxvY2sgICA9PiAyMFxuXHRcdFx0Ly8gRW5kICAgICAgICAgPT4gMzVcblx0XHRcdC8vIEhvbWUgICAgICAgID0+IDM2XG5cdFx0XHQvLyBMZWZ0IGFycm93ICA9PiAzN1xuXHRcdFx0Ly8gVXAgYXJyb3cgICAgPT4gMzhcblx0XHRcdC8vIFJpZ2h0IGFycm93ID0+IDM5XG5cdFx0XHQvLyBEb3duIGFycm93ICA9PiA0MFxuXHRcdFx0Ly8gSW5zZXJ0ICAgICAgPT4gNDVcblx0XHRcdC8vIE51bSBsb2NrICAgID0+IDE0NFxuXHRcdFx0Ly8gQWx0R3Iga2V5ICAgPT4gMjI1XG5cdFx0XHR2YXIgZXhjbHVkZWRLZXlzID0gW1xuXHRcdFx0XHQxNiwgMTcsIDE4LCAyMCwgMzUsIDM2LCAzNyxcblx0XHRcdFx0MzgsIDM5LCA0MCwgNDUsIDE0NCwgMjI1XG5cdFx0XHRdO1xuXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09PSA5ICYmIHRoaXMuZWxlbWVudFZhbHVlKCBlbGVtZW50ICkgPT09IFwiXCIgfHwgJC5pbkFycmF5KCBldmVudC5rZXlDb2RlLCBleGNsdWRlZEtleXMgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSBpbiB0aGlzLnN1Ym1pdHRlZCB8fCBlbGVtZW50Lm5hbWUgaW4gdGhpcy5pbnZhbGlkICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0XHQvLyBDbGljayBvbiBzZWxlY3RzLCByYWRpb2J1dHRvbnMgYW5kIGNoZWNrYm94ZXNcblx0XHRcdGlmICggZWxlbWVudC5uYW1lIGluIHRoaXMuc3VibWl0dGVkICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gT3Igb3B0aW9uIGVsZW1lbnRzLCBjaGVjayBwYXJlbnQgc2VsZWN0IGluIHRoYXQgY2FzZVxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5wYXJlbnROb2RlLm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudCggZWxlbWVudC5wYXJlbnROb2RlICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoaWdobGlnaHQ6IGZ1bmN0aW9uKCBlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzICkge1xuXHRcdFx0aWYgKCBlbGVtZW50LnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5hZGRDbGFzcyggZXJyb3JDbGFzcyApLnJlbW92ZUNsYXNzKCB2YWxpZENsYXNzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCBlbGVtZW50ICkuYWRkQ2xhc3MoIGVycm9yQ2xhc3MgKS5yZW1vdmVDbGFzcyggdmFsaWRDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dW5oaWdobGlnaHQ6IGZ1bmN0aW9uKCBlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzICkge1xuXHRcdFx0aWYgKCBlbGVtZW50LnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5yZW1vdmVDbGFzcyggZXJyb3JDbGFzcyApLmFkZENsYXNzKCB2YWxpZENsYXNzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCBlbGVtZW50ICkucmVtb3ZlQ2xhc3MoIGVycm9yQ2xhc3MgKS5hZGRDbGFzcyggdmFsaWRDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2pRdWVyeS52YWxpZGF0b3Iuc2V0RGVmYXVsdHMvXG5cdHNldERlZmF1bHRzOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0JC5leHRlbmQoICQudmFsaWRhdG9yLmRlZmF1bHRzLCBzZXR0aW5ncyApO1xuXHR9LFxuXG5cdG1lc3NhZ2VzOiB7XG5cdFx0cmVxdWlyZWQ6IFwiVGhpcyBmaWVsZCBpcyByZXF1aXJlZC5cIixcblx0XHRyZW1vdGU6IFwiUGxlYXNlIGZpeCB0aGlzIGZpZWxkLlwiLFxuXHRcdGVtYWlsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXCIsXG5cdFx0dXJsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIFVSTC5cIixcblx0XHRkYXRlOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGUuXCIsXG5cdFx0ZGF0ZUlTTzogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlIChJU08pLlwiLFxuXHRcdG51bWJlcjogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBudW1iZXIuXCIsXG5cdFx0ZGlnaXRzOiBcIlBsZWFzZSBlbnRlciBvbmx5IGRpZ2l0cy5cIixcblx0XHRlcXVhbFRvOiBcIlBsZWFzZSBlbnRlciB0aGUgc2FtZSB2YWx1ZSBhZ2Fpbi5cIixcblx0XHRtYXhsZW5ndGg6ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgbm8gbW9yZSB0aGFuIHswfSBjaGFyYWN0ZXJzLlwiICksXG5cdFx0bWlubGVuZ3RoOiAkLnZhbGlkYXRvci5mb3JtYXQoIFwiUGxlYXNlIGVudGVyIGF0IGxlYXN0IHswfSBjaGFyYWN0ZXJzLlwiICksXG5cdFx0cmFuZ2VsZW5ndGg6ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgYSB2YWx1ZSBiZXR3ZWVuIHswfSBhbmQgezF9IGNoYXJhY3RlcnMgbG9uZy5cIiApLFxuXHRcdHJhbmdlOiAkLnZhbGlkYXRvci5mb3JtYXQoIFwiUGxlYXNlIGVudGVyIGEgdmFsdWUgYmV0d2VlbiB7MH0gYW5kIHsxfS5cIiApLFxuXHRcdG1heDogJC52YWxpZGF0b3IuZm9ybWF0KCBcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7MH0uXCIgKSxcblx0XHRtaW46ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gezB9LlwiICksXG5cdFx0c3RlcDogJC52YWxpZGF0b3IuZm9ybWF0KCBcIlBsZWFzZSBlbnRlciBhIG11bHRpcGxlIG9mIHswfS5cIiApXG5cdH0sXG5cblx0YXV0b0NyZWF0ZVJhbmdlczogZmFsc2UsXG5cblx0cHJvdG90eXBlOiB7XG5cblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMubGFiZWxDb250YWluZXIgPSAkKCB0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXIgKTtcblx0XHRcdHRoaXMuZXJyb3JDb250ZXh0ID0gdGhpcy5sYWJlbENvbnRhaW5lci5sZW5ndGggJiYgdGhpcy5sYWJlbENvbnRhaW5lciB8fCAkKCB0aGlzLmN1cnJlbnRGb3JtICk7XG5cdFx0XHR0aGlzLmNvbnRhaW5lcnMgPSAkKCB0aGlzLnNldHRpbmdzLmVycm9yQ29udGFpbmVyICkuYWRkKCB0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXIgKTtcblx0XHRcdHRoaXMuc3VibWl0dGVkID0ge307XG5cdFx0XHR0aGlzLnZhbHVlQ2FjaGUgPSB7fTtcblx0XHRcdHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwO1xuXHRcdFx0dGhpcy5wZW5kaW5nID0ge307XG5cdFx0XHR0aGlzLmludmFsaWQgPSB7fTtcblx0XHRcdHRoaXMucmVzZXQoKTtcblxuXHRcdFx0dmFyIGN1cnJlbnRGb3JtID0gdGhpcy5jdXJyZW50Rm9ybSxcblx0XHRcdFx0Z3JvdXBzID0gKCB0aGlzLmdyb3VwcyA9IHt9ICksXG5cdFx0XHRcdHJ1bGVzO1xuXHRcdFx0JC5lYWNoKCB0aGlzLnNldHRpbmdzLmdyb3VwcywgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuc3BsaXQoIC9cXHMvICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5lYWNoKCB2YWx1ZSwgZnVuY3Rpb24oIGluZGV4LCBuYW1lICkge1xuXHRcdFx0XHRcdGdyb3Vwc1sgbmFtZSBdID0ga2V5O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRydWxlcyA9IHRoaXMuc2V0dGluZ3MucnVsZXM7XG5cdFx0XHQkLmVhY2goIHJ1bGVzLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0cnVsZXNbIGtleSBdID0gJC52YWxpZGF0b3Iubm9ybWFsaXplUnVsZSggdmFsdWUgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0ZnVuY3Rpb24gZGVsZWdhdGUoIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgaXNDb250ZW50RWRpdGFibGUgPSB0eXBlb2YgJCggdGhpcyApLmF0dHIoIFwiY29udGVudGVkaXRhYmxlXCIgKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAkKCB0aGlzICkuYXR0ciggXCJjb250ZW50ZWRpdGFibGVcIiApICE9PSBcImZhbHNlXCI7XG5cblx0XHRcdFx0Ly8gU2V0IGZvcm0gZXhwYW5kbyBvbiBjb250ZW50ZWRpdGFibGVcblx0XHRcdFx0aWYgKCAhdGhpcy5mb3JtICYmIGlzQ29udGVudEVkaXRhYmxlICkge1xuXHRcdFx0XHRcdHRoaXMuZm9ybSA9ICQoIHRoaXMgKS5jbG9zZXN0KCBcImZvcm1cIiApWyAwIF07XG5cdFx0XHRcdFx0dGhpcy5uYW1lID0gJCggdGhpcyApLmF0dHIoIFwibmFtZVwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZ25vcmUgdGhlIGVsZW1lbnQgaWYgaXQgYmVsb25ncyB0byBhbm90aGVyIGZvcm0uIFRoaXMgd2lsbCBoYXBwZW4gbWFpbmx5XG5cdFx0XHRcdC8vIHdoZW4gc2V0dGluZyB0aGUgYGZvcm1gIGF0dHJpYnV0ZSBvZiBhbiBpbnB1dCB0byB0aGUgaWQgb2YgYW5vdGhlciBmb3JtLlxuXHRcdFx0XHRpZiAoIGN1cnJlbnRGb3JtICE9PSB0aGlzLmZvcm0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHZhbGlkYXRvciA9ICQuZGF0YSggdGhpcy5mb3JtLCBcInZhbGlkYXRvclwiICksXG5cdFx0XHRcdFx0ZXZlbnRUeXBlID0gXCJvblwiICsgZXZlbnQudHlwZS5yZXBsYWNlKCAvXnZhbGlkYXRlLywgXCJcIiApLFxuXHRcdFx0XHRcdHNldHRpbmdzID0gdmFsaWRhdG9yLnNldHRpbmdzO1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzWyBldmVudFR5cGUgXSAmJiAhJCggdGhpcyApLmlzKCBzZXR0aW5ncy5pZ25vcmUgKSApIHtcblx0XHRcdFx0XHRzZXR0aW5nc1sgZXZlbnRUeXBlIF0uY2FsbCggdmFsaWRhdG9yLCB0aGlzLCBldmVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCQoIHRoaXMuY3VycmVudEZvcm0gKVxuXHRcdFx0XHQub24oIFwiZm9jdXNpbi52YWxpZGF0ZSBmb2N1c291dC52YWxpZGF0ZSBrZXl1cC52YWxpZGF0ZVwiLFxuXHRcdFx0XHRcdFwiOnRleHQsIFt0eXBlPSdwYXNzd29yZCddLCBbdHlwZT0nZmlsZSddLCBzZWxlY3QsIHRleHRhcmVhLCBbdHlwZT0nbnVtYmVyJ10sIFt0eXBlPSdzZWFyY2gnXSwgXCIgK1xuXHRcdFx0XHRcdFwiW3R5cGU9J3RlbCddLCBbdHlwZT0ndXJsJ10sIFt0eXBlPSdlbWFpbCddLCBbdHlwZT0nZGF0ZXRpbWUnXSwgW3R5cGU9J2RhdGUnXSwgW3R5cGU9J21vbnRoJ10sIFwiICtcblx0XHRcdFx0XHRcIlt0eXBlPSd3ZWVrJ10sIFt0eXBlPSd0aW1lJ10sIFt0eXBlPSdkYXRldGltZS1sb2NhbCddLCBbdHlwZT0ncmFuZ2UnXSwgW3R5cGU9J2NvbG9yJ10sIFwiICtcblx0XHRcdFx0XHRcIlt0eXBlPSdyYWRpbyddLCBbdHlwZT0nY2hlY2tib3gnXSwgW2NvbnRlbnRlZGl0YWJsZV0sIFt0eXBlPSdidXR0b24nXVwiLCBkZWxlZ2F0ZSApXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lLCBvbGRJRVxuXHRcdFx0XHQvLyBcInNlbGVjdFwiIGlzIHByb3ZpZGVkIGFzIGV2ZW50LnRhcmdldCB3aGVuIGNsaWNraW5nIGEgb3B0aW9uXG5cdFx0XHRcdC5vbiggXCJjbGljay52YWxpZGF0ZVwiLCBcInNlbGVjdCwgb3B0aW9uLCBbdHlwZT0ncmFkaW8nXSwgW3R5cGU9J2NoZWNrYm94J11cIiwgZGVsZWdhdGUgKTtcblxuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLmludmFsaWRIYW5kbGVyICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkub24oIFwiaW52YWxpZC1mb3JtLnZhbGlkYXRlXCIsIHRoaXMuc2V0dGluZ3MuaW52YWxpZEhhbmRsZXIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9WYWxpZGF0b3IuZm9ybS9cblx0XHRmb3JtOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY2hlY2tGb3JtKCk7XG5cdFx0XHQkLmV4dGVuZCggdGhpcy5zdWJtaXR0ZWQsIHRoaXMuZXJyb3JNYXAgKTtcblx0XHRcdHRoaXMuaW52YWxpZCA9ICQuZXh0ZW5kKCB7fSwgdGhpcy5lcnJvck1hcCApO1xuXHRcdFx0aWYgKCAhdGhpcy52YWxpZCgpICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkudHJpZ2dlckhhbmRsZXIoIFwiaW52YWxpZC1mb3JtXCIsIFsgdGhpcyBdICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNob3dFcnJvcnMoKTtcblx0XHRcdHJldHVybiB0aGlzLnZhbGlkKCk7XG5cdFx0fSxcblxuXHRcdGNoZWNrRm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnByZXBhcmVGb3JtKCk7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGVsZW1lbnRzID0gKCB0aGlzLmN1cnJlbnRFbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKSApOyBlbGVtZW50c1sgaSBdOyBpKysgKSB7XG5cdFx0XHRcdHRoaXMuY2hlY2soIGVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnZhbGlkKCk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvVmFsaWRhdG9yLmVsZW1lbnQvXG5cdFx0ZWxlbWVudDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgY2xlYW5FbGVtZW50ID0gdGhpcy5jbGVhbiggZWxlbWVudCApLFxuXHRcdFx0XHRjaGVja0VsZW1lbnQgPSB0aGlzLnZhbGlkYXRpb25UYXJnZXRGb3IoIGNsZWFuRWxlbWVudCApLFxuXHRcdFx0XHR2ID0gdGhpcyxcblx0XHRcdFx0cmVzdWx0ID0gdHJ1ZSxcblx0XHRcdFx0cnMsIGdyb3VwO1xuXG5cdFx0XHRpZiAoIGNoZWNrRWxlbWVudCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5pbnZhbGlkWyBjbGVhbkVsZW1lbnQubmFtZSBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wcmVwYXJlRWxlbWVudCggY2hlY2tFbGVtZW50ICk7XG5cdFx0XHRcdHRoaXMuY3VycmVudEVsZW1lbnRzID0gJCggY2hlY2tFbGVtZW50ICk7XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBlbGVtZW50IGlzIGdyb3VwZWQsIHRoZW4gdmFsaWRhdGUgYWxsIGdyb3VwIGVsZW1lbnRzIGFscmVhZHlcblx0XHRcdFx0Ly8gY29udGFpbmluZyBhIHZhbHVlXG5cdFx0XHRcdGdyb3VwID0gdGhpcy5ncm91cHNbIGNoZWNrRWxlbWVudC5uYW1lIF07XG5cdFx0XHRcdGlmICggZ3JvdXAgKSB7XG5cdFx0XHRcdFx0JC5lYWNoKCB0aGlzLmdyb3VwcywgZnVuY3Rpb24oIG5hbWUsIHRlc3Rncm91cCApIHtcblx0XHRcdFx0XHRcdGlmICggdGVzdGdyb3VwID09PSBncm91cCAmJiBuYW1lICE9PSBjaGVja0VsZW1lbnQubmFtZSApIHtcblx0XHRcdFx0XHRcdFx0Y2xlYW5FbGVtZW50ID0gdi52YWxpZGF0aW9uVGFyZ2V0Rm9yKCB2LmNsZWFuKCB2LmZpbmRCeU5hbWUoIG5hbWUgKSApICk7XG5cdFx0XHRcdFx0XHRcdGlmICggY2xlYW5FbGVtZW50ICYmIGNsZWFuRWxlbWVudC5uYW1lIGluIHYuaW52YWxpZCApIHtcblx0XHRcdFx0XHRcdFx0XHR2LmN1cnJlbnRFbGVtZW50cy5wdXNoKCBjbGVhbkVsZW1lbnQgKTtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgPSB2LmNoZWNrKCBjbGVhbkVsZW1lbnQgKSAmJiByZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRycyA9IHRoaXMuY2hlY2soIGNoZWNrRWxlbWVudCApICE9PSBmYWxzZTtcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0ICYmIHJzO1xuXHRcdFx0XHRpZiAoIHJzICkge1xuXHRcdFx0XHRcdHRoaXMuaW52YWxpZFsgY2hlY2tFbGVtZW50Lm5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuaW52YWxpZFsgY2hlY2tFbGVtZW50Lm5hbWUgXSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICF0aGlzLm51bWJlck9mSW52YWxpZHMoKSApIHtcblxuXHRcdFx0XHRcdC8vIEhpZGUgZXJyb3IgY29udGFpbmVycyBvbiBsYXN0IGVycm9yXG5cdFx0XHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLnRvSGlkZS5hZGQoIHRoaXMuY29udGFpbmVycyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2hvd0Vycm9ycygpO1xuXG5cdFx0XHRcdC8vIEFkZCBhcmlhLWludmFsaWQgc3RhdHVzIGZvciBzY3JlZW4gcmVhZGVyc1xuXHRcdFx0XHQkKCBlbGVtZW50ICkuYXR0ciggXCJhcmlhLWludmFsaWRcIiwgIXJzICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvVmFsaWRhdG9yLnNob3dFcnJvcnMvXG5cdFx0c2hvd0Vycm9yczogZnVuY3Rpb24oIGVycm9ycyApIHtcblx0XHRcdGlmICggZXJyb3JzICkge1xuXHRcdFx0XHR2YXIgdmFsaWRhdG9yID0gdGhpcztcblxuXHRcdFx0XHQvLyBBZGQgaXRlbXMgdG8gZXJyb3IgbGlzdCBhbmQgbWFwXG5cdFx0XHRcdCQuZXh0ZW5kKCB0aGlzLmVycm9yTWFwLCBlcnJvcnMgKTtcblx0XHRcdFx0dGhpcy5lcnJvckxpc3QgPSAkLm1hcCggdGhpcy5lcnJvck1hcCwgZnVuY3Rpb24oIG1lc3NhZ2UsIG5hbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdFx0XHRcdFx0XHRlbGVtZW50OiB2YWxpZGF0b3IuZmluZEJ5TmFtZSggbmFtZSApWyAwIF1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGl0ZW1zIGZyb20gc3VjY2VzcyBsaXN0XG5cdFx0XHRcdHRoaXMuc3VjY2Vzc0xpc3QgPSAkLmdyZXAoIHRoaXMuc3VjY2Vzc0xpc3QsIGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0XHRcdHJldHVybiAhKCBlbGVtZW50Lm5hbWUgaW4gZXJyb3JzICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5zaG93RXJyb3JzICkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnNob3dFcnJvcnMuY2FsbCggdGhpcywgdGhpcy5lcnJvck1hcCwgdGhpcy5lcnJvckxpc3QgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGVmYXVsdFNob3dFcnJvcnMoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9WYWxpZGF0b3IucmVzZXRGb3JtL1xuXHRcdHJlc2V0Rm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICQuZm4ucmVzZXRGb3JtICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkucmVzZXRGb3JtKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmludmFsaWQgPSB7fTtcblx0XHRcdHRoaXMuc3VibWl0dGVkID0ge307XG5cdFx0XHR0aGlzLnByZXBhcmVGb3JtKCk7XG5cdFx0XHR0aGlzLmhpZGVFcnJvcnMoKTtcblx0XHRcdHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKVxuXHRcdFx0XHQucmVtb3ZlRGF0YSggXCJwcmV2aW91c1ZhbHVlXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWludmFsaWRcIiApO1xuXG5cdFx0XHR0aGlzLnJlc2V0RWxlbWVudHMoIGVsZW1lbnRzICk7XG5cdFx0fSxcblxuXHRcdHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uKCBlbGVtZW50cyApIHtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBlbGVtZW50c1sgaSBdOyBpKysgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKCB0aGlzLCBlbGVtZW50c1sgaSBdLFxuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCBcIlwiICk7XG5cdFx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKCBlbGVtZW50c1sgaSBdLm5hbWUgKS5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRzXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG51bWJlck9mSW52YWxpZHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub2JqZWN0TGVuZ3RoKCB0aGlzLmludmFsaWQgKTtcblx0XHR9LFxuXG5cdFx0b2JqZWN0TGVuZ3RoOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0LyoganNoaW50IHVudXNlZDogZmFsc2UgKi9cblx0XHRcdHZhciBjb3VudCA9IDAsXG5cdFx0XHRcdGk7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblxuXHRcdFx0XHQvLyBUaGlzIGNoZWNrIGFsbG93cyBjb3VudGluZyBlbGVtZW50cyB3aXRoIGVtcHR5IGVycm9yXG5cdFx0XHRcdC8vIG1lc3NhZ2UgYXMgaW52YWxpZCBlbGVtZW50c1xuXHRcdFx0XHRpZiAoIG9ialsgaSBdICE9PSB1bmRlZmluZWQgJiYgb2JqWyBpIF0gIT09IG51bGwgJiYgb2JqWyBpIF0gIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9LFxuXG5cdFx0aGlkZUVycm9yczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhpZGVUaGVzZSggdGhpcy50b0hpZGUgKTtcblx0XHR9LFxuXG5cdFx0aGlkZVRoZXNlOiBmdW5jdGlvbiggZXJyb3JzICkge1xuXHRcdFx0ZXJyb3JzLm5vdCggdGhpcy5jb250YWluZXJzICkudGV4dCggXCJcIiApO1xuXHRcdFx0dGhpcy5hZGRXcmFwcGVyKCBlcnJvcnMgKS5oaWRlKCk7XG5cdFx0fSxcblxuXHRcdHZhbGlkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcblx0XHR9LFxuXG5cdFx0c2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lcnJvckxpc3QubGVuZ3RoO1xuXHRcdH0sXG5cblx0XHRmb2N1c0ludmFsaWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLmZvY3VzSW52YWxpZCApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQkKCB0aGlzLmZpbmRMYXN0QWN0aXZlKCkgfHwgdGhpcy5lcnJvckxpc3QubGVuZ3RoICYmIHRoaXMuZXJyb3JMaXN0WyAwIF0uZWxlbWVudCB8fCBbXSApXG5cdFx0XHRcdFx0LmZpbHRlciggXCI6dmlzaWJsZVwiIClcblx0XHRcdFx0XHQudHJpZ2dlciggXCJmb2N1c1wiIClcblxuXHRcdFx0XHRcdC8vIE1hbnVhbGx5IHRyaWdnZXIgZm9jdXNpbiBldmVudDsgd2l0aG91dCBpdCwgZm9jdXNpbiBoYW5kbGVyIGlzbid0IGNhbGxlZCwgZmluZExhc3RBY3RpdmUgd29uJ3QgaGF2ZSBhbnl0aGluZyB0byBmaW5kXG5cdFx0XHRcdFx0LnRyaWdnZXIoIFwiZm9jdXNpblwiICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gSWdub3JlIElFIHRocm93aW5nIGVycm9ycyB3aGVuIGZvY3VzaW5nIGhpZGRlbiBlbGVtZW50c1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGZpbmRMYXN0QWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsYXN0QWN0aXZlID0gdGhpcy5sYXN0QWN0aXZlO1xuXHRcdFx0cmV0dXJuIGxhc3RBY3RpdmUgJiYgJC5ncmVwKCB0aGlzLmVycm9yTGlzdCwgZnVuY3Rpb24oIG4gKSB7XG5cdFx0XHRcdHJldHVybiBuLmVsZW1lbnQubmFtZSA9PT0gbGFzdEFjdGl2ZS5uYW1lO1xuXHRcdFx0fSApLmxlbmd0aCA9PT0gMSAmJiBsYXN0QWN0aXZlO1xuXHRcdH0sXG5cblx0XHRlbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdmFsaWRhdG9yID0gdGhpcyxcblx0XHRcdFx0cnVsZXNDYWNoZSA9IHt9O1xuXG5cdFx0XHQvLyBTZWxlY3QgYWxsIHZhbGlkIGlucHV0cyBpbnNpZGUgdGhlIGZvcm0gKG5vIHN1Ym1pdCBvciByZXNldCBidXR0b25zKVxuXHRcdFx0cmV0dXJuICQoIHRoaXMuY3VycmVudEZvcm0gKVxuXHRcdFx0LmZpbmQoIFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFtjb250ZW50ZWRpdGFibGVdXCIgKVxuXHRcdFx0Lm5vdCggXCI6c3VibWl0LCA6cmVzZXQsIDppbWFnZSwgOmRpc2FibGVkXCIgKVxuXHRcdFx0Lm5vdCggdGhpcy5zZXR0aW5ncy5pZ25vcmUgKVxuXHRcdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gdGhpcy5uYW1lIHx8ICQoIHRoaXMgKS5hdHRyKCBcIm5hbWVcIiApOyAvLyBGb3IgY29udGVudGVkaXRhYmxlXG5cdFx0XHRcdHZhciBpc0NvbnRlbnRFZGl0YWJsZSA9IHR5cGVvZiAkKCB0aGlzICkuYXR0ciggXCJjb250ZW50ZWRpdGFibGVcIiApICE9PSBcInVuZGVmaW5lZFwiICYmICQoIHRoaXMgKS5hdHRyKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgIT09IFwiZmFsc2VcIjtcblxuXHRcdFx0XHRpZiAoICFuYW1lICYmIHZhbGlkYXRvci5zZXR0aW5ncy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiVvIGhhcyBubyBuYW1lIGFzc2lnbmVkXCIsIHRoaXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBmb3JtIGV4cGFuZG8gb24gY29udGVudGVkaXRhYmxlXG5cdFx0XHRcdGlmICggaXNDb250ZW50RWRpdGFibGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb3JtID0gJCggdGhpcyApLmNsb3Nlc3QoIFwiZm9ybVwiIClbIDAgXTtcblx0XHRcdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWdub3JlIGVsZW1lbnRzIHRoYXQgYmVsb25nIHRvIG90aGVyL25lc3RlZCBmb3Jtc1xuXHRcdFx0XHRpZiAoIHRoaXMuZm9ybSAhPT0gdmFsaWRhdG9yLmN1cnJlbnRGb3JtICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlbGVjdCBvbmx5IHRoZSBmaXJzdCBlbGVtZW50IGZvciBlYWNoIG5hbWUsIGFuZCBvbmx5IHRob3NlIHdpdGggcnVsZXMgc3BlY2lmaWVkXG5cdFx0XHRcdGlmICggbmFtZSBpbiBydWxlc0NhY2hlIHx8ICF2YWxpZGF0b3Iub2JqZWN0TGVuZ3RoKCAkKCB0aGlzICkucnVsZXMoKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJ1bGVzQ2FjaGVbIG5hbWUgXSA9IHRydWU7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRjbGVhbjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuICQoIHNlbGVjdG9yIClbIDAgXTtcblx0XHR9LFxuXG5cdFx0ZXJyb3JzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlcnJvckNsYXNzID0gdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLnNwbGl0KCBcIiBcIiApLmpvaW4oIFwiLlwiICk7XG5cdFx0XHRyZXR1cm4gJCggdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIi5cIiArIGVycm9yQ2xhc3MsIHRoaXMuZXJyb3JDb250ZXh0ICk7XG5cdFx0fSxcblxuXHRcdHJlc2V0SW50ZXJuYWxzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc3VjY2Vzc0xpc3QgPSBbXTtcblx0XHRcdHRoaXMuZXJyb3JMaXN0ID0gW107XG5cdFx0XHR0aGlzLmVycm9yTWFwID0ge307XG5cdFx0XHR0aGlzLnRvU2hvdyA9ICQoIFtdICk7XG5cdFx0XHR0aGlzLnRvSGlkZSA9ICQoIFtdICk7XG5cdFx0fSxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmVzZXRJbnRlcm5hbHMoKTtcblx0XHRcdHRoaXMuY3VycmVudEVsZW1lbnRzID0gJCggW10gKTtcblx0XHR9LFxuXG5cdFx0cHJlcGFyZUZvcm06IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLmVycm9ycygpLmFkZCggdGhpcy5jb250YWluZXJzICk7XG5cdFx0fSxcblxuXHRcdHByZXBhcmVFbGVtZW50OiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdHRoaXMudG9IaWRlID0gdGhpcy5lcnJvcnNGb3IoIGVsZW1lbnQgKTtcblx0XHR9LFxuXG5cdFx0ZWxlbWVudFZhbHVlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHZhciAkZWxlbWVudCA9ICQoIGVsZW1lbnQgKSxcblx0XHRcdFx0dHlwZSA9IGVsZW1lbnQudHlwZSxcblx0XHRcdFx0aXNDb250ZW50RWRpdGFibGUgPSB0eXBlb2YgJGVsZW1lbnQuYXR0ciggXCJjb250ZW50ZWRpdGFibGVcIiApICE9PSBcInVuZGVmaW5lZFwiICYmICRlbGVtZW50LmF0dHIoIFwiY29udGVudGVkaXRhYmxlXCIgKSAhPT0gXCJmYWxzZVwiLFxuXHRcdFx0XHR2YWwsIGlkeDtcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5maWx0ZXIoIFwiOmNoZWNrZWRcIiApLnZhbCgpO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZWxlbWVudC52YWxpZGl0eSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQudmFsaWRpdHkuYmFkSW5wdXQgPyBcIk5hTlwiIDogJGVsZW1lbnQudmFsKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNDb250ZW50RWRpdGFibGUgKSB7XG5cdFx0XHRcdHZhbCA9ICRlbGVtZW50LnRleHQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9ICRlbGVtZW50LnZhbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZmlsZVwiICkge1xuXG5cdFx0XHRcdC8vIE1vZGVybiBicm93c2VyIChjaHJvbWUgJiBzYWZhcmkpXG5cdFx0XHRcdGlmICggdmFsLnN1YnN0ciggMCwgMTIgKSA9PT0gXCJDOlxcXFxmYWtlcGF0aFxcXFxcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsLnN1YnN0ciggMTIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExlZ2FjeSBicm93c2Vyc1xuXHRcdFx0XHQvLyBVbml4LWJhc2VkIHBhdGhcblx0XHRcdFx0aWR4ID0gdmFsLmxhc3RJbmRleE9mKCBcIi9cIiApO1xuXHRcdFx0XHRpZiAoIGlkeCA+PSAwICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWwuc3Vic3RyKCBpZHggKyAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXaW5kb3dzLWJhc2VkIHBhdGhcblx0XHRcdFx0aWR4ID0gdmFsLmxhc3RJbmRleE9mKCBcIlxcXFxcIiApO1xuXHRcdFx0XHRpZiAoIGlkeCA+PSAwICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWwuc3Vic3RyKCBpZHggKyAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBKdXN0IHRoZSBmaWxlIG5hbWVcblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsLnJlcGxhY2UoIC9cXHIvZywgXCJcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9LFxuXG5cdFx0Y2hlY2s6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudCA9IHRoaXMudmFsaWRhdGlvblRhcmdldEZvciggdGhpcy5jbGVhbiggZWxlbWVudCApICk7XG5cblx0XHRcdHZhciBydWxlcyA9ICQoIGVsZW1lbnQgKS5ydWxlcygpLFxuXHRcdFx0XHRydWxlc0NvdW50ID0gJC5tYXAoIHJ1bGVzLCBmdW5jdGlvbiggbiwgaSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fSApLmxlbmd0aCxcblx0XHRcdFx0ZGVwZW5kZW5jeU1pc21hdGNoID0gZmFsc2UsXG5cdFx0XHRcdHZhbCA9IHRoaXMuZWxlbWVudFZhbHVlKCBlbGVtZW50ICksXG5cdFx0XHRcdHJlc3VsdCwgbWV0aG9kLCBydWxlLCBub3JtYWxpemVyO1xuXG5cdFx0XHQvLyBQcmlvcml0aXplIHRoZSBsb2NhbCBub3JtYWxpemVyIGRlZmluZWQgZm9yIHRoaXMgZWxlbWVudCBvdmVyIHRoZSBnbG9iYWwgb25lXG5cdFx0XHQvLyBpZiB0aGUgZm9ybWVyIGV4aXN0cywgb3RoZXJ3aXNlIHVzZXIgdGhlIGdsb2JhbCBvbmUgaW4gY2FzZSBpdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR5cGVvZiBydWxlcy5ub3JtYWxpemVyID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZXIgPSBydWxlcy5ub3JtYWxpemVyO1xuXHRcdFx0fSBlbHNlIGlmIChcdHR5cGVvZiB0aGlzLnNldHRpbmdzLm5vcm1hbGl6ZXIgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0bm9ybWFsaXplciA9IHRoaXMuc2V0dGluZ3Mubm9ybWFsaXplcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm9ybWFsaXplciBpcyBkZWZpbmVkLCB0aGVuIGNhbGwgaXQgdG8gcmV0cmVpdmUgdGhlIGNoYW5nZWQgdmFsdWUgaW5zdGVhZFxuXHRcdFx0Ly8gb2YgdXNpbmcgdGhlIHJlYWwgb25lLlxuXHRcdFx0Ly8gTm90ZSB0aGF0IGB0aGlzYCBpbiB0aGUgbm9ybWFsaXplciBpcyBgZWxlbWVudGAuXG5cdFx0XHRpZiAoIG5vcm1hbGl6ZXIgKSB7XG5cdFx0XHRcdHZhbCA9IG5vcm1hbGl6ZXIuY2FsbCggZWxlbWVudCwgdmFsICk7XG5cblx0XHRcdFx0Ly8gRGVsZXRlIHRoZSBub3JtYWxpemVyIGZyb20gcnVsZXMgdG8gYXZvaWQgdHJlYXRpbmcgaXQgYXMgYSBwcmUtZGVmaW5lZCBtZXRob2QuXG5cdFx0XHRcdGRlbGV0ZSBydWxlcy5ub3JtYWxpemVyO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBtZXRob2QgaW4gcnVsZXMgKSB7XG5cdFx0XHRcdHJ1bGUgPSB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbWV0ZXJzOiBydWxlc1sgbWV0aG9kIF0gfTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXN1bHQgPSAkLnZhbGlkYXRvci5tZXRob2RzWyBtZXRob2QgXS5jYWxsKCB0aGlzLCB2YWwsIGVsZW1lbnQsIHJ1bGUucGFyYW1ldGVycyApO1xuXG5cdFx0XHRcdFx0Ly8gSWYgYSBtZXRob2QgaW5kaWNhdGVzIHRoYXQgdGhlIGZpZWxkIGlzIG9wdGlvbmFsIGFuZCB0aGVyZWZvcmUgdmFsaWQsXG5cdFx0XHRcdFx0Ly8gZG9uJ3QgbWFyayBpdCBhcyB2YWxpZCB3aGVuIHRoZXJlIGFyZSBubyBvdGhlciBydWxlc1xuXHRcdFx0XHRcdGlmICggcmVzdWx0ID09PSBcImRlcGVuZGVuY3ktbWlzbWF0Y2hcIiAmJiBydWxlc0NvdW50ID09PSAxICkge1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeU1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZXBlbmRlbmN5TWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcmVzdWx0ID09PSBcInBlbmRpbmdcIiApIHtcblx0XHRcdFx0XHRcdHRoaXMudG9IaWRlID0gdGhpcy50b0hpZGUubm90KCB0aGlzLmVycm9yc0ZvciggZWxlbWVudCApICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhcmVzdWx0ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5mb3JtYXRBbmRBZGQoIGVsZW1lbnQsIHJ1bGUgKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkV4Y2VwdGlvbiBvY2N1cnJlZCB3aGVuIGNoZWNraW5nIGVsZW1lbnQgXCIgKyBlbGVtZW50LmlkICsgXCIsIGNoZWNrIHRoZSAnXCIgKyBydWxlLm1ldGhvZCArIFwiJyBtZXRob2QuXCIsIGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBlIGluc3RhbmNlb2YgVHlwZUVycm9yICkge1xuXHRcdFx0XHRcdFx0ZS5tZXNzYWdlICs9IFwiLiAgRXhjZXB0aW9uIG9jY3VycmVkIHdoZW4gY2hlY2tpbmcgZWxlbWVudCBcIiArIGVsZW1lbnQuaWQgKyBcIiwgY2hlY2sgdGhlICdcIiArIHJ1bGUubWV0aG9kICsgXCInIG1ldGhvZC5cIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRlcGVuZGVuY3lNaXNtYXRjaCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm9iamVjdExlbmd0aCggcnVsZXMgKSApIHtcblx0XHRcdFx0dGhpcy5zdWNjZXNzTGlzdC5wdXNoKCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjdXN0b20gbWVzc2FnZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgYW5kIHZhbGlkYXRpb24gbWV0aG9kXG5cdFx0Ly8gc3BlY2lmaWVkIGluIHRoZSBlbGVtZW50J3MgSFRNTDUgZGF0YSBhdHRyaWJ1dGVcblx0XHQvLyByZXR1cm4gdGhlIGdlbmVyaWMgbWVzc2FnZSBpZiBwcmVzZW50IGFuZCBubyBtZXRob2Qgc3BlY2lmaWMgbWVzc2FnZSBpcyBwcmVzZW50XG5cdFx0Y3VzdG9tRGF0YU1lc3NhZ2U6IGZ1bmN0aW9uKCBlbGVtZW50LCBtZXRob2QgKSB7XG5cdFx0XHRyZXR1cm4gJCggZWxlbWVudCApLmRhdGEoIFwibXNnXCIgKyBtZXRob2QuY2hhckF0KCAwICkudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdG1ldGhvZC5zdWJzdHJpbmcoIDEgKS50b0xvd2VyQ2FzZSgpICkgfHwgJCggZWxlbWVudCApLmRhdGEoIFwibXNnXCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjdXN0b20gbWVzc2FnZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgbmFtZSBhbmQgdmFsaWRhdGlvbiBtZXRob2Rcblx0XHRjdXN0b21NZXNzYWdlOiBmdW5jdGlvbiggbmFtZSwgbWV0aG9kICkge1xuXHRcdFx0dmFyIG0gPSB0aGlzLnNldHRpbmdzLm1lc3NhZ2VzWyBuYW1lIF07XG5cdFx0XHRyZXR1cm4gbSAmJiAoIG0uY29uc3RydWN0b3IgPT09IFN0cmluZyA/IG0gOiBtWyBtZXRob2QgXSApO1xuXHRcdH0sXG5cblx0XHQvLyBSZXR1cm4gdGhlIGZpcnN0IGRlZmluZWQgYXJndW1lbnQsIGFsbG93aW5nIGVtcHR5IHN0cmluZ3Ncblx0XHRmaW5kRGVmaW5lZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzWyBpIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYXJndW1lbnRzWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblxuXHRcdC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyICdydWxlJyB1c2VkIHRvIGJlIGEgc3RyaW5nLCBhbmQgZXh0ZW5kZWQgdG8gYW4gb2JqZWN0IGxpdGVyYWxcblx0XHQvLyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XG5cdFx0Ly8gcnVsZSA9IHtcblx0XHQvLyAgICAgbWV0aG9kOiBcIm1ldGhvZCBuYW1lXCIsXG5cdFx0Ly8gICAgIHBhcmFtZXRlcnM6IFwidGhlIGdpdmVuIG1ldGhvZCBwYXJhbWV0ZXJzXCJcblx0XHQvLyB9XG5cdFx0Ly9cblx0XHQvLyBUaGUgb2xkIGJlaGF2aW9yIHN0aWxsIHN1cHBvcnRlZCwga2VwdCB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGhcblx0XHQvLyBvbGQgY29kZSwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHRcdGRlZmF1bHRNZXNzYWdlOiBmdW5jdGlvbiggZWxlbWVudCwgcnVsZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHJ1bGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJ1bGUgPSB7IG1ldGhvZDogcnVsZSB9O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWVzc2FnZSA9IHRoaXMuZmluZERlZmluZWQoXG5cdFx0XHRcdFx0dGhpcy5jdXN0b21NZXNzYWdlKCBlbGVtZW50Lm5hbWUsIHJ1bGUubWV0aG9kICksXG5cdFx0XHRcdFx0dGhpcy5jdXN0b21EYXRhTWVzc2FnZSggZWxlbWVudCwgcnVsZS5tZXRob2QgKSxcblxuXHRcdFx0XHRcdC8vICd0aXRsZScgaXMgbmV2ZXIgdW5kZWZpbmVkLCBzbyBoYW5kbGUgZW1wdHkgc3RyaW5nIGFzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdCF0aGlzLnNldHRpbmdzLmlnbm9yZVRpdGxlICYmIGVsZW1lbnQudGl0bGUgfHwgdW5kZWZpbmVkLFxuXHRcdFx0XHRcdCQudmFsaWRhdG9yLm1lc3NhZ2VzWyBydWxlLm1ldGhvZCBdLFxuXHRcdFx0XHRcdFwiPHN0cm9uZz5XYXJuaW5nOiBObyBtZXNzYWdlIGRlZmluZWQgZm9yIFwiICsgZWxlbWVudC5uYW1lICsgXCI8L3N0cm9uZz5cIlxuXHRcdFx0XHQpLFxuXHRcdFx0XHR0aGVyZWdleCA9IC9cXCQ/XFx7KFxcZCspXFx9L2c7XG5cdFx0XHRpZiAoIHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdG1lc3NhZ2UgPSBtZXNzYWdlLmNhbGwoIHRoaXMsIHJ1bGUucGFyYW1ldGVycywgZWxlbWVudCApO1xuXHRcdFx0fSBlbHNlIGlmICggdGhlcmVnZXgudGVzdCggbWVzc2FnZSApICkge1xuXHRcdFx0XHRtZXNzYWdlID0gJC52YWxpZGF0b3IuZm9ybWF0KCBtZXNzYWdlLnJlcGxhY2UoIHRoZXJlZ2V4LCBcInskMX1cIiApLCBydWxlLnBhcmFtZXRlcnMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdFx0fSxcblxuXHRcdGZvcm1hdEFuZEFkZDogZnVuY3Rpb24oIGVsZW1lbnQsIHJ1bGUgKSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IHRoaXMuZGVmYXVsdE1lc3NhZ2UoIGVsZW1lbnQsIHJ1bGUgKTtcblxuXHRcdFx0dGhpcy5lcnJvckxpc3QucHVzaCgge1xuXHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0XHRtZXRob2Q6IHJ1bGUubWV0aG9kXG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuZXJyb3JNYXBbIGVsZW1lbnQubmFtZSBdID0gbWVzc2FnZTtcblx0XHRcdHRoaXMuc3VibWl0dGVkWyBlbGVtZW50Lm5hbWUgXSA9IG1lc3NhZ2U7XG5cdFx0fSxcblxuXHRcdGFkZFdyYXBwZXI6IGZ1bmN0aW9uKCB0b1RvZ2dsZSApIHtcblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy53cmFwcGVyICkge1xuXHRcdFx0XHR0b1RvZ2dsZSA9IHRvVG9nZ2xlLmFkZCggdG9Ub2dnbGUucGFyZW50KCB0aGlzLnNldHRpbmdzLndyYXBwZXIgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRvVG9nZ2xlO1xuXHRcdH0sXG5cblx0XHRkZWZhdWx0U2hvd0Vycm9yczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSwgZWxlbWVudHMsIGVycm9yO1xuXHRcdFx0Zm9yICggaSA9IDA7IHRoaXMuZXJyb3JMaXN0WyBpIF07IGkrKyApIHtcblx0XHRcdFx0ZXJyb3IgPSB0aGlzLmVycm9yTGlzdFsgaSBdO1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0ICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0LmNhbGwoIHRoaXMsIGVycm9yLmVsZW1lbnQsIHRoaXMuc2V0dGluZ3MuZXJyb3JDbGFzcywgdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zaG93TGFiZWwoIGVycm9yLmVsZW1lbnQsIGVycm9yLm1lc3NhZ2UgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5lcnJvckxpc3QubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnRvU2hvdyA9IHRoaXMudG9TaG93LmFkZCggdGhpcy5jb250YWluZXJzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3Muc3VjY2VzcyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IHRoaXMuc3VjY2Vzc0xpc3RbIGkgXTsgaSsrICkge1xuXHRcdFx0XHRcdHRoaXMuc2hvd0xhYmVsKCB0aGlzLnN1Y2Nlc3NMaXN0WyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLnVuaGlnaGxpZ2h0ICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgZWxlbWVudHMgPSB0aGlzLnZhbGlkRWxlbWVudHMoKTsgZWxlbWVudHNbIGkgXTsgaSsrICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCggdGhpcywgZWxlbWVudHNbIGkgXSwgdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCB0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLnRvSGlkZS5ub3QoIHRoaXMudG9TaG93ICk7XG5cdFx0XHR0aGlzLmhpZGVFcnJvcnMoKTtcblx0XHRcdHRoaXMuYWRkV3JhcHBlciggdGhpcy50b1Nob3cgKS5zaG93KCk7XG5cdFx0fSxcblxuXHRcdHZhbGlkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnRzLm5vdCggdGhpcy5pbnZhbGlkRWxlbWVudHMoKSApO1xuXHRcdH0sXG5cblx0XHRpbnZhbGlkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQoIHRoaXMuZXJyb3JMaXN0ICkubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0c2hvd0xhYmVsOiBmdW5jdGlvbiggZWxlbWVudCwgbWVzc2FnZSApIHtcblx0XHRcdHZhciBwbGFjZSwgZ3JvdXAsIGVycm9ySUQsIHYsXG5cdFx0XHRcdGVycm9yID0gdGhpcy5lcnJvcnNGb3IoIGVsZW1lbnQgKSxcblx0XHRcdFx0ZWxlbWVudElEID0gdGhpcy5pZE9yTmFtZSggZWxlbWVudCApLFxuXHRcdFx0XHRkZXNjcmliZWRCeSA9ICQoIGVsZW1lbnQgKS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApO1xuXG5cdFx0XHRpZiAoIGVycm9yLmxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyBSZWZyZXNoIGVycm9yL3N1Y2Nlc3MgY2xhc3Ncblx0XHRcdFx0ZXJyb3IucmVtb3ZlQ2xhc3MoIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyApLmFkZENsYXNzKCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MgKTtcblxuXHRcdFx0XHQvLyBSZXBsYWNlIG1lc3NhZ2Ugb24gZXhpc3RpbmcgbGFiZWxcblx0XHRcdFx0ZXJyb3IuaHRtbCggbWVzc2FnZSApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBDcmVhdGUgZXJyb3IgZWxlbWVudFxuXHRcdFx0XHRlcnJvciA9ICQoIFwiPFwiICsgdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIj5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiaWRcIiwgZWxlbWVudElEICsgXCItZXJyb3JcIiApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MgKVxuXHRcdFx0XHRcdC5odG1sKCBtZXNzYWdlIHx8IFwiXCIgKTtcblxuXHRcdFx0XHQvLyBNYWludGFpbiByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdG8gYmUgcGxhY2VkIGludG8gdGhlIERPTVxuXHRcdFx0XHRwbGFjZSA9IGVycm9yO1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3Mud3JhcHBlciApIHtcblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlLCBldmVuIGluIElFXG5cdFx0XHRcdFx0Ly8gYWN0dWFsbHkgc2hvd2luZyB0aGUgd3JhcHBlZCBlbGVtZW50IGlzIGhhbmRsZWQgZWxzZXdoZXJlXG5cdFx0XHRcdFx0cGxhY2UgPSBlcnJvci5oaWRlKCkuc2hvdygpLndyYXAoIFwiPFwiICsgdGhpcy5zZXR0aW5ncy53cmFwcGVyICsgXCIvPlwiICkucGFyZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLmxhYmVsQ29udGFpbmVyLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLmxhYmVsQ29udGFpbmVyLmFwcGVuZCggcGxhY2UgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5zZXR0aW5ncy5lcnJvclBsYWNlbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmVycm9yUGxhY2VtZW50LmNhbGwoIHRoaXMsIHBsYWNlLCAkKCBlbGVtZW50ICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwbGFjZS5pbnNlcnRBZnRlciggZWxlbWVudCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTGluayBlcnJvciBiYWNrIHRvIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggZXJyb3IuaXMoIFwibGFiZWxcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGVycm9yIGlzIGEgbGFiZWwsIHRoZW4gYXNzb2NpYXRlIHVzaW5nICdmb3InXG5cdFx0XHRcdFx0ZXJyb3IuYXR0ciggXCJmb3JcIiwgZWxlbWVudElEICk7XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBpcyBub3QgYSBjaGlsZCBvZiBhbiBhc3NvY2lhdGVkIGxhYmVsLCB0aGVuIGl0J3MgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0Ly8gdG8gZXhwbGljaXRseSBhcHBseSBhcmlhLWRlc2NyaWJlZGJ5XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVycm9yLnBhcmVudHMoIFwibGFiZWxbZm9yPSdcIiArIHRoaXMuZXNjYXBlQ3NzTWV0YSggZWxlbWVudElEICkgKyBcIiddXCIgKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0ZXJyb3JJRCA9IGVycm9yLmF0dHIoIFwiaWRcIiApO1xuXG5cdFx0XHRcdFx0Ly8gUmVzcGVjdCBleGlzdGluZyBub24tZXJyb3IgYXJpYS1kZXNjcmliZWRieVxuXHRcdFx0XHRcdGlmICggIWRlc2NyaWJlZEJ5ICkge1xuXHRcdFx0XHRcdFx0ZGVzY3JpYmVkQnkgPSBlcnJvcklEO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFkZXNjcmliZWRCeS5tYXRjaCggbmV3IFJlZ0V4cCggXCJcXFxcYlwiICsgdGhpcy5lc2NhcGVDc3NNZXRhKCBlcnJvcklEICkgKyBcIlxcXFxiXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBBZGQgdG8gZW5kIG9mIGxpc3QgaWYgbm90IGFscmVhZHkgcHJlc2VudFxuXHRcdFx0XHRcdFx0ZGVzY3JpYmVkQnkgKz0gXCIgXCIgKyBlcnJvcklEO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkKCBlbGVtZW50ICkuYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIGRlc2NyaWJlZEJ5ICk7XG5cblx0XHRcdFx0XHQvLyBJZiB0aGlzIGVsZW1lbnQgaXMgZ3JvdXBlZCwgdGhlbiBhc3NpZ24gdG8gYWxsIGVsZW1lbnRzIGluIHRoZSBzYW1lIGdyb3VwXG5cdFx0XHRcdFx0Z3JvdXAgPSB0aGlzLmdyb3Vwc1sgZWxlbWVudC5uYW1lIF07XG5cdFx0XHRcdFx0aWYgKCBncm91cCApIHtcblx0XHRcdFx0XHRcdHYgPSB0aGlzO1xuXHRcdFx0XHRcdFx0JC5lYWNoKCB2Lmdyb3VwcywgZnVuY3Rpb24oIG5hbWUsIHRlc3Rncm91cCApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXN0Z3JvdXAgPT09IGdyb3VwICkge1xuXHRcdFx0XHRcdFx0XHRcdCQoIFwiW25hbWU9J1wiICsgdi5lc2NhcGVDc3NNZXRhKCBuYW1lICkgKyBcIiddXCIsIHYuY3VycmVudEZvcm0gKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiLCBlcnJvci5hdHRyKCBcImlkXCIgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFtZXNzYWdlICYmIHRoaXMuc2V0dGluZ3Muc3VjY2VzcyApIHtcblx0XHRcdFx0ZXJyb3IudGV4dCggXCJcIiApO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGlzLnNldHRpbmdzLnN1Y2Nlc3MgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0ZXJyb3IuYWRkQ2xhc3MoIHRoaXMuc2V0dGluZ3Muc3VjY2VzcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3VjY2VzcyggZXJyb3IsIGVsZW1lbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy50b1Nob3cgPSB0aGlzLnRvU2hvdy5hZGQoIGVycm9yICk7XG5cdFx0fSxcblxuXHRcdGVycm9yc0ZvcjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgbmFtZSA9IHRoaXMuZXNjYXBlQ3NzTWV0YSggdGhpcy5pZE9yTmFtZSggZWxlbWVudCApICksXG5cdFx0XHRcdGRlc2NyaWJlciA9ICQoIGVsZW1lbnQgKS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApLFxuXHRcdFx0XHRzZWxlY3RvciA9IFwibGFiZWxbZm9yPSdcIiArIG5hbWUgKyBcIiddLCBsYWJlbFtmb3I9J1wiICsgbmFtZSArIFwiJ10gKlwiO1xuXG5cdFx0XHQvLyAnYXJpYS1kZXNjcmliZWRieScgc2hvdWxkIGRpcmVjdGx5IHJlZmVyZW5jZSB0aGUgZXJyb3IgZWxlbWVudFxuXHRcdFx0aWYgKCBkZXNjcmliZXIgKSB7XG5cdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3IgKyBcIiwgI1wiICsgdGhpcy5lc2NhcGVDc3NNZXRhKCBkZXNjcmliZXIgKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCAvXFxzKy9nLCBcIiwgI1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHRcdC5lcnJvcnMoKVxuXHRcdFx0XHQuZmlsdGVyKCBzZWxlY3RvciApO1xuXHRcdH0sXG5cblx0XHQvLyBTZWUgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9jYXRlZ29yeS9zZWxlY3RvcnMvLCBmb3IgQ1NTXG5cdFx0Ly8gbWV0YS1jaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIGVzY2FwZWQgaW4gb3JkZXIgdG8gYmUgdXNlZCB3aXRoIEpRdWVyeVxuXHRcdC8vIGFzIGEgbGl0ZXJhbCBwYXJ0IG9mIGEgbmFtZS9pZCBvciBhbnkgc2VsZWN0b3IuXG5cdFx0ZXNjYXBlQ3NzTWV0YTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggLyhbXFxcXCFcIiMkJSYnKCkqKywuLzo7PD0+P0BcXFtcXF1eYHt8fX5dKS9nLCBcIlxcXFwkMVwiICk7XG5cdFx0fSxcblxuXHRcdGlkT3JOYW1lOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLmdyb3Vwc1sgZWxlbWVudC5uYW1lIF0gfHwgKCB0aGlzLmNoZWNrYWJsZSggZWxlbWVudCApID8gZWxlbWVudC5uYW1lIDogZWxlbWVudC5pZCB8fCBlbGVtZW50Lm5hbWUgKTtcblx0XHR9LFxuXG5cdFx0dmFsaWRhdGlvblRhcmdldEZvcjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHRcdC8vIElmIHJhZGlvL2NoZWNrYm94LCB2YWxpZGF0ZSBmaXJzdCBlbGVtZW50IGluIGdyb3VwIGluc3RlYWRcblx0XHRcdGlmICggdGhpcy5jaGVja2FibGUoIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZmluZEJ5TmFtZSggZWxlbWVudC5uYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFsd2F5cyBhcHBseSBpZ25vcmUgZmlsdGVyXG5cdFx0XHRyZXR1cm4gJCggZWxlbWVudCApLm5vdCggdGhpcy5zZXR0aW5ncy5pZ25vcmUgKVsgMCBdO1xuXHRcdH0sXG5cblx0XHRjaGVja2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuICggL3JhZGlvfGNoZWNrYm94L2kgKS50ZXN0KCBlbGVtZW50LnR5cGUgKTtcblx0XHR9LFxuXG5cdFx0ZmluZEJ5TmFtZTogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gJCggdGhpcy5jdXJyZW50Rm9ybSApLmZpbmQoIFwiW25hbWU9J1wiICsgdGhpcy5lc2NhcGVDc3NNZXRhKCBuYW1lICkgKyBcIiddXCIgKTtcblx0XHR9LFxuXG5cdFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQgKSB7XG5cdFx0XHRzd2l0Y2ggKCBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRjYXNlIFwic2VsZWN0XCI6XG5cdFx0XHRcdHJldHVybiAkKCBcIm9wdGlvbjpzZWxlY3RlZFwiLCBlbGVtZW50ICkubGVuZ3RoO1xuXHRcdFx0Y2FzZSBcImlucHV0XCI6XG5cdFx0XHRcdGlmICggdGhpcy5jaGVja2FibGUoIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5maWx0ZXIoIFwiOmNoZWNrZWRcIiApLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlLmxlbmd0aDtcblx0XHR9LFxuXG5cdFx0ZGVwZW5kOiBmdW5jdGlvbiggcGFyYW0sIGVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZXBlbmRUeXBlc1sgdHlwZW9mIHBhcmFtIF0gPyB0aGlzLmRlcGVuZFR5cGVzWyB0eXBlb2YgcGFyYW0gXSggcGFyYW0sIGVsZW1lbnQgKSA6IHRydWU7XG5cdFx0fSxcblxuXHRcdGRlcGVuZFR5cGVzOiB7XG5cdFx0XHRcImJvb2xlYW5cIjogZnVuY3Rpb24oIHBhcmFtICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyYW07XG5cdFx0XHR9LFxuXHRcdFx0XCJzdHJpbmdcIjogZnVuY3Rpb24oIHBhcmFtLCBlbGVtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gISEkKCBwYXJhbSwgZWxlbWVudC5mb3JtICkubGVuZ3RoO1xuXHRcdFx0fSxcblx0XHRcdFwiZnVuY3Rpb25cIjogZnVuY3Rpb24oIHBhcmFtLCBlbGVtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyYW0oIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b3B0aW9uYWw6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIHZhbCA9IHRoaXMuZWxlbWVudFZhbHVlKCBlbGVtZW50ICk7XG5cdFx0XHRyZXR1cm4gISQudmFsaWRhdG9yLm1ldGhvZHMucmVxdWlyZWQuY2FsbCggdGhpcywgdmFsLCBlbGVtZW50ICkgJiYgXCJkZXBlbmRlbmN5LW1pc21hdGNoXCI7XG5cdFx0fSxcblxuXHRcdHN0YXJ0UmVxdWVzdDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRpZiAoICF0aGlzLnBlbmRpbmdbIGVsZW1lbnQubmFtZSBdICkge1xuXHRcdFx0XHR0aGlzLnBlbmRpbmdSZXF1ZXN0Kys7XG5cdFx0XHRcdCQoIGVsZW1lbnQgKS5hZGRDbGFzcyggdGhpcy5zZXR0aW5ncy5wZW5kaW5nQ2xhc3MgKTtcblx0XHRcdFx0dGhpcy5wZW5kaW5nWyBlbGVtZW50Lm5hbWUgXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0b3BSZXF1ZXN0OiBmdW5jdGlvbiggZWxlbWVudCwgdmFsaWQgKSB7XG5cdFx0XHR0aGlzLnBlbmRpbmdSZXF1ZXN0LS07XG5cblx0XHRcdC8vIFNvbWV0aW1lcyBzeW5jaHJvbml6YXRpb24gZmFpbHMsIG1ha2Ugc3VyZSBwZW5kaW5nUmVxdWVzdCBpcyBuZXZlciA8IDBcblx0XHRcdGlmICggdGhpcy5wZW5kaW5nUmVxdWVzdCA8IDAgKSB7XG5cdFx0XHRcdHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIHRoaXMucGVuZGluZ1sgZWxlbWVudC5uYW1lIF07XG5cdFx0XHQkKCBlbGVtZW50ICkucmVtb3ZlQ2xhc3MoIHRoaXMuc2V0dGluZ3MucGVuZGluZ0NsYXNzICk7XG5cdFx0XHRpZiAoIHZhbGlkICYmIHRoaXMucGVuZGluZ1JlcXVlc3QgPT09IDAgJiYgdGhpcy5mb3JtU3VibWl0dGVkICYmIHRoaXMuZm9ybSgpICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkuc3VibWl0KCk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBoaWRkZW4gaW5wdXQgdGhhdCB3YXMgdXNlZCBhcyBhIHJlcGxhY2VtZW50IGZvciB0aGVcblx0XHRcdFx0Ly8gbWlzc2luZyBzdWJtaXQgYnV0dG9uLiBUaGUgaGlkZGVuIGlucHV0IGlzIGFkZGVkIGJ5IGBoYW5kbGUoKWBcblx0XHRcdFx0Ly8gdG8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSB1c2VkIHN1Ym1pdCBidXR0b24gaXMgcGFzc2VkIG9uXG5cdFx0XHRcdC8vIGZvciBzY3JpcHRlZCBzdWJtaXRzIHRyaWdnZXJlZCBieSB0aGlzIG1ldGhvZFxuXHRcdFx0XHRpZiAoIHRoaXMuc3VibWl0QnV0dG9uICkge1xuXHRcdFx0XHRcdCQoIFwiaW5wdXQ6aGlkZGVuW25hbWU9J1wiICsgdGhpcy5zdWJtaXRCdXR0b24ubmFtZSArIFwiJ11cIiwgdGhpcy5jdXJyZW50Rm9ybSApLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5mb3JtU3VibWl0dGVkID0gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCAhdmFsaWQgJiYgdGhpcy5wZW5kaW5nUmVxdWVzdCA9PT0gMCAmJiB0aGlzLmZvcm1TdWJtaXR0ZWQgKSB7XG5cdFx0XHRcdCQoIHRoaXMuY3VycmVudEZvcm0gKS50cmlnZ2VySGFuZGxlciggXCJpbnZhbGlkLWZvcm1cIiwgWyB0aGlzIF0gKTtcblx0XHRcdFx0dGhpcy5mb3JtU3VibWl0dGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHByZXZpb3VzVmFsdWU6IGZ1bmN0aW9uKCBlbGVtZW50LCBtZXRob2QgKSB7XG5cdFx0XHRtZXRob2QgPSB0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiICYmIG1ldGhvZCB8fCBcInJlbW90ZVwiO1xuXG5cdFx0XHRyZXR1cm4gJC5kYXRhKCBlbGVtZW50LCBcInByZXZpb3VzVmFsdWVcIiApIHx8ICQuZGF0YSggZWxlbWVudCwgXCJwcmV2aW91c1ZhbHVlXCIsIHtcblx0XHRcdFx0b2xkOiBudWxsLFxuXHRcdFx0XHR2YWxpZDogdHJ1ZSxcblx0XHRcdFx0bWVzc2FnZTogdGhpcy5kZWZhdWx0TWVzc2FnZSggZWxlbWVudCwgeyBtZXRob2Q6IG1ldGhvZCB9IClcblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gQ2xlYW5zIHVwIGFsbCBmb3JtcyBhbmQgZWxlbWVudHMsIHJlbW92ZXMgdmFsaWRhdG9yLXNwZWNpZmljIGV2ZW50c1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNldEZvcm0oKTtcblxuXHRcdFx0JCggdGhpcy5jdXJyZW50Rm9ybSApXG5cdFx0XHRcdC5vZmYoIFwiLnZhbGlkYXRlXCIgKVxuXHRcdFx0XHQucmVtb3ZlRGF0YSggXCJ2YWxpZGF0b3JcIiApXG5cdFx0XHRcdC5maW5kKCBcIi52YWxpZGF0ZS1lcXVhbFRvLWJsdXJcIiApXG5cdFx0XHRcdFx0Lm9mZiggXCIudmFsaWRhdGUtZXF1YWxUb1wiIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidmFsaWRhdGUtZXF1YWxUby1ibHVyXCIgKVxuXHRcdFx0XHQuZmluZCggXCIudmFsaWRhdGUtbGVzc1RoYW4tYmx1clwiIClcblx0XHRcdFx0XHQub2ZmKCBcIi52YWxpZGF0ZS1sZXNzVGhhblwiIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidmFsaWRhdGUtbGVzc1RoYW4tYmx1clwiIClcblx0XHRcdFx0LmZpbmQoIFwiLnZhbGlkYXRlLWxlc3NUaGFuRXF1YWwtYmx1clwiIClcblx0XHRcdFx0XHQub2ZmKCBcIi52YWxpZGF0ZS1sZXNzVGhhbkVxdWFsXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ2YWxpZGF0ZS1sZXNzVGhhbkVxdWFsLWJsdXJcIiApXG5cdFx0XHRcdC5maW5kKCBcIi52YWxpZGF0ZS1ncmVhdGVyVGhhbkVxdWFsLWJsdXJcIiApXG5cdFx0XHRcdFx0Lm9mZiggXCIudmFsaWRhdGUtZ3JlYXRlclRoYW5FcXVhbFwiIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidmFsaWRhdGUtZ3JlYXRlclRoYW5FcXVhbC1ibHVyXCIgKVxuXHRcdFx0XHQuZmluZCggXCIudmFsaWRhdGUtZ3JlYXRlclRoYW4tYmx1clwiIClcblx0XHRcdFx0XHQub2ZmKCBcIi52YWxpZGF0ZS1ncmVhdGVyVGhhblwiIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidmFsaWRhdGUtZ3JlYXRlclRoYW4tYmx1clwiICk7XG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xhc3NSdWxlU2V0dGluZ3M6IHtcblx0XHRyZXF1aXJlZDogeyByZXF1aXJlZDogdHJ1ZSB9LFxuXHRcdGVtYWlsOiB7IGVtYWlsOiB0cnVlIH0sXG5cdFx0dXJsOiB7IHVybDogdHJ1ZSB9LFxuXHRcdGRhdGU6IHsgZGF0ZTogdHJ1ZSB9LFxuXHRcdGRhdGVJU086IHsgZGF0ZUlTTzogdHJ1ZSB9LFxuXHRcdG51bWJlcjogeyBudW1iZXI6IHRydWUgfSxcblx0XHRkaWdpdHM6IHsgZGlnaXRzOiB0cnVlIH0sXG5cdFx0Y3JlZGl0Y2FyZDogeyBjcmVkaXRjYXJkOiB0cnVlIH1cblx0fSxcblxuXHRhZGRDbGFzc1J1bGVzOiBmdW5jdGlvbiggY2xhc3NOYW1lLCBydWxlcyApIHtcblx0XHRpZiAoIGNsYXNzTmFtZS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nICkge1xuXHRcdFx0dGhpcy5jbGFzc1J1bGVTZXR0aW5nc1sgY2xhc3NOYW1lIF0gPSBydWxlcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0JC5leHRlbmQoIHRoaXMuY2xhc3NSdWxlU2V0dGluZ3MsIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fSxcblxuXHRjbGFzc1J1bGVzOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgcnVsZXMgPSB7fSxcblx0XHRcdGNsYXNzZXMgPSAkKCBlbGVtZW50ICkuYXR0ciggXCJjbGFzc1wiICk7XG5cblx0XHRpZiAoIGNsYXNzZXMgKSB7XG5cdFx0XHQkLmVhY2goIGNsYXNzZXMuc3BsaXQoIFwiIFwiICksIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgaW4gJC52YWxpZGF0b3IuY2xhc3NSdWxlU2V0dGluZ3MgKSB7XG5cdFx0XHRcdFx0JC5leHRlbmQoIHJ1bGVzLCAkLnZhbGlkYXRvci5jbGFzc1J1bGVTZXR0aW5nc1sgdGhpcyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJ1bGVzO1xuXHR9LFxuXG5cdG5vcm1hbGl6ZUF0dHJpYnV0ZVJ1bGU6IGZ1bmN0aW9uKCBydWxlcywgdHlwZSwgbWV0aG9kLCB2YWx1ZSApIHtcblxuXHRcdC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGEgbnVtYmVyIGZvciBudW1iZXIgaW5wdXRzLCBhbmQgZm9yIHRleHQgZm9yIGJhY2t3YXJkcyBjb21wYWJpbGl0eVxuXHRcdC8vIGFsbG93cyB0eXBlPVwiZGF0ZVwiIGFuZCBvdGhlcnMgdG8gYmUgY29tcGFyZWQgYXMgc3RyaW5nc1xuXHRcdGlmICggL21pbnxtYXh8c3RlcC8udGVzdCggbWV0aG9kICkgJiYgKCB0eXBlID09PSBudWxsIHx8IC9udW1iZXJ8cmFuZ2V8dGV4dC8udGVzdCggdHlwZSApICkgKSB7XG5cdFx0XHR2YWx1ZSA9IE51bWJlciggdmFsdWUgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydCBPcGVyYSBNaW5pLCB3aGljaCByZXR1cm5zIE5hTiBmb3IgdW5kZWZpbmVkIG1pbmxlbmd0aFxuXHRcdFx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcblx0XHRcdFx0dmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCApIHtcblx0XHRcdHJ1bGVzWyBtZXRob2QgXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IG1ldGhvZCAmJiB0eXBlICE9PSBcInJhbmdlXCIgKSB7XG5cblx0XHRcdC8vIEV4Y2VwdGlvbjogdGhlIGpxdWVyeSB2YWxpZGF0ZSAncmFuZ2UnIG1ldGhvZFxuXHRcdFx0Ly8gZG9lcyBub3QgdGVzdCBmb3IgdGhlIGh0bWw1ICdyYW5nZScgdHlwZVxuXHRcdFx0cnVsZXNbIG1ldGhvZCBdID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0YXR0cmlidXRlUnVsZXM6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBydWxlcyA9IHt9LFxuXHRcdFx0JGVsZW1lbnQgPSAkKCBlbGVtZW50ICksXG5cdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICksXG5cdFx0XHRtZXRob2QsIHZhbHVlO1xuXG5cdFx0Zm9yICggbWV0aG9kIGluICQudmFsaWRhdG9yLm1ldGhvZHMgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgZm9yIDxpbnB1dCByZXF1aXJlZD4gaW4gYm90aCBodG1sNSBhbmQgb2xkZXIgYnJvd3NlcnNcblx0XHRcdGlmICggbWV0aG9kID09PSBcInJlcXVpcmVkXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoIG1ldGhvZCApO1xuXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIGFuIGVtcHR5IHN0cmluZyBmb3IgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyBhbmQgbm9uLUhUTUw1IGJyb3dzZXJzIG1pZ2h0IGhhdmUgcmVxdWlyZWQ9XCJcIiBtYXJrdXBcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJcIiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBub24tSFRNTDUgYnJvd3NlcnMgdG8gcmV0dXJuIGJvb2xcblx0XHRcdFx0dmFsdWUgPSAhIXZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSAkZWxlbWVudC5hdHRyKCBtZXRob2QgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ub3JtYWxpemVBdHRyaWJ1dGVSdWxlKCBydWxlcywgdHlwZSwgbWV0aG9kLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vICdtYXhsZW5ndGgnIG1heSBiZSByZXR1cm5lZCBhcyAtMSwgMjE0NzQ4MzY0NyAoIElFICkgYW5kIDUyNDI4OCAoIHNhZmFyaSApIGZvciB0ZXh0IGlucHV0c1xuXHRcdGlmICggcnVsZXMubWF4bGVuZ3RoICYmIC8tMXwyMTQ3NDgzNjQ3fDUyNDI4OC8udGVzdCggcnVsZXMubWF4bGVuZ3RoICkgKSB7XG5cdFx0XHRkZWxldGUgcnVsZXMubWF4bGVuZ3RoO1xuXHRcdH1cblxuXHRcdHJldHVybiBydWxlcztcblx0fSxcblxuXHRkYXRhUnVsZXM6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBydWxlcyA9IHt9LFxuXHRcdFx0JGVsZW1lbnQgPSAkKCBlbGVtZW50ICksXG5cdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICksXG5cdFx0XHRtZXRob2QsIHZhbHVlO1xuXG5cdFx0Zm9yICggbWV0aG9kIGluICQudmFsaWRhdG9yLm1ldGhvZHMgKSB7XG5cdFx0XHR2YWx1ZSA9ICRlbGVtZW50LmRhdGEoIFwicnVsZVwiICsgbWV0aG9kLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyBtZXRob2Quc3Vic3RyaW5nKCAxICkudG9Mb3dlckNhc2UoKSApO1xuXG5cdFx0XHQvLyBDYXN0IGVtcHR5IGF0dHJpYnV0ZXMgbGlrZSBgZGF0YS1ydWxlLXJlcXVpcmVkYCB0byBgdHJ1ZWBcblx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ub3JtYWxpemVBdHRyaWJ1dGVSdWxlKCBydWxlcywgdHlwZSwgbWV0aG9kLCB2YWx1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcnVsZXM7XG5cdH0sXG5cblx0c3RhdGljUnVsZXM6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBydWxlcyA9IHt9LFxuXHRcdFx0dmFsaWRhdG9yID0gJC5kYXRhKCBlbGVtZW50LmZvcm0sIFwidmFsaWRhdG9yXCIgKTtcblxuXHRcdGlmICggdmFsaWRhdG9yLnNldHRpbmdzLnJ1bGVzICkge1xuXHRcdFx0cnVsZXMgPSAkLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKCB2YWxpZGF0b3Iuc2V0dGluZ3MucnVsZXNbIGVsZW1lbnQubmFtZSBdICkgfHwge307XG5cdFx0fVxuXHRcdHJldHVybiBydWxlcztcblx0fSxcblxuXHRub3JtYWxpemVSdWxlczogZnVuY3Rpb24oIHJ1bGVzLCBlbGVtZW50ICkge1xuXG5cdFx0Ly8gSGFuZGxlIGRlcGVuZGVuY3kgY2hlY2tcblx0XHQkLmVhY2goIHJ1bGVzLCBmdW5jdGlvbiggcHJvcCwgdmFsICkge1xuXG5cdFx0XHQvLyBJZ25vcmUgcnVsZSB3aGVuIHBhcmFtIGlzIGV4cGxpY2l0bHkgZmFsc2UsIGVnLiByZXF1aXJlZDpmYWxzZVxuXHRcdFx0aWYgKCB2YWwgPT09IGZhbHNlICkge1xuXHRcdFx0XHRkZWxldGUgcnVsZXNbIHByb3AgXTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWwucGFyYW0gfHwgdmFsLmRlcGVuZHMgKSB7XG5cdFx0XHRcdHZhciBrZWVwUnVsZSA9IHRydWU7XG5cdFx0XHRcdHN3aXRjaCAoIHR5cGVvZiB2YWwuZGVwZW5kcyApIHtcblx0XHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxuXHRcdFx0XHRcdGtlZXBSdWxlID0gISEkKCB2YWwuZGVwZW5kcywgZWxlbWVudC5mb3JtICkubGVuZ3RoO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRcdFx0XHRrZWVwUnVsZSA9IHZhbC5kZXBlbmRzLmNhbGwoIGVsZW1lbnQsIGVsZW1lbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGtlZXBSdWxlICkge1xuXHRcdFx0XHRcdHJ1bGVzWyBwcm9wIF0gPSB2YWwucGFyYW0gIT09IHVuZGVmaW5lZCA/IHZhbC5wYXJhbSA6IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRhKCBlbGVtZW50LmZvcm0sIFwidmFsaWRhdG9yXCIgKS5yZXNldEVsZW1lbnRzKCAkKCBlbGVtZW50ICkgKTtcblx0XHRcdFx0XHRkZWxldGUgcnVsZXNbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIEV2YWx1YXRlIHBhcmFtZXRlcnNcblx0XHQkLmVhY2goIHJ1bGVzLCBmdW5jdGlvbiggcnVsZSwgcGFyYW1ldGVyICkge1xuXHRcdFx0cnVsZXNbIHJ1bGUgXSA9IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBydWxlICE9PSBcIm5vcm1hbGl6ZXJcIiA/IHBhcmFtZXRlciggZWxlbWVudCApIDogcGFyYW1ldGVyO1xuXHRcdH0gKTtcblxuXHRcdC8vIENsZWFuIG51bWJlciBwYXJhbWV0ZXJzXG5cdFx0JC5lYWNoKCBbIFwibWlubGVuZ3RoXCIsIFwibWF4bGVuZ3RoXCIgXSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJ1bGVzWyB0aGlzIF0gKSB7XG5cdFx0XHRcdHJ1bGVzWyB0aGlzIF0gPSBOdW1iZXIoIHJ1bGVzWyB0aGlzIF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0JC5lYWNoKCBbIFwicmFuZ2VsZW5ndGhcIiwgXCJyYW5nZVwiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBhcnRzO1xuXHRcdFx0aWYgKCBydWxlc1sgdGhpcyBdICkge1xuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHJ1bGVzWyB0aGlzIF0gKSApIHtcblx0XHRcdFx0XHRydWxlc1sgdGhpcyBdID0gWyBOdW1iZXIoIHJ1bGVzWyB0aGlzIF1bIDAgXSApLCBOdW1iZXIoIHJ1bGVzWyB0aGlzIF1bIDEgXSApIF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBydWxlc1sgdGhpcyBdID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHBhcnRzID0gcnVsZXNbIHRoaXMgXS5yZXBsYWNlKCAvW1xcW1xcXV0vZywgXCJcIiApLnNwbGl0KCAvW1xccyxdKy8gKTtcblx0XHRcdFx0XHRydWxlc1sgdGhpcyBdID0gWyBOdW1iZXIoIHBhcnRzWyAwIF0gKSwgTnVtYmVyKCBwYXJ0c1sgMSBdICkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGlmICggJC52YWxpZGF0b3IuYXV0b0NyZWF0ZVJhbmdlcyApIHtcblxuXHRcdFx0Ly8gQXV0by1jcmVhdGUgcmFuZ2VzXG5cdFx0XHRpZiAoIHJ1bGVzLm1pbiAhPSBudWxsICYmIHJ1bGVzLm1heCAhPSBudWxsICkge1xuXHRcdFx0XHRydWxlcy5yYW5nZSA9IFsgcnVsZXMubWluLCBydWxlcy5tYXggXTtcblx0XHRcdFx0ZGVsZXRlIHJ1bGVzLm1pbjtcblx0XHRcdFx0ZGVsZXRlIHJ1bGVzLm1heDtcblx0XHRcdH1cblx0XHRcdGlmICggcnVsZXMubWlubGVuZ3RoICE9IG51bGwgJiYgcnVsZXMubWF4bGVuZ3RoICE9IG51bGwgKSB7XG5cdFx0XHRcdHJ1bGVzLnJhbmdlbGVuZ3RoID0gWyBydWxlcy5taW5sZW5ndGgsIHJ1bGVzLm1heGxlbmd0aCBdO1xuXHRcdFx0XHRkZWxldGUgcnVsZXMubWlubGVuZ3RoO1xuXHRcdFx0XHRkZWxldGUgcnVsZXMubWF4bGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBydWxlcztcblx0fSxcblxuXHQvLyBDb252ZXJ0cyBhIHNpbXBsZSBzdHJpbmcgdG8gYSB7c3RyaW5nOiB0cnVlfSBydWxlLCBlLmcuLCBcInJlcXVpcmVkXCIgdG8ge3JlcXVpcmVkOnRydWV9XG5cdG5vcm1hbGl6ZVJ1bGU6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR2YXIgdHJhbnNmb3JtZWQgPSB7fTtcblx0XHRcdCQuZWFjaCggZGF0YS5zcGxpdCggL1xccy8gKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRyYW5zZm9ybWVkWyB0aGlzIF0gPSB0cnVlO1xuXHRcdFx0fSApO1xuXHRcdFx0ZGF0YSA9IHRyYW5zZm9ybWVkO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2pRdWVyeS52YWxpZGF0b3IuYWRkTWV0aG9kL1xuXHRhZGRNZXRob2Q6IGZ1bmN0aW9uKCBuYW1lLCBtZXRob2QsIG1lc3NhZ2UgKSB7XG5cdFx0JC52YWxpZGF0b3IubWV0aG9kc1sgbmFtZSBdID0gbWV0aG9kO1xuXHRcdCQudmFsaWRhdG9yLm1lc3NhZ2VzWyBuYW1lIF0gPSBtZXNzYWdlICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlIDogJC52YWxpZGF0b3IubWVzc2FnZXNbIG5hbWUgXTtcblx0XHRpZiAoIG1ldGhvZC5sZW5ndGggPCAzICkge1xuXHRcdFx0JC52YWxpZGF0b3IuYWRkQ2xhc3NSdWxlcyggbmFtZSwgJC52YWxpZGF0b3Iubm9ybWFsaXplUnVsZSggbmFtZSApICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvalF1ZXJ5LnZhbGlkYXRvci5tZXRob2RzL1xuXHRtZXRob2RzOiB7XG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3JlcXVpcmVkLW1ldGhvZC9cblx0XHRyZXF1aXJlZDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgZGVwZW5kZW5jeSBpcyBtZXRcblx0XHRcdGlmICggIXRoaXMuZGVwZW5kKCBwYXJhbSwgZWxlbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gXCJkZXBlbmRlbmN5LW1pc21hdGNoXCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIiApIHtcblxuXHRcdFx0XHQvLyBDb3VsZCBiZSBhbiBhcnJheSBmb3Igc2VsZWN0LW11bHRpcGxlIG9yIGEgc3RyaW5nLCBib3RoIGFyZSBmaW5lIHRoaXMgd2F5XG5cdFx0XHRcdHZhciB2YWwgPSAkKCBlbGVtZW50ICkudmFsKCk7XG5cdFx0XHRcdHJldHVybiB2YWwgJiYgdmFsLmxlbmd0aCA+IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuY2hlY2thYmxlKCBlbGVtZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldExlbmd0aCggdmFsdWUsIGVsZW1lbnQgKSA+IDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5sZW5ndGggPiAwO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2VtYWlsLW1ldGhvZC9cblx0XHRlbWFpbDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXG5cdFx0XHQvLyBGcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3Ncblx0XHRcdC8vIFJldHJpZXZlZCAyMDE0LTAxLTE0XG5cdFx0XHQvLyBJZiB5b3UgaGF2ZSBhIHByb2JsZW0gd2l0aCB0aGlzIGltcGxlbWVudGF0aW9uLCByZXBvcnQgYSBidWcgYWdhaW5zdCB0aGUgYWJvdmUgc3BlY1xuXHRcdFx0Ly8gT3IgdXNlIGN1c3RvbSBtZXRob2RzIHRvIGltcGxlbWVudCB5b3VyIG93biBlbWFpbCB2YWxpZGF0aW9uXG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IC9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvLnRlc3QoIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvdXJsLW1ldGhvZC9cblx0XHR1cmw6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCApIHtcblxuXHRcdFx0Ly8gQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGllZ28gUGVyaW5pLCBNSVQgbGljZW5zZWRcblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG5cdFx0XHQvLyBzZWUgYWxzbyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcblx0XHRcdC8vIG1vZGlmaWVkIHRvIGFsbG93IHByb3RvY29sLXJlbGF0aXZlIFVSTHNcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgL14oPzooPzooPzpodHRwcz98ZnRwKTopP1xcL1xcLykoPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ISg/OjEwfDEyNykoPzpcXC5cXGR7MSwzfSl7M30pKD8hKD86MTY5XFwuMjU0fDE5MlxcLjE2OCkoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtejAtOVxcdTAwYTEtXFx1ZmZmZl1bYS16MC05XFx1MDBhMS1cXHVmZmZmXy1dezAsNjJ9KT9bYS16MC05XFx1MDBhMS1cXHVmZmZmXVxcLikrKD86W2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9XFwuPykpKD86OlxcZHsyLDV9KT8oPzpbLz8jXVxcUyopPyQvaS50ZXN0KCB2YWx1ZSApO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2RhdGUtbWV0aG9kL1xuXHRcdGRhdGU6ICggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2FsbGVkID0gZmFsc2U7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQgKSB7XG5cdFx0XHRcdGlmICggIWNhbGxlZCApIHtcblx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdFx0XCJUaGUgYGRhdGVgIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiAnMi4wLjAnLlxcblwiICtcblx0XHRcdFx0XHRcdFx0XCJQbGVhc2UgZG9uJ3QgdXNlIGl0LCBzaW5jZSBpdCByZWxpZXMgb24gdGhlIERhdGUgY29uc3RydWN0b3IsIHdoaWNoXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHRcImJlaGF2ZXMgdmVyeSBkaWZmZXJlbnRseSBhY3Jvc3MgYnJvd3NlcnMgYW5kIGxvY2FsZXMuIFVzZSBgZGF0ZUlTT2BcXG5cIiArXG5cdFx0XHRcdFx0XHRcdFwiaW5zdGVhZCBvciBvbmUgb2YgdGhlIGxvY2FsZSBzcGVjaWZpYyBtZXRob2RzIGluIGBsb2NhbGl6YXRpb25zL2BcXG5cIiArXG5cdFx0XHRcdFx0XHRcdFwiYW5kIGBhZGRpdGlvbmFsLW1ldGhvZHMuanNgLlwiXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgIS9JbnZhbGlkfE5hTi8udGVzdCggbmV3IERhdGUoIHZhbHVlICkudG9TdHJpbmcoKSApO1xuXHRcdFx0fTtcblx0XHR9KCkgKSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvZGF0ZUlTTy1tZXRob2QvXG5cdFx0ZGF0ZUlTTzogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAvXlxcZHs0fVtcXC9cXC1dKDA/WzEtOV18MVswMTJdKVtcXC9cXC1dKDA/WzEtOV18WzEyXVswLTldfDNbMDFdKSQvLnRlc3QoIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvbnVtYmVyLW1ldGhvZC9cblx0XHRudW1iZXI6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgL14oPzotP1xcZCt8LT9cXGR7MSwzfSg/OixcXGR7M30pKyk/KD86XFwuXFxkKyk/JC8udGVzdCggdmFsdWUgKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9kaWdpdHMtbWV0aG9kL1xuXHRcdGRpZ2l0czogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAvXlxcZCskLy50ZXN0KCB2YWx1ZSApO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL21pbmxlbmd0aC1tZXRob2QvXG5cdFx0bWlubGVuZ3RoOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IEFycmF5LmlzQXJyYXkoIHZhbHVlICkgPyB2YWx1ZS5sZW5ndGggOiB0aGlzLmdldExlbmd0aCggdmFsdWUsIGVsZW1lbnQgKTtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgbGVuZ3RoID49IHBhcmFtO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL21heGxlbmd0aC1tZXRob2QvXG5cdFx0bWF4bGVuZ3RoOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IEFycmF5LmlzQXJyYXkoIHZhbHVlICkgPyB2YWx1ZS5sZW5ndGggOiB0aGlzLmdldExlbmd0aCggdmFsdWUsIGVsZW1lbnQgKTtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgbGVuZ3RoIDw9IHBhcmFtO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3JhbmdlbGVuZ3RoLW1ldGhvZC9cblx0XHRyYW5nZWxlbmd0aDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblx0XHRcdHZhciBsZW5ndGggPSBBcnJheS5pc0FycmF5KCB2YWx1ZSApID8gdmFsdWUubGVuZ3RoIDogdGhpcy5nZXRMZW5ndGgoIHZhbHVlLCBlbGVtZW50ICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8ICggbGVuZ3RoID49IHBhcmFtWyAwIF0gJiYgbGVuZ3RoIDw9IHBhcmFtWyAxIF0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9taW4tbWV0aG9kL1xuXHRcdG1pbjogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgdmFsdWUgPj0gcGFyYW07XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvbWF4LW1ldGhvZC9cblx0XHRtYXg6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IHZhbHVlIDw9IHBhcmFtO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3JhbmdlLW1ldGhvZC9cblx0XHRyYW5nZTogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgKCB2YWx1ZSA+PSBwYXJhbVsgMCBdICYmIHZhbHVlIDw9IHBhcmFtWyAxIF0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9zdGVwLW1ldGhvZC9cblx0XHRzdGVwOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0dmFyIHR5cGUgPSAkKCBlbGVtZW50ICkuYXR0ciggXCJ0eXBlXCIgKSxcblx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gXCJTdGVwIGF0dHJpYnV0ZSBvbiBpbnB1dCB0eXBlIFwiICsgdHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQuXCIsXG5cdFx0XHRcdHN1cHBvcnRlZFR5cGVzID0gWyBcInRleHRcIiwgXCJudW1iZXJcIiwgXCJyYW5nZVwiIF0sXG5cdFx0XHRcdHJlID0gbmV3IFJlZ0V4cCggXCJcXFxcYlwiICsgdHlwZSArIFwiXFxcXGJcIiApLFxuXHRcdFx0XHRub3RTdXBwb3J0ZWQgPSB0eXBlICYmICFyZS50ZXN0KCBzdXBwb3J0ZWRUeXBlcy5qb2luKCkgKSxcblx0XHRcdFx0ZGVjaW1hbFBsYWNlcyA9IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoID0gKCBcIlwiICsgbnVtICkubWF0Y2goIC8oPzpcXC4oXFxkKykpPyQvICk7XG5cdFx0XHRcdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOdW1iZXIgb2YgZGlnaXRzIHJpZ2h0IG9mIGRlY2ltYWwgcG9pbnQuXG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoWyAxIF0gPyBtYXRjaFsgMSBdLmxlbmd0aCA6IDA7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvSW50ID0gZnVuY3Rpb24oIG51bSApIHtcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggbnVtICogTWF0aC5wb3coIDEwLCBkZWNpbWFscyApICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZhbGlkID0gdHJ1ZSxcblx0XHRcdFx0ZGVjaW1hbHM7XG5cblx0XHRcdC8vIFdvcmtzIG9ubHkgZm9yIHRleHQsIG51bWJlciBhbmQgcmFuZ2UgaW5wdXQgdHlwZXNcblx0XHRcdC8vIFRPRE8gZmluZCBhIHdheSB0byBzdXBwb3J0IGlucHV0IHR5cGVzIGRhdGUsIGRhdGV0aW1lLCBkYXRldGltZS1sb2NhbCwgbW9udGgsIHRpbWUgYW5kIHdlZWtcblx0XHRcdGlmICggbm90U3VwcG9ydGVkICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWNpbWFscyA9IGRlY2ltYWxQbGFjZXMoIHBhcmFtICk7XG5cblx0XHRcdC8vIFZhbHVlIGNhbid0IGhhdmUgdG9vIG1hbnkgZGVjaW1hbHNcblx0XHRcdGlmICggZGVjaW1hbFBsYWNlcyggdmFsdWUgKSA+IGRlY2ltYWxzIHx8IHRvSW50KCB2YWx1ZSApICUgdG9JbnQoIHBhcmFtICkgIT09IDAgKSB7XG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgdmFsaWQ7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvZXF1YWxUby1tZXRob2QvXG5cdFx0ZXF1YWxUbzogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblxuXHRcdFx0Ly8gQmluZCB0byB0aGUgYmx1ciBldmVudCBvZiB0aGUgdGFyZ2V0IGluIG9yZGVyIHRvIHJldmFsaWRhdGUgd2hlbmV2ZXIgdGhlIHRhcmdldCBmaWVsZCBpcyB1cGRhdGVkXG5cdFx0XHR2YXIgdGFyZ2V0ID0gJCggcGFyYW0gKTtcblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5vbmZvY3Vzb3V0ICYmIHRhcmdldC5ub3QoIFwiLnZhbGlkYXRlLWVxdWFsVG8tYmx1clwiICkubGVuZ3RoICkge1xuXHRcdFx0XHR0YXJnZXQuYWRkQ2xhc3MoIFwidmFsaWRhdGUtZXF1YWxUby1ibHVyXCIgKS5vbiggXCJibHVyLnZhbGlkYXRlLWVxdWFsVG9cIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCggZWxlbWVudCApLnZhbGlkKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0LnZhbCgpO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3JlbW90ZS1tZXRob2QvXG5cdFx0cmVtb3RlOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtLCBtZXRob2QgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIFwiZGVwZW5kZW5jeS1taXNtYXRjaFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXRob2QgPSB0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiICYmIG1ldGhvZCB8fCBcInJlbW90ZVwiO1xuXG5cdFx0XHR2YXIgcHJldmlvdXMgPSB0aGlzLnByZXZpb3VzVmFsdWUoIGVsZW1lbnQsIG1ldGhvZCApLFxuXHRcdFx0XHR2YWxpZGF0b3IsIGRhdGEsIG9wdGlvbkRhdGFTdHJpbmc7XG5cblx0XHRcdGlmICggIXRoaXMuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdICkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLm1lc3NhZ2VzWyBlbGVtZW50Lm5hbWUgXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cHJldmlvdXMub3JpZ2luYWxNZXNzYWdlID0gcHJldmlvdXMub3JpZ2luYWxNZXNzYWdlIHx8IHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdWyBtZXRob2QgXTtcblx0XHRcdHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdWyBtZXRob2QgXSA9IHByZXZpb3VzLm1lc3NhZ2U7XG5cblx0XHRcdHBhcmFtID0gdHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiICYmIHsgdXJsOiBwYXJhbSB9IHx8IHBhcmFtO1xuXHRcdFx0b3B0aW9uRGF0YVN0cmluZyA9ICQucGFyYW0oICQuZXh0ZW5kKCB7IGRhdGE6IHZhbHVlIH0sIHBhcmFtLmRhdGEgKSApO1xuXHRcdFx0aWYgKCBwcmV2aW91cy5vbGQgPT09IG9wdGlvbkRhdGFTdHJpbmcgKSB7XG5cdFx0XHRcdHJldHVybiBwcmV2aW91cy52YWxpZDtcblx0XHRcdH1cblxuXHRcdFx0cHJldmlvdXMub2xkID0gb3B0aW9uRGF0YVN0cmluZztcblx0XHRcdHZhbGlkYXRvciA9IHRoaXM7XG5cdFx0XHR0aGlzLnN0YXJ0UmVxdWVzdCggZWxlbWVudCApO1xuXHRcdFx0ZGF0YSA9IHt9O1xuXHRcdFx0ZGF0YVsgZWxlbWVudC5uYW1lIF0gPSB2YWx1ZTtcblx0XHRcdCQuYWpheCggJC5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0bW9kZTogXCJhYm9ydFwiLFxuXHRcdFx0XHRwb3J0OiBcInZhbGlkYXRlXCIgKyBlbGVtZW50Lm5hbWUsXG5cdFx0XHRcdGRhdGFUeXBlOiBcImpzb25cIixcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0Y29udGV4dDogdmFsaWRhdG9yLmN1cnJlbnRGb3JtLFxuXHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbGlkID0gcmVzcG9uc2UgPT09IHRydWUgfHwgcmVzcG9uc2UgPT09IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdFx0ZXJyb3JzLCBtZXNzYWdlLCBzdWJtaXR0ZWQ7XG5cblx0XHRcdFx0XHR2YWxpZGF0b3Iuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdWyBtZXRob2QgXSA9IHByZXZpb3VzLm9yaWdpbmFsTWVzc2FnZTtcblx0XHRcdFx0XHRpZiAoIHZhbGlkICkge1xuXHRcdFx0XHRcdFx0c3VibWl0dGVkID0gdmFsaWRhdG9yLmZvcm1TdWJtaXR0ZWQ7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IucmVzZXRJbnRlcm5hbHMoKTtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci50b0hpZGUgPSB2YWxpZGF0b3IuZXJyb3JzRm9yKCBlbGVtZW50ICk7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IuZm9ybVN1Ym1pdHRlZCA9IHN1Ym1pdHRlZDtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5zdWNjZXNzTGlzdC5wdXNoKCBlbGVtZW50ICk7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IuaW52YWxpZFsgZWxlbWVudC5uYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5zaG93RXJyb3JzKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVycm9ycyA9IHt9O1xuXHRcdFx0XHRcdFx0bWVzc2FnZSA9IHJlc3BvbnNlIHx8IHZhbGlkYXRvci5kZWZhdWx0TWVzc2FnZSggZWxlbWVudCwgeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1ldGVyczogdmFsdWUgfSApO1xuXHRcdFx0XHRcdFx0ZXJyb3JzWyBlbGVtZW50Lm5hbWUgXSA9IHByZXZpb3VzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdFx0XHRcdFx0dmFsaWRhdG9yLmludmFsaWRbIGVsZW1lbnQubmFtZSBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5zaG93RXJyb3JzKCBlcnJvcnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJldmlvdXMudmFsaWQgPSB2YWxpZDtcblx0XHRcdFx0XHR2YWxpZGF0b3Iuc3RvcFJlcXVlc3QoIGVsZW1lbnQsIHZhbGlkICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHBhcmFtICkgKTtcblx0XHRcdHJldHVybiBcInBlbmRpbmdcIjtcblx0XHR9XG5cdH1cblxufSApO1xuXHJcbi8vIEFqYXggbW9kZTogYWJvcnRcbi8vIHVzYWdlOiAkLmFqYXgoeyBtb2RlOiBcImFib3J0XCJbLCBwb3J0OiBcInVuaXF1ZXBvcnRcIl19KTtcbi8vIGlmIG1vZGU6XCJhYm9ydFwiIGlzIHVzZWQsIHRoZSBwcmV2aW91cyByZXF1ZXN0IG9uIHRoYXQgcG9ydCAocG9ydCBjYW4gYmUgdW5kZWZpbmVkKSBpcyBhYm9ydGVkIHZpYSBYTUxIdHRwUmVxdWVzdC5hYm9ydCgpXG5cbnZhciBwZW5kaW5nUmVxdWVzdHMgPSB7fSxcblx0YWpheDtcblxuLy8gVXNlIGEgcHJlZmlsdGVyIGlmIGF2YWlsYWJsZSAoMS41KylcbmlmICggJC5hamF4UHJlZmlsdGVyICkge1xuXHQkLmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzZXR0aW5ncywgXywgeGhyICkge1xuXHRcdHZhciBwb3J0ID0gc2V0dGluZ3MucG9ydDtcblx0XHRpZiAoIHNldHRpbmdzLm1vZGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdGlmICggcGVuZGluZ1JlcXVlc3RzWyBwb3J0IF0gKSB7XG5cdFx0XHRcdHBlbmRpbmdSZXF1ZXN0c1sgcG9ydCBdLmFib3J0KCk7XG5cdFx0XHR9XG5cdFx0XHRwZW5kaW5nUmVxdWVzdHNbIHBvcnQgXSA9IHhocjtcblx0XHR9XG5cdH0gKTtcbn0gZWxzZSB7XG5cblx0Ly8gUHJveHkgYWpheFxuXHRhamF4ID0gJC5hamF4O1xuXHQkLmFqYXggPSBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0dmFyIG1vZGUgPSAoIFwibW9kZVwiIGluIHNldHRpbmdzID8gc2V0dGluZ3MgOiAkLmFqYXhTZXR0aW5ncyApLm1vZGUsXG5cdFx0XHRwb3J0ID0gKCBcInBvcnRcIiBpbiBzZXR0aW5ncyA/IHNldHRpbmdzIDogJC5hamF4U2V0dGluZ3MgKS5wb3J0O1xuXHRcdGlmICggbW9kZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0aWYgKCBwZW5kaW5nUmVxdWVzdHNbIHBvcnQgXSApIHtcblx0XHRcdFx0cGVuZGluZ1JlcXVlc3RzWyBwb3J0IF0uYWJvcnQoKTtcblx0XHRcdH1cblx0XHRcdHBlbmRpbmdSZXF1ZXN0c1sgcG9ydCBdID0gYWpheC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRyZXR1cm4gcGVuZGluZ1JlcXVlc3RzWyBwb3J0IF07XG5cdFx0fVxuXHRcdHJldHVybiBhamF4LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fTtcbn1cbnJldHVybiAkO1xyXG59KSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jquery-validation/dist/jquery.validate.js\n");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.6.0\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-03-02T17:08Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif (  true && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar flat = arr.flat ? function( array ) {\n\treturn arr.flat.call( array );\n} : function( array ) {\n\treturn arr.concat.apply( [], array );\n};\n\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n\t\t// Support: Chrome <=57, Firefox <=52\n\t\t// In some browsers, typeof returns \"function\" for HTML <object> elements\n\t\t// (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n\t\t// We don't want to classify *any* DOM node as a function.\n\t\t// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n\t\t// Plus for old WebKit, typeof returns \"function\" for HTML collections\n\t\t// (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n\t\treturn typeof obj === \"function\" && typeof obj.nodeType !== \"number\" &&\n\t\t\ttypeof obj.item !== \"function\";\n\t};\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\nvar document = window.document;\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnonce: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, node, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar i, val,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\n\t\t\t\t// Support: Firefox 64+, Edge 18+\n\t\t\t\t// Some browsers don't support the \"nonce\" property on scripts.\n\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n\t\t\t\t// becomes browsing-context connected.\n\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n\t\t\t\t// The `node.getAttribute` check was added for the sake of\n\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n\t\t\t\t// via an object.\n\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n\t\t\t\tif ( val ) {\n\t\t\t\t\tscript.setAttribute( i, val );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.6.0\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teven: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn ( i + 1 ) % 2;\n\t\t} ) );\n\t},\n\n\todd: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn i % 2;\n\t\t} ) );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent Object.prototype pollution\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\t\t\t\t\tsrc = target[ name ];\n\n\t\t\t\t\t// Ensure proper type for the source value\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n\t\t\t\t\t\tclone = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src;\n\t\t\t\t\t}\n\t\t\t\t\tcopyIsArray = false;\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a provided context; falls back to the global one\n\t// if not specified.\n\tglobalEval: function( code, options, doc ) {\n\t\tDOMEval( code, { nonce: options && options.nonce }, doc );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn flat( ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n\tfunction( _i, name ) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.6\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2021-02-16\n */\n( function( window ) {\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ( {} ).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpushNative = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" +\n\t\t\"ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\n\t\t// \"Attribute values must be CSS identifiers [capture 5]\n\t\t// or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n\t\twhitespace + \"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" +\n\t\twhitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace +\n\t\t\"*\" ),\n\trdescend = new RegExp( whitespace + \"|>\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace +\n\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n\tfunescape = function( escape, nonHex ) {\n\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n\n\t\treturn nonHex ?\n\n\t\t\t// Strip the backslash prefix from a non-hex escape sequence\n\t\t\tnonHex :\n\n\t\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n\t\t\t// Support: IE <=11+\n\t\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n\t\t\t// surrogate pair\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" +\n\t\t\t\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n\t\tpreferredDoc.childNodes\n\t);\n\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\t// eslint-disable-next-line no-unused-expressions\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpushNative.apply( target, slice.call( els ) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\t\tsetDocument( context );\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[ 2 ] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t( nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\" ) ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// The technique has to be used as well when a leading combinator is used\n\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 &&\n\t\t\t\t\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\n\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n\t\t\t\t\t// supports it & if we're not changing the context.\n\t\t\t\t\tif ( newContext !== context || !support.scope ) {\n\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn ( cache[ key + \" \" ] = value );\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement( \"fieldset\" );\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch ( e ) {\n\t\treturn false;\n\t} finally {\n\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split( \"|\" ),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[ i ] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( ( cur = cur.nextSibling ) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn ( name === \"input\" || name === \"button\" ) && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction( function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction( function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t} );\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem && elem.namespaceURI,\n\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( preferredDoc != document &&\n\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n\t// IE/Edge & older browsers don't support the :scope pseudo-class.\n\t// Support: Safari 6.0 only\n\t// Safari 6.0 supports :scope but it's an alias of :root there.\n\tsupport.scope = assert( function( el ) {\n\t\tdocElem.appendChild( el ).appendChild( document.createElement( \"div\" ) );\n\t\treturn typeof el.querySelectorAll !== \"undefined\" &&\n\t\t\t!el.querySelectorAll( \":scope fieldset div\" ).length;\n\t} );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert( function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute( \"className\" );\n\t} );\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert( function( el ) {\n\t\tel.appendChild( document.createComment( \"\" ) );\n\t\treturn !el.getElementsByTagName( \"*\" ).length;\n\t} );\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert( function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t} );\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[ \"ID\" ] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[ \"ID\" ] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode( \"id\" );\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[ \"TAG\" ] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[ \"CLASS\" ] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\n\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert( function( el ) {\n\n\t\t\tvar input;\n\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll( \"[msallowcapture^='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"~=\" );\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 15 - 18+\n\t\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n\t\t\t// Adding a temporary attribute to the document before the selection works\n\t\t\t// around the issue.\n\t\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n\t\t\tinput = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"name\", \"\" );\n\t\t\tel.appendChild( input );\n\t\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n\t\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n\t\t\t\trbuggyQSA.push( \":checked\" );\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n\t\t\t}\n\n\t\t\t// Support: Firefox <=3.6 - 5 only\n\t\t\t// Old Firefox doesn't throw on a badly-escaped identifier.\n\t\t\tel.querySelectorAll( \"\\\\\\f\" );\n\t\t\trbuggyQSA.push( \"[\\\\r\\\\n\\\\f]\" );\n\t\t} );\n\n\t\tassert( function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll( \"[name=d]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll( \":enabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: Opera 10 - 11 only\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll( \"*,:x\" );\n\t\t\trbuggyQSA.push( \",.*:\" );\n\t\t} );\n\t}\n\n\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector ) ) ) ) {\n\n\t\tassert( function( el ) {\n\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t} );\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( \"|\" ) );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t) );\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( ( b = b.parentNode ) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( a == document || a.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, a ) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( b == document || b.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, b ) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\treturn a == document ? -1 :\n\t\t\t\tb == document ? 1 :\n\t\t\t\t/* eslint-enable eqeqeq */\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[ i ] === bp[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[ i ], bp[ i ] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\tap[ i ] == preferredDoc ? -1 :\n\t\t\tbp[ i ] == preferredDoc ? 1 :\n\t\t\t/* eslint-enable eqeqeq */\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\tsetDocument( elem );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\n\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t// fragment in IE 9\n\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( context.ownerDocument || context ) != document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( elem.ownerDocument || elem ) != document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( ( node = elem[ i++ ] ) ) {\n\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\n\t\t\t\tmatch[ 5 ] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[ 2 ] === \"~=\" ) {\n\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n\n\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[ 3 ] ) {\n\t\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" ) );\n\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n\n\t\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[ 3 ] ) {\n\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n\n\t\t\tif ( matchExpr[ \"CHILD\" ].test( match[ 0 ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[ 3 ] ) {\n\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn true;\n\t\t\t\t} :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace +\n\t\t\t\t\t\")\" + className + \"(\" + whitespace + \"|$)\" ) ) && classCache(\n\t\t\t\t\t\tclassName, function( elem ) {\n\t\t\t\t\t\t\treturn pattern.test(\n\t\t\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n\t\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n\t\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n\t\t\t\t\t\t\t\t\"\"\n\t\t\t\t\t\t\t);\n\t\t\t\t} );\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\t/* eslint-disable max-len */\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t\t/* eslint-enable max-len */\n\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, _argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction( function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[ i ] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} ) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction( function( selector ) {\n\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) :\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tinput[ 0 ] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[ 0 ] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t} ),\n\n\t\t\"has\": markFunction( function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t} ),\n\n\t\t\"contains\": markFunction( function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t} ),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t} ),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement &&\n\t\t\t\t( !document.hasFocus || document.hasFocus() ) &&\n\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn ( nodeName === \"input\" && !!elem.checked ) ||\n\t\t\t\t( nodeName === \"option\" && !!elem.selected );\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[ \"empty\" ]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n\t\t\t\t\tattr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo( function() {\n\t\t\treturn [ 0 ];\n\t\t} ),\n\n\t\t\"last\": createPositionalPseudo( function( _matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t} ),\n\n\t\t\"eq\": createPositionalPseudo( function( _matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t} ),\n\n\t\t\"even\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"odd\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"lt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"gt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} )\n\t}\n};\n\nExpr.pseudos[ \"nth\" ] = Expr.pseudos[ \"eq\" ];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n\t\t\tif ( match ) {\n\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( ( tokens = [] ) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( ( match = rcombinators.exec( soFar ) ) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push( {\n\t\t\t\tvalue: matched,\n\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[ 0 ].replace( rtrim, \" \" )\n\t\t\t} );\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push( {\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t} );\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[ i ].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] ||\n\t\t\t\t\t\t\t( outerCache[ elem.uniqueID ] = {} );\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[ 0 ];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[ i ], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction( function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts(\n\t\t\t\tselector || \"*\",\n\t\t\t\tcontext.nodeType ? [ context ] : context,\n\t\t\t\t[]\n\t\t\t),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n\t\t\t\t\t\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\n\n\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t} );\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t( checkContext = context ).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\n\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\ttokens\n\t\t\t\t\t\t.slice( 0, i - 1 )\n\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[ \"TAG\" ]( \"*\", outermost ),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\toutermostContext = context == document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[ i ] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache(\n\t\t\tselector,\n\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\n\t\t);\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n\n\t\t\tcontext = ( Expr.find[ \"ID\" ]( token.matches[ 0 ]\n\t\t\t\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[ \"needsContext\" ].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[ i ];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( ( seed = find(\n\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext\n\t\t\t\t) ) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert( function( el ) {\n\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n} );\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert( function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute( \"href\" ) === \"#\";\n} ) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert( function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n} ) ) {\n\taddHandle( \"value\", function( elem, _name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert( function( el ) {\n\treturn el.getAttribute( \"disabled\" ) == null;\n} ) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t}\n\t} );\n}\n\nreturn Sizzle;\n\n} )( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n}\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\tif ( elem.contentDocument != null &&\n\n\t\t\t// Support: IE 11+\n\t\t\t// <object> elements with no `data` attribute has an object\n\t\t\t// `contentDocument` with a `null` prototype.\n\t\t\tgetProto( elem.contentDocument ) ) {\n\n\t\t\treturn elem.contentDocument;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t// Treat the template element as a regular one in browsers that\n\t\t// don't support it.\n\t\tif ( nodeName( elem, \"template\" ) ) {\n\t\t\telem = elem.content || elem;\n\t\t}\n\n\t\treturn jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the primary Deferred\n\t\t\tprimary = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( primary.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn primary.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n\t\t}\n\n\t\treturn primary.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, _key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\t\tvalue :\n\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( _all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar documentElement = document.documentElement;\n\n\n\n\tvar isAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n\t\t},\n\t\tcomposed = { composed: true };\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n\t// Support: iOS 10.0-10.2 only\n\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n\t// leading to errors. We need to check for `getRootNode`.\n\tif ( documentElement.getRootNode ) {\n\t\tisAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n\t\t};\n\t}\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tisAttached( elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = elem.nodeType &&\n\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n\t// Support: IE <=9 only\n\t// IE <=9 replaces <option> tags with their contents when inserted outside of\n\t// the select element.\n\tdiv.innerHTML = \"<option></option>\";\n\tsupport.option = !!div.lastChild;\n} )();\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: IE <=9 only\nif ( !support.option ) {\n\twrapMap.optgroup = wrapMap.option = [ 1, \"<select multiple='multiple'>\", \"</select>\" ];\n}\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, attached, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tattached = isAttached( elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( attached ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\nvar rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 - 11+\n// focus() and blur() are asynchronous, except when they are no-op.\n// So expect focus to be synchronous when the element is already active,\n// and blur to be synchronous when the element is not already active.\n// (focus and blur are always synchronous in other supported browsers,\n// this just defines when we can count on it).\nfunction expectSync( elem, type ) {\n\treturn ( elem === safeActiveElement() ) === ( type === \"focus\" );\n}\n\n// Support: IE <=9 only\n// Accessing document.activeElement can throw unexpectedly\n// https://bugs.jquery.com/ticket/13393\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Only attach events to objects that accept data\n\t\tif ( !acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = Object.create( null );\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix( nativeEvent ),\n\n\t\t\thandlers = (\n\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n\t\t\t)[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n\t\t\t\t// specially universal or its namespaces are a superset of the event's.\n\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\tleverageNative( el, \"click\" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n\t\t\t\t\tnodeName( target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Ensure the presence of an event listener that handles manually-triggered\n// synthetic events by interrupting progress until reinvoked in response to\n// *native* events that it fires directly, ensuring that state changes have\n// already occurred before other listeners are invoked.\nfunction leverageNative( el, type, expectSync ) {\n\n\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n\tif ( !expectSync ) {\n\t\tif ( dataPriv.get( el, type ) === undefined ) {\n\t\t\tjQuery.event.add( el, type, returnTrue );\n\t\t}\n\t\treturn;\n\t}\n\n\t// Register the controller as a special universal handler for all event namespaces\n\tdataPriv.set( el, type, false );\n\tjQuery.event.add( el, type, {\n\t\tnamespace: false,\n\t\thandler: function( event ) {\n\t\t\tvar notAsync, result,\n\t\t\t\tsaved = dataPriv.get( this, type );\n\n\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n\n\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n\t\t\t\t// from an async native handler (gh-4350)\n\t\t\t\tif ( !saved.length ) {\n\n\t\t\t\t\t// Store arguments for use when handling the inner native event\n\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n\t\t\t\t\t// will not be confused with a leftover capture object.\n\t\t\t\t\tsaved = slice.call( arguments );\n\t\t\t\t\tdataPriv.set( this, type, saved );\n\n\t\t\t\t\t// Trigger the native event and capture its result\n\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t// focus() and blur() are asynchronous\n\t\t\t\t\tnotAsync = expectSync( this, type );\n\t\t\t\t\tthis[ type ]();\n\t\t\t\t\tresult = dataPriv.get( this, type );\n\t\t\t\t\tif ( saved !== result || notAsync ) {\n\t\t\t\t\t\tdataPriv.set( this, type, false );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( saved !== result ) {\n\n\t\t\t\t\t\t// Cancel the outer synthetic event\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t\t// Support: Chrome 86+\n\t\t\t\t\t\t// In Chrome, if an element having a focusout handler is blurred by\n\t\t\t\t\t\t// clicking outside of it, it invokes the handler synchronously. If\n\t\t\t\t\t\t// that handler calls `.remove()` on the element, the data is cleared,\n\t\t\t\t\t\t// leaving `result` undefined. We need to guard against this.\n\t\t\t\t\t\treturn result && result.value;\n\t\t\t\t\t}\n\n\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n\t\t\t\t// native event and prevent that from happening again here.\n\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n\t\t\t\t// less bad than duplication.\n\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t// If this is a native event triggered above, everything is now in order\n\t\t\t// Fire an inner synthetic event with the original arguments\n\t\t\t} else if ( saved.length ) {\n\n\t\t\t\t// ...and capture the result\n\t\t\t\tdataPriv.set( this, type, {\n\t\t\t\t\tvalue: jQuery.event.trigger(\n\n\t\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n\t\t\t\t\t\tsaved.slice( 1 ),\n\t\t\t\t\t\tthis\n\t\t\t\t\t)\n\t\t\t\t} );\n\n\t\t\t\t// Abort handling of the native event\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t} );\n}\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcode: true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\twhich: true\n}, jQuery.event.addProp );\n\njQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n\tjQuery.event.special[ type ] = {\n\n\t\t// Utilize native event if possible so blur/focus sequence is correct\n\t\tsetup: function() {\n\n\t\t\t// Claim the first handler\n\t\t\t// dataPriv.set( this, \"focus\", ... )\n\t\t\t// dataPriv.set( this, \"blur\", ... )\n\t\t\tleverageNative( this, type, expectSync );\n\n\t\t\t// Return false to allow normal processing in the caller\n\t\t\treturn false;\n\t\t},\n\t\ttrigger: function() {\n\n\t\t\t// Force setup before trigger\n\t\t\tleverageNative( this, type );\n\n\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\treturn true;\n\t\t},\n\n\t\t// Suppress native focus or blur as it's already being fired\n\t\t// in leverageNative.\n\t\t_default: function() {\n\t\t\treturn true;\n\t\t},\n\n\t\tdelegateType: delegateType\n\t};\n} );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.get( src );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdataPriv.remove( dest, \"handle events\" );\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = flat( args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n\t\t\t\t\t\t\t\t}, doc );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && isAttached( node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html;\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = isAttached( elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar swap = function( elem, options, callback ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.call( elem );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t// Support: Chrome <=64\n\t\t// Don't get tricked when zoom affects offsetWidth (gh-4029)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableTrDimensionsVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t},\n\n\t\t// Support: IE 9 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Behavior in IE 9 is more subtle than in newer versions & it passes\n\t\t// some versions of this test; make sure not to make it pass there!\n\t\t//\n\t\t// Support: Firefox 70+\n\t\t// Only Firefox includes border widths\n\t\t// in computed dimensions. (gh-4529)\n\t\treliableTrDimensions: function() {\n\t\t\tvar table, tr, trChild, trStyle;\n\t\t\tif ( reliableTrDimensionsVal == null ) {\n\t\t\t\ttable = document.createElement( \"table\" );\n\t\t\t\ttr = document.createElement( \"tr\" );\n\t\t\t\ttrChild = document.createElement( \"div\" );\n\n\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n\t\t\t\ttr.style.cssText = \"border:1px solid\";\n\n\t\t\t\t// Support: Chrome 86+\n\t\t\t\t// Height set through cssText does not get applied.\n\t\t\t\t// Computed height then comes back as 0.\n\t\t\t\ttr.style.height = \"1px\";\n\t\t\t\ttrChild.style.height = \"9px\";\n\n\t\t\t\t// Support: Android 8 Chrome 86+\n\t\t\t\t// In our bodyBackground.html iframe,\n\t\t\t\t// display for all div elements is set to \"inline\",\n\t\t\t\t// which causes a problem only in Android 8 Chrome 86.\n\t\t\t\t// Ensuring the div is display: block\n\t\t\t\t// gets around this issue.\n\t\t\t\ttrChild.style.display = \"block\";\n\n\t\t\t\tdocumentElement\n\t\t\t\t\t.appendChild( table )\n\t\t\t\t\t.appendChild( tr )\n\t\t\t\t\t.appendChild( trChild );\n\n\t\t\t\ttrStyle = window.getComputedStyle( tr );\n\t\t\t\treliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +\n\t\t\t\t\tparseInt( trStyle.borderTopWidth, 10 ) +\n\t\t\t\t\tparseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;\n\n\t\t\t\tdocumentElement.removeChild( table );\n\t\t\t}\n\t\t\treturn reliableTrDimensionsVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style,\n\tvendorProps = {};\n\n// Return a vendor-prefixed property or undefined\nfunction vendorPropName( name ) {\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\nfunction finalPropName( name ) {\n\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n\n\tif ( final ) {\n\t\treturn final;\n\t}\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t};\n\nfunction setPositiveNumber( _elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\n\t\t// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n\t\t// Use an explicit zero to avoid NaN (gh-3964)\n\t\t) ) || 0;\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\n\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n\t\t// Fake content-box until we know it's needed to know the true value.\n\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n\t\tisBorderBox = boxSizingNeeded &&\n\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox,\n\n\t\tval = curCSS( elem, dimension, styles ),\n\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\n\t// Support: IE 9 - 11 only\n\t// Use offsetWidth/offsetHeight for when box sizing is unreliable.\n\t// In those cases, the computed value can be trusted to be border-box.\n\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n\n\t\t// Support: IE 10 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Interestingly, in some cases IE 9 doesn't suffer from this issue.\n\t\t!support.reliableTrDimensions() && nodeName( elem, \"tr\" ) ||\n\n\t\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t\t// This happens for inline elements with no explicit setting (gh-3571)\n\t\tval === \"auto\" ||\n\n\t\t// Support: Android <=4.1 - 4.3 only\n\t\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n\n\t\t// Make sure the element is visible & connected\n\t\telem.getClientRects().length ) {\n\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n\t\t// retrieved value as a content box dimension.\n\t\tvalueIsBorderBox = offsetProp in elem;\n\t\tif ( valueIsBorderBox ) {\n\t\t\tval = elem[ offsetProp ];\n\t\t}\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"gridArea\": true,\n\t\t\"gridColumn\": true,\n\t\t\"gridColumnEnd\": true,\n\t\t\"gridColumnStart\": true,\n\t\t\"gridRow\": true,\n\t\t\"gridRowEnd\": true,\n\t\t\"gridRowStart\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n\t\t\t// \"px\" to a few hardcoded values.\n\t\t\tif ( type === \"number\" && !isCustomProp ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( _i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t} ) :\n\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\n\t\t\t\t// Only read styles.position if the test has a chance to fail\n\t\t\t\t// to avoid forcing a reflow.\n\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n\t\t\t\t\tstyles.position === \"absolute\",\n\n\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n\t\t\t\tisBorderBox = boxSizingNeeded &&\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra ?\n\t\t\t\t\tboxModelAdjustment(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tdimension,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tisBorderBox,\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) :\n\t\t\t\t\t0;\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 && (\n\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\n\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( _i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( _i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || Object.create( null ) )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\n\t\t\t\t// Handle: regular nodes (via `this.ownerDocument`), window\n\t\t\t\t// (via `this.document`) & document (via `this`).\n\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = { guid: Date.now() };\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, parserErrorElem;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {}\n\n\tparserErrorElem = xml && xml.getElementsByTagName( \"parsererror\" )[ 0 ];\n\tif ( !xml || parserErrorElem ) {\n\t\tjQuery.error( \"Invalid XML: \" + (\n\t\t\tparserErrorElem ?\n\t\t\t\tjQuery.map( parserErrorElem.childNodes, function( el ) {\n\t\t\t\t\treturn el.textContent;\n\t\t\t\t} ).join( \"\\n\" ) :\n\t\t\t\tdata\n\t\t) );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\tif ( a == null ) {\n\t\treturn \"\";\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} ).filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} ).map( function( _i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\noriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce.guid++ ) +\n\t\t\t\t\tuncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Use a noop converter for missing script but not if jsonp\n\t\t\tif ( !isSuccess &&\n\t\t\t\tjQuery.inArray( \"script\", s.dataTypes ) > -1 &&\n\t\t\t\tjQuery.inArray( \"json\", s.dataTypes ) < 0 ) {\n\t\t\t\ts.converters[ \"text script\" ] = function() {};\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( _i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\njQuery.ajaxPrefilter( function( s ) {\n\tvar i;\n\tfor ( i in s.headers ) {\n\t\tif ( i.toLowerCase() === \"content-type\" ) {\n\t\t\ts.contentType = s.headers[ i ] || \"\";\n\t\t}\n\t}\n} );\n\n\njQuery._evalUrl = function( url, options, doc ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\n\t\t// Only evaluate the response if it is successful (gh-4126)\n\t\t// dataFilter is not invoked for failure responses, so using it instead\n\t\t// of the default converter is kludgy but it works.\n\t\tconverters: {\n\t\t\t\"text script\": function() {}\n\t\t},\n\t\tdataFilter: function( response ) {\n\t\t\tjQuery.globalEval( response, options, doc );\n\t\t}\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce.guid++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( _i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( {\n\t\tpadding: \"inner\" + name,\n\t\tcontent: type,\n\t\t\"\": \"outer\" + name\n\t}, function( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( _i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t},\n\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\njQuery.each(\n\t( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( _i, name ) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t}\n);\n\n\n\n\n// Support: Android <=4.0 only\n// Make sure we trim BOM and NBSP\nvar rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\njQuery.trim = function( text ) {\n\treturn text == null ?\n\t\t\"\" :\n\t\t( text + \"\" ).replace( rtrim, \"\" );\n};\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === \"undefined\" ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxLQUEwQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsWUFBWTs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsNkJBQTZCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFNBQVMsZ0NBQWdDO0FBQ3pDLFNBQVMsbUJBQW1CO0FBQzVCLFNBQVMscUNBQXFDO0FBQzlDLFNBQVM7QUFDVCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlEQUFpRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsV0FBVyw0Q0FBNEM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLEVBQUU7Ozs7QUFJRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQiwyQkFBMkIsd0JBQXdCOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwyQ0FBMkM7QUFDM0MsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLHFDQUFxQztBQUM5RSxxQ0FBcUMsc0NBQXNDO0FBQzNFLHFDQUFxQyxxQ0FBcUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQyxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYTtBQUNyQyxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsY0FBYzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1Q0FBdUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUF1RDtBQUMvRTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtDQUErQztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZUFBZSxvQ0FBb0M7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7OztBQUdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFD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QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhEQUE4RDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0QsMEJBQTBCO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWSxpQkFBaUI7QUFDN0IsZUFBZTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxtQkFBbUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxjQUFjOztBQUVkOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjs7QUFFQSxZQUFZO0FBQ1osSUFBSTtBQUNKO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQSxlQUFlLHFEQUFxRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUEwQztBQUMvQyxDQUFDLGlDQUFrQixFQUFFLG1DQUFFO0FBQ3ZCO0FBQ0EsRUFBRTtBQUFBLGtHQUFFO0FBQ0o7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2VhcmVhdGhsb24vZnJvbnRlbmQtd2VicGFjay1ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanM/MTE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNi4wXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMjEtMDMtMDJUMTc6MDhaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGZsYXQgPSBhcnIuZmxhdCA/IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5mbGF0LmNhbGwoIGFycmF5ICk7XG59IDogZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmNvbmNhdC5hcHBseSggW10sIGFycmF5ICk7XG59O1xuXG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG5cdFx0Ly8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG5cdFx0Ly8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cblx0XHQvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG5cdFx0Ly8gU3VwcG9ydDogUXRXZWIgPD0zLjguNSwgV2ViS2l0IDw9NTM0LjM0LCB3a2h0bWx0b3BkZiB0b29sIDw9MC4xMi41XG5cdFx0Ly8gUGx1cyBmb3Igb2xkIFdlYktpdCwgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIGNvbGxlY3Rpb25zXG5cdFx0Ly8gKGUuZy4sIGB0eXBlb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIikgPT09IFwiZnVuY3Rpb25cImApLiAoZ2gtNDc1Nilcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCIgJiZcblx0XHRcdHR5cGVvZiBvYmouaXRlbSAhPT0gXCJmdW5jdGlvblwiO1xuXHR9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy42LjBcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGV2ZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAoIGkgKyAxICkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdG9kZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHt9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBwcm92aWRlZCBjb250ZXh0OyBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb25lXG5cdC8vIGlmIG5vdCBzcGVjaWZpZWQuXG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zLCBkb2MgKSB7XG5cdFx0RE9NRXZhbCggY29kZSwgeyBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlIH0sIGRvYyApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGZsYXQoIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdFx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuNlxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXG4gKlxuICogRGF0ZTogMjAyMS0wMi0xNlxuICovXG4oIGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoIHt9ICkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoTmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0WyBpIF0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxcIiArXG5cdFx0XCJpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaWRlbnQtdG9rZW4tZGlhZ3JhbVxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XVxuXHRcdC8vIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblxuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIiwgXCJnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIGVzY2FwZSwgbm9uSGV4ICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlLnNsaWNlKCAxICkgLSAweDEwMDAwO1xuXG5cdFx0cmV0dXJuIG5vbkhleCA/XG5cblx0XHRcdC8vIFN0cmlwIHRoZSBiYWNrc2xhc2ggcHJlZml4IGZyb20gYSBub24taGV4IGVzY2FwZSBzZXF1ZW5jZVxuXHRcdFx0bm9uSGV4IDpcblxuXHRcdFx0Ly8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHRcdC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxuXHRcdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgK1xuXHRcdFx0XHRjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KCBhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApICksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggZWxzICkgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICggdGFyZ2V0WyBqKysgXSA9IGVsc1sgaSsrIF0gKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAoIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAoIG0gPSBtYXRjaFsgMSBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKCBlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMiBdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIG0gPSBtYXRjaFsgMyBdICkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSApICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOCBvbmx5XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdCggbm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoZSB0ZWNobmlxdWUgaGFzIHRvIGJlIHVzZWQgYXMgd2VsbCB3aGVuIGEgbGVhZGluZyBjb21iaW5hdG9yIGlzIHVzZWRcblx0XHRcdFx0Ly8gYXMgc3VjaCBzZWxlY3RvcnMgYXJlIG5vdCByZWNvZ25pemVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSB8fCByY29tYmluYXRvcnMudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gV2UgY2FuIHVzZSA6c2NvcGUgaW5zdGVhZCBvZiB0aGUgSUQgaGFjayBpZiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdC8vIHN1cHBvcnRzIGl0ICYgaWYgd2UncmUgbm90IGNoYW5naW5nIHRoZSBjb250ZXh0LlxuXHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAhPT0gY29udGV4dCB8fCAhc3VwcG9ydC5zY29wZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGlmICggKCBuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkgKSApIHtcblx0XHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsICggbmlkID0gZXhwYW5kbyApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbIGkgXSA9ICggbmlkID8gXCIjXCIgKyBuaWQgOiBcIjpzY29wZVwiICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcdHRvU2VsZWN0b3IoIGdyb3Vwc1sgaSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoIGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUgKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoIFwifFwiICksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbIGkgXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5uZXh0U2libGluZyApICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuICggbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIgKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcblx0XHRcdFx0XHRzZWVkWyBqIF0gPSAhKCBtYXRjaGVzWyBqIF0gPSBzZWVkWyBqIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5hbWVzcGFjZSA9IGVsZW0gJiYgZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0ZG9jRWxlbSA9IGVsZW0gJiYgKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApLmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PThcblx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xuXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNDgzM1xuXHRyZXR1cm4gIXJodG1sLnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIGRvYyA9PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPSBkb2N1bWVudCAmJlxuXHRcdCggc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgKSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBDaHJvbWUgPD0xNiAtIDI1IG9ubHksIEZpcmVmb3ggPD0zLjYgLSAzMSBvbmx5LFxuXHQvLyBTYWZhcmkgNCAtIDUgb25seSwgT3BlcmEgPD0xMS42IC0gMTIueCBvbmx5XG5cdC8vIElFL0VkZ2UgJiBvbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSA6c2NvcGUgcHNldWRvLWNsYXNzLlxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wIG9ubHlcblx0Ly8gU2FmYXJpIDYuMCBzdXBwb3J0cyA6c2NvcGUgYnV0IGl0J3MgYW4gYWxpYXMgb2YgOnJvb3QgdGhlcmUuXG5cdHN1cHBvcnQuc2NvcGUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblx0XHRyZXR1cm4gdHlwZW9mIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdCFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpzY29wZSBmaWVsZHNldCBkaXZcIiApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiApO1xuXHR9ICk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoIFwiXCIgKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiKlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlclsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImlkXCIgKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1zWyBpKysgXSApICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbIFwiVEFHXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kWyBcIkNMQVNTXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoIHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkgKSApIHtcblxuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdFx0dmFyIGlucHV0O1xuXG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW3NlbGVjdGVkXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIn49XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0XHQvLyBJRSAxMS9FZGdlIGRvbid0IGZpbmQgZWxlbWVudHMgb24gYSBgW25hbWU9JyddYCBxdWVyeSBpbiBzb21lIGNhc2VzLlxuXHRcdFx0Ly8gQWRkaW5nIGEgdGVtcG9yYXJ5IGF0dHJpYnV0ZSB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBzZWxlY3Rpb24gd29ya3Ncblx0XHRcdC8vIGFyb3VuZCB0aGUgaXNzdWUuXG5cdFx0XHQvLyBJbnRlcmVzdGluZ2x5LCBJRSAxMCAmIG9sZGVyIGRvbid0IHNlZW0gdG8gaGF2ZSB0aGUgaXNzdWUuXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJcIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIio9XCIgK1xuXHRcdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpjaGVja2VkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjpjaGVja2VkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIi4jLitbK35dXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTMuNiAtIDUgb25seVxuXHRcdFx0Ly8gT2xkIEZpcmVmb3ggZG9lc24ndCB0aHJvdyBvbiBhIGJhZGx5LWVzY2FwZWQgaWRlbnRpZmllci5cblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiXFxcXFxcZlwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbXFxcXHJcXFxcblxcXFxmXVwiICk7XG5cdFx0fSApO1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT1kXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjplbmFibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZGlzYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBPcGVyYSAxMCAtIDExIG9ubHlcblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIiosOnhcIiApO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLC4qOlwiICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAoIG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvciApICkgKSApIHtcblxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCBcInxcIiApICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oIFwifFwiICkgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkgKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGIgPSBiLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUgKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBhID09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0Y29udGFpbnMoIHByZWZlcnJlZERvYywgYSApICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGIgPT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRyZXR1cm4gYSA9PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwWyBpIF0gPT09IGJwWyBpIF0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbIGkgXSwgYnBbIGkgXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRhcFsgaSBdID09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblxuXHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoIHNlbCArIFwiXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoICggbm9kZSA9IGVsZW1bIGkrKyBdICkgKSB7XG5cblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHxcblx0XHRcdFx0bWF0Y2hbIDUgXSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMiBdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWyAzIF0gPSBcIiBcIiArIG1hdGNoWyAzIF0gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMSBdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWyA0IF0gPSArKCBtYXRjaFsgNCBdID9cblx0XHRcdFx0XHRtYXRjaFsgNSBdICsgKCBtYXRjaFsgNiBdIHx8IDEgKSA6XG5cdFx0XHRcdFx0MiAqICggbWF0Y2hbIDMgXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWyA1IF0gPSArKCAoIG1hdGNoWyA3IF0gKyBtYXRjaFsgOCBdICkgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbIDYgXSAmJiBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwclsgXCJDSElMRFwiIF0udGVzdCggbWF0Y2hbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KCBleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSApICYmXG5cblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdCggZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XHRcdFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApICkgJiYgY2xhc3NDYWNoZShcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoXG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8XG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHxcblx0XHRcdFx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gbm9kZVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblxuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGkgXSA9ICEoIG1hdGNoZXNbIGkgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QoIGxhbmcgfHwgXCJcIiApICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJ4bWw6bGFuZ1wiICkgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoIFwibGFuZ1wiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoICggZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuXHRcdFx0XHQoICFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpICkgJiZcblx0XHRcdFx0ISEoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXggKTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCApIHx8XG5cdFx0XHRcdCggbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkICk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbIFwiZW1wdHlcIiBdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKCBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgKSA9PSBudWxsIHx8XG5cdFx0XHRcdFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9ICksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9ICksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID9cblx0XHRcdFx0YXJndW1lbnQgKyBsZW5ndGggOlxuXHRcdFx0XHRhcmd1bWVudCA+IGxlbmd0aCA/XG5cdFx0XHRcdFx0bGVuZ3RoIDpcblx0XHRcdFx0XHRhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbIFwibnRoXCIgXSA9IEV4cHIucHNldWRvc1sgXCJlcVwiIF07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8ICggbWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFsgMCBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICggdG9rZW5zID0gW10gKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAoIG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWyAwIF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0gKTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoICggbWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApICkgJiYgKCAhcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdCggbWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkgKSApICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbIGkgXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoICggb2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0gKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoIG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKCBuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1sgaSBdKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWyAwIF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbIGkgXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoXG5cdFx0XHRcdHNlbGVjdG9yIHx8IFwiKlwiLFxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LFxuXHRcdFx0XHRbXVxuXHRcdFx0KSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoIGVsZW0gPSB0ZW1wWyBpIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwWyBpIF0gXSA9ICEoIG1hdGNoZXJJblsgcG9zdE1hcFsgaSBdIF0gPSBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goICggbWF0Y2hlckluWyBpIF0gPSBlbGVtICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKCBtYXRjaGVyT3V0ID0gW10gKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgJiZcblx0XHRcdFx0XHRcdCggdGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbIHRlbXAgXSA9ICEoIHJlc3VsdHNbIHRlbXAgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyBcIiBcIiBdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoIGNoZWNrQ29udGV4dCA9IGNvbnRleHQgKS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggbWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaSBdLnR5cGUgXSApICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyICkgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbIGkgXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1sgaSBdLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaiBdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHR0b2tlbnNcblx0XHRcdFx0XHRcdC5zbGljZSggMCwgaSAtIDEgKVxuXHRcdFx0XHRcdFx0LmNvbmNhdCggeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0gKVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKCB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFsgXCJUQUdcIiBdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9ICggZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEgKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblxuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0gKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IHNldE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISggdW5tYXRjaGVkWyBpIF0gfHwgc2V0TWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFsgaSBdID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbIGkgXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZShcblx0XHRcdHNlbGVjdG9yLFxuXHRcdFx0bWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzIClcblx0XHQpO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoIHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IgKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAoIHRva2VuID0gdG9rZW5zWyAwIF0gKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAxIF0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbIFwiSURcIiBdKCB0b2tlbi5tYXRjaGVzWyAwIF1cblx0XHRcdFx0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksIGNvbnRleHQgKSB8fCBbXSApWyAwIF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByWyBcIm5lZWRzQ29udGV4dFwiIF0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICggZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdICkgKSB7XG5cblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKCBzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbIDAgXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0XG5cdFx0XHRcdCkgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdCggXCJcIiApLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oIFwiXCIgKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKSApICYgMTtcbn0gKTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJocmVmXCIgKSA9PT0gXCIjXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSApICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIF9uYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09IG51bGw7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdCggdmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9ICk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0gKSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG5cdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyA8b2JqZWN0PiBlbGVtZW50cyB3aXRoIG5vIGBkYXRhYCBhdHRyaWJ1dGUgaGFzIGFuIG9iamVjdFxuXHRcdFx0Ly8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXG5cdFx0XHRnZXRQcm90byggZWxlbS5jb250ZW50RG9jdW1lbnQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuXHRcdC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuXHRcdC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG5cdFx0XHRlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBfaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIHByaW1hcnkgRGVmZXJyZWRcblx0XHRcdHByaW1hcnkgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0cHJpbWFyeS5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgcHJpbWFyeS5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBwcmltYXJ5LnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIHByaW1hcnkuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHByaW1hcnkudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgcHJpbWFyeS5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJpbWFyeS5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIF9rZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIF9hbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gSUUgPD05IHJlcGxhY2VzIDxvcHRpb24+IHRhZ3Mgd2l0aCB0aGVpciBjb250ZW50cyB3aGVuIGluc2VydGVkIG91dHNpZGUgb2Zcblx0Ly8gdGhlIHNlbGVjdCBlbGVtZW50LlxuXHRkaXYuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiO1xuXHRzdXBwb3J0Lm9wdGlvbiA9ICEhZGl2Lmxhc3RDaGlsZDtcbn0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbmlmICggIXN1cHBvcnQub3B0aW9uICkge1xuXHR3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb24gPSBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF07XG59XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxudmFyIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuLy8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXMsIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIG5vLW9wLlxuLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbi8vIChmb2N1cyBhbmQgYmx1ciBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIGluIG90aGVyIHN1cHBvcnRlZCBicm93c2Vycyxcbi8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cbmZ1bmN0aW9uIGV4cGVjdFN5bmMoIGVsZW0sIHR5cGUgKSB7XG5cdHJldHVybiAoIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgKSA9PT0gKCB0eXBlID09PSBcImZvY3VzXCIgKTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBPbmx5IGF0dGFjaCBldmVudHMgdG8gb2JqZWN0cyB0aGF0IGFjY2VwdCBkYXRhXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblxuXHRcdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICksXG5cblx0XHRcdGhhbmRsZXJzID0gKFxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IHRvIGVuc3VyZSBjb3JyZWN0IHN0YXRlIGZvciBjaGVja2FibGUgaW5wdXRzXG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHQvLyBkYXRhUHJpdi5zZXQoIGVsLCBcImNsaWNrXCIsIC4uLiApXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIsIHJldHVyblRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHQvLyBBbHNvIHByZXZlbnQgaXQgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cdFx0XHRcdHJldHVybiByY2hlY2thYmxlVHlwZS50ZXN0KCB0YXJnZXQudHlwZSApICYmXG5cdFx0XHRcdFx0dGFyZ2V0LmNsaWNrICYmIG5vZGVOYW1lKCB0YXJnZXQsIFwiaW5wdXRcIiApICYmXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0YXJnZXQsIFwiY2xpY2tcIiApIHx8XG5cdFx0XHRcdFx0bm9kZU5hbWUoIHRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBFbnN1cmUgdGhlIHByZXNlbmNlIG9mIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaGFuZGxlcyBtYW51YWxseS10cmlnZ2VyZWRcbi8vIHN5bnRoZXRpYyBldmVudHMgYnkgaW50ZXJydXB0aW5nIHByb2dyZXNzIHVudGlsIHJlaW52b2tlZCBpbiByZXNwb25zZSB0b1xuLy8gKm5hdGl2ZSogZXZlbnRzIHRoYXQgaXQgZmlyZXMgZGlyZWN0bHksIGVuc3VyaW5nIHRoYXQgc3RhdGUgY2hhbmdlcyBoYXZlXG4vLyBhbHJlYWR5IG9jY3VycmVkIGJlZm9yZSBvdGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQuXG5mdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZSggZWwsIHR5cGUsIGV4cGVjdFN5bmMgKSB7XG5cblx0Ly8gTWlzc2luZyBleHBlY3RTeW5jIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcblx0aWYgKCAhZXhwZWN0U3luYyApIHtcblx0XHRpZiAoIGRhdGFQcml2LmdldCggZWwsIHR5cGUgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHJldHVyblRydWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGNvbnRyb2xsZXIgYXMgYSBzcGVjaWFsIHVuaXZlcnNhbCBoYW5kbGVyIGZvciBhbGwgZXZlbnQgbmFtZXNwYWNlc1xuXHRkYXRhUHJpdi5zZXQoIGVsLCB0eXBlLCBmYWxzZSApO1xuXHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwge1xuXHRcdG5hbWVzcGFjZTogZmFsc2UsXG5cdFx0aGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIG5vdEFzeW5jLCByZXN1bHQsXG5cdFx0XHRcdHNhdmVkID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdGlmICggKCBldmVudC5pc1RyaWdnZXIgJiAxICkgJiYgdGhpc1sgdHlwZSBdICkge1xuXG5cdFx0XHRcdC8vIEludGVycnVwdCBwcm9jZXNzaW5nIG9mIHRoZSBvdXRlciBzeW50aGV0aWMgLnRyaWdnZXIoKWVkIGV2ZW50XG5cdFx0XHRcdC8vIFNhdmVkIGRhdGEgc2hvdWxkIGJlIGZhbHNlIGluIHN1Y2ggY2FzZXMsIGJ1dCBtaWdodCBiZSBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0XG5cdFx0XHRcdC8vIGZyb20gYW4gYXN5bmMgbmF0aXZlIGhhbmRsZXIgKGdoLTQzNTApXG5cdFx0XHRcdGlmICggIXNhdmVkLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGFyZ3VtZW50cyBmb3IgdXNlIHdoZW4gaGFuZGxpbmcgdGhlIGlubmVyIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRcdC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxuXHRcdFx0XHRcdC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cblx0XHRcdFx0XHRzYXZlZCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgc2F2ZWQgKTtcblxuXHRcdFx0XHRcdC8vIFRyaWdnZXIgdGhlIG5hdGl2ZSBldmVudCBhbmQgY2FwdHVyZSBpdHMgcmVzdWx0XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0XHRcdFx0Ly8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXNcblx0XHRcdFx0XHRub3RBc3luYyA9IGV4cGVjdFN5bmMoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHR0aGlzWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRyZXN1bHQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgfHwgbm90QXN5bmMgKSB7XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIGZhbHNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhbmNlbCB0aGUgb3V0ZXIgc3ludGhldGljIGV2ZW50XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA4Nitcblx0XHRcdFx0XHRcdC8vIEluIENocm9tZSwgaWYgYW4gZWxlbWVudCBoYXZpbmcgYSBmb2N1c291dCBoYW5kbGVyIGlzIGJsdXJyZWQgYnlcblx0XHRcdFx0XHRcdC8vIGNsaWNraW5nIG91dHNpZGUgb2YgaXQsIGl0IGludm9rZXMgdGhlIGhhbmRsZXIgc3luY2hyb25vdXNseS4gSWZcblx0XHRcdFx0XHRcdC8vIHRoYXQgaGFuZGxlciBjYWxscyBgLnJlbW92ZSgpYCBvbiB0aGUgZWxlbWVudCwgdGhlIGRhdGEgaXMgY2xlYXJlZCxcblx0XHRcdFx0XHRcdC8vIGxlYXZpbmcgYHJlc3VsdGAgdW5kZWZpbmVkLiBXZSBuZWVkIHRvIGd1YXJkIGFnYWluc3QgdGhpcy5cblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQgJiYgcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuXHRcdFx0XHQvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZyB0aGVcblx0XHRcdFx0Ly8gbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cblx0XHRcdFx0Ly8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcblx0XHRcdFx0Ly8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xuXHRcdFx0XHQvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge30gKS5kZWxlZ2F0ZVR5cGUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG5cdFx0XHQvLyBGaXJlIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCB3aXRoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHNhdmVkLmxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG5cdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwge1xuXHRcdFx0XHRcdHZhbHVlOiBqUXVlcnkuZXZlbnQudHJpZ2dlcihcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0XHRcdFx0XHQvLyBFeHRlbmQgd2l0aCB0aGUgcHJvdG90eXBlIHRvIHJlc2V0IHRoZSBhYm92ZSBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggc2F2ZWRbIDAgXSwgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSApLFxuXHRcdFx0XHRcdFx0c2F2ZWQuc2xpY2UoIDEgKSxcblx0XHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNvZGU6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXHR3aGljaDogdHJ1ZVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxualF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIHR5cGUsIGRlbGVnYXRlVHlwZSApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSA9IHtcblxuXHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJmb2N1c1wiLCAuLi4gKVxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImJsdXJcIiwgLi4uIClcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlLCBleHBlY3RTeW5jICk7XG5cblx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwcmVzcyBuYXRpdmUgZm9jdXMgb3IgYmx1ciBhcyBpdCdzIGFscmVhZHkgYmVpbmcgZmlyZWRcblx0XHQvLyBpbiBsZXZlcmFnZU5hdGl2ZS5cblx0XHRfZGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmdldCggc3JjICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRlc3QsIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBmbGF0KCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9LCBkb2MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgbm9kZSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEJlaGF2aW9yIGluIElFIDkgaXMgbW9yZSBzdWJ0bGUgdGhhbiBpbiBuZXdlciB2ZXJzaW9ucyAmIGl0IHBhc3Nlc1xuXHRcdC8vIHNvbWUgdmVyc2lvbnMgb2YgdGhpcyB0ZXN0OyBtYWtlIHN1cmUgbm90IHRvIG1ha2UgaXQgcGFzcyB0aGVyZSFcblx0XHQvL1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNzArXG5cdFx0Ly8gT25seSBGaXJlZm94IGluY2x1ZGVzIGJvcmRlciB3aWR0aHNcblx0XHQvLyBpbiBjb21wdXRlZCBkaW1lbnNpb25zLiAoZ2gtNDUyOSlcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuXHRcdFx0aWYgKCByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGFibGVcIiApO1xuXHRcdFx0XHR0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidHJcIiApO1xuXHRcdFx0XHR0ckNoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdFx0XHRcdHRhYmxlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7Ym9yZGVyLWNvbGxhcHNlOnNlcGFyYXRlXCI7XG5cdFx0XHRcdHRyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjoxcHggc29saWRcIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgODYrXG5cdFx0XHRcdC8vIEhlaWdodCBzZXQgdGhyb3VnaCBjc3NUZXh0IGRvZXMgbm90IGdldCBhcHBsaWVkLlxuXHRcdFx0XHQvLyBDb21wdXRlZCBoZWlnaHQgdGhlbiBjb21lcyBiYWNrIGFzIDAuXG5cdFx0XHRcdHRyLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDggQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBJbiBvdXIgYm9keUJhY2tncm91bmQuaHRtbCBpZnJhbWUsXG5cdFx0XHRcdC8vIGRpc3BsYXkgZm9yIGFsbCBkaXYgZWxlbWVudHMgaXMgc2V0IHRvIFwiaW5saW5lXCIsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhIHByb2JsZW0gb25seSBpbiBBbmRyb2lkIDggQ2hyb21lIDg2LlxuXHRcdFx0XHQvLyBFbnN1cmluZyB0aGUgZGl2IGlzIGRpc3BsYXk6IGJsb2NrXG5cdFx0XHRcdC8vIGdldHMgYXJvdW5kIHRoaXMgaXNzdWUuXG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnRcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRhYmxlIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyQ2hpbGQgKTtcblxuXHRcdFx0XHR0clN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIHRyICk7XG5cdFx0XHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID0gKCBwYXJzZUludCggdHJTdHlsZS5oZWlnaHQsIDEwICkgK1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0clN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCApICtcblx0XHRcdFx0XHRwYXJzZUludCggdHJTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCwgMTAgKSApID09PSB0ci5vZmZzZXRIZWlnaHQ7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBVc2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZS5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG5cdFx0IXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJncmlkQXJlYVwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtbkVuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblN0YXJ0XCI6IHRydWUsXG5cdFx0XCJncmlkUm93XCI6IHRydWUsXG5cdFx0XCJncmlkUm93RW5kXCI6IHRydWUsXG5cdFx0XCJncmlkUm93U3RhcnRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIF9pLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApIClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIEhhbmRsZTogcmVndWxhciBub2RlcyAodmlhIGB0aGlzLm93bmVyRG9jdW1lbnRgKSwgd2luZG93XG5cdFx0XHRcdC8vICh2aWEgYHRoaXMuZG9jdW1lbnRgKSAmIGRvY3VtZW50ICh2aWEgYHRoaXNgKS5cblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWwsIHBhcnNlckVycm9yRWxlbTtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge31cblxuXHRwYXJzZXJFcnJvckVsZW0gPSB4bWwgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKVsgMCBdO1xuXHRpZiAoICF4bWwgfHwgcGFyc2VyRXJyb3JFbGVtICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyAoXG5cdFx0XHRwYXJzZXJFcnJvckVsZW0gP1xuXHRcdFx0XHRqUXVlcnkubWFwKCBwYXJzZXJFcnJvckVsZW0uY2hpbGROb2RlcywgZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0XHRcdHJldHVybiBlbC50ZXh0Q29udGVudDtcblx0XHRcdFx0fSApLmpvaW4oIFwiXFxuXCIgKSA6XG5cdFx0XHRcdGRhdGFcblx0XHQpICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBfaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxub3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZS5ndWlkKysgKSArXG5cdFx0XHRcdFx0dW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBhIG5vb3AgY29udmVydGVyIGZvciBtaXNzaW5nIHNjcmlwdCBidXQgbm90IGlmIGpzb25wXG5cdFx0XHRpZiAoICFpc1N1Y2Nlc3MgJiZcblx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIFwic2NyaXB0XCIsIHMuZGF0YVR5cGVzICkgPiAtMSAmJlxuXHRcdFx0XHRqUXVlcnkuaW5BcnJheSggXCJqc29uXCIsIHMuZGF0YVR5cGVzICkgPCAwICkge1xuXHRcdFx0XHRzLmNvbnZlcnRlcnNbIFwidGV4dCBzY3JpcHRcIiBdID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggX2ksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHR2YXIgaTtcblx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0aWYgKCBpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIgKSB7XG5cdFx0XHRzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXCJcIjtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zLCBkb2MgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucywgZG9jICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UuZ3VpZCsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggX2ksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHtcblx0XHRwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLFxuXHRcdGNvbnRlbnQ6IHR5cGUsXG5cdFx0XCJcIjogXCJvdXRlclwiICsgbmFtZVxuXHR9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBfaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKFxuXHQoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxudmFyIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5qUXVlcnkudHJpbSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcIlwiIDpcblx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcbn07XG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jquery/dist/jquery.js\n");

/***/ }),

/***/ "./src/scss/app.scss":
/*!***************************!*\
  !*** ./src/scss/app.scss ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2Nzcy9hcHAuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2VhcmVhdGhsb24vZnJvbnRlbmQtd2VicGFjay1ib2lsZXJwbGF0ZS8uL3NyYy9zY3NzL2FwcC5zY3NzPzYyOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/scss/app.scss\n");

/***/ }),

/***/ "./node_modules/rive-js/dist/rive.dev.js":
/*!***********************************************!*\
  !*** ./node_modules/rive-js/dist/rive.dev.js ***!
  \***********************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_509__) => {\n\n\"use strict\";\nvar __filename = \"/index.js\";\nvar __dirname = \"/\";\n__nested_webpack_require_509__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_509__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\nvar Rive = (function() {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  if (true) _scriptDir = _scriptDir || __filename;\n  return (\nfunction(Rive) {\n  Rive = Rive || {};\n\nnull;\n\nvar Module = typeof Rive !== \"undefined\" ? Rive : {};\n\nvar readyPromiseResolve, readyPromiseReject;\n\nModule[\"ready\"] = new Promise(function(resolve, reject) {\n readyPromiseResolve = resolve;\n readyPromiseReject = reject;\n});\n\nvar moduleOverrides = {};\n\nvar key;\n\nfor (key in Module) {\n if (Module.hasOwnProperty(key)) {\n  moduleOverrides[key] = Module[key];\n }\n}\n\nvar arguments_ = [];\n\nvar thisProgram = \"./this.program\";\n\nvar quit_ = function(status, toThrow) {\n throw toThrow;\n};\n\nvar ENVIRONMENT_IS_WEB = false;\n\nvar ENVIRONMENT_IS_WORKER = false;\n\nvar ENVIRONMENT_IS_NODE = false;\n\nvar ENVIRONMENT_IS_SHELL = false;\n\nENVIRONMENT_IS_WEB = typeof window === \"object\";\n\nENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n\nENVIRONMENT_IS_NODE = typeof process === \"object\" && typeof process.versions === \"object\" && typeof process.versions.node === \"string\";\n\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nvar scriptDirectory = \"\";\n\nfunction locateFile(path) {\n if (Module[\"locateFile\"]) {\n  return Module[\"locateFile\"](path, scriptDirectory);\n }\n return scriptDirectory + path;\n}\n\nvar read_, readAsync, readBinary, setWindowTitle;\n\nvar nodeFS;\n\nvar nodePath;\n\nif (ENVIRONMENT_IS_NODE) {\n if (ENVIRONMENT_IS_WORKER) {\n  scriptDirectory = __nested_webpack_require_509__(2).dirname(scriptDirectory) + \"/\";\n } else {\n  scriptDirectory = __dirname + \"/\";\n }\n read_ = function shell_read(filename, binary) {\n  var ret = tryParseAsDataURI(filename);\n  if (ret) {\n   return binary ? ret : ret.toString();\n  }\n  if (!nodeFS) nodeFS = __nested_webpack_require_509__(3);\n  if (!nodePath) nodePath = __nested_webpack_require_509__(2);\n  filename = nodePath[\"normalize\"](filename);\n  return nodeFS[\"readFileSync\"](filename, binary ? null : \"utf8\");\n };\n readBinary = function readBinary(filename) {\n  var ret = read_(filename, true);\n  if (!ret.buffer) {\n   ret = new Uint8Array(ret);\n  }\n  assert(ret.buffer);\n  return ret;\n };\n if (process[\"argv\"].length > 1) {\n  thisProgram = process[\"argv\"][1].replace(/\\\\/g, \"/\");\n }\n arguments_ = process[\"argv\"].slice(2);\n process[\"on\"](\"uncaughtException\", function(ex) {\n  if (!(ex instanceof ExitStatus)) {\n   throw ex;\n  }\n });\n process[\"on\"](\"unhandledRejection\", abort);\n quit_ = function(status) {\n  process[\"exit\"](status);\n };\n Module[\"inspect\"] = function() {\n  return \"[Emscripten Module object]\";\n };\n} else if (ENVIRONMENT_IS_SHELL) {\n if (typeof read != \"undefined\") {\n  read_ = function shell_read(f) {\n   var data = tryParseAsDataURI(f);\n   if (data) {\n    return intArrayToString(data);\n   }\n   return read(f);\n  };\n }\n readBinary = function readBinary(f) {\n  var data;\n  data = tryParseAsDataURI(f);\n  if (data) {\n   return data;\n  }\n  if (typeof readbuffer === \"function\") {\n   return new Uint8Array(readbuffer(f));\n  }\n  data = read(f, \"binary\");\n  assert(typeof data === \"object\");\n  return data;\n };\n if (typeof scriptArgs != \"undefined\") {\n  arguments_ = scriptArgs;\n } else if (typeof arguments != \"undefined\") {\n  arguments_ = arguments;\n }\n if (typeof quit === \"function\") {\n  quit_ = function(status) {\n   quit(status);\n  };\n }\n if (typeof print !== \"undefined\") {\n  if (typeof console === \"undefined\") console = {};\n  console.log = print;\n  console.warn = console.error = typeof printErr !== \"undefined\" ? printErr : print;\n }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n if (ENVIRONMENT_IS_WORKER) {\n  scriptDirectory = self.location.href;\n } else if (typeof document !== \"undefined\" && document.currentScript) {\n  scriptDirectory = document.currentScript.src;\n }\n if (_scriptDir) {\n  scriptDirectory = _scriptDir;\n }\n if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1);\n } else {\n  scriptDirectory = \"\";\n }\n {\n  read_ = function(url) {\n   try {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    xhr.send(null);\n    return xhr.responseText;\n   } catch (err) {\n    var data = tryParseAsDataURI(url);\n    if (data) {\n     return intArrayToString(data);\n    }\n    throw err;\n   }\n  };\n  if (ENVIRONMENT_IS_WORKER) {\n   readBinary = function(url) {\n    try {\n     var xhr = new XMLHttpRequest();\n     xhr.open(\"GET\", url, false);\n     xhr.responseType = \"arraybuffer\";\n     xhr.send(null);\n     return new Uint8Array(xhr.response);\n    } catch (err) {\n     var data = tryParseAsDataURI(url);\n     if (data) {\n      return data;\n     }\n     throw err;\n    }\n   };\n  }\n  readAsync = function(url, onload, onerror) {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url, true);\n   xhr.responseType = \"arraybuffer\";\n   xhr.onload = function() {\n    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n     onload(xhr.response);\n     return;\n    }\n    var data = tryParseAsDataURI(url);\n    if (data) {\n     onload(data.buffer);\n     return;\n    }\n    onerror();\n   };\n   xhr.onerror = onerror;\n   xhr.send(null);\n  };\n }\n setWindowTitle = function(title) {\n  document.title = title;\n };\n} else {}\n\nvar out = Module[\"print\"] || console.log.bind(console);\n\nvar err = Module[\"printErr\"] || console.warn.bind(console);\n\nfor (key in moduleOverrides) {\n if (moduleOverrides.hasOwnProperty(key)) {\n  Module[key] = moduleOverrides[key];\n }\n}\n\nmoduleOverrides = null;\n\nif (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n\nif (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n\nif (Module[\"quit\"]) quit_ = Module[\"quit\"];\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = function(value) {\n tempRet0 = value;\n};\n\nvar wasmBinary;\n\nif (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n\nvar noExitRuntime = Module[\"noExitRuntime\"] || true;\n\nif (typeof WebAssembly !== \"object\") {\n abort(\"no native wasm support detected\");\n}\n\nvar wasmMemory;\n\nvar ABORT = false;\n\nvar EXITSTATUS;\n\nfunction assert(condition, text) {\n if (!condition) {\n  abort(\"Assertion failed: \" + text);\n }\n}\n\nvar UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\n var endIdx = idx + maxBytesToRead;\n var endPtr = idx;\n while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n  return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n } else {\n  var str = \"\";\n  while (idx < endPtr) {\n   var u0 = heap[idx++];\n   if (!(u0 & 128)) {\n    str += String.fromCharCode(u0);\n    continue;\n   }\n   var u1 = heap[idx++] & 63;\n   if ((u0 & 224) == 192) {\n    str += String.fromCharCode((u0 & 31) << 6 | u1);\n    continue;\n   }\n   var u2 = heap[idx++] & 63;\n   if ((u0 & 240) == 224) {\n    u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n   } else {\n    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\n   }\n   if (u0 < 65536) {\n    str += String.fromCharCode(u0);\n   } else {\n    var ch = u0 - 65536;\n    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n   }\n  }\n }\n return str;\n}\n\nfunction UTF8ToString(ptr, maxBytesToRead) {\n return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n}\n\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n if (!(maxBytesToWrite > 0)) return 0;\n var startIdx = outIdx;\n var endIdx = outIdx + maxBytesToWrite - 1;\n for (var i = 0; i < str.length; ++i) {\n  var u = str.charCodeAt(i);\n  if (u >= 55296 && u <= 57343) {\n   var u1 = str.charCodeAt(++i);\n   u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n  }\n  if (u <= 127) {\n   if (outIdx >= endIdx) break;\n   heap[outIdx++] = u;\n  } else if (u <= 2047) {\n   if (outIdx + 1 >= endIdx) break;\n   heap[outIdx++] = 192 | u >> 6;\n   heap[outIdx++] = 128 | u & 63;\n  } else if (u <= 65535) {\n   if (outIdx + 2 >= endIdx) break;\n   heap[outIdx++] = 224 | u >> 12;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  } else {\n   if (outIdx + 3 >= endIdx) break;\n   heap[outIdx++] = 240 | u >> 18;\n   heap[outIdx++] = 128 | u >> 12 & 63;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  }\n }\n heap[outIdx] = 0;\n return outIdx - startIdx;\n}\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n}\n\nfunction lengthBytesUTF8(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var u = str.charCodeAt(i);\n  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n  if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4;\n }\n return len;\n}\n\nvar UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n\nfunction UTF16ToString(ptr, maxBytesToRead) {\n var endPtr = ptr;\n var idx = endPtr >> 1;\n var maxIdx = idx + maxBytesToRead / 2;\n while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n endPtr = idx << 1;\n if (endPtr - ptr > 32 && UTF16Decoder) {\n  return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n } else {\n  var str = \"\";\n  for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n   var codeUnit = HEAP16[ptr + i * 2 >> 1];\n   if (codeUnit == 0) break;\n   str += String.fromCharCode(codeUnit);\n  }\n  return str;\n }\n}\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 2) return 0;\n maxBytesToWrite -= 2;\n var startPtr = outPtr;\n var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n for (var i = 0; i < numCharsToWrite; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  HEAP16[outPtr >> 1] = codeUnit;\n  outPtr += 2;\n }\n HEAP16[outPtr >> 1] = 0;\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF16(str) {\n return str.length * 2;\n}\n\nfunction UTF32ToString(ptr, maxBytesToRead) {\n var i = 0;\n var str = \"\";\n while (!(i >= maxBytesToRead / 4)) {\n  var utf32 = HEAP32[ptr + i * 4 >> 2];\n  if (utf32 == 0) break;\n  ++i;\n  if (utf32 >= 65536) {\n   var ch = utf32 - 65536;\n   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n  } else {\n   str += String.fromCharCode(utf32);\n  }\n }\n return str;\n}\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 4) return 0;\n var startPtr = outPtr;\n var endPtr = startPtr + maxBytesToWrite - 4;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) {\n   var trailSurrogate = str.charCodeAt(++i);\n   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n  }\n  HEAP32[outPtr >> 2] = codeUnit;\n  outPtr += 4;\n  if (outPtr + 4 > endPtr) break;\n }\n HEAP32[outPtr >> 2] = 0;\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF32(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n  len += 4;\n }\n return len;\n}\n\nfunction alignUp(x, multiple) {\n if (x % multiple > 0) {\n  x += multiple - x % multiple;\n }\n return x;\n}\n\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n buffer = buf;\n Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n}\n\nvar INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n\nvar wasmTable;\n\nvar __ATPRERUN__ = [];\n\nvar __ATINIT__ = [];\n\nvar __ATMAIN__ = [];\n\nvar __ATPOSTRUN__ = [];\n\nvar runtimeInitialized = false;\n\nfunction preRun() {\n if (Module[\"preRun\"]) {\n  if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [ Module[\"preRun\"] ];\n  while (Module[\"preRun\"].length) {\n   addOnPreRun(Module[\"preRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n runtimeInitialized = true;\n callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction postRun() {\n if (Module[\"postRun\"]) {\n  if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [ Module[\"postRun\"] ];\n  while (Module[\"postRun\"].length) {\n   addOnPostRun(Module[\"postRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n __ATINIT__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n __ATPOSTRUN__.unshift(cb);\n}\n\nvar runDependencies = 0;\n\nvar runDependencyWatcher = null;\n\nvar dependenciesFulfilled = null;\n\nfunction addRunDependency(id) {\n runDependencies++;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n}\n\nfunction removeRunDependency(id) {\n runDependencies--;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n if (runDependencies == 0) {\n  if (runDependencyWatcher !== null) {\n   clearInterval(runDependencyWatcher);\n   runDependencyWatcher = null;\n  }\n  if (dependenciesFulfilled) {\n   var callback = dependenciesFulfilled;\n   dependenciesFulfilled = null;\n   callback();\n  }\n }\n}\n\nModule[\"preloadedImages\"] = {};\n\nModule[\"preloadedAudios\"] = {};\n\nfunction abort(what) {\n if (Module[\"onAbort\"]) {\n  Module[\"onAbort\"](what);\n }\n what += \"\";\n err(what);\n ABORT = true;\n EXITSTATUS = 1;\n what = \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n var e = new WebAssembly.RuntimeError(what);\n readyPromiseReject(e);\n throw e;\n}\n\nfunction hasPrefix(str, prefix) {\n return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;\n}\n\nvar dataURIPrefix = \"data:application/octet-stream;base64,\";\n\nfunction isDataURI(filename) {\n return hasPrefix(filename, dataURIPrefix);\n}\n\nvar fileURIPrefix = \"file://\";\n\nfunction isFileURI(filename) {\n return hasPrefix(filename, fileURIPrefix);\n}\n\nvar wasmBinaryFile = \"data:application/octet-stream;base64,AGFzbQEAAAAB5ANCYAF/AX9gAX8AYAJ/fwF/YAJ/fwBgA39/fwF/YAN/f38AYAF/AX1gA399fQBgAn99AGAHf319fX19fQBgA39/fQBgBH9/f30AYAN/fX8AYAAAYAR/f39/AGAFf39/f38AYAR/f39/AX9gBX99fX19AGAGf39/f39/AGAAAX9gA39/fQF/YAZ/f399f30AYAR/f319AGAFf39/f38Bf2ABfQF9YAJ/fQF/YAJ/fwF9YAN9fX0BfWAIf39/f39/f38AYAp/f39/f39/f39/AGACf3wBf2AGf3x/f39/AX9gA39+fwF+YAF8AX1gAXwBfGACfH8BfGAHf39/f39/fwBgDX9/f39/f39/f39/f38AYAZ/f39/fX8AYAV/f399fQBgBH9/fX8AYAZ/f319f38AYAZ/f319fX0AYAh/f319fX19fQBgBX99fX9/AGAHfX1/f39/fwBgAXwBf2AGf39/f39/AX9gB39/f39/f38Bf2AEf39/fQF/YAN/f3wBf2ADf319AX9gAn5/AX9gAn1/AX9gAnx/AX9gAX8BfmADf39/AX1gCH9/f399fX1/AX1gAn99AX1gAn19AX1gAX8BfGADf39/AXxgBX9/f39/AXxgAn1/AXxgAnx8AXxgA3x8fwF8AuUBJgFhAWEAHAFhAWIAHQFhAWMAJQFhAWQAAgFhAWUADgFhAWYAHAFhAWcABQFhAWgADwFhAWkAJAFhAWoABQFhAWsADgFhAWwAPQFhAW0ABQFhAW4ABAFhAW8AEAFhAXAABQFhAXEAAwFhAXIAEgFhAXMADQFhAXQAAgFhAXUAAgFhAXYAFwFhAXcAAQFhAXgAAAFhAXkAAAFhAXoAAwFhAUEADwFhAUIAAwFhAUMAAQFhAUQAAQFhAUUAAAFhAUYAAQFhAUcAPgFhAUgAAQFhAUkAHQFhAUoAEgFhAUsAEgFhAUwAAAO6CbgJAgAAAQAAAgABAjwAAAQBAwAAAAMAAgEAAQAzAgEAAA0ABQUDAQIDAgAFAgIBAAAACAgCDwQECAEEAgECAQIBAwQCAwEhIQsBAAENAwAAAQEFAwAaAwAAAwALAQA3CAAAAAEDAAAAAAAABgYAAQACABMDAQADAAQEEAIEAwADAgACAAITADQYGAIKAAQEBAECAQIAAwEFBQUBAAEAAQAAQEETAQEBFAMCAQADBAUAAwMAAgEmAQMDAAYAAgMACBsADAEDAw4EAAAEAwAAIwAEAwMDLgQBAgICLxcFAQABAAAAAwEBAgICAgADAAAAAAABAAAQBQEBEAIEAQApLDkAAQAAAQEBAAAFAAAtAAAAAQUDGQIGFgMGAQACAwUAAgAAAgMDAAIECgADAQQBAQAAAAQDBAQDBQQFAAUDBQAFBDAiBCICAgMDAQMCBAQNAwUBAQIAAAECAAQBAQEUGRABAAMAAwEBAwADAwMBBAMFEwIEBQADDwIAAwUDAQEBABECAwEAAAAAAAACAAABAAMBAAAAAwEDAwEBBQABDgICAgEDAwEFAQUDEAMBAwAFAgABARsCCQMEBwcDBQMBAwEBGAADAAEAAAAAAQAAAAADGgECAjsDAAMAAAABAQADAwAABAEDAQEFAQACAAQCADgAAAIAEAgCAwMACAA/BgACAwMDAwMFCAMICAgICBYDKAABAAI6GwECAgEDAgMBAQAKCAYCAAIEAgICAAIAAAABAQIEBAMABAAAAAMBAAAAAAADAwAAAAAAAAABBAAEAAMAAQAAAQMAAQEDAAEABAMBAAAYBAIDAwADBAYOAA8jAjU2FwEBAQEBAQ0CAAIAEgMLDgADAAAOAAAAAwMGAwEEBAMDDwAAAgECAgEBAAEBBQACAAEBAgICBQABAQUCAwECAQECBQIBBAACAQICAQIAAQEAAgACAgMDHgMDBAICAQEAAwMBAAEBAgEDAwABAwIBAAEAAQABAwABAgADAQQDAAICAgEAAAMBCQcABwEFAQQCAAIAAQMFAQEBAQABAwECBgIGBAAAAAAAAAICAAQCAAAABAIAAAIAAAQCAAICAgMBAwACAQIBBgYBAgICAgICAAICCgwCAgICAgEEAgICAQIAAhQBAQAIAwACAgICAQAAAgIAAgEAAgIBFQsGBgYVBgsAFQsCAgICAgYBAgICAQYGAgQCAAICAQEMAgAAAAEBDAIAAQQCAAACAAQCAAIEAgIAAAIAAQoMAAACAAAEAgAAAgACAAIAAAIAAAIAAAQCAAACAAACAQIAAgAEAgAAAAIAAAQCAAAEAgAABAIAAAIABAICAAAEAgAAAAQCAAACAAACAAAEAgAAAgAAAgACAAQCAAACAAEABAIAAAQCAgAABAIAAAACAAAEAgAABAIAAAIAAAQCAAACBgAA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cSIEdEEPdiABIAJyIARyayIBQQF0IAAgAUEVanZBAXFyQRxqIQILIAMgAjYCHCACQQJ0QeDDAWohAQJAAkACQEG0wQEoAgAiBEEBIAJ0IgdxRQRAQbTBASAEIAdyNgIAIAEgAzYCACADIAE2AhgMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgASgCACEBA0AgASIEKAIEQXhxIABGDQIgAkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtB0MEBQdDBASgCAEEBayIAQX8gABs2AgALCw0AIAAoAgAgAUECdGoLVAICfwF9IwBBEGsiASQAAn0gACgCACAAKAIEIAFBDGoQhgQiAkUEQCAAEMABQwAAAAAMAQsgACAAKAIAIAJqNgIAIAEqAgwLIQMgAUEQaiQAIAO7CwcAIABBDGoLEAAgACgCBCAAKAIAa0ECdQspAQF/IAIEQCAAIQMDQCADIAE6AAAgA0EBaiEDIAJBAWsiAg0ACwsgAAsGACAAEC4LNQEBfyMAQRBrIgIkACACIAAoAgA2AgwgACABKAIANgIAIAEgAkEMaigCADYCACACQRBqJAALCAAgABCCAacLFAEBf0EIECciASAAKQIANwMAIAELKQEBfyMAQRBrIgEkACABIAApAgA3AwggAUEIahA3IQAgAUEQaiQAIAALDAAgACABKQIANwIACwkAIAAQ+wQgAAsoAQF/IAEgAUEBayICcUUEQCAAIAJxDwsgACABTwR/IAAgAXAFIAALCwsAIAAQQxogABAuCwcAIABBBGoLLAEBfyAAEL0CIAAoAgAEQCAAELUEIAAQKBogACgCACEBIAAQlQEaIAEQLgsLBAAgAAsSACAAIAI4AgQgACABOAIAIAALCwAgACABNgIAIAALAwAACxoAIABBiOgANgIAIABBGGoQPiAAEJQCGiAACwsAIABCADcCACAACwUAEBIACwcAIABBEGoLEwAgACABEMACIABBBGogAhDoAQsMACABIAIoAgA2AgALPQECfyMAQRBrIgMkACADIABBARDrASECIAAQKCACKAIEIAEQSCACIAIoAgRBBGo2AgQgAhBpIANBEGokAAtVAQF/IAAoAgQhAQNAIAEgACgCCEcEQCAAKAIQGiAAIAAoAghBBGs2AggMAQsLIAAoAgAEQCAAKAIQGiAAKAIAIQEgABAxKAIAIAAoAgBrGiABEC4LC1kBAn8jAEEQayICJAAgAiABNgIMIAEgABDIBCIDTQRAIAAQlQEiACADQQF2SQRAIAIgAEEBdDYCCCACQQhqIAJBDGoQWCgCACEDCyACQRBqJAAgAw8LEHAAC1ABAX8gABC9AiAAECggACgCACAAKAIEIAFBBGoiAhDqASAAIAIQNSAAQQRqIAFBCGoQNSAAECggARAxEDUgASABKAIENgIAIAAgABAyEMcCCw0AIAAoAgAgAUEDdGoLEAAgACgCBCAAKAIAa0EDdQsYACAALQAAQSBxRQRAIAEgAiAAENwCGgsLCwAgACABEGFBAEcLUgEBfyMAQRBrIgIkACACIAE7AQ4gAiAAIAJBDmoQzQQ2AgggAhCpATYCAEEAIQAgAkEIaiACEMwERQRAIAJBCGoQcygCBCEACyACQRBqJAAgAAtLAQJ/IwBBEGsiASQAIAEgABCIBSEAIwBBEGsiAiQAIAJBCGogACgCBBBBKAIAQQE6AAAgACgCCEEBOgAAIAJBEGokACABQRBqJAALdQEDfyMAQRBrIgIkACACIAAQiAUhACMAQRBrIgMkACADQQhqIAAoAgQQQSgCAC0AAEUEQAJ/AkAgACgCCCIALQAAIgFBAUcEfyABQQJxDQEgAEECOgAAQQEFQQALDAELAAshAQsgA0EQaiQAIAJBEGokACABCygAIABB4NAAKQIANwIQIABB2NAAKQIANwIIIABB0NAAKQIANwIAIAALCQAgABA9KAIACyEAIAEgACoCNFwEQCAAIAE4AjQgACAAKAIAKAI8EQEACwshACABIAAqAjBcBEAgACABOAIwIAAgACgCACgCOBEBAAsLJAECfyMAQRBrIgIkACAAIAEQxgIhAyACQRBqJAAgASAAIAMbC20BAX8jAEGAAmsiBSQAIARBgMAEcSACIANMckUEQCAFIAFB/wFxIAIgA2siAkGAAiACQYACSSIBGxAzGiABRQRAA0AgACAFQYACEE8gAkGAAmsiAkH/AUsNAAsLIAAgBSACEE8LIAVBgAJqJAALDgBBy78BIAEgAhAJIAALUAECfyMAQRBrIgMkAAJAAkACQAJAIAFBBGsOAgABAwsgAyACEMwBIABBBGogAxDOAiADEG8MAQsgACACEDY2AhALQQEhBAsgA0EQaiQAIAQLGQAgACgCACABOAIAIAAgACgCAEEIajYCAAsJACAAKAIAEB0LuwEBAn8jAEEQayIDJAACf0EAIAAvASwgARBhIAFGDQAaIABBLGogARDVASAAIAAvASwgACgCACgCMBEDACAAKAIoIgRBLGpBAhDVASAAKAIkIAQoAqQBSQRAIAQgACgCJDYCpAELQQEgAkUNABogAyAAQRhqIgAQKjYCCCADIAAQKzYCAAN/IANBCGogAxAsBH8gAygCCCgCACABQQEQXhogA0EIahAtGgwBBUEBCwsLIQAgA0EQaiQAIAALWgECfyAAIAFByABrQQAgARsiAzYCKAJAIAAgA0YNAEEBIQIgASAAKAIQIAEoAgAoAgARAgAiAUUNACABQQsgASgCACgCDBECAEUNACAAIAE2AhRBACECCyACCw8AIAAgACgCACgCZBEBAAsHACAAIAFxCwoAIABBqAw2AgALBABBAAsUACAABEAgACAAKAIAKAIEEQEACwspAQF/IwBBEGsiAiQAIAIgATYCDCAAQYwBaiACQQxqEMcDIAJBEGokAAszAQF/IAIEQCAAIQMDQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQQFrIgINAAsLIAALGAAgACABKgIAOAIAIAAgASoCBDgCBCAACxkAIABBBGogAUEEahCJBSAAIAEoAhA2AhALDwAgACgCACAAKAIENgIEC08BAXwgACAAoiIARIFeDP3//9+/okQAAAAAAADwP6AgACAAoiIBREI6BeFTVaU/oqAgACABoiAARGlQ7uBCk/k+okQnHg/oh8BWv6CioLYLSwECfCAAIACiIgEgAKIiAiABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAUSy+26JEBGBP6JEd6zLVFVVxb+goiAAoKC2C1IBAn0gAUEAECYqAgAhBCACQQAQJioCACEFIABBABAmIAQgBSADlJI4AgAgAUEBECYqAgAhBCACQQEQJioCACEFIABBARAmIAQgBSADlJI4AgALDAAgABDtARogABAuCyEAIAAQ/wIgAEEANgI8IABB9Bw2AgAgAEG85AA2AgAgAAsdAQF/IAAQhQEEQCAAKAIAIQEgABDEAhogARAuCwsFABBFAAsoAQF/IwBBEGsiAiQAIAIgATYCDCAAQRhqIAJBDGoQxwMgAkEQaiQACxIAIAAQhQEEQCAAKAIADwsgAAsKACAAKAIAQQhqC0gAIAAQYiAAQfALNgIAIABBBGpBnAwQlwEgAEEANgIQIABBADYCFCAAQYjoADYCACAAQRhqEDoaIABB//8DOwEsIABBADYCKAsMACAAEOIBGiAAEC4LNwEBfyAAKAIEIgNBAXUgAWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEDAAsZACAAKAIAIAE2AgAgACAAKAIAQQhqNgIACxQBAX9BBBAnIgEgACgCADYCACABC1MCAn8BfSMAQRBrIgIkACAAKAIAIQMgAiABIAAoAgQiAEEBdWoiASAAQQFxBH8gASgCACADaigCAAUgAwsRBgA4AgwgAioCDCEEIAJBEGokACAECyABAX8gACgCACECIAAgATYCACACBEAgABA9IAIQnQMLCxEAIAAgAEEBa3FFIABBAktxCxAAIAAoAgQgACgCAGtBBnULJwAgARCnAgRAIAAgASgCOBC/AxBnGg8LIAAgASoCMCABKgI0EEAaCwgAIABB2ABqC1gBA30gAUEAECYqAgAhBCABQQEQJioCACEFIAJBABAmKgIAIQYgAEEAECYgBCAGIASTIAOUkjgCACACQQEQJioCACEEIABBARAmIAUgBCAFkyADlJI4AgALCwAgAEGYzwA2AgALDQAgACgCBCAAKAIAawufAQIHfwF+IwBBEGsiAyQAAn4CfyAAKAIEIQUgACgCACIGIQECQANAIAEgBU8NASABLQAAIgdB/wBxrSACQf8BcSICrYYgCIQhCCABQQFqIQEgAkEHaiECIAdBgAFxDQALIAMgCDcDCCABIAZrIQQLIAQiAUULBEAgABDAAUIADAELIAAgACgCACABajYCACADKQMICyEIIANBEGokACAICyEAIAEgACoCPFwEQCAAIAE4AjwgACAAKAIAKAJEEQEACwsQACAAKAIEIAAoAgBrQShtCwoAIAAtAAtBB3YL7gwBCH8jAEEQayIEJAAgBCAANgIMAkAgAEHTAU0EQEGgtwFB4LgBIARBDGoQjQUoAgAhAAwBCyAAQXxPBEAQRQALIAQg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ACAAKAIAa0EDbQsSACAAECgoAgAgACgCAGtBA3ULEAAgACgCBCAAKAIAa0EDbQsNACAAKgIMIAAqAgSTCw0AIAAqAgggACoCAJMLDwAgABAoKAIAIAAoAgBrCwcAIAAQhAMLFQAgABCFAQRAIAAoAgQPCyAALQALC60BAQR/AkAgABCTASICIAEQkwFHDQAgABByIQMgARByIQEgABCFAUUEQANAIAJFIQQgAkUNAiADLQAAIAEtAABHDQIgAUEBaiEBIANBAWohAyACQQFrIQIMAAsACyACBH9BACEAAkAgAkUNAANAIAMtAAAiBCABLQAAIgVGBEAgAUEBaiEBIANBAWohAyACQQFrIgINAQwCCwsgBCAFayEACyAABUEAC0UhBAsgBAsSACAAECgoAgAgACgCAGtBAnULJAECfyMAQRBrIgAkACAAQQhqQQAQQSgCACEBIABBEGokACABCyABAX8jAEEQayICJAAgACABIAEQhQUQ4QIgAkEQaiQACxYAIAAQdCAAQbALNgIAIABB8Ao2AgALBABBAAsPACAAQQRqIAFBBGoQiQULUgECf0GMvgEoAgAiASAAQQNqQXxxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABAXRQ0BC0GMvgEgADYCACABDwtB4MABQTA2AgBBfwtXAQJ/IwBBEGsiAyQAIAAoAgQiBEEBdSABaiEBIAAoAgAhACAEQQFxBEAgASgCACAAaigCACEACyADIAIQpwUgASADIAARAgAhACADEG8gA0EQaiQAIAALDgBB/L4BIAEgAhAJIAALmgEBAn8gASgCACAAKAIAIAMoAgARAgAhBSACKAIAIAEoAgAgAygCABECACEEAn8CQCAFRQRAQQAgBEUNAhogASACEDVBASABKAIAIAAoAgAgAygCABECAEUNAhogACABEDUMAQsgBARAIAAgAhA1QQEPCyAAIAEQNUEBIAIoAgAgASgCACADKAIAEQIARQ0BGiABIAIQNQtBAgsLDgAgACABKAIANgIAIAALCwAgACABIAIQ0QELIAAgACgCBCAAECgoAgBHBEAgACABEEkPCyAAIAEQpgMLBwAgAEECRwvnDQILfwl9IAAgARCHAiABQQgQUARAIAAoAogBIQMgACAAKAIAKAJoEQAAIQsjAEGQAWsiAiQAIAMgAygCACgCCBEBAAJAIABBjAFqIggQMiIJQQJJDQACQCAIQQAQLygCACIAELgBIgoEQCACQUBrIAAQ3QEQZyIBQQAQJioCACERIAFBARAmKgIAIRIgAkGIAWogABCmAhBnIgFBABAmKgIAIQ0gAUEBECYqAgAhDyACQYABaiAAEH0gAyACQYABakEAECYqAgAiEyACQYABakEBECYqAgAiFCADKAIAKAIUEQcADAELIAIgAkFAayAAEMQDIgQqAjwiDTgCPAJAIA1DAAAAAF4EQCAIIAlBAWsQLygCACEBIAJBiAFqIAQQfSACQYABahBEIQACQCABELgBBEAgAkEwaiABEKYCEGcaDAELIAJBMGogARB9CyAAIAJBMGogAkGIAWoQuwEgAiAAEN4BIg04AiwgAEEAECYiASABKgIAIA2VOAIAIAIqAiwhDSAAQQEQJiIBIAEqAgAgDZU4AgAgCEEBEC8oAgAhBSACQTBqEEQhAQJAIAUQuAEEQCACQSBqIAUQ3QEQZxoMAQsgAkEgaiAFEH0LIAEgAkEgaiACQYgBahC7ASACIAEQ3gEiDTgCHCABQQAQJiIFIAUqAgAgDZU4AgAgAioCHCENIAFBARAmIgUgBSoCACANlTgCACACQSxqIAJBHGogAkE8ahCmARCmASoCACENIAJBIGoQRCIFIAJBiAFqIAAgDRBsIAMgBUEAECYqAgAiESAFQQEQJioCACISIAMoAgAoAhQRBwAgAkEQahBEIgUgAkGIAWogACANQ+465T6UIg8QbCACQQhqEEQiACACQYgBaiABIA8QbCACEEQiByACQYgBaiABIA0QbCADIAVBABAmKgIAIAVBARAmKgIAIABBABAmKgIAIABBARAmKgIAIAdBABAmKgIAIg0gB0EBECYqAgAiDyADKAIAKAIcEQkADAELIAJBiAFqIAQQfSADIAJBiAFqQQAQJioCACIRIAJBiAFqQQEQJioCACISIAMoAgAoAhQRBwAgEiEPIBEhDQsgBBBDGiASIRQgESETCyAJQQEgCUEBSxshDEEBIQUgCiEAAkADQCAFIAxGBEACQCALRQ0EIAAgCnJBAXFFDQAgAyANIA8gESASIBMgFCADKAIAKAIcEQkADAMLBQJAIAggBRAvKAIAIgQQuAEiAQRAIAJBQGsgBBDdARBnIQAgAkGIAWogBBB9IAMg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AToAPAsUACAAQcgAaiABEPMDIABBAToAPQsYACAAEKcCBEAgACgCOBDsAw8LIAAQ6wMLIgEBfSAAQQAQJioCACIBIAGUIABBARAmKgIAIgEgAZSSkQsUACAAKAIIIgAgACgCACgCCBEAAAsfAQF/IABBHGoiABAyIAFLBH8gACABEC8oAgAFQQALCxIAIAAgATYCBCAAQYjAADYCAAtsAQN/IwBBEGsiASQAIABBhD42AgAgASAAQQRqIgIQKjYCCCABIAIQKzYCAANAIAFBCGogARAsBEAgASgCCCgCACIDBEAgAyADKAIAKAIEEQEACyABQQhqEC0aDAELCyACED4gAUEQaiQAIAALIQAgASAAKgJ4XARAIAAgATgCeCAAIAAoAgAoAlQRAQALCzcBAX0gAUMAAEBAlCIDIAJDAABAQJQiAiABQwAAwMCUkiADQwAAgD8gApOSIACUkiAAlJIgAJQLJAEBfyMAQRBrIgEkACABQQhqIAAQQSgCACEAIAFBEGokACAAC2IBAX8jAEEQayICJAAgAEEAOgAUIAIgAEEIaiIDECo2AgggAiADECs2AgADQCACQQhqIAIQLARAIAIoAghBBGogARC3AgRAIABBAToAFAsgAkEIahDCAQwBCwsgAkEQaiQACwwAIAAQxQIaIAAQLgsJACAAIAE2AgALDAAgACABLQAAOgAACycAIAMgAygCACACIAFrIgBrIgI2AgAgAEEBTgRAIAIgASAAEGYaCwskACAAIAE2AgAgACABKAIEIgE2AgQgACABIAJBAnRqNgIIIAALCQAgAEEcahAyCxMAIABBkC42AgAgAEEEahBvIAALRAEBfwJAAkACQAJAAkAgAUHDAGsOAwABAgQLIAAgAhA2NgIEDAILIAAgAhA2NgIIDAELIAAgAhA2NgIMC0EBIQMLIAMLDAAgACABKAIENgIECyMAIAAQYiAAQfAjNgIAIABBBGpByCQQlwEgAEGgJDYCACAACyIAIAAQ+AQgAEIANwJ4IABBnM4ANgIAIABBhPUANgIAIAALqAEAAkAgAUGACE4EQCAARAAAAAAAAOB/oiEAIAFB/w9IBEAgAUH/B2shAQwCCyAARAAAAAAAAOB/oiEAIAFB/RcgAUH9F0gbQf4PayEBDAELIAFBgXhKDQAgAEQAAAAAAAAQAKIhACABQYNwSgRA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lDgCACACQQIQJiIDIAMqAgAgBZQ4AgAgAkEDECYiAiACKgIAIAWUOAIACyABQcAAEFAEQAJAIABB2ABqIQIgACgCdCIDBEAgAiADQdgAaiAAQUBrEL0BDAELIABBQGsiA0EAECYqAgAhBCACQQAQJiAEOAIAIANBARAmKgIAIQQgAkEBECYgBDgCACADQQIQJioCACEEIAJBAhAmIAQ4AgAgA0EDECYqAgAhBCACQQMQJiAEOAIAIANBBBAmKgIAIQQgAkEEECYgBDgCACADQQUQJioCACEEIAJBBRAmIAQ4AgALCwJAIAFBgAEQUEUNACAAIAAqAjw4AnAgACgCdCIBRQ0AIAAgASABKAIAKAJIEQYAIAAqAnCUOAJwCwsTACAAKAIUBEAgACgCFCAAEHELCw8AIAAgACgCACgCADYCAAsQACAAKAIAIAEoAgBrQQJ1C8UBAQN/IwBBEGsiACQAIAAgATYCCCAAQQhqIQJBBCEBQQQhAwNAIANBBE8EQCACKAAAQZXTx94FbCIEQRh2IARzQZXTx94FbCABQZXTx94FbHMhASADQQRrIQMgAkEEaiECDAELCwJAAkACQAJAIANBAWsOAwIBAAMLIAItAAJBEHQgAXMhAQsgAi0AAUEIdCABcyEBCyABIAItAABzQZXTx94FbCEBCyAAQRBqJAAgAUENdiABc0GV08feBWwiAEEPdiAAcwsgAQF/IABB6ABqIgAQMiABSwR/IAAgARAvKAIABUEACwsMACAAIAEQygJBAXMLJwEBfyMAQRBrIgEkACABQQhqIAAQ6AEgASgCCCEAIAFBEGokACAACyAAIAAoAgQgABAoKAIASQRAIAAgARBJDwsgACABEKYDC1QBAX8jAEEQayIBJAAgABChAyAAQQhqEKADIAFBADYCDCAAQQxqIAFBDGogAUEIahCeAyABQYCAgPwDNgIEIABBEGogAUEEahCfAyABQRBqJAAgAAsRACAAQRggACgCACgCDBECAAtIAQJ/IABBoN0ANgIAIABBsAFqIgEQvQMgASgCAARAIAEgASgCABC6AyABECgaIAEoAgAhAiABEIoBGiACEC4LIAAQiwEaIAALKwAgABDaASAAQgU3AqgBIABB2Bc2AgAgAEGg3QA2AgAgAEGwAWoQOhogAAsTACAAQfALNgIAIABBBGoQbyAACwcA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0gMgAyADKAIIQQhqNgIIIAcQmgIgBxAoIAcoAgAgBygCBCADQQRqIgAQ6gEgByAAEDUgB0EEaiADQQhqEDUgBxAoIAMQMRA1IAMgAygCBDYCACAHIAcQThDQAyADEJsCIAFBIGokAAsLIAhBMGokACAECw0AIAAoAgAgACgCBEYLFgEBfyAAEE4hASAAEOMDIAAgARDiAwsXACAAEKcCBEAgACgCOBB+DwsgABDqAwsKACAAKAI4QQBHCw4AIABBADoAPSAAELYBCw4AIABBADoAPCAAELYBCw4AIABBADsBPCAAELYBCxEAIABBAiAAKAIAKAIMEQIACxEAIABBDSAAKAIAKAIMEQIAC4oBAQV9IAFBABAmKgIAIQYgAUEBECYqAgAhByACQQAQJioCACEDIAJBAhAmKgIAIQQgAkEEECYqAgAhBSAAQQAQJiAFIAYgA5QgByAElJKSOAIAIAJBARAmKgIAIQMgAkEDECYqAgAhBCACQQUQJioCACEFIABBARAmIAUgBiADlCAHIASUkpI4AgALMwAgABB0IABC/////w83AjAgAEHUzQA2AgAgAEEANgJAIABCADcCOCAAQeTpADYCACAACxoAIABBxMYANgIAIABB/ABqED4gABBDGiAAC58CAg19AX8gBEEAECYqAgAhDiAEQQIQJioCACEPIARBBBAmKgIAIRAgBEEBECYqAgAhESAEQQMQJioCACESIARBBRAmKgIAIRMDQCAUQQRGRQRAIBQgAxCOBCIEBEAgDSAEskMAAH9DlSIHIAUgFCACEI4EQRhsIgRqKgIAlJIhDSAMIAcgBSAEQQRyaiIEKgIAlJIhDCAJIAcgBCoCDJSSIQkgCiAHIAQqAgiUkiEKIAsgByAEKgIElJIhCyAIIAcgBCoCEJSSIQgLIBRBAWohFAwBCwsgBkEAECYgCSARIACUIBIgAZSSIBOSIgcgC5QgDiAAlCAPIAGUkiAQkiIAIA2UkpI4AgAgBkEBECYgCCAHIAqUIAAgDJSSkjgCAAsRACAAQSggACgCACgCDBECAAssACAAEHQgAEL/gYCAEDcCMCAAQaAQNgIAIABByMoANgIAIABBOGoQRBogAAttAQN/IwBBEGsiASQAIABBtMMANgIAIAEgAEEYaiICECo2AgggASACECs2AgADQCABQQhqIAEQLARAIAEoAggoAgAiAwRAIAMgAygCACgCBBEBAAsgAUEIahAtGgwBCwsgAhA+IAFBEGokACAACwwAIAAoAgRBAToABAsZACAAIAE2AgggACACNgIEIABByMEANgIACxwAIAAgASgCMDYCMCAAIAEoAjQ2AjQgACABEGgL4gQCBX8DfSAAKAIAIgIqAhghCSAAIAAqAggiBzgCDCAAIAcgAZI4AgggACAAKgIEIAkgAZQgACgCFLKUkjgCBCACKAIQIQMgACoCBCEBIAItACgEQCACKAIgIQQLIAOyIQgCfyACLQAoBEAgAigCJAwBCyACKAIUCyEFIAEgCJQhAUEAIQMgAEEANgIQAkACQAJAAkACQAJAAkAgACgCHCICQX9GBH8gACgCACgCHAUgAgsOAwABAwILIAAoAhQhAwJAIAEgBbIiB15FDQBBASECIANBAUcNACAAIAcgCJU4AgQgACABIAeTIAiVOAIQDAYLIAEgBLIiB11FIANBf0dyDQEgACAHIAiVOAIEIAAgByABkyAIlTgCEAwECyAFIARrIQIgACgCFCEDAkAgASAFsiIHYEUNAEEBIQYgA0EBRw0AIAAgASAHkyAIlTgCECAAIAAqAgQgCJQgBLKTIAIQoAQgBLegtiAIlTgCBAwECyABIASyIgdfRQ0AIANBf0YNAgtBASEGQQAhAgwDCyAAKAIUIQIgBLIhByAFsiEJA0AgAAJ9IAEgCWBFIAJBAUdyRQRAQX8hAiAAQX82AhQgACABIAmTIAiVOAIQIAkgAZMgCZIMAQsgASAHXUEAIAJBf0YbRQRAQQEhBiADIQIMBQtBASECIABBATYCFCAAIAcgAZMiASAIlTgCECABIAeSCyIBIAiVOAIEQQEhAwwACwALIAAgByABkyAIlTgCECAAIAW3IAcgACoCBCAIlJMgAhCgBJmhtiAIlTgCBEEBIQYLQQEhAgsgACACOgAYIAYLRAEBfSAAIAE2AgAgAS0AKARAIAEoAiCyIAEoAhCylSECCyAAQX82AhwgAEKAgICAEDcCECAAQgA3AgggACACOAIEIAALJwACfyAALQAoBEAgACgCJAwBCyAAKAIUC7IgACgCELKVIAAQoQSTC8oDAgl/AX0jAEEQayIGJAAgBiAAQSxqIgAQKjYCCCAGIAAQKzYCAANAIAZBCGogBhAsBEAgBigCCCgCACEAIwBBEGsiByQAAkAgASAAKAIEIAEoAgAoAlARAgAiCEUNACAHIABBCGoiABAqNgIIIAcgABArNgIAA0AgB0EIaiAHECxFDQFBACEEIAcoAggoAgAiCkEIaiIJEDIiCyEFA0AgBUEBayEMAkADQCAEIAVOBEAgBCEADAILIAIgCSAEIAxqQQF1IgAQLygCACoCFCINXgRAIABBAWohBAwBCwsgACEFIAIgDV0NAQsLIAooAgQhBQJAIABFBEAgCUEAEC8oAgAiACAIIAUgAyAAKAIAKAIwEQsADAELIAkgAEEBaxAvKAIAIQQgACALSARAIAIgCSAAEC8oAgAiACoCFFsEQCAAIAggBSADIAAoAgAoAjARCwAMAgsgBCgCCEUEQCAEIAggBSADIAQoAgAoAjARCwAMAgsgBCAIIAUgAiAAIAMgBCgCACgCNBEVAAwBCyAEIAggBSADIAQoAgAoAjARCwALIAdBCGoQLRoMAAsACyAHQRBqJAAgBkEIahAtGgwBBSAGQRBqJAALCwshACABIAAoAjBHBEAgACABNgIwIAAgACgCACgCOBEBAAsLBwAgACoCBAs0ACAAKAIAGiAAKAIAIAAQlQFBAnRqGiAAKAIAIAAQMkECdGoaIAAoAgAgABCVAUECdGoaCxQAIABBrDg2AgAgAEEIahDCBCAACyQBAn8jAEEQayICJAAgACABELwEIQMgAkEQaiQAIAEgACADGwsJACAAQQA2AgALCwAgASACQSgQZhoLFAAgAEGANzYCACAAQQhqEMIEIAALDQAgACgCACABQShsagsOACAAKAIIQf////8HcQsZACAAQbQ2NgIAIABBEGoQPiAAEOIBGiAACw0AIAAoAgAgASgCAEkLLAAgACgCABogACgCACAAEJUBQQJ0ahogACgCACAAEJUBQQJ0ahogACgCABoLCQAgACABOgALCxEAIABBOCAAKAIAKAIMEQIACw0AIAAoAgAgASgCAEYLGgAgAUGlAUYEQCAAIAIQNjYCBAsgAUGlAUYLEwAgACgCACABIAAqAgQgAhC6Ags7ACAAEO4EIABCADcCDCAAQv////8PNwIEIABBvDA2AgAgAEEANgIUIABBtMMANgIAIABBGGoQOhogAAtZAQJ/IwBBEGsiAiQAIAAQhQEEQCAAKAIAIQMgABDEAhogAxAuCyAAIAEo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ADYCQCAAQYT8ADYCACAAKAJEIgEEQCABIAEoAgAoAgQRAQALIAAQQxogAAtTAQF/IAAQdCAAQgA3AjAgAEGgIzYCACAAQgA3AjggAEFAayIBQez8ADYCACAAQYT8ADYCACABQdz8ADYCABDHASEBIABBADYCSCAAIAE2AkQgAAswAQJ/IABBNGoiASgCCARAIAEoAggiAiAAKAIwIAEqAgQQggMgAigCACgCBBEDAAsLPAEBfyABKAIUIQIgACABNgIMIAJBFSACKAIAKAIMEQIAIgEEQCAAIAIgACACKAIAKAJAEQIANgIICyABCysBAX8gAEH4+QA2AgAgACgCMCIBBEAgASABKAIAKAIsEQEACyAAEEMaIAAL7wIBB38jAEEQayIFJABBASEDAkACQAJAAkACQAJAIAEgAGtBAnUOBgUFAAECAwQLIAFBBGsiASgCACAAKAIAIAIoAgARAgBFDQQgACABEDUMBAsgACAAQQRqIAFBBGsgAhCeARoMAwsgACAAQQRqIABBCGogAUEEayACEP8BGgwCCyAAIABBBGogAEEIaiAAQQxqIAFBBGsgAhD+ARoMAQsgACAAQQRqIABBCGoiBiACEJ4BGiAAQQxqIQQCQANAIAEgBEYiCA0BAkAgBCgCACAGKAIAIAIoAgARAgAEQCAFIAQoAgA2AgwgBCEHA0ACQCAHIAYiAygCADYCACAAIANGBEAgACEDDAELIAMhByAFKAIMIANBBGsiBigCACACKAIAEQIADQELCyADIAVBDGooAgA2AgAgCUEBaiIJQQhGDQELIAQiBkEEaiEEDAELCyAEQQRqIAFGIQMLIAMgCHIhAwsgBUEQaiQAIANBAXELBwAgABCBAgsmACAAEJgBIABCADcCMCAAQeASNgIAIABBADYCOCAAQczbADYCAAsMACAAEPwCGiAAEC4LQQAgABCCAiABEIICIAIQywEgABCGAiABEIYCIAIQywEgABCFAiABEIUCIAIQywEgABCEAiABEIQCIAIQywEQgwML1AECAX0CfwJ/An8gABCCArNDAAB/Q5VDAAB/Q5QgAZQiAbwiA0EXdkH/AXEiBEGVAU0EQCAEQf0ATQR9IAFDAAAAAJQFAn0gASABjCADQX9KGyIBQwAAAEuSQwAAAMuSIAGTIgJDAAAAP14EQCABIAKSQwAAgL+SDAELIAEgApIiASACQwAAAL9fRQ0AGiABQwAAgD+SCyIBIAGMIANBf0obCyEBCyABQwAAgE9dIAFDAAAAAGBxCwRAIAGpDAELQQALIAAQhgIgABCFAiAAEIQCEIMDCyUAIANB/wFxIAJBCHRBgP4DcSABQRB0QYCA/AdxIABBGHRycnILFwAgAEEgQQAQXgRAIABBwABBARBeGgsLEQAgAEEmIAAoAgAoAgwRAgALqAIBB38gABA9IQICQCABBEAgACACIAEQtwEQeiAAED0gATYCAEEAIQIDQCABIAJGBEAgAEEIaiICKAIAIgNFDQMgACADKAIEIAEQOyIHEC8gAjYCAANAIAMoAgAiAkUNBAJAIAIoAgQgARA7IgQgB0YNACACIQUgACAEEC8oAgBFBEAgACAEEC8gAzYCACAEIQcMAQsDQAJAIAUiBigCAEUEQEEAIQUMAQsgABBGGiACQQhqIAYoAgBBCGoQyQQhCCAGKAIAIQUgCA0BCwsgAyAFNgIAIAYgACAEEC8oAgAoAgA2AgAgACAEEC8oAgAgAjYCAAwBCyACIQMMAAsABSAAIAIQL0EANgIAIAJBAWohAgwBCwALAAsgAEEAEHogABA9QQA2AgALCxEAIAAgACgCAEEEazYCACAACxAAIAAgATYCBCAAIAE2AgALIQAgABCqARogAEG87QA2AgAgAEG0NjYCACAAQRBqEDoaCyUAIAAQYiAAQX82AgQgAEHc7AA2AgAgAEEANgIIIABBpDQ2AgALpwIBB38gABA9IQICQCABBEAgACACIAEQtwEQeiAAED0gATYCAEEAIQIDQCABIAJGBEAgAEEIaiICKAIAIgNFDQMgACADKAIEIAEQOyIHEC8gAjYCAANAIAMoAgAiAkUNBAJAIAIoAgQgARA7IgQgB0YNACACIQUgACAEEC8oAgBFBEAgACAEEC8gAzYCACAEIQcMAQsDQAJAIAUiBigCAEUEQEEAIQUMAQsgABBGIAJBCGogBigCAEEIahCgASEIIAYoAgAhBSAIDQELCyADIAU2AgAgBiAAIAQQLygCACgCADYCACAAIAQQLygCACACNgIADAELIAIhAwwACwAFIAAgAhAvQQA2AgAgAkEBaiECDAELAAsACyAAQQAQeiAAED1BADYCAAsLSwECfyMAQRBrIgEkACABQQhqAn8jAEEQayIC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LygCACgCADYCACAAIAQQLygCACACNgIADAELIAIhAwwACwAFIAAgAhAvQQA2AgAgAkEBaiECDAELAAsACyAAQQAQeiAAED1BADYCAAsLOAAgAygCACECIwBBEGsiACQAIAAgAjYCCCAAKAIIKAIAIQIgAUEANgIEIAEgAjYCACAAQRBqJAALDAAgACABKAIAEIsCCygAIAAQgwIgAEEANgJYIABCADcCUCAAQbQRNgIAIABBgNIANgIAIAALDAAgACgCABogARAuCwkAIAAgARDUAQsMACAAIAEqAgA4AgALCQAgAEEANgIAC04BAn8jAEEQayICJAAgAkEANgIMIAAgAkEMahDUASMAQRBrIgEkACABQQA2AgwgAEEEaiABQQxqIAFBCGoQngMgAUEQaiQAIAJBEGokAAtNAQF/IwBBEGsiASQAIAAQoQMgAEEIahCgAyABQQA2AgwgAEEMaiABQQxqENQBIAFBgICA/AM2AgQgAEEQaiABQQRqEJ8DIAFBEGokAAsOACAALwEsQQIQYUECRgtdACAAIAEgAiAAKAIAKAIUEQcAIAAgASADkiIDIAIgACgCACgCGBEHACAAIAMgAiAEkiICIAAoAgAoAhgRBwAgACABIAIgACgCACgCGBEHACAAIAAoAgAoAiARAQALKgEBfwJAIAFBAEgNACAAQdwAaiIAEDIgAUwNACAAIAEQLygCACECCyACC7gBAQd/IwBBIGsiByQAIAAQKCIDAn8gACAAEDJBAWoQSyEEIAAQMiEIIwBBEGsiBSQAIAVBADYCDCAHQQhqIgJBDGogBUEMaiADEEcgBARAIAIoAhAaIAQQmAMhBgsgAiAGNgIAIAIgBiAIQQJ0aiIDNgIIIAIgAzYCBCACEDEgBiAEQQJ0ajYCACAFQRBqJAAgAigCCAsgARBIIAIgAigCCEEEajYCCCAAIAIQTCACEEogB0EgaiQACw8AIABBFGoQtAEgABC0AQsSAQF/IAAoAgAhASAAEC0aIAELEQAgABCiAyAAQRRqEKIDIAALyBMCE38BfSMAQcABayIBJAAgACAAQcwAaiICQQAQtQE2AqgBIAAgAkEAELUBNgKsASABIABB3ABqIgkQKjYCUCABIAkQKzYCKCAAQcgAaiEKA0ACQCABQdAAaiABQShqECwiA0UNACABKAJQKAIAIgIEQCAC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IAALDAAgASACKQIANwIAC2ICAX8BfSMAQRBrIgIkACACIABBABAmKgIAIAFBABAmKgIAk4s4AgwgAiAAQQEQJioCACABQQEQJioCAJOLOAIIIAJBDGogAkEIahC/AioCACEDIAJBEGokACADQwAAgD9eCywBAX8gAEH81gA2AgAgACgCaCIBBEAgASABKAIAKAIEEQEACyAAEKACGiAACwsAIABBoNgANgIAC1AAIAAQ1QMgAEGs1wA2AgAgAEEEahA6GiAAQRBqEDoaIABBHGoQOhogAEEoahA6GiAAQTRqEDoaIABBQGsQOhogAEEANgJMIABB0ABqEFQaCw0AIAEgAJMgApQgAJILDQAgACgCACABQQNsagtjAQF/IwBBEGsiByQAIABBKGogB0EIakEBIABBBGoiABBOQf8BcRDbAxDaAyAAIAdBCGogASACEEAQuQEgACAHQQhqIAMgBBBAELkBIAAgB0EIaiAFIAYQQBC5ASAHQRBqJAALogUBB38gACgCBCAAECgoAgBJBEAjAEEQayICJAAgAiAANgIAIAIgACgCBCIDNgIEIAIgA0EDajYCCCAAECggAigCBCABEMsDIAIgAigCBEEDajYCBCACEGkgAkEQaiQADwsjAEEgayIHJAAgABAoIggCfyAHQQhqIQICfyAAEI4BQQFqIQYjAEEQayIFJAAgBSAGNgIMAn8jAEEQayIEJAAgABAoGiAEQdWq1aoFNgIMIARB/////wc2AgggBEEMaiAEQQhqEKgBKAIAIQMgBEEQaiQAIAMgBk8LBEAgABCMASIEIANBAXZJBEAgBSAEQQF0NgIIIAVBCGogBUEMahBYKAIAIQMLIAVBEGokACADDAELEHAACyEFIAAQjgEhBkEAIQMjAEEQayIEJAAgBEEANgIMIAJBDGogBEEMaiAIEEcgBQRAIAIoAhAaIAVB1arVqgVLBEAQRQALIAVBA2wQJyEDCyACIAM2AgAgAiADIAZBA2xqIgY2AgggAiAGNgIEIAIQMSADIAVBA2xqNgIAIARBEGokACACKAIICyABEMsDIAIgAigCCEEDajYCCCAAEM8DIAAQKBogAkEEaiIDIgEgASgCACAAKAIEIAAoAgAiBWsiAUF9bUEDbGoiBDYCACABQQFOBEAgBCAFIAEQZhoLIAAgAxA1IABBBGogAkEIahA1IAAQKCACEDEQNSACIAIoAgQ2AgAgABCOARogACgCABogACgCACAAEIwBQQNsahogACgCACAAEIwBQQNsahogACgCABogAigCBCEAA0AgACACKAIIRwRAIAIoAhAaIAIgAigCCEEDazYCCAwBCwsgAigCAARAIAIoAhAaIAIoAgAhACACEDEoAgAgAigCAGsaIAAQLgsgB0EgaiQACxkAIABBADoAAiAAIAI6AAEgACABOgAAIAALQAEBfyMAQRBrIgMkACAAQShqIANBCGpBACAAQQRqIgAQTkH/AXEQ2wMQ2gMgACADIAEgAhBAELkBIANBEGokAAsnAQF/IwBBEGsiAyQAIABBBGogA0EIaiABIAIQQBC5ASADQRBqJAALnwEBAn8gACgCBCAAECgoAgBHBEAjAEEQayIDJAAgAyAAQQEQ6wEhAiAAECggAigCBCABEMkDIAIgAigCBEEEajYCBCACEGkgA0EQaiQADwsjAEEgayIDJAAgABAoIgIgA0EIaiAAIAAQMkEBahBLIAAQMiACEM0DIgIoAgggARDJAyACIAIoAghBBGo2AgggACACEEwgAhBKIANBIGokAAuJCAIOfwJ9IwBBEGsiCSQAIAkgATYCDCMAQSBrIgUkAAJAAkAgAUE0aiIKEKQCDQACQCACQQAQJioCACABQdAAaiIEQQAQJioCAFwNACACQQEQJioCACAEQQEQJioCAFwNACACQQIQJioCACAEQQIQJioCAFwNACACQQMQJioCACAEQQMQJioCAFwNACACQQQQJioCACAEQQQQJioCAFwNACACQQUQJioCACAEQQUQJioCAFshAwsgA0UNACABKgJMIREMAQsgASACKQIANwJQIAEgAikCEDcCYCABIAIpAgg3AlggChC6ASABQRxqIgsQpQIgAUEEaiINEE4hAwJAIAMgAUEQaiIMIgQQTiIGSwRAIwBBIGsiDiQAAkAgAyAGayIGIAQQKCgCACAEKAIEa0EDdU0EQCMAQRBrIggkACAIIAQgBhCeAiIDKAIEIQYDQCADKAIIIAZHBEAgBBAoGiADKAIEEMoDIAMgAygCBEEIaiIGNgIEDAELCyADEGkgCEEQaiQADAELIAQQKCEDIA5BCGogBCAEEE4gBmoQnQIgBBBOIAMQnAIiDyEIIwBBEGsiAyQAIAMgCCgCCDYCACAI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QQAgACgCCCICRQ0AGiACKAIECyICIAFHBEAgACABBH8gASABKAIAKAIkEQAABUEACzYCCAsgASACRwsoAQF/IwBBEGsiAiQAIAIgATYCDCAAQRxqIAJBDGoQnAQgAkEQaiQAC+ABAQd/IAAoAgQgABAoKAIARwRAIAAgARBJDwsjAEEgayIHJAAgABAoIgQCfyAAIAAQMkEBahBLIQMgABAyIQgjAEEQayIFJAAgBUEANgIMIAdBCGoiAkEMaiAFQQxqIAQQRyADBEAgAigCEBogA0H/////A0sEQBBFAAsgA0ECdBAnIQYLIAIgBjYCACACIAYgCEECdGoiBDYCCCACIAQ2AgQgAhAxIAYgA0ECdGo2AgAgBUEQaiQAIAIoAggLIAEQSCACIAIoAghBBGo2AgggACACEEwgAhBKIAdBIGokAAvGAQEEfyMAQRBrIgEkACAAQaTAADYCACABIABBHGoiAxAqNgIIIAEgAxArNgIAA0ACQCABQQhqIAEQLEUEQCABIABBEGoiAhAqNgIIIAEgAhArNgIAA0AgAUEIaiABECxFDQIgASgCCCgCACIEBEAgBCAEKAIAKAIEEQEACyABQQhqEC0aDAALAAsgASgCCCgCACICBEAgAiACKAIAKAIEEQEACyABQQhqEC0aDAELCyADED4gAhA+IAAQwwEaIAFBEGokACAAC2UCAn8BfSABIAAqAgRcBEAgACABOAIEIAAqAgggACoCDJMhBCAAKAIALQAoBEAgACgCACgCICECCyAAKAIAKAIQIQMgAEEBNgIUIAAgASACIANsspMiATgCCCAAIAEgBJM4AgwLC0IAIAAQsgIaIABC/4GAgBA3AkggAEL/gYCAEDcCQCAAQdQMNgIAIABBrA02AgAgAEHQAGoQRBogAEHYAGoQRBogAAurBAMBfwR+AnwCfCAAuyEHAkAgAbciCL0iBUIBhiIEUCAFQv///////////wCDQoCAgICAgID4/wBWckUEQCAHvSIGQjSIp0H/D3EiAkH/D0cNAQsgByAIoiIIIAijDAELAn4CQCAEIAZCAYYiA1QEQCAFQjSIp0H/D3EhASACRQRAIAZCDIYiA0IAUwRAQQAhAgwDC0F/IQIDQCADQgGGIgNCAFMNAyACQQFrIQIMAAsACyAGQv////////8Hg0KAgICAgICACIQMAgsg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IgAgAEELRhsFQQoLC0UBAX8jAEEQayICJAACQCABEIUBRQRAIAAgASgCCDYCCCAAIAEpAgA3AgAMAQsgACABKAIAIAEoAgQQ4QILIAJBEGokAAt+AQN/IwBBEGsiBSQAIwBBEGsiAyQAIAEgAGtBAnUhAQNAIAEEQCADIAA2AgwgAyADKAIMIAFBAXYiBEECdGo2AgwgASAEQX9zaiAEIAMoAgwgAhDGAiIEGyEBIAMoAgxBBGogACAEGyEADAELCyADQRBqJAAgBUEQaiQAIAALBwAgACoCeAu7AgACQCABQRRLDQACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDgoAAQIDBAUGBwgJCgsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALC1IBA38CQCAAKAIALAAAEMQBRQRADAELA0AgACgCACICLAAAIQMgACACQQFqNgIAIAEgA2pBMGshASACLAABEMQBRQ0BIAFBCmwhAQwACwALIAEL1gIBA38jAEHQAWsiBSQAIAUgAjYCzAFBACECIAVBoAFqQQBBKBAzGiAFIAUoAswBNgLIAQJAQQAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQ5QJBAEgNACAAKAJMQQBOIQIgACgCACEGIAAsAEpBAEwEQCAAIAZBX3E2AgALIAZBIHEhBwJ/IAAoAjAEQCAAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEEOUCDAELIABB0AA2AjAgACAFQdAAajYCECAAIAU2AhwgACAFNgIUIAAoAiwhBiAAIAU2AiwgACABIAVByAFqIAVB0ABqIAVBoAFqIAMgBBDlAiAGRQ0AGiAAQQBBACAAKAIkEQQAGiAAQQA2AjAgACAG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vgELxjUEF38BfQF+AXwjAEEwayINJAAgDUEgahA6IQkjAEEQayIDJAAgDUEIaiAAKAIAAn8gA0EIaiIBQaH9ABAeNgIAIAEoAgALEBQQQRogARBdIANBEGokACMAQRBrIgMkACANKAIIQbCIASgCACADQQRqEAshGiADIAMoAgQQQSEBIBoQ+AEhAiABEMgBIANBEGokACANQQhqEF0CQCACIAkQgQEiA0sEQCMAQSBrIgYkAAJAIAIgA2siBSAJECgoAgAgCSgCBGtNBEAgCSAFEIgEDAELIAkQKCEIIAZBCGohAwJ/IAkQgQEgBWohCiMAQRBrIgEkACABIAo2AgwgCiAJEIQEIgRNBEAgCRCRASIKIARBAXZJBEAgASAKQQF0NgIIIAFBCGogAUEMahBYKAIAIQQLIAFBEGokACAEDAELEHAACyEBIAkQgQEhCiMAQRBrIgQkACAEQQA2AgwgA0EMaiAEQQxqIAgQRyABBEAgAygCEBogARAnIQcLIAMgBzYCACADIAcgCmoiCjYCCCADIAo2AgQgAxAxIAEgB2o2AgAgBEEQaiQAIwBBEGsiASQAIAEgAygCCDYCACADKAIIIQQgASADQQhqNgIIIAEgBCAFajYCBCABKAIAIQQDQCABKAIEIARHBEAgAygCEBogASgCABC+ASABIAEoAgBBAWoiBDYCAAwBCwsgARDYASABQRBqJAAgCRCHBCAJECggCSgCACAJKAIEIANBBGoiARDqASAJIAEQNSAJQQRqIANBCGoQNSAJECggAxAxEDUgAyADKAIENgIAIAkgCRCBARCDBCADKAIEIQEDQCABIAMoAghHBEAgAygCEBogAyADKAIIQQFrNgIIDAELCyADKAIABEAgAygCEBogAygCACEBIAMQMSgCACADKAIAaxogARAuCwsgBkEgaiQADAELIAIgA0kEQCAJKAIAIAJqIQMgCRCBARogCSADEIIEIAkoAgAaIAkoAgAgCRCRAWoaIAkoAgAaIAkoAgAgCRCBAWoaCwsgDSAJKAIANgIMIA0gAjYCCCMAQRBrIgEkACMAQRBrIgMkACADIAFBCGoiBDYCBCADQQhqIA1BCGoQOSADKAIEIAMoAgg2AgAgAygCBCADKAIMNgIEIAMgAygCBEEIajYCBCADQRBqJAAgDUEYaiIWQei+ASAEEBM2AgAg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AjwgASgCACgCEBEDACABIAAoAkAgASgCACgCDBEDACABCwwAQQJBBCAALQBEGwsPACAAIAAoAgAoAjwRAQALCgAgAEE0axD6AgszAAJAIAAgARBfIgENAEEBIQEgAEE0aiAAEPsCRQ0AIAAgACgCACgCPBEBAEEAIQELIAELIgAgAUEKa0H//wNxIgBBGk0EQEGTgIAgIAB2QQFxDwtBAAvZAgEIfwJ/AkACQAJAIAAoAhQiASABKAIAKAIIEQAAQQFrDgMAAgECCyABQcwAakEAIAEbDAILIAFBoAFqQQAgARshAgsgAgsiAUUEQEEBDwtBACECIwBBEGsiBCQAIAQgADYCDCAEQQxqIQcCQCABQQRqIgEoAgQgARAoKAIARwRAIAEgBxBJDAELIwBBIGsiCCQAIAEQKCIFAn8gASABEDJBAWoQSyEDIAEQMiEJIwBBEGsiBiQAIAZBADYCDCAIQQhqIgBBDGogBkEMaiAFEEcgAwRAIAAoAhAaIANB/////wNLBEAQRQALIANBAnQQJyECCyAAIAI2AgAgACACIAlBAnRqIgU2AgggACAFNgIEIAAQMSACIANBAnRqNgIAIAZBEGokACAAKAIICyAHEEggACAAKAIIQQRqNgIIIAEgABBMIAAQSiAIQSBqJAALIARBEGokAEEACzgAIAAoAkwiACABQQAQJioCACABQQEQJioCACACQQAQJioCACACQQEQJioCACAAKAIAKAIcEREACwQAQSQLCQAgABDUAhAuCwsAIABBxABrEIECCzgAIAAoAkwiACABQQAQJioCACABQQEQJioCACACQQAQJioCACACQQEQJioCACAAKAIAKAIYEREACw0AIAAqAjQgASoCNF0LqgMCBX8CfSMAQSBrIgMkACABQYAEEFAEQCAAQdQAaiICECohBSACECshBCMAQSBrIgIkACACIAQ2AhAgAiAFNgIYIAJBugY2AgwgAigCGCACKAIQIAJBDGoQgAIgAkEgaiQACyABQcAAEFAhAkEAIAIgACgCFCIFIAUoAgAoAkQRAAAiBEEERnFFIAFBgAJBgAEQpAFBIBCkARBQG0UEQCAAKAJMIQEgA0EYaiAAKgIwIAAqAjQQQCECIANBEGogACoCOCAAKgI8EEAhBQJAAkAgBEEERw0AIAAoAmAiBEUNACAEEH4hBCADQQhqEEQiBiACIAQQrQIgAxBEIgIgBSAEEK0CIAAgBiACIAAoAgAoAlARBQAMAQsgACACIAUgACgCACgCUBEFAAsgACoCQCEHIAAqAkghCCADIABB1ABqIgAQKjYCCCADIAAQKzYCACAHIAiUIQcDQCADQQhqIAMQLARAIAEgAygCCCgCACIAKAIwIAcQggMgACoCNCABKAIAKAIgEQoAIANBCGoQLRoMAQUgASABKAIAKAIkEQEACwsLIANBIGokAAs2AQF/AkAgACgCFCIBRQ0AIAEoAhRFDQAgACABKAIUIgEQqwIEfyABBUEACzYCYCABIAAQcQsLHwAgACABEF8iAUUEQCAAQcQAaiAAEPsCQQFzDwsgAQsVACAAKAIUQYACQYAEEKQBQQAQXhoLCgAgACgCFBCBAgu9AgEIfwJAIAAgARBfIgENAEEBIQEgACgCFCICQRYgAigCACgCDBECAEUNACAAKAIUIQEjAEEQayIDJAAgAyAANgIMIANBDGohBwJAIAFB1ABqIgEoAgQgARAoKAIARwRAIAEgBxBJDAELIwBBIGsiCCQAIAEQKCIEAn8gASABEDJBAWoQSyECIAEQMiEJIwBBEGsiBSQAIAVBADYCDCAIQQhqIgBBDGogBUEMaiAEEEcgAgRAIAAoAhAaIAJB/////wNLBEAQRQALIAJBAnQQJyEGCyAAIAY2AgAgACAGIAlBAnRqIgQ2AgggACAENgIEIAAQMSAGIAJBAnRqNgIAIAVBEGokACAAKAIICyAHEEggACAAKAIIQQRqNgIIIAEgABBMIAAQSiAIQSBqJAALIANBEGokAEEAIQELIAELRQAgACAAKAIAKAI4EQAABEAgAiACKAIAKAIkEQAAIgIgACgCOCACKAIAKAIMEQMAIAEgAiAAKAIwIAEoAgAoAhQRBQALCxoAIAAgARD9ASIAQQEgACgCACgCABEDACAACwwAIABBgAFBARBeGgtKAAJAAkACQAJAIAFBzwBrDgMAAQIDCyAAIAIQMLY4AlBBAQ8LIAAgAhAwtjgCVEEBDwsgACACEDC2OAJYQQEPCyAAIAEgAhCxAQsdAQF/IABBBGoiABCkAgR/QQAFIABBABAvKAIACwtjAQF/IwBBEGsiAiQAIAIgAEEEaiIAECo2AgggAiAAECs2AgADQAJAIAJBCGogAhAsRQRAQQAhAAwBCyACKAIIKAIAIgAQPSABEJQBDQAgAkEIahAtGgwBCwsgAkEQaiQAIAALDgAgACgCKEEEQQAQXhoLQQEBfwJAIAAgARBfIgINAEEBIQIgASAAKAIwIAEoAgAoAgARAgAiAUUNACABEKwCRQ0AIAAgATYCOEEAIQILIAILIgAgAUEKa0H//wNxIgBBGk0EQEGTgIAoIAB2QQFxDwtBAAtJAQF/AkACQCAAKAIoIgEgACgCMCABKAIAKAJQEQIAIgEEQCABENYBDQELIABBADYCNAwBCyAAIAE2AjQLIAAoAihBBEEAEF4aCzkBAX8CQCAAIAEQXyICDQAgASAAKAIwIAEoAgAoAgARAgAiAUUNACABENYBRQ0AIAAgATYCNAsgAgsEAEEiCwgAIAAQQxAuCyABAX8gACgCACEBIABBADYCACABBEAgABA9IAEQnQMLC+QCAQV/IwBBIGsiASQAIAEgACAAKAIAKAIUEQAAIgI2AhggAkHcAGoiBCABQRhqEI8CIAEgAEHcAGoiBRAqNgIYA0AgAUEYahAtIQMgASAFECs2AhAgAyABQRBqECwEQCABAn9BACABKAIYKAIAIgNFDQAaIAMgAygCACgCFBEAAAs2AhAgBCABQRBqEI8CDAELCyABIABB6ABqIgMQKjYCECABIAMQKzYCCCACQegAaiEDA38gAUEQaiABQQhqECwEfyABIAEoAhAoAgA2AgQgAyABQQRqEKEBIAFBEGoQLRoMAQUgASAAQfQAaiIAECo2AhAgASAAECs2AgggAkH0AGohAAN/IAFBEGogAUEIahAsBH8gASABKAIQKAIANgIEIAAgAUEEahChASABQRBqEC0aDAEFIAIQqgMEQCACIAIoAgAoAgQRAQBBACECCyACQQE6ALQBIAFBIGokACACCwsLCwsgAQF/IABB9ABqIgAQMiABSwR/IAAgARAvKAIABUEACws8AQJ/QdwAECdBAEHcABAzEJwDIgIiASAAKgJQOAJQIAEgACoCVDgCVCABIAAqAlg4AlggASAAENABIAILZAEBfyMAQRBrIgIkACACIABB9ABqIgAQKjYCCCACIAAQKzYCAANAAkAgAkEIaiACECxFBEBBACEADAELIAIoAggoAgAiABA9IAEQlAENACACQQhqEC0aDAELCyACQRBqJAAgAAtkAQF/IwBB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ARDoAiECIAwgC0EBchCuAyIKIAIgCKIgA6C2EFcgCiABEOYCIAmiIASgthBWIAogACoCrAEQgwEgC0ECaiELIAUgAaAhAQwBCwsLCwAgACgCqAFBAXQLDAAgABCgAhogABAuCwkAIAAQsgMQLgscAQF/IAAgARBfIgIEfyACBSAAQbABaiABEF8LC3IBAn8jAEEQayIBJAAgAEGwAWoQwAMgABCIAiABIABBpAFqIgIQKjYCCCABIAIQKzYCAANAIAFBCGogARAsBEAgASgCCCgCACgCMCICIAAoAoABIAIoAgAoAhQRAwAgAUEIahAtGgwBBSABQRBqJAALCwvYAgEEfyMAQRBrIgMkACMAQRBrIgIkAAJAIABBiAFqIgQQMiIFRQ0AIAEgASgCACgCCBEBACACIAQQKjYCCCACIAQQKzYCAANAIAJBCGogAhAsRQ0BIAIoAggoAgAiBC0AOARAIAEgBCgCTCABKAIAKAIYEQMACyACQQhqEC0aDAALAAsgAkEQaiQAIAVBAEchBCADIABBpAFqIgIQKjYCCCADIAIQKzYCAANAIANBCGogAxAsRQRAIAQEQCABIAEoAgAoAgwRAQALIANBEGokAA8LIAMoAggoAgAiAiACKAIAKAI4EQAABEAgASABKAIAKAIIEQEAIAIgAQJ/IAIgAigCACgCRBEAAEECEGFBAkYEQCABIAAQfiABKAIAKAIQEQMAIAAoAuQBDAELIAAoAugBCyACKAIAKAJIEQUAIAEgASgCACgCDBEBAAsgA0EIahAtGgwACwALiwECAX8BfSMAQRBrIgIkACAAIAEQhwICQCABQYABEFBFDQAgAiAAQaQBaiIBECo2AgggAiABECs2AgADQCACQQhqIAIQLEUNASAAKgJwIgMgAigCCCgCACgCNCIBKgIEXARAIAEgAzgCBCABIAEoAgAoAgARAQALIAJBCGoQLRoMAAsACyACQRBqJAALPQECf0HQABAnQQBB0AAQMyIBELADIQIgASAAKAIwNgIwIAEgACgCNDYCNCABIAAtADg6ADggASAAEGggAgsJACAAELYDEC4L7gECAn8EfSABQQgQUARAIAAqAqwBIQUgAC0AqAEhAyAAKgKkASEHIAAqApwBIQQgAEG8AWoiAiAAKgKYASAAKgKgAYyUIgYQVyACIAQgB4yUIgQQViAC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BTYCCCAAIAU2AgQgABAxIAIgA0ECdGo2AgAgBkEQaiQAIAAoAggLIAcQSCAAIAAoAghBBGo2AgggASAAEEwgABBKIAhBIGokAAsgBEEQaiQAQQALawEBfyMAQRBrIgIkACACIABBCGoiABAqNgIIIAIgABArNgIAA0ACQCACQQhqIAIQLEUEQEEAIQAMAQsgAigCCCgCACIAIAEgACgCACgCHBECACIADQAgAkEIahAtGgwBCwsgAkEQaiQAIAALawEBfyMAQRBrIgIkACACIABBCGoiABAqNgIIIAIgABArNgIAA0ACQCACQQhqIAIQLEUEQEEAIQAMAQsgAigCCCgCACIAIAEgACgCACgCGBECACIADQAgAkEIahAtGgwBCwsgAkEQaiQAIAALBwAgACoCFAsJACAAELQEEC4LnwIBCH8gAUEfEFEiAUUEQEEBDwsgASgCBCEBIwBBEGsiAyQAIAMgADYCDCADQQxqIQcCQCABQSxqIgEoAgQgARAoKAIARwRAIAEgBxBJDAELIwBBIGsiCCQAIAEQKCIEAn8gASABEDJBAWoQSyECIAEQMiEJIwBBEGsiBSQAIAVBADYCDCAIQQhqIgBBDGogBUEMaiAEEEcgAgRAIAAoAhAaIAJB/////wNLBEAQRQALIAJBAnQQJyEGCyAAIAY2AgAgACAGIAlBAnRqIgQ2AgggACAENgIEIAAQMSAGIAJBAnRqNgIAIAVBEGokACAAKAIICyAHEEggACAAKAIIQQRqNgIIIAEgABBMIAAQSiAIQSBqJAALIANBEGokAEEAC18BAX8jAEEQayICJAAgAiAAQQhqIgAQKjYCCCACIAAQKzYCAAN/IAJBCGogAhAsBH8gAigCCCgCACIAIAEgACgCACgCHBECABogAkEIahAtGgwBBSACQRBqJABBAAsLC4sBAQF/IwBBEGsiAiQAAkAgASAAKAIEIAEoAgAoAgARAgAEQCACIABBCGoiABAqNgIIIAIgABArNgIAA0AgAkEIaiACECxFBEBBACEADAMLIAIoAggoAgAiACABIAAoAgAoAhgRAgAiAA0CIAJBCGoQLRoMAAsACyACQRBqJABBAQ8LIAJBEGokACAACwkAIAAQtgQQLgsHACAAKgIQCwcAIAAqAggLPgBBACEBA38gAUELRgR/QQAFIAAgAUECdGogAbJD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DwtBAAsEAEEMCyEAIAFBIEYEQCAAIAIQiQE6AJgBQQEPCyAAIAEgAhDkAgsmACABQQJrIgBB//8DcUEkTQRAQoGOgYCAAiAArYinQQFxDwtBAAsEAEEQCywBAn9BpAEQJ0EAQaQBEDMiARCEBSECIAEgAC0AmAE6AJgBIAEgABCjBSACCyIBAX4gASACrSADrUIghoQgBCAAESAAIgVCIIinEBYgBacLAwAACwcAIAAqAnwL1AIBB38jAEEgayIDJAAgAyAAKAIcIgQ2AhAgACgCFCEFIAMgAjYCHCADIAE2AhggAyAFIARrIgE2AhQgASACaiEEQQIhByADQRBqIQECfwJAAkAgACgCPCADQRBqQQIgA0EMahAOEOICRQRAA0AgBCADKAIMIgVGDQIgBUF/TA0DIAEgBSABKAIEIghLIgZBA3RqIgkgBSAIQQAgBhtrIgggCSgCAGo2AgAgAUEMQQQgBhtqIgkgCSgCACAIazYCACAEIAVrIQQgACgCPCABQQhqIAEgBhsiASAHIAZrIgcgA0EMahAOEOICRQ0ACwsgBEF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgASgCBGsLIQQgA0EgaiQAIAQLQgEBfyMAQRBrIgMkACAAKAI8IAGnIAFCIIinIAJB/wFxIANBCGoQFRDiAiEAIAMpAwghASADQRBqJABCfyABIAAbCwkAIAAoAjwQGAuPBQIGfgF/IAEgASgCAEEPakFwcSIBQRBqNgIAIAACfCABKQMAIQQgASkDCCEFIwBBIGsiACQAAkAgBUL///////////8AgyIDQoCAgICAgMCAPH0gA0KAgICAgIDA/8MAfVQEQCAFQgSGIARCPIiEIQMgBEL//////////w+DIgRCgYCAgICAgIAIWgRAIANCgYCAgICAgIDAAHwhAgwCCyADQoCAgICAgICAQH0hAiAEQoCAgICAgICACIVCAFINASACIANCAYN8IQIMAQsgBFAgA0KAgICAgIDA//8AVCADQoCAgICAgMD//wBRG0UEQCAFQgSGIARCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiADQv///////7//wwBWDQBCACECIANCMIinIgFBkfcASQ0AIAQhAiAFQv///////z+DQoCAgICAgMAAhCIDIQYCQCABQYH3AGsiCEHAAHEEQCACIAhBQGqthiEGQgAhAgwBCyAIRQ0AIAYgCK0iB4YgAkHAACAIa62IhCEGIAIgB4YhAgsgACACNwMQIAAgBjcDGAJAQYH4ACABayIBQcAAcQRAIAMgAUFAaq2IIQRCACEDDAELIAFFDQAgA0HAACABa62GIAQgAa0iAoiEIQQgAyACiCEDCyAAIAQ3AwAgACADNwMIIAApAwhCBIYgACkDACIEQjyIhCECIAApAxAgACkDGIRCAFKtIARC//////////8Pg4QiBEKBgICAgICAgAhaBEAgAkIBfCECDAELIARCgICAgICAgIAIhUIAUg0AIAJCAYMgAnwhAgsgAEEgaiQAIAIgBUKAgICAgICAgIB/g4S/CzkDAAuoFwMSfwJ+AXwjAEGwBGsiCSQAIAlBADYCLAJ/IAG9IhhCf1cEQEEBIRIgAZoiAb0hGEHgtgEMAQtBASESQeO2ASAEQYAQcQ0AGkHmtgEgBEEBcQ0AGkEAIRJBASETQeG2AQshFAJAIBhCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiASQQNqIg0gBEH//3txEFkgACAUIBIQTyAAQfu2AUH/tgEgBUEgcSIDG0HztgFB97YBIAMbIAEgAWIbQQMQTwwBCyAJQRBqIQ8CQAJ/AkAgASAJQSxqEJIFIgEgAaAiAUQAAAAAAAAAAGIEQCAJIAkoAiwiBkEBazYCLCAFQSByIhVB4QBHDQEMAwsgBUEgciIVQeEARg0CIAkoAiwhC0EGIAMgA0EASBsMAQsgCSAGQR1rIgs2AiwgAUQAAAAAAACwQaIhAUEGIAMgA0EASBsLIQogCUEwaiAJQdACaiALQQBIGyIOIQgDQCAIAn8gAUQAAAAAAADwQWMgAUQAAAAAAAAAAGZxBEAgAasMAQtBAAsiAzYCACAIQQRqIQggASADuKFEAAAAAGXNzUGiIgFEAAAAAAAAAABiDQALAkAgC0EBSARAIAshAyAIIQYgDiEHDAELIA4hByALIQMDQCADQR0gA0EdSBshDAJAIAhBBGsiBiAHSQ0AIAytIRlCACEYA0AgBiAGNQIAIBmGIBh8IhggGEKAlOvcA4AiGEKAlOvcA359PgIAIAcgBkEEayIGTQRAIBhC/////w+DIRgMAQsLIBinIgNFDQAgB0EEayIHIAM2AgALA0AgByAIIgZJBEAgBkEEayIIKAIARQ0BCwsgCSAJKAIsIAxrIgM2AiwgBiEIIANBAEoNAAsLIApBGWpBCW0hCCADQX9MBEAgCEEBaiERIBVB5gBGIQ0DQEEJQQAgA2sgA0F3SBshFgJAIAYgB0sEQEGAlOvcAyAWdiEXQX8gFnRBf3MhEEEAIQMgByEIA0AgCCADIAgoAgAiDCAWdmo2AgAgDCAQcSAXbCEDIAhBBGoiCCAGSQ0ACyAHIAdBBGogBygCABshByADRQ0BIAYgAzYCACAGQQRqIQYMAQsgByAHQQRqIAcoAgAbIQcLIAkgCSgCLCAWaiIDNgIsIA4gByANGyIIIBFBAnRqIAYgBiAIa0ECdSARShshBiADQQBIDQALC0EAIQgCQCAGIAdNDQAgDiAHa0ECdUEJbCEIIAcoAgAiDEEKSQ0AQeQAIQMDQCAIQQFqIQggAyAMSw0BIANBCmwhAwwACwALIApBACAIIBVB5gBGG2sgFUHnAEYgCkEAR3FrIgMgBiAOa0ECdUEJbEEJa0gEQCADQYDIAGoiEEEJbSIMQQJ0IAlBMGpBBHIgCUHUAmogC0EASBtqQYAgayENQQohAwJAIBAgDEEJbGsiDEEHSg0AQeQAIQMDQCAMQQFqIgxBCEYNASADQQpsIQMMAAsACwJAIA0oAgAiDCAMIANuIhEgA2xrIhBFQQAgDUEEaiILIAZGGw0ARAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgC0YbRAAAAAAAAPg/IBAgA0EBdiILRhsgCyAQSxshGkQBAAAAAABAQ0QAAAAAAABAQyARQQFxGyEBAkAgEw0AIBQtAABBLUcNACAamiEaIAGaIQELIA0gDCAQayILNgIAIAEgGqAgAWENACANIAMgC2oiAzYCACADQYCU69wDTwRAA0AgDUEANgIAIAcgDUEEayINSwRAIAdBBGsiB0EANgIACyANIA0oAgBBAWoiAzYCACADQf+T69wDSw0ACwsgDiAHa0ECdUEJbCEIIAcoAgAiC0EKSQ0AQeQAIQMDQCAIQQFqIQggAyALSw0BIANBCmwhAwwACwALIA1BBGoiAyAGIAMgBkkbIQYLA0AgBiILIAdNIgxFBEAgC0EEayIGKAIARQ0BCwsCQCAVQecARwRAIARBCHEhEwwBCyAIQX9zQX8gCkEBIAobIgYgCEogCEF7SnEiAxsgBmohCkF/QX4gAxsgBWohBSAEQQhxIhMNAEF3IQYCQCAMDQAgC0EEaygCACIDRQ0AQQAhBiADQQpwDQBBACEMQeQAIQYDQCADIAZwRQRAIAxBAWohDCAGQQpsIQYMAQsLIAxBf3MhBgsgCyAOa0ECdUEJbCEDIAVBX3FBxgBGBEBBACETIAogAyAGakEJayIDQQAgA0EAShsiAyADIApKGyEKDAELQQAhEyAKIAMgCGogBmpBCWsiA0EAIANBAEobIgMgAyAKShshCgsgCiATciIXQQBHIRAgAEEgIAICfyAIQQAgCEEAShsgBUFfcSIMQcYARg0AGiAPIAggCEEfdSIDaiADc60gDxCrASIGa0EBTARAA0AgBkEBayIGQTA6AAAgDyAGa0ECSA0ACwsgBkECayIRIAU6AAAgBkEBa0EtQSsgCEEASBs6AAAgDyARawsgCiASaiAQampBAWoiDSAEEFkgACAUIBIQTyAAQTAgAiANIARBgIAEcxBZAkACQAJAIAxBxgBGBEAgCUEQakEIciEDIAlBEGpBCXIhCCAOIAcgByAOSxsiBSEHA0AgBzUCACAIEKsBIQYCQCAFIAdHBEAgBiAJQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAJQRBqSw0ACwwBCyAGIAhHDQAgCUEwOgAYIAMhBgsgACAGIAggBmsQTyAHQQRqIgcgDk0NAAsgFwRAIABBg7cBQQEQTwsgCkEBSCAHIAtPcg0BA0AgBzUCACAIEKsBIgYgCUEQaksEQANAIAZBAWsiBkEwOgAAIAYgCUEQaksNAAsLIAAgBiAKQQkgCkEJSBsQTyAKQQlrIQYgB0EEaiIHIAtPDQMgCkEJSiEDIAYhCiADDQALDAILAkAgCkEASA0AIAsgB0EEaiAHIAtJGyEFIAlBEGpBCXIhCyAJQRBqQQhyIQMgByEIA0AgCyAINQIAIAsQqwEiBkYEQCAJQTA6ABggAyEGCwJAIAcgCEcEQCAGIAlBEGpNDQEDQCAGQQFrIgZBMDoAACAGIAlBEGpLDQALDAELIAAgBkEBEE8gBkEBaiEGIBNFQQAgCkEBSBsNACAAQYO3AUEBEE8LIAAgBiALIAZrIgYgCiAGIApIGxBPIAogBmshCiAIQQRqIgggBU8NASAKQX9KDQALCyAAQTAgCkESakESQQAQWSAAIBEgDyARaxBPDAILIAohBgsgAEEwIAZBCWpBCUEAEFkLDAELIBRBCWogFCAFQSBxIgsbIQoCQCADQQtLDQBBDCADayIGRQ0ARAAAAAAAACBAIRoDQCAaRAAAAAAAADBAoiEaIAZBAWsiBg0ACyAKLQAAQS1GBEAgGiABmiAaoaCaIQEMAQsgASAaoCAaoSEBCyAPIAkoAiwiBiAGQR91IgZqIAZzrSAPEKsBIgZGBEAgCUEwOgAPIAlBD2ohBgsgEkECciEOIAkoAiwhCCAGQQJrIgwgBUEPajoAACAGQQFrQS1BKyAIQQBIGzoAACAEQQhxIQggCUEQaiEHA0AgByIFAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLIgZB0LYBai0AACALcjoAACAFQQFqIgcgCUEQamtBAUcgCCADQQBKckVBACABIAa3oUQAAAAAAAAwQKIiAUQAAAAAAAAAAGEbckUEQCAFQS46AAEgBUECaiEHCyABRAAAAAAAAAAAYg0ACyAAQSAgAiAOIA8gCUEQaiAMamsgB2ogAyAPaiAMa0ECaiADRSAHIAlrQRJrIANOchsiA2oiDSAEEFkgACAKIA4QTyAAQTAgAiANIARBgIAEcxBZIAAgCUEQaiAHIAlBEGprIgUQTyAAQTAgAyAFIA8gDGsiA2prQQBBABBZIAAgDCADEE8LIABBICACIA0gBEGAwABzEFkgCUGwBGokACACIA0gAiANShsLMwEBfyAAKAIUIgMgASACIAAoAhAgA2siASABIAJLGyIBEGYaIAAgACgCFCABajYCFCACCycBAX8jAEEQayIBJAAgASAANgIMIAEoAgwhABCdBSABQRBqJAAgAAsmACABQQJrIgBB//8DcUEkTQRAQoXOgICAAiAArYinQQFxDwtBAAv6AQEEfyMAQfAAayICJAAgAiAANgJsIAIgAigCbDYCACMAQRBrIgMkACADIAI2AgwjAEGgAWsiACQAIABBCGpB0LEBQZABEGYaIAAgAkEQaiIBNgI0IAAgATYCHCAAQX4gAWsiBEH/////ByAEQf////8HSRsiBDYCOCAAIAEgBGoiATYCJCAAIAE2AhggAEEIakGSlQEgAkHsCEHtCBCRBSAEBEAgACgCHCIBIAEgACgCGEZrQQA6AAALIABBoAFqJAAgA0EQaiQAAn9BACACQRBqIgAQhQVBAWoiARDzASIDRQ0AGiADIAAgARBmCyEAIAJB8ABqJAAgAAsvAQF/IwBBEGsiAyQAIAMgASACIAAoAgARBQAgAxCfBSEAIAMQbyADQRBqJAAgAAsEAEEECzkBAX8gACgCBCIEQQF1IAFqIQEgACgCACEAIAEgAiADIARBAXEEfyABKAIAIABqKAIABSAACxEUAAs3AQF/IAAoAgQiA0EBdSABaiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALERkACzsBAX8gACgCBCIFQQF1IAFqIQEgACgCACEAIAEgAiADIAQgBUEBcQR/IAEoAgAgAGooAgAFIAALERYACzcBAX8gACgCBCIDQQF1IAFqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRHgALDAAgABChBRogABAuCwsAIABBooEBEIgBC8YBAQN/IwBBEGsiAyQAIAMgAjgCCCADIAE2AgwgACgCCCEAIwBBEGsiASQAAn8CQEGQwAEtAABBAXENAEGQwAEQU0UNACMAQRBrIgQkAEEDQfSRARADIQUgBEEQaiQAQYzAASAFNgIAQZDAARBSC0GMwAEoAgALIABBmoEBAn8jAEEQayIAJAAgACABNgIMIABBDGogA0EMaigCABB3IABBDGogA0EIaioCABBcIABBEGokACABCxAEIAFBEGokACADQRBqJAALSgEBfyMAQRBrIgUkACAFIAI4AgggBSABOAIMIAUgAzgCBCAFIAQ4AgAgAEGLgQEgBUEMaiAFQQhqIAVBBGogBRCiBSAFQRBqJAALSgEBfyMAQRBrIgUkACAFIAI4AgggBSABOAIMIAUgAzgCBCAFIAQ4AgAgAEH8gAEgBUEMaiAFQQhqIAVBBGogBRCiBSAFQRBqJAALkgEBA38jAEEQayICJAAgAiABNgIMIAAoAgghASMAQRBrIgAkAAJ/AkBBgMABLQAAQQFxDQBBgMABEFNFDQAjAEEQayIDJABBAkHQkQEQAyEEIANBEGokAEH8vwEgBDYCAEGAwAEQUgtB/L8BKAIACyABQfKAASAAQQhqIAJBDGoQrgEQBCAAQRBqJAAgAkEQaiQAC5IBAQN/IwBBEGsiAiQAIAIgATYCDCAAKAIIIQEjAEEQayIAJAACfwJAQfi/AS0AAEEBcQ0AQfi/ARBTRQ0AIwBBEGsiAyQAQQJByJEBEAMhBCADQRBqJABB9L8BIAQ2AgBB+L8BEFILQfS/ASgCAAsgAUHugAEgAEEIaiACQQxqEK4BEAQgAEEQaiQAIAJBEGokAAuSAQEDfyMAQRBrIgIkACACIAE2AgwgACgCCCEBIwBBEGsiACQAAn8CQEHwvwEtAABBAXENAEHwvwEQU0UNACMAQRBrIgMkAEECQcCRARADIQQgA0EQaiQAQey/ASAENgIAQfC/ARBSC0HsvwEoAgALIAFB6YABIABBCGogAkEMahCuARAEIABBEGokACACQRBqJAALtQEBBH8jAEEQayICJAAgAiABOAIMIAAoAgghACMAQRBrIgQkAAJ/AkBB6L8BLQAAQQFxDQBB6L8BEFNFDQAjAEEQayIDJABBAkG4kQEQAyEFIANBEGokAEHkvwEgBTYCAEHovwEQUgtB5L8BKAIACyAAQd+AAQJ/IwBBEGsiACQAIAAgBEEIaiIDNgIMIABBDGogAkEMaioCABBcIABBEGokACADCxAEIARBEGokACACQRBqJAALtQEBA38jAEEQayICJAAgAiABNgIMIAAoAgghACMAQRBrIgEkAAJ/AkBB4L8BLQAAQQFxDQBB4L8BEFNFDQAjAEEQayIDJABBAkGwkQEQAyEEIANBEGokAEHcvwEgBDYCAEHgvwEQUgtB3L8BKAIACyAAQbyAAQJ/IwBBEGsiACQAIAAgAUEIaiIDNgIMIABBDGogAkEMaigCABB3IABBEGokACADCxAEIAFBEGokACACQRBqJAALkgEBA38jAEEQayICJAAgAiABNgIMIAAoAgghASMAQRBrIgAkAAJ/AkBB2L8BLQAAQQFxDQBB2L8BEFNFDQAjAEEQayIDJABBAkGokQEQAyEEIANBEGokAEHUvwEgBDYCAEHYvwEQUgtB1L8BKAIACyABQdmAASAAQQhqIAJBDGoQrgEQBCAAQRBqJAAgAkEQaiQACz0BAX8gACgCBCIGQQF1IAFqIQEgACgCACEAIAEgAiADIAQgBSAGQQFxBH8gASgCACAAaigCAAUgAAsREQALNwEBfyAAKAIEIgNBAXUgAWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEIAAu8AQEDfyMAQRBrIgMkACADIAE2AgwgACgCCCEAIwBBEGsiASQAAn8CQEHEvwEtAABBAXENAEHEvwEQU0UNACMAQRBrIgQkAEEDQcyOARADIQUgBEEQaiQAQcC/ASAFNgIAQcS/ARBSC0HAvwEoAgALIABBjv4AAn8jAEEQayIAJAAgACABNgIMIABBDGogA0EMaigCABB3IABBDGogAhCoBRB3IABBEGokACABCxAEIAFBEGokACADQRBqJAALCwAgAEG1/gAQiAELngIBBH8jAEEgayIHJAAgByACOAIYIAcgATgCHCAHIAM4AhQgByAEOAIQIAcgBTgCDCAHIAY4AgggACgCCCEAIwBBMGsiCCQAAn8CQEG8vwEtAABBAXENAEG8vwEQU0UNACMAQRBrIgkkAEEHQbCOARADIQogCUEQaiQAQbi/ASAKNgIAQby/ARBSC0G4vwEoAgALIABBrf4AAn8jAEEQayIAJAAgACAINgIMIABBDGogB0EcaioCABBcIABBDGogB0EYaioCABBcIABBDGogB0EUaioCABBcIABBDGogB0EQaioCABBcIABBDGogB0EMaioCABBcIABBDGogB0EIaioCABBcIABBEGokACAICxAEIAhBMGokACAHQSBqJAALNQEBfyMAQRBrIgMkACADIAI4AgggAyABOAIMIABBpv4AIANBDGogA0EIahClBSADQRBqJAALNQEBfyMAQRBrIgMkACADIAI4AgggAyABOAIMIABBn/4AIANBDGogA0EIahClBSADQRBqJAALHgAgACABIAEoAgAoAiQRAAAgAiAAKAIAKAIoEQUAC5IBAQN/IwBBEGsiAiQAIAIgATYCDCAAKAIIIQEjAEEQayIAJAACfwJAQay/AS0AAEEBcQ0AQay/ARBTRQ0AIwBBEGsiAyQAQQJBmI4BEAMhBCADQRBqJABBqL8BIAQ2AgBBrL8BEFILQai/ASgCAAsgAUGW/gAgAEEIaiACQQxqEK4BEAQgAEEQaiQAIAJBEGokAAsLACAAQYj+ABCIAQsMACAAEKYFGiAAEC4LQQEBfyAAKAIEIghBAXUgAWohASAAKAIAIQAgASACIAMgBCAFIAYgByAIQQFxBH8gASgCACAAaigCAAUgAAsRCQALOQEBfyAAKAIEIgRBAXUgAWohASAAKAIAIQAgASACIAMgBEEBcQR/IAEoAgAgAGooAgAFIAALEQcACxUBAX9BqAQQJxDoAyIBIAAQ9QEgAQsjACABQQprQf//A3EiAEEeTQRAQYOAgIAHIAB2QQFxDwtBAAuSAQEDfyMAQRBrIgIkACACIAE2AgwgACgCCCEBIwBBEGsiACQAAn8CQEGcvwEtAABBAXENAEGcvwEQU0UNACMAQRBrIgMkAEECQdiLARADIQQgA0EQaiQAQZi/ASAENgIAQZy/ARBSC0GYvwEoAgALIAFB3v0AIABBCGogAkEMahCuARAEIABBEGokACACQRBqJAALxgEBAn8jAEEQayIDJAAgAyACNgIIIAMgATYCDCAAKAIIIQAjAEEQayIBJAACfwJAQZS/AS0AAEEBcQ0AQZS/ARBTRQ0AIwBBEGsiAiQAQQNBzIsBEAMhBCACQRBqJABBkL8BIAQ2AgBBlL8BEFILQZC/ASgCAAsgAEHV/QACfyMAQRBrIgAkACAAIAE2AgwgAEEMaiADQQxqKAIAEHcgAEEMaiADQQhqKAIAEHcgAEEQaiQAIAELEAQgAUEQaiQAIANBEGokAAubAQEDfyAAKAIIIQAjAEEQayIDJAACfwJAQYy/AS0AAEEBcQ0AQYy/ARBTRQ0AIwBBEGsiAiQAQQJBxIsBEAMhBCACQRBqJABBiL8BIAQ2AgBBjL8BEFILQYi/ASgCAAsgAEHL/QACfyMAQRBrIgAkACAAIANBCGoiAjYCDCAAQQxqIAEQqAUQdyAAQRBqJAAgAgsQBCADQRBqJAALCwAgAEHD/QAQiAELCwAgAEG+/QAQiAELDAAgABCpBRogABAuCzkAAkACQAJAIAFB0gBrDgIAAQILIAAgAhAwtjgCUEEBDwsgACACEDC2OAJUQQEPCyAAIAEgAhCxAQs9AQF/IAAoAgQiBkEBdSABaiEBIAAoAgAhACABIAIgAyAEIAUgBkEBcQR/IAEoAgAgAGooAgAFIAALEQ8ACyIAIAFBCmtB//8DcSIAQRpNBEBBk4CAMCAAdkEBcQ8LQQALDwAgASAAKAIAaiACOAIACw0AIAEgACgCAGoqAgALGAEBf0EQECciAEIANwIAIABCADcCCCAACwQAQSMLBgAgABA3CwYAQf2+AQsGAEHFwAELBgBBw8ABCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRAwALBgBBwcABCw8AIABBACAAEN8BQTpGGwsPACAAQQAgABDfAUE4RhsLDwAgAEEAIAAQ3wFBO0YbCwcAIAAvAQALUQECfyMAQRBrIgIkACAAKAIAIQMgAiABIAAoAgQiAEEBdWoiASAAQQFxBH8gASgCACADaigCAAUgAwsRAAA7AQ4gAi8BDiEAIAJBEGokACAACwYAQbvAAQvNAQECfwJAAkACfwNAAkACQCABKAIQIANLBH8gASgCFCADQSxsai0AIEUNAiACIARHDQECf0EAIAEoAhQgA0EsbGooAggiAUUNABogASgCBAsFQQALDAMLIARBAWohBAsgA0EBaiEDDAALAAsiAUUNAAJAAkACQAJAIAEgASgCACgCCBEAAEE9aw4EAAMBAgQLIAAgASgCFBA9EIwFDAQLIABBzJQBEJcBDAMLIABB0pQBEJcBDAILIABB15QBEJcBDAELIABB25QBEJcBCwuYBAIFfwF+QRgQJyEDIAAoAgAhBEEAIQAgA0EAOgAEIAMgBDYCACADIAQQ7AEiATYCCCADQX8gAUECdCABIAFB/////wNxRxsQJzYCDAN/IAAgAU8EfyADIARBEGoQMiIANgIQQX9BfyAArUIsfiIGpyIBQQRqIgIgASACSxsgBkIgiKcbECciASAANgIAIAFBBGohASAABEAgASAAQSxsaiECIAEhAANAIABCADcCACAAQgA3AiQgAEEAOwEgIABCgICA/IOAgMA/NwIYIABCADcADSAAQgA3AgggAEEsaiIAIAJHDQALCyADIAE2AhRBAAVBACEBAkAgBCAAEOABIgJFDQACQAJAAkAgAiACKAIAKAIIEQAAQThrDgQBAwIAAwtBEBAnIgEgAiADELUCIAFB3MEANgIAIAEgAi0AEDoADAwCC0EQECciASACIAMQtQIgAUHwwQA2AgAgASACKgIQOAIMDAELQRAQJyIBIAIgAxC1AiABQQA6AAwgAUGEwgA2AgALIAMoAgwgAEECdGogATYCACAAQQFqIQAgAygCCCEBDAELCyEAA0AgAygCECAASwRAIAMoAhQgAEEsbGohASAEQRBq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LwAAAB8AAAAwAAAApwEAQeAtCyaeAQAArgEAAK8BAACwAQAArQEAABoAAAAvAAAAHwAAADAAAACnAQBBkC4LJp4BAACxAQAArwEAALABAACtAQAAGgAAAC8AAAAfAAAAMAAAAKcBAEHELgsmngEAALIBAACzAQAAtAEAAK0BAAC1AQAALwAAAB8AAAAwAAAApwEAQfQuCyqeAQAAtgEAALcBAAC4AQAAuQEAALoBAACkAQAApQEAAKYBAACnAQAAuwEAQagvCyqeAQAAvAEAALcBAAC4AQAAuQEAALoBAACkAQAApQEAAKYBAACnAQAAuwEAQdwvCyaeAQAAvQEAAL4BAAC/AQAArQEAAMABAACkAQAApQEAAKYBAACnAQBBjDALJp4BAADBAQAAvgEAAL8BAACtAQAAwAEAAKQBAAClAQAApgEAAKcBAEG8MAsyMQAAAMIBAADDAQAAxAEAAMUBAADGAQAALwAAAB8AAAAwAAAAxwEAAMgBAADJAQAAygEAQfgwCzIxAAAAywEAAMwBAADNAQAAzgEAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAANUBAADWAQBBtDELMjEAAADXAQAA2AEAANkBAADOAQAAGgAAANABAADRAQAA0gEAANMBAADUAQAA1QEAANYBAEHwMQsyMQAAANoBAADYAQAA2QEAAM4BAAAaAAAA0AEAANEBAADSAQAA0wEAANQBAADVAQAA1gEAQawyCyYxAAAA2wEAANwBAADdAQAA3gEAABoAAAAvAAAAHwAAADAAAADTAQBB3DILNjEAAADfAQAA4AEAAOEBAADiAQAA4wEAANABAADRAQAA0gEAANMBAADUAQAA1QEAANYBAADkAQBBnDMLLjEAAADlAQAA5gEAAOcBAADeAQAA6AEAANABAADRAQAA0gEAANMBAADUAQAA1QEAQdQzCyo8AQAA6QEAAD4BAAA/AQAAQAEAAEEBAABCAQAAQwEAAEQBAADqAQAARgEAQYg0CxLrAQAA7AEAAO0BAADuAQAA7wEAQaQ0CyYxAAAA8AEAAPEBAADyAQAA8wEAABoAAAAvAAAAHwAAAPQBAAD1AQBB1DQLKjEAAAD2AQAA9wEAAPgBAAD5AQAAGgAAAPoBAAD7AQAA9AEAAPUBAAD8AQBBiDULbzEAAAD9AQAA/gEAAP8BAAAAAgAA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AAAAAgAAAAIAAAD/////AgAAAAIAAAD/////AAAAAAIAAAACAAAAAgAAAP////////////////////8CAAAAAAAAAAIAAAACAAAAAgAAAP////8DAAAAAwAAAAIAQazwAAsVAgAAAP///////////////wIAAAACAEHU8AALDf////8AAAAA/////wEAQezwAAsBAgBBgPEACw0CAAAAAgAAAAIAAAACAEGc8QALVQIAAAD//////////////////////////////////////////wIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAMAAAACAAAAAgAAAAIAQYTyAAsVAgAAAAIAAAACAAAAAgAAAAIAAAACAEGk8gALFQIAAAACAAAAAgAAAAIAAAACAAAAAgBBzPIACxQCAAAAAgAAAAIAAAAAAAAA/////wBB8PIACxECAAAAAgAAAAAAAAACAAAAAgBBjPMAC4UB//////////////////////////////////////////8BAAAA/////wIAAAAAAAAA/////////////////////////////////////wAAAAD/////AAAAAAAAAAD//////////wAAAAAAAAAAAgAAAAAAAAD/////AAAAAAIAAAACAAAAAgBBnPQACwECAEGo9AALKP//////////AAAAAAAAgL8AAIC/AAAAAAAAgL8AAIA/AACAvwAAgL8AQd70AAt/gD8AAAAAAACAvwAAgD8AAAAAAACAPwAAgD8AAIA/AAAAAAAAAAABAAAAMAMAAJ4CAACfAgAAoAIAALkAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAowAAAKQAAAClAAAApgBB6PUAC1EBAAAAMQMAAB0AAAAeAAAAGQAAABoAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABQAQcT2AAtN7AAAADIDAADuAAAA7wAAAPAAAADxAAAABwAAAPIAAAAJAAAACgAAAAsAAAAgAAAADQAAACEAAADzAAAA9AAAADMDAAA0AwAANQMAAPYAQZz3AAs+AQAAADYDAAD8AAAA/QAAAP4AAAD/AAAANwMAAB8AAAAJAAAACgAAAAsAAAAgAAAADQAAACEAAAA4AwAAOQMAQeT3AAujAQwBAAA7AwAAAwEAAAQBAAAFAQAABgEAABEBAAAfAAAACQAAAAoAAAALAAAAEgEAAA0AAAATAQAAFAEAABUBAAAWAQAAFwEAABgBAAAZAQAAGgEAALz///8AAAAAGwEAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAQZD5AAteDAEAADwDAAAOAQAADwEAAAUBAAAQAQAAEQEAAB8AAAAJAAAACgAAAAsAAAASAQAADQAAABMBAAAUAQAAFQEAABYBAAAXAQAAGAEAABkBAAA9AwAAvP///wAAAAAbAQBB+PkAC0nsAAAAPgMAAPgAAAD5AAAA+gAAABoAAAAHAAAA8gAAAAkAAAAKAAAACwAAACAAAAANAAAAIQAAAPMAAAD0AAAA9QAAABQAAAAUAEHM+gALSgEAAAA/AwAAHQEAAB4BAAAfAQAAIAEAAEADAAAfAAAACQAAAAoAAAALAAAAIAAAAA0AAAAhAAAAQQMAAEIDAADM////AAAAAEMDAEGg+wALWuwAAABEAwAAIwEAACQBAAAlAQAAJgEAAAcAAADyAAAACQAAAAoAAAALAAAAIAAAAA0AAAAhAAAARQMAAPQAAABGAwAARwMAAEgDAABJAwAASgMAAEsDAAAqAQBBhPwAC15MAwAATQMAACwBAAAtAQAALgEAAC8BAAAHAAAATgMAAAkAAAAKAAAACwAAACAAAAANAAAAIQAAAE8DAABQAwAAUQMAAFIDAABTAwAAVAMAAMD///8AAAAAVQMAAFYDAEHs/AALxAwUAAAAFAAAAHJlbmRlckZhY3RvcnkAbWFrZVJlbmRlclBhaW50AG1ha2VSZW5kZXJQYXRoAGJ5dGVMZW5ndGgAc2V0AGxvYWQAUmVuZGVyZXIAc2F2ZQByZXN0b3JlAHRyYW5zZm9ybQBkcmF3UGF0aABjbGlwUGF0aABhbGlnbgBSZW5kZXJlcldyYXBwZXIAUmVuZGVyUGF0aAByZXNldABhZGRQYXRoAGZpbGxSdWxlAG1vdmVUbwBsaW5lVG8AY3ViaWNUbwBjbG9zZQBSZW5kZXJQYXRoV3JhcHBlcgBSZW5kZXJQYWludFN0eWxlAGZpbGwAc3Ryb2tlAEZpbGxSdWxlAG5vblplcm8AZXZlbk9kZABTdHJva2VDYXAAYnV0dAByb3VuZABzcXVhcmUAU3Ryb2tlSm9pbgBtaXRlcgBiZXZlbABCbGVuZE1vZGUAc3JjT3ZlcgBzY3JlZW4Ab3ZlcmxheQBkYXJrZW4AbGlnaHRlbgBjb2xvckRvZGdlAGNvbG9yQnVybgBoYXJkTGlnaHQAc29mdExpZ2h0AGRpZmZlcmVuY2UAZXhjbHVzaW9uAG11bHRpcGx5AGh1ZQBzYXR1cmF0aW9uAGNvbG9yAGx1bWlub3NpdHkAUmVuZGVyUGFpbnQAc3R5bGUAdGhpY2tuZXNzAGpvaW4AY2FwAGJsZW5kTW9kZQBsaW5lYXJHcmFkaWVudAByYWRpYWxHcmFkaWVudABhZGRTdG9wAGNvbXBsZXRlR3JhZGllbnQAUmVuZGVyUGFpbnRXcmFwcGVyAE1hdDJEAHh4AHh5AHl4AHl5AHR4AHR5AEZpbGUAZGVmYXVsdEFydGJvYXJkAGFydGJvYXJkQnlOYW1lAGFydGJvYXJkQnlJbmRleABhcnRib2FyZENvdW50AEFydGJvYXJkAG5hbWUAYWR2YW5jZQBkcmF3AHRyYW5zZm9ybUNvbXBvbmVudABub2RlAGJvbmUAcm9vdEJvbmUAYW5pbWF0aW9uQnlJbmRleABhbmltYXRpb25CeU5hbWUAYW5pbWF0aW9uQ291bnQAc3RhdGVNYWNoaW5lQnlJbmRleABzdGF0ZU1hY2hpbmVCeU5hbWUAc3RhdGVNYWNoaW5lQ291bnQAYm91bmRzAGluc3RhbmNlAFRyYW5zZm9ybUNvbXBvbmVudABzY2FsZVgAc2NhbGVZAHJvdGF0aW9uAE5vZGUAeAB5AEJvbmUAbGVuZ3RoAFJvb3RCb25lAEFuaW1hdGlvbgBMaW5lYXJBbmltYXRpb24AZHVyYXRpb24AZnBzAHdvcmtTdGFydAB3b3JrRW5kAGVuYWJsZVdvcmtBcmVhAGxvb3BWYWx1ZQBzcGVlZABhcHBseQBMaW5lYXJBbmltYXRpb25JbnN0YW5jZQB0aW1lAGRpZExvb3AAU3RhdGVNYWNoaW5lAFN0YXRlTWFjaGluZUluc3RhbmNlAGlucHV0Q291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OGAAACNgAEGglAEL5xwcYAAAOGAAABhgAACmXwAAaWlpaWYAAAAZYAAAOWAAADpgAAA5YAAAGWAAAGVudHJ5AGV4aXQAYW55AHVua25vd24AAKBfAAA3YAAAGWAAAD5gAAA7YAAAP2AAADtgAABAYAAAO2AAAHRfAABAYAAAaQAlcAB2b2lkAGJvb2wAY2hhcgBzaWduZWQgY2hhcgB1bnNpZ25lZCBjaGFyAHNob3J0AHVuc2lnbmVkIHNob3J0AGludAB1bnNpZ25lZCBpbnQAbG9uZwB1bnNpZ25lZCBsb25nAGZsb2F0AGRvdWJsZQBzdGQ6OnN0cmluZwBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBzdGQ6OndzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAZW1zY3JpcHRlbjo6dmFsAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46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\";\n\nif (!isDataURI(wasmBinaryFile)) {\n wasmBinaryFile = locateFile(wasmBinaryFile);\n}\n\nfunction getBinary(file) {\n try {\n  if (file == wasmBinaryFile && wasmBinary) {\n   return new Uint8Array(wasmBinary);\n  }\n  var binary = tryParseAsDataURI(file);\n  if (binary) {\n   return binary;\n  }\n  if (readBinary) {\n   return readBinary(file);\n  } else {\n   throw \"both async and sync fetching of the wasm failed\";\n  }\n } catch (err) {\n  abort(err);\n }\n}\n\nfunction getBinaryPromise() {\n if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n  if (typeof fetch === \"function\" && !isFileURI(wasmBinaryFile)) {\n   return fetch(wasmBinaryFile, {\n    credentials: \"same-origin\"\n   }).then(function(response) {\n    if (!response[\"ok\"]) {\n     throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n    }\n    return response[\"arrayBuffer\"]();\n   }).catch(function() {\n    return getBinary(wasmBinaryFile);\n   });\n  } else {\n   if (readAsync) {\n    return new Promise(function(resolve, reject) {\n     readAsync(wasmBinaryFile, function(response) {\n      resolve(new Uint8Array(response));\n     }, reject);\n    });\n   }\n  }\n }\n return Promise.resolve().then(function() {\n  return getBinary(wasmBinaryFile);\n });\n}\n\nfunction createWasm() {\n var info = {\n  \"a\": asmLibraryArg\n };\n function receiveInstance(instance, module) {\n  var exports = instance.exports;\n  Module[\"asm\"] = exports;\n  wasmMemory = Module[\"asm\"][\"M\"];\n  updateGlobalBufferAndViews(wasmMemory.buffer);\n  wasmTable = Module[\"asm\"][\"O\"];\n  addOnInit(Module[\"asm\"][\"N\"]);\n  removeRunDependency(\"wasm-instantiate\");\n }\n addRunDependency(\"wasm-instantiate\");\n function receiveInstantiatedSource(output) {\n  receiveInstance(output[\"instance\"]);\n }\n function instantiateArrayBuffer(receiver) {\n  return getBinaryPromise().then(function(binary) {\n   var result = WebAssembly.instantiate(binary, info);\n   return result;\n  }).then(receiver, function(reason) {\n   err(\"failed to asynchronously prepare wasm: \" + reason);\n   abort(reason);\n  });\n }\n function instantiateAsync() {\n  if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === \"function\") {\n   return fetch(wasmBinaryFile, {\n    credentials: \"same-origin\"\n   }).then(function(response) {\n    var result = WebAssembly.instantiateStreaming(response, info);\n    return result.then(receiveInstantiatedSource, function(reason) {\n     err(\"wasm streaming compile failed: \" + reason);\n     err(\"falling back to ArrayBuffer instantiation\");\n     return instantiateArrayBuffer(receiveInstantiatedSource);\n    });\n   });\n  } else {\n   return instantiateArrayBuffer(receiveInstantiatedSource);\n  }\n }\n if (Module[\"instantiateWasm\"]) {\n  try {\n   var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n   return exports;\n  } catch (e) {\n   err(\"Module.instantiateWasm callback failed with error: \" + e);\n   return false;\n  }\n }\n instantiateAsync().catch(readyPromiseReject);\n return {};\n}\n\nfunction callRuntimeCallbacks(callbacks) {\n while (callbacks.length > 0) {\n  var callback = callbacks.shift();\n  if (typeof callback == \"function\") {\n   callback(Module);\n   continue;\n  }\n  var func = callback.func;\n  if (typeof func === \"number\") {\n   if (callback.arg === undefined) {\n    wasmTable.get(func)();\n   } else {\n    wasmTable.get(func)(callback.arg);\n   }\n  } else {\n   func(callback.arg === undefined ? null : callback.arg);\n  }\n }\n}\n\nvar char_0 = 48;\n\nvar char_9 = 57;\n\nfunction makeLegalFunctionName(name) {\n if (undefined === name) {\n  return \"_unknown\";\n }\n name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n var f = name.charCodeAt(0);\n if (f >= char_0 && f <= char_9) {\n  return \"_\" + name;\n } else {\n  return name;\n }\n}\n\nfunction createNamedFunction(name, body) {\n name = makeLegalFunctionName(name);\n return new Function(\"body\", \"return function \" + name + \"() {\\n\" + '    \"use strict\";' + \"    return body.apply(this, arguments);\\n\" + \"};\\n\")(body);\n}\n\nvar emval_free_list = [];\n\nvar emval_handle_array = [ {}, {\n value: undefined\n}, {\n value: null\n}, {\n value: true\n}, {\n value: false\n} ];\n\nfunction count_emval_handles() {\n var count = 0;\n for (var i = 5; i < emval_handle_array.length; ++i) {\n  if (emval_handle_array[i] !== undefined) {\n   ++count;\n  }\n }\n return count;\n}\n\nfunction get_first_emval() {\n for (var i = 5; i < emval_handle_array.length; ++i) {\n  if (emval_handle_array[i] !== undefined) {\n   return emval_handle_array[i];\n  }\n }\n return null;\n}\n\nfunction init_emval() {\n Module[\"count_emval_handles\"] = count_emval_handles;\n Module[\"get_first_emval\"] = get_first_emval;\n}\n\nfunction __emval_register(value) {\n switch (value) {\n case undefined:\n  {\n   return 1;\n  }\n\n case null:\n  {\n   return 2;\n  }\n\n case true:\n  {\n   return 3;\n  }\n\n case false:\n  {\n   return 4;\n  }\n\n default:\n  {\n   var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n   emval_handle_array[handle] = {\n    refcount: 1,\n    value: value\n   };\n   return handle;\n  }\n }\n}\n\nfunction extendError(baseErrorType, errorName) {\n var errorClass = createNamedFunction(errorName, function(message) {\n  this.name = errorName;\n  this.message = message;\n  var stack = new Error(message).stack;\n  if (stack !== undefined) {\n   this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n  }\n });\n errorClass.prototype = Object.create(baseErrorType.prototype);\n errorClass.prototype.constructor = errorClass;\n errorClass.prototype.toString = function() {\n  if (this.message === undefined) {\n   return this.name;\n  } else {\n   return this.name + \": \" + this.message;\n  }\n };\n return errorClass;\n}\n\nvar PureVirtualError = undefined;\n\nfunction embind_init_charCodes() {\n var codes = new Array(256);\n for (var i = 0; i < 256; ++i) {\n  codes[i] = String.fromCharCode(i);\n }\n embind_charCodes = codes;\n}\n\nvar embind_charCodes = undefined;\n\nfunction readLatin1String(ptr) {\n var ret = \"\";\n var c = ptr;\n while (HEAPU8[c]) {\n  ret += embind_charCodes[HEAPU8[c++]];\n }\n return ret;\n}\n\nfunction getInheritedInstanceCount() {\n return Object.keys(registeredInstances).length;\n}\n\nfunction getLiveInheritedInstances() {\n var rv = [];\n for (var k in registeredInstances) {\n  if (registeredInstances.hasOwnProperty(k)) {\n   rv.push(registeredInstances[k]);\n  }\n }\n return rv;\n}\n\nvar deletionQueue = [];\n\nfunction flushPendingDeletes() {\n while (deletionQueue.length) {\n  var obj = deletionQueue.pop();\n  obj.$$.deleteScheduled = false;\n  obj[\"delete\"]();\n }\n}\n\nvar delayFunction = undefined;\n\nfunction setDelayFunction(fn) {\n delayFunction = fn;\n if (deletionQueue.length && delayFunction) {\n  delayFunction(flushPendingDeletes);\n }\n}\n\nfunction init_embind() {\n Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n Module[\"setDelayFunction\"] = setDelayFunction;\n}\n\nvar registeredInstances = {};\n\nvar BindingError = undefined;\n\nfunction throwBindingError(message) {\n throw new BindingError(message);\n}\n\nfunction getBasestPointer(class_, ptr) {\n if (ptr === undefined) {\n  throwBindingError(\"ptr should not be undefined\");\n }\n while (class_.baseClass) {\n  ptr = class_.upcast(ptr);\n  class_ = class_.baseClass;\n }\n return ptr;\n}\n\nfunction registerInheritedInstance(class_, ptr, instance) {\n ptr = getBasestPointer(class_, ptr);\n if (registeredInstances.hasOwnProperty(ptr)) {\n  throwBindingError(\"Tried to register registered instance: \" + ptr);\n } else {\n  registeredInstances[ptr] = instance;\n }\n}\n\nfunction requireHandle(handle) {\n if (!handle) {\n  throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n }\n return emval_handle_array[handle].value;\n}\n\nvar registeredTypes = {};\n\nfunction getTypeName(type) {\n var ptr = ___getTypeName(type);\n var rv = readLatin1String(ptr);\n _free(ptr);\n return rv;\n}\n\nfunction requireRegisteredType(rawType, humanName) {\n var impl = registeredTypes[rawType];\n if (undefined === impl) {\n  throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n }\n return impl;\n}\n\nfunction unregisterInheritedInstance(class_, ptr) {\n ptr = getBasestPointer(class_, ptr);\n if (registeredInstances.hasOwnProperty(ptr)) {\n  delete registeredInstances[ptr];\n } else {\n  throwBindingError(\"Tried to unregister unregistered instance: \" + ptr);\n }\n}\n\nfunction detachFinalizer(handle) {}\n\nvar finalizationGroup = false;\n\nfunction runDestructor($$) {\n if ($$.smartPtr) {\n  $$.smartPtrType.rawDestructor($$.smartPtr);\n } else {\n  $$.ptrType.registeredClass.rawDestructor($$.ptr);\n }\n}\n\nfunction releaseClassHandle($$) {\n $$.count.value -= 1;\n var toDelete = 0 === $$.count.value;\n if (toDelete) {\n  runDestructor($$);\n }\n}\n\nfunction attachFinalizer(handle) {\n if (\"undefined\" === typeof FinalizationGroup) {\n  attachFinalizer = function(handle) {\n   return handle;\n  };\n  return handle;\n }\n finalizationGroup = new FinalizationGroup(function(iter) {\n  for (var result = iter.next(); !result.done; result = iter.next()) {\n   var $$ = result.value;\n   if (!$$.ptr) {\n    console.warn(\"object already deleted: \" + $$.ptr);\n   } else {\n    releaseClassHandle($$);\n   }\n  }\n });\n attachFinalizer = function(handle) {\n  finalizationGroup.register(handle, handle.$$, handle.$$);\n  return handle;\n };\n detachFinalizer = function(handle) {\n  finalizationGroup.unregister(handle.$$);\n };\n return attachFinalizer(handle);\n}\n\nfunction __embind_create_inheriting_constructor(constructorName, wrapperType, properties) {\n constructorName = readLatin1String(constructorName);\n wrapperType = requireRegisteredType(wrapperType, \"wrapper\");\n properties = requireHandle(properties);\n var arraySlice = [].slice;\n var registeredClass = wrapperType.registeredClass;\n var wrapperPrototype = registeredClass.instancePrototype;\n var baseClass = registeredClass.baseClass;\n var baseClassPrototype = baseClass.instancePrototype;\n var baseConstructor = registeredClass.baseClass.constructor;\n var ctor = createNamedFunction(constructorName, function() {\n  registeredClass.baseClass.pureVirtualFunctions.forEach(function(name) {\n   if (this[name] === baseClassPrototype[name]) {\n    throw new PureVirtualError(\"Pure virtual function \" + name + \" must be implemented in JavaScript\");\n   }\n  }.bind(this));\n  Object.defineProperty(this, \"__parent\", {\n   value: wrapperPrototype\n  });\n  this[\"__construct\"].apply(this, arraySlice.call(arguments));\n });\n wrapperPrototype[\"__construct\"] = function __construct() {\n  if (this === wrapperPrototype) {\n   throwBindingError(\"Pass correct 'this' to __construct\");\n  }\n  var inner = baseConstructor[\"implement\"].apply(undefined, [ this ].concat(arraySlice.call(arguments)));\n  detachFinalizer(inner);\n  var $$ = inner.$$;\n  inner[\"notifyOnDestruction\"]();\n  $$.preservePointerOnDelete = true;\n  Object.defineProperties(this, {\n   $$: {\n    value: $$\n   }\n  });\n  attachFinalizer(this);\n  registerInheritedInstance(registeredClass, $$.ptr, this);\n };\n wrapperPrototype[\"__destruct\"] = function __destruct() {\n  if (this === wrapperPrototype) {\n   throwBindingError(\"Pass correct 'this' to __destruct\");\n  }\n  detachFinalizer(this);\n  unregisterInheritedInstance(registeredClass, this.$$.ptr);\n };\n ctor.prototype = Object.create(wrapperPrototype);\n for (var p in properties) {\n  ctor.prototype[p] = properties[p];\n }\n return __emval_register(ctor);\n}\n\nvar structRegistrations = {};\n\nfunction runDestructors(destructors) {\n while (destructors.length) {\n  var ptr = destructors.pop();\n  var del = destructors.pop();\n  del(ptr);\n }\n}\n\nfunction simpleReadValueFromPointer(pointer) {\n return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n}\n\nvar awaitingDependencies = {};\n\nvar typeDependencies = {};\n\nvar InternalError = undefined;\n\nfunction throwInternalError(message) {\n throw new InternalError(message);\n}\n\nfunction whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n myTypes.forEach(function(type) {\n  typeDependencies[type] = dependentTypes;\n });\n function onComplete(typeConverters) {\n  var myTypeConverters = getTypeConverters(typeConverters);\n  if (myTypeConverters.length !== myTypes.length) {\n   throwInternalError(\"Mismatched type converter count\");\n  }\n  for (var i = 0; i < myTypes.length; ++i) {\n   registerType(myTypes[i], myTypeConverters[i]);\n  }\n }\n var typeConverters = new Array(dependentTypes.length);\n var unregisteredTypes = [];\n var registered = 0;\n dependentTypes.forEach(function(dt, i) {\n  if (registeredTypes.hasOwnProperty(dt)) {\n   typeConverters[i] = registeredTypes[dt];\n  } else {\n   unregisteredTypes.push(dt);\n   if (!awaitingDependencies.hasOwnProperty(dt)) {\n    awaitingDependencies[dt] = [];\n   }\n   awaitingDependencies[dt].push(function() {\n    typeConverters[i] = registeredTypes[dt];\n    ++registered;\n    if (registered === unregisteredTypes.length) {\n     onComplete(typeConverters);\n    }\n   });\n  }\n });\n if (0 === unregisteredTypes.length) {\n  onComplete(typeConverters);\n }\n}\n\nfunction __embind_finalize_value_object(structType) {\n var reg = structRegistrations[structType];\n delete structRegistrations[structType];\n var rawConstructor = reg.rawConstructor;\n var rawDestructor = reg.rawDestructor;\n var fieldRecords = reg.fields;\n var fieldTypes = fieldRecords.map(function(field) {\n  return field.getterReturnType;\n }).concat(fieldRecords.map(function(field) {\n  return field.setterArgumentType;\n }));\n whenDependentTypesAreResolved([ structType ], fieldTypes, function(fieldTypes) {\n  var fields = {};\n  fieldRecords.forEach(function(field, i) {\n   var fieldName = field.fieldName;\n   var getterReturnType = fieldTypes[i];\n   var getter = field.getter;\n   var getterContext = field.getterContext;\n   var setterArgumentType = fieldTypes[i + fieldRecords.length];\n   var setter = field.setter;\n   var setterContext = field.setterContext;\n   fields[fieldName] = {\n    read: function(ptr) {\n     return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n    },\n    write: function(ptr, o) {\n     var destructors = [];\n     setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n     runDestructors(destructors);\n    }\n   };\n  });\n  return [ {\n   name: reg.name,\n   \"fromWireType\": function(ptr) {\n    var rv = {};\n    for (var i in fields) {\n     rv[i] = fields[i].read(ptr);\n    }\n    rawDestructor(ptr);\n    return rv;\n   },\n   \"toWireType\": function(destructors, o) {\n    for (var fieldName in fields) {\n     if (!(fieldName in o)) {\n      throw new TypeError('Missing field:  \"' + fieldName + '\"');\n     }\n    }\n    var ptr = rawConstructor();\n    for (fieldName in fields) {\n     fields[fieldName].write(ptr, o[fieldName]);\n    }\n    if (destructors !== null) {\n     destructors.push(rawDestructor, ptr);\n    }\n    return ptr;\n   },\n   \"argPackAdvance\": 8,\n   \"readValueFromPointer\": simpleReadValueFromPointer,\n   destructorFunction: rawDestructor\n  } ];\n });\n}\n\nfunction getShiftFromSize(size) {\n switch (size) {\n case 1:\n  return 0;\n\n case 2:\n  return 1;\n\n case 4:\n  return 2;\n\n case 8:\n  return 3;\n\n default:\n  throw new TypeError(\"Unknown type size: \" + size);\n }\n}\n\nfunction registerType(rawType, registeredInstance, options) {\n options = options || {};\n if (!(\"argPackAdvance\" in registeredInstance)) {\n  throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n }\n var name = registeredInstance.name;\n if (!rawType) {\n  throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n }\n if (registeredTypes.hasOwnProperty(rawType)) {\n  if (options.ignoreDuplicateRegistrations) {\n   return;\n  } else {\n   throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n  }\n }\n registeredTypes[rawType] = registeredInstance;\n delete typeDependencies[rawType];\n if (awaitingDependencies.hasOwnProperty(rawType)) {\n  var callbacks = awaitingDependencies[rawType];\n  delete awaitingDependencies[rawType];\n  callbacks.forEach(function(cb) {\n   cb();\n  });\n }\n}\n\nfunction __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(wt) {\n   return !!wt;\n  },\n  \"toWireType\": function(destructors, o) {\n   return o ? trueValue : falseValue;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": function(pointer) {\n   var heap;\n   if (size === 1) {\n    heap = HEAP8;\n   } else if (size === 2) {\n    heap = HEAP16;\n   } else if (size === 4) {\n    heap = HEAP32;\n   } else {\n    throw new TypeError(\"Unknown boolean type size: \" + name);\n   }\n   return this[\"fromWireType\"](heap[pointer >> shift]);\n  },\n  destructorFunction: null\n });\n}\n\nfunction ClassHandle_isAliasOf(other) {\n if (!(this instanceof ClassHandle)) {\n  return false;\n }\n if (!(other instanceof ClassHandle)) {\n  return false;\n }\n var leftClass = this.$$.ptrType.registeredClass;\n var left = this.$$.ptr;\n var rightClass = other.$$.ptrType.registeredClass;\n var right = other.$$.ptr;\n while (leftClass.baseClass) {\n  left = leftClass.upcast(left);\n  leftClass = leftClass.baseClass;\n }\n while (rightClass.baseClass) {\n  right = rightClass.upcast(right);\n  rightClass = rightClass.baseClass;\n }\n return leftClass === rightClass && left === right;\n}\n\nfunction shallowCopyInternalPointer(o) {\n return {\n  count: o.count,\n  deleteScheduled: o.deleteScheduled,\n  preservePointerOnDelete: o.preservePointerOnDelete,\n  ptr: o.ptr,\n  ptrType: o.ptrType,\n  smartPtr: o.smartPtr,\n  smartPtrType: o.smartPtrType\n };\n}\n\nfunction throwInstanceAlreadyDeleted(obj) {\n function getInstanceTypeName(handle) {\n  return handle.$$.ptrType.registeredClass.name;\n }\n throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n}\n\nfunction ClassHandle_clone() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.preservePointerOnDelete) {\n  this.$$.count.value += 1;\n  return this;\n } else {\n  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n   $$: {\n    value: shallowCopyInternalPointer(this.$$)\n   }\n  }));\n  clone.$$.count.value += 1;\n  clone.$$.deleteScheduled = false;\n  return clone;\n }\n}\n\nfunction ClassHandle_delete() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n  throwBindingError(\"Object already scheduled for deletion\");\n }\n detachFinalizer(this);\n releaseClassHandle(this.$$);\n if (!this.$$.preservePointerOnDelete) {\n  this.$$.smartPtr = undefined;\n  this.$$.ptr = undefined;\n }\n}\n\nfunction ClassHandle_isDeleted() {\n return !this.$$.ptr;\n}\n\nfunction ClassHandle_deleteLater() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n  throwBindingError(\"Object already scheduled for deletion\");\n }\n deletionQueue.push(this);\n if (deletionQueue.length === 1 && delayFunction) {\n  delayFunction(flushPendingDeletes);\n }\n this.$$.deleteScheduled = true;\n return this;\n}\n\nfunction init_ClassHandle() {\n ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n}\n\nfunction ClassHandle() {}\n\nvar registeredPointers = {};\n\nfunction ensureOverloadTable(proto, methodName, humanName) {\n if (undefined === proto[methodName].overloadTable) {\n  var prevFunc = proto[methodName];\n  proto[methodName] = function() {\n   if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n    throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n   }\n   return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n  };\n  proto[methodName].overloadTable = [];\n  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n }\n}\n\nfunction exposePublicSymbol(name, value, numArguments) {\n if (Module.hasOwnProperty(name)) {\n  if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n   throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n  }\n  ensureOverloadTable(Module, name, name);\n  if (Module.hasOwnProperty(numArguments)) {\n   throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n  }\n  Module[name].overloadTable[numArguments] = value;\n } else {\n  Module[name] = value;\n  if (undefined !== numArguments) {\n   Module[name].numArguments = numArguments;\n  }\n }\n}\n\nfunction RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n this.name = name;\n this.constructor = constructor;\n this.instancePrototype = instancePrototype;\n this.rawDestructor = rawDestructor;\n this.baseClass = baseClass;\n this.getActualType = getActualType;\n this.upcast = upcast;\n this.downcast = downcast;\n this.pureVirtualFunctions = [];\n}\n\nfunction upcastPointer(ptr, ptrClass, desiredClass) {\n while (ptrClass !== desiredClass) {\n  if (!ptrClass.upcast) {\n   throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n  }\n  ptr = ptrClass.upcast(ptr);\n  ptrClass = ptrClass.baseClass;\n }\n return ptr;\n}\n\nfunction constNoSmartPtrRawPointerToWireType(destructors, handle) {\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  return 0;\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n return ptr;\n}\n\nfunction genericPointerToWireType(destructors, handle) {\n var ptr;\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  if (this.isSmartPointer) {\n   ptr = this.rawConstructor();\n   if (destructors !== null) {\n    destructors.push(this.rawDestructor, ptr);\n   }\n   return ptr;\n  } else {\n   return 0;\n  }\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n if (!this.isConst && handle.$$.ptrType.isConst) {\n  throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n if (this.isSmartPointer) {\n  if (undefined === handle.$$.smartPtr) {\n   throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n  }\n  switch (this.sharingPolicy) {\n  case 0:\n   if (handle.$$.smartPtrType === this) {\n    ptr = handle.$$.smartPtr;\n   } else {\n    throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n   }\n   break;\n\n  case 1:\n   ptr = handle.$$.smartPtr;\n   break;\n\n  case 2:\n   if (handle.$$.smartPtrType === this) {\n    ptr = handle.$$.smartPtr;\n   } else {\n    var clonedHandle = handle[\"clone\"]();\n    ptr = this.rawShare(ptr, __emval_register(function() {\n     clonedHandle[\"delete\"]();\n    }));\n    if (destructors !== null) {\n     destructors.push(this.rawDestructor, ptr);\n    }\n   }\n   break;\n\n  default:\n   throwBindingError(\"Unsupporting sharing policy\");\n  }\n }\n return ptr;\n}\n\nfunction nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  return 0;\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n if (handle.$$.ptrType.isConst) {\n  throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n return ptr;\n}\n\nfunction RegisteredPointer_getPointee(ptr) {\n if (this.rawGetPointee) {\n  ptr = this.rawGetPointee(ptr);\n }\n return ptr;\n}\n\nfunction RegisteredPointer_destructor(ptr) {\n if (this.rawDestructor) {\n  this.rawDestructor(ptr);\n }\n}\n\nfunction RegisteredPointer_deleteObject(handle) {\n if (handle !== null) {\n  handle[\"delete\"]();\n }\n}\n\nfunction downcastPointer(ptr, ptrClass, desiredClass) {\n if (ptrClass === desiredClass) {\n  return ptr;\n }\n if (undefined === desiredClass.baseClass) {\n  return null;\n }\n var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n if (rv === null) {\n  return null;\n }\n return desiredClass.downcast(rv);\n}\n\nfunction getInheritedInstance(class_, ptr) {\n ptr = getBasestPointer(class_, ptr);\n return registeredInstances[ptr];\n}\n\nfunction makeClassHandle(prototype, record) {\n if (!record.ptrType || !record.ptr) {\n  throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n }\n var hasSmartPtrType = !!record.smartPtrType;\n var hasSmartPtr = !!record.smartPtr;\n if (hasSmartPtrType !== hasSmartPtr) {\n  throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n }\n record.count = {\n  value: 1\n };\n return attachFinalizer(Object.create(prototype, {\n  $$: {\n   value: record\n  }\n }));\n}\n\nfunction RegisteredPointer_fromWireType(ptr) {\n var rawPointer = this.getPointee(ptr);\n if (!rawPointer) {\n  this.destructor(ptr);\n  return null;\n }\n var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n if (undefined !== registeredInstance) {\n  if (0 === registeredInstance.$$.count.value) {\n   registeredInstance.$$.ptr = rawPointer;\n   registeredInstance.$$.smartPtr = ptr;\n   return registeredInstance[\"clone\"]();\n  } else {\n   var rv = registeredInstance[\"clone\"]();\n   this.destructor(ptr);\n   return rv;\n  }\n }\n function makeDefaultHandle() {\n  if (this.isSmartPointer) {\n   return makeClassHandle(this.registeredClass.instancePrototype, {\n    ptrType: this.pointeeType,\n    ptr: rawPointer,\n    smartPtrType: this,\n    smartPtr: ptr\n   });\n  } else {\n   return makeClassHandle(this.registeredClass.instancePrototype, {\n    ptrType: this,\n    ptr: ptr\n   });\n  }\n }\n var actualType = this.registeredClass.getActualType(rawPointer);\n var registeredPointerRecord = registeredPointers[actualType];\n if (!registeredPointerRecord) {\n  return makeDefaultHandle.call(this);\n }\n var toType;\n if (this.isConst) {\n  toType = registeredPointerRecord.constPointerType;\n } else {\n  toType = registeredPointerRecord.pointerType;\n }\n var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n if (dp === null) {\n  return makeDefaultHandle.call(this);\n }\n if (this.isSmartPointer) {\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\n   ptrType: toType,\n   ptr: dp,\n   smartPtrType: this,\n   smartPtr: ptr\n  });\n } else {\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\n   ptrType: toType,\n   ptr: dp\n  });\n }\n}\n\nfunction init_RegisteredPointer() {\n RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n}\n\nfunction RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n this.name = name;\n this.registeredClass = registeredClass;\n this.isReference = isReference;\n this.isConst = isConst;\n this.isSmartPointer = isSmartPointer;\n this.pointeeType = pointeeType;\n this.sharingPolicy = sharingPolicy;\n this.rawGetPointee = rawGetPointee;\n this.rawConstructor = rawConstructor;\n this.rawShare = rawShare;\n this.rawDestructor = rawDestructor;\n if (!isSmartPointer && registeredClass.baseClass === undefined) {\n  if (isConst) {\n   this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n   this.destructorFunction = null;\n  } else {\n   this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n   this.destructorFunction = null;\n  }\n } else {\n  this[\"toWireType\"] = genericPointerToWireType;\n }\n}\n\nfunction replacePublicSymbol(name, value, numArguments) {\n if (!Module.hasOwnProperty(name)) {\n  throwInternalError(\"Replacing nonexistant public symbol\");\n }\n if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n  Module[name].overloadTable[numArguments] = value;\n } else {\n  Module[name] = value;\n  Module[name].argCount = numArguments;\n }\n}\n\nfunction dynCallLegacy(sig, ptr, args) {\n var f = Module[\"dynCall_\" + sig];\n return args && args.length ? f.apply(null, [ ptr ].concat(args)) : f.call(null, ptr);\n}\n\nfunction dynCall(sig, ptr, args) {\n if (sig.indexOf(\"j\") != -1) {\n  return dynCallLegacy(sig, ptr, args);\n }\n return wasmTable.get(ptr).apply(null, args);\n}\n\nfunction getDynCaller(sig, ptr) {\n var argCache = [];\n return function() {\n  argCache.length = arguments.length;\n  for (var i = 0; i < arguments.length; i++) {\n   argCache[i] = arguments[i];\n  }\n  return dynCall(sig, ptr, argCache);\n };\n}\n\nfunction embind__requireFunction(signature, rawFunction) {\n signature = readLatin1String(signature);\n function makeDynCaller() {\n  if (signature.indexOf(\"j\") != -1) {\n   return getDynCaller(signature, rawFunction);\n  }\n  return wasmTable.get(rawFunction);\n }\n var fp = makeDynCaller();\n if (typeof fp !== \"function\") {\n  throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n }\n return fp;\n}\n\nvar UnboundTypeError = undefined;\n\nfunction throwUnboundTypeError(message, types) {\n var unboundTypes = [];\n var seen = {};\n function visit(type) {\n  if (seen[type]) {\n   return;\n  }\n  if (registeredTypes[type]) {\n   return;\n  }\n  if (typeDependencies[type]) {\n   typeDependencies[type].forEach(visit);\n   return;\n  }\n  unboundTypes.push(type);\n  seen[type] = true;\n }\n types.forEach(visit);\n throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([ \", \" ]));\n}\n\nfunction __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n name = readLatin1String(name);\n getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n if (upcast) {\n  upcast = embind__requireFunction(upcastSignature, upcast);\n }\n if (downcast) {\n  downcast = embind__requireFunction(downcastSignature, downcast);\n }\n rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n var legalFunctionName = makeLegalFunctionName(name);\n exposePublicSymbol(legalFunctionName, function() {\n  throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [ baseClassRawType ]);\n });\n whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], function(base) {\n  base = base[0];\n  var baseClass;\n  var basePrototype;\n  if (baseClassRawType) {\n   baseClass = base.registeredClass;\n   basePrototype = baseClass.instancePrototype;\n  } else {\n   basePrototype = ClassHandle.prototype;\n  }\n  var constructor = createNamedFunction(legalFunctionName, function() {\n   if (Object.getPrototypeOf(this) !== instancePrototype) {\n    throw new BindingError(\"Use 'new' to construct \" + name);\n   }\n   if (undefined === registeredClass.constructor_body) {\n    throw new BindingError(name + \" has no accessible constructor\");\n   }\n   var body = registeredClass.constructor_body[arguments.length];\n   if (undefined === body) {\n    throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n   }\n   return body.apply(this, arguments);\n  });\n  var instancePrototype = Object.create(basePrototype, {\n   constructor: {\n    value: constructor\n   }\n  });\n  constructor.prototype = instancePrototype;\n  var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n  var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n  var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n  var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n  registeredPointers[rawType] = {\n   pointerType: pointerConverter,\n   constPointerType: constPointerConverter\n  };\n  replacePublicSymbol(legalFunctionName, constructor);\n  return [ referenceConverter, pointerConverter, constPointerConverter ];\n });\n}\n\nfunction new_(constructor, argumentList) {\n if (!(constructor instanceof Function)) {\n  throw new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\");\n }\n var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n dummy.prototype = constructor.prototype;\n var obj = new dummy();\n var r = constructor.apply(obj, argumentList);\n return r instanceof Object ? r : obj;\n}\n\nfunction craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n var argCount = argTypes.length;\n if (argCount < 2) {\n  throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n }\n var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n var needsDestructorStack = false;\n for (var i = 1; i < argTypes.length; ++i) {\n  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n   needsDestructorStack = true;\n   break;\n  }\n }\n var returns = argTypes[0].name !== \"void\";\n var argsList = \"\";\n var argsListWired = \"\";\n for (var i = 0; i < argCount - 2; ++i) {\n  argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n  argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n }\n var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n if (needsDestructorStack) {\n  invokerFnBody += \"var destructors = [];\\n\";\n }\n var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n var args1 = [ \"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\" ];\n var args2 = [ throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];\n if (isClassMethodFunc) {\n  invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n }\n for (var i = 0; i < argCount - 2; ++i) {\n  invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n  args1.push(\"argType\" + i);\n  args2.push(argTypes[i + 2]);\n }\n if (isClassMethodFunc) {\n  argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n }\n invokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n if (needsDestructorStack) {\n  invokerFnBody += \"runDestructors(destructors);\\n\";\n } else {\n  for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n   var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n   if (argTypes[i].destructorFunction !== null) {\n    invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n    args1.push(paramName + \"_dtor\");\n    args2.push(argTypes[i].destructorFunction);\n   }\n  }\n }\n if (returns) {\n  invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n } else {}\n invokerFnBody += \"}\\n\";\n args1.push(invokerFnBody);\n var invokerFunction = new_(Function, args1).apply(null, args2);\n return invokerFunction;\n}\n\nfunction heap32VectorToArray(count, firstElement) {\n var array = [];\n for (var i = 0; i < count; i++) {\n  array.push(HEAP32[(firstElement >> 2) + i]);\n }\n return array;\n}\n\nfunction __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn) {\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n methodName = readLatin1String(methodName);\n rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + methodName;\n  function unboundTypesHandler() {\n   throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n  }\n  var proto = classType.registeredClass.constructor;\n  if (undefined === proto[methodName]) {\n   unboundTypesHandler.argCount = argCount - 1;\n   proto[methodName] = unboundTypesHandler;\n  } else {\n   ensureOverloadTable(proto, methodName, humanName);\n   proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;\n  }\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));\n   var func = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn);\n   if (undefined === proto[methodName].overloadTable) {\n    func.argCount = argCount - 1;\n    proto[methodName] = func;\n   } else {\n    proto[methodName].overloadTable[argCount - 1] = func;\n   }\n   return [];\n  });\n  return [];\n });\n}\n\nfunction validateThis(this_, classType, humanName) {\n if (!(this_ instanceof Object)) {\n  throwBindingError(humanName + ' with invalid \"this\": ' + this_);\n }\n if (!(this_ instanceof classType.registeredClass.constructor)) {\n  throwBindingError(humanName + ' incompatible with \"this\" of type ' + this_.constructor.name);\n }\n if (!this_.$$.ptr) {\n  throwBindingError(\"cannot call emscripten binding method \" + humanName + \" on deleted object\");\n }\n return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);\n}\n\nfunction __embind_register_class_class_property(rawClassType, fieldName, rawFieldType, rawFieldPtr, getterSignature, getter, setterSignature, setter) {\n fieldName = readLatin1String(fieldName);\n getter = embind__requireFunction(getterSignature, getter);\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + fieldName;\n  var desc = {\n   get: function() {\n    throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [ rawFieldType ]);\n   },\n   enumerable: true,\n   configurable: true\n  };\n  if (setter) {\n   desc.set = function() {\n    throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [ rawFieldType ]);\n   };\n  } else {\n   desc.set = function(v) {\n    throwBindingError(humanName + \" is a read-only property\");\n   };\n  }\n  Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);\n  whenDependentTypesAreResolved([], [ rawFieldType ], function(fieldType) {\n   fieldType = fieldType[0];\n   var desc = {\n    get: function() {\n     return fieldType[\"fromWireType\"](getter(rawFieldPtr));\n    },\n    enumerable: true\n   };\n   if (setter) {\n    setter = embind__requireFunction(setterSignature, setter);\n    desc.set = function(v) {\n     var destructors = [];\n     setter(rawFieldPtr, fieldType[\"toWireType\"](destructors, v));\n     runDestructors(destructors);\n    };\n   }\n   Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);\n   return [];\n  });\n  return [];\n });\n}\n\nfunction __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n assert(argCount > 0);\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n invoker = embind__requireFunction(invokerSignature, invoker);\n var args = [ rawConstructor ];\n var destructors = [];\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = \"constructor \" + classType.name;\n  if (undefined === classType.registeredClass.constructor_body) {\n   classType.registeredClass.constructor_body = [];\n  }\n  if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n   throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n  }\n  classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {\n   throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n  };\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {\n    if (arguments.length !== argCount - 1) {\n     throwBindingError(humanName + \" called with \" + arguments.length + \" arguments, expected \" + (argCount - 1));\n    }\n    destructors.length = 0;\n    args.length = argCount;\n    for (var i = 1; i < argCount; ++i) {\n     args[i] = argTypes[i][\"toWireType\"](destructors, arguments[i - 1]);\n    }\n    var ptr = invoker.apply(null, args);\n    runDestructors(destructors);\n    return argTypes[0][\"fromWireType\"](ptr);\n   };\n   return [];\n  });\n  return [];\n });\n}\n\nfunction __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n methodName = readLatin1String(methodName);\n rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + methodName;\n  if (isPureVirtual) {\n   classType.registeredClass.pureVirtualFunctions.push(methodName);\n  }\n  function unboundTypesHandler() {\n   throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n  }\n  var proto = classType.registeredClass.instancePrototype;\n  var method = proto[methodName];\n  if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n   unboundTypesHandler.argCount = argCount - 2;\n   unboundTypesHandler.className = classType.name;\n   proto[methodName] = unboundTypesHandler;\n  } else {\n   ensureOverloadTable(proto, methodName, humanName);\n   proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n  }\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n   if (undefined === proto[methodName].overloadTable) {\n    memberFunction.argCount = argCount - 2;\n    proto[methodName] = memberFunction;\n   } else {\n    proto[methodName].overloadTable[argCount - 2] = memberFunction;\n   }\n   return [];\n  });\n  return [];\n });\n}\n\nfunction __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n fieldName = readLatin1String(fieldName);\n getter = embind__requireFunction(getterSignature, getter);\n whenDependentTypesAreResolved([], [ classType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + fieldName;\n  var desc = {\n   get: function() {\n    throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [ getterReturnType, setterArgumentType ]);\n   },\n   enumerable: true,\n   configurable: true\n  };\n  if (setter) {\n   desc.set = function() {\n    throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [ getterReturnType, setterArgumentType ]);\n   };\n  } else {\n   desc.set = function(v) {\n    throwBindingError(humanName + \" is a read-only property\");\n   };\n  }\n  Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n  whenDependentTypesAreResolved([], setter ? [ getterReturnType, setterArgumentType ] : [ getterReturnType ], function(types) {\n   var getterReturnType = types[0];\n   var desc = {\n    get: function() {\n     var ptr = validateThis(this, classType, humanName + \" getter\");\n     return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n    },\n    enumerable: true\n   };\n   if (setter) {\n    setter = embind__requireFunction(setterSignature, setter);\n    var setterArgumentType = types[1];\n    desc.set = function(v) {\n     var ptr = validateThis(this, classType, humanName + \" setter\");\n     var destructors = [];\n     setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, v));\n     runDestructors(destructors);\n    };\n   }\n   Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n   return [];\n  });\n  return [];\n });\n}\n\nfunction __emval_decref(handle) {\n if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n  emval_handle_array[handle] = undefined;\n  emval_free_list.push(handle);\n }\n}\n\nfunction __embind_register_emval(rawType, name) {\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(handle) {\n   var rv = emval_handle_array[handle].value;\n   __emval_decref(handle);\n   return rv;\n  },\n  \"toWireType\": function(destructors, value) {\n   return __emval_register(value);\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: null\n });\n}\n\nfunction enumReadValueFromPointer(name, shift, signed) {\n switch (shift) {\n case 0:\n  return function(pointer) {\n   var heap = signed ? HEAP8 : HEAPU8;\n   return this[\"fromWireType\"](heap[pointer]);\n  };\n\n case 1:\n  return function(pointer) {\n   var heap = signed ? HEAP16 : HEAPU16;\n   return this[\"fromWireType\"](heap[pointer >> 1]);\n  };\n\n case 2:\n  return function(pointer) {\n   var heap = signed ? HEAP32 : HEAPU32;\n   return this[\"fromWireType\"](heap[pointer >> 2]);\n  };\n\n default:\n  throw new TypeError(\"Unknown integer type: \" + name);\n }\n}\n\nfunction __embind_register_enum(rawType, name, size, isSigned) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n function ctor() {}\n ctor.values = {};\n registerType(rawType, {\n  name: name,\n  constructor: ctor,\n  \"fromWireType\": function(c) {\n   return this.constructor.values[c];\n  },\n  \"toWireType\": function(destructors, c) {\n   return c.value;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": enumReadValueFromPointer(name, shift, isSigned),\n  destructorFunction: null\n });\n exposePublicSymbol(name, ctor);\n}\n\nfunction __embind_register_enum_value(rawEnumType, name, enumValue) {\n var enumType = requireRegisteredType(rawEnumType, \"enum\");\n name = readLatin1String(name);\n var Enum = enumType.constructor;\n var Value = Object.create(enumType.constructor.prototype, {\n  value: {\n   value: enumValue\n  },\n  constructor: {\n   value: createNamedFunction(enumType.name + \"_\" + name, function() {})\n  }\n });\n Enum.values[enumValue] = Value;\n Enum[name] = Value;\n}\n\nfunction _embind_repr(v) {\n if (v === null) {\n  return \"null\";\n }\n var t = typeof v;\n if (t === \"object\" || t === \"array\" || t === \"function\") {\n  return v.toString();\n } else {\n  return \"\" + v;\n }\n}\n\nfunction floatReadValueFromPointer(name, shift) {\n switch (shift) {\n case 2:\n  return function(pointer) {\n   return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n  };\n\n case 3:\n  return function(pointer) {\n   return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n  };\n\n default:\n  throw new TypeError(\"Unknown float type: \" + name);\n }\n}\n\nfunction __embind_register_float(rawType, name, size) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   return value;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n    throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n   }\n   return value;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n  destructorFunction: null\n });\n}\n\nfunction __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n name = readLatin1String(name);\n rawInvoker = embind__requireFunction(signature, rawInvoker);\n exposePublicSymbol(name, function() {\n  throwUnboundTypeError(\"Cannot call \" + name + \" due to unbound types\", argTypes);\n }, argCount - 1);\n whenDependentTypesAreResolved([], argTypes, function(argTypes) {\n  var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));\n  replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\n  return [];\n });\n}\n\nfunction integerReadValueFromPointer(name, shift, signed) {\n switch (shift) {\n case 0:\n  return signed ? function readS8FromPointer(pointer) {\n   return HEAP8[pointer];\n  } : function readU8FromPointer(pointer) {\n   return HEAPU8[pointer];\n  };\n\n case 1:\n  return signed ? function readS16FromPointer(pointer) {\n   return HEAP16[pointer >> 1];\n  } : function readU16FromPointer(pointer) {\n   return HEAPU16[pointer >> 1];\n  };\n\n case 2:\n  return signed ? function readS32FromPointer(pointer) {\n   return HEAP32[pointer >> 2];\n  } : function readU32FromPointer(pointer) {\n   return HEAPU32[pointer >> 2];\n  };\n\n default:\n  throw new TypeError(\"Unknown integer type: \" + name);\n }\n}\n\nfunction __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n name = readLatin1String(name);\n if (maxRange === -1) {\n  maxRange = 4294967295;\n }\n var shift = getShiftFromSize(size);\n var fromWireType = function(value) {\n  return value;\n };\n if (minRange === 0) {\n  var bitshift = 32 - 8 * size;\n  fromWireType = function(value) {\n   return value << bitshift >>> bitshift;\n  };\n }\n var isUnsignedType = name.indexOf(\"unsigned\") != -1;\n registerType(primitiveType, {\n  name: name,\n  \"fromWireType\": fromWireType,\n  \"toWireType\": function(destructors, value) {\n   if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n    throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n   }\n   if (value < minRange || value > maxRange) {\n    throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\n   }\n   return isUnsignedType ? value >>> 0 : value | 0;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n  destructorFunction: null\n });\n}\n\nfunction __embind_register_memory_view(rawType, dataTypeIndex, name) {\n var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];\n var TA = typeMapping[dataTypeIndex];\n function decodeMemoryView(handle) {\n  handle = handle >> 2;\n  var heap = HEAPU32;\n  var size = heap[handle];\n  var data = heap[handle + 1];\n  return new TA(buffer, data, size);\n }\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": decodeMemoryView,\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": decodeMemoryView\n }, {\n  ignoreDuplicateRegistrations: true\n });\n}\n\nfunction __embind_register_std_string(rawType, name) {\n name = readLatin1String(name);\n var stdStringIsUTF8 = name === \"std::string\";\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   var length = HEAPU32[value >> 2];\n   var str;\n   if (stdStringIsUTF8) {\n    var decodeStartPtr = value + 4;\n    for (var i = 0; i <= length; ++i) {\n     var currentBytePtr = value + 4 + i;\n     if (i == length || HEAPU8[currentBytePtr] == 0) {\n      var maxRead = currentBytePtr - decodeStartPtr;\n      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n      if (str === undefined) {\n       str = stringSegment;\n      } else {\n       str += String.fromCharCode(0);\n       str += stringSegment;\n      }\n      decodeStartPtr = currentBytePtr + 1;\n     }\n    }\n   } else {\n    var a = new Array(length);\n    for (var i = 0; i < length; ++i) {\n     a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n    }\n    str = a.join(\"\");\n   }\n   _free(value);\n   return str;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (value instanceof ArrayBuffer) {\n    value = new Uint8Array(value);\n   }\n   var getLength;\n   var valueIsOfTypeString = typeof value === \"string\";\n   if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n    throwBindingError(\"Cannot pass non-string to std::string\");\n   }\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\n    getLength = function() {\n     return lengthBytesUTF8(value);\n    };\n   } else {\n    getLength = function() {\n     return value.length;\n    };\n   }\n   var length = getLength();\n   var ptr = _malloc(4 + length + 1);\n   HEAPU32[ptr >> 2] = length;\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\n    stringToUTF8(value, ptr + 4, length + 1);\n   } else {\n    if (valueIsOfTypeString) {\n     for (var i = 0; i < length; ++i) {\n      var charCode = value.charCodeAt(i);\n      if (charCode > 255) {\n       _free(ptr);\n       throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n      }\n      HEAPU8[ptr + 4 + i] = charCode;\n     }\n    } else {\n     for (var i = 0; i < length; ++i) {\n      HEAPU8[ptr + 4 + i] = value[i];\n     }\n    }\n   }\n   if (destructors !== null) {\n    destructors.push(_free, ptr);\n   }\n   return ptr;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: function(ptr) {\n   _free(ptr);\n  }\n });\n}\n\nfunction __embind_register_std_wstring(rawType, charSize, name) {\n name = readLatin1String(name);\n var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n if (charSize === 2) {\n  decodeString = UTF16ToString;\n  encodeString = stringToUTF16;\n  lengthBytesUTF = lengthBytesUTF16;\n  getHeap = function() {\n   return HEAPU16;\n  };\n  shift = 1;\n } else if (charSize === 4) {\n  decodeString = UTF32ToString;\n  encodeString = stringToUTF32;\n  lengthBytesUTF = lengthBytesUTF32;\n  getHeap = function() {\n   return HEAPU32;\n  };\n  shift = 2;\n }\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   var length = HEAPU32[value >> 2];\n   var HEAP = getHeap();\n   var str;\n   var decodeStartPtr = value + 4;\n   for (var i = 0; i <= length; ++i) {\n    var currentBytePtr = value + 4 + i * charSize;\n    if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n     var maxReadBytes = currentBytePtr - decodeStartPtr;\n     var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n     if (str === undefined) {\n      str = stringSegment;\n     } else {\n      str += String.fromCharCode(0);\n      str += stringSegment;\n     }\n     decodeStartPtr = currentBytePtr + charSize;\n    }\n   }\n   _free(value);\n   return str;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (!(typeof value === \"string\")) {\n    throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n   }\n   var length = lengthBytesUTF(value);\n   var ptr = _malloc(4 + length + charSize);\n   HEAPU32[ptr >> 2] = length >> shift;\n   encodeString(value, ptr + 4, length + charSize);\n   if (destructors !== null) {\n    destructors.push(_free, ptr);\n   }\n   return ptr;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: function(ptr) {\n   _free(ptr);\n  }\n });\n}\n\nfunction __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n structRegistrations[rawType] = {\n  name: readLatin1String(name),\n  rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n  rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n  fields: []\n };\n}\n\nfunction __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n structRegistrations[structType].fields.push({\n  fieldName: readLatin1String(fieldName),\n  getterReturnType: getterReturnType,\n  getter: embind__requireFunction(getterSignature, getter),\n  getterContext: getterContext,\n  setterArgumentType: setterArgumentType,\n  setter: embind__requireFunction(setterSignature, setter),\n  setterContext: setterContext\n });\n}\n\nfunction __embind_register_void(rawType, name) {\n name = readLatin1String(name);\n registerType(rawType, {\n  isVoid: true,\n  name: name,\n  \"argPackAdvance\": 0,\n  \"fromWireType\": function() {\n   return undefined;\n  },\n  \"toWireType\": function(destructors, o) {\n   return undefined;\n  }\n });\n}\n\nfunction __emval_as(handle, returnType, destructorsRef) {\n handle = requireHandle(handle);\n returnType = requireRegisteredType(returnType, \"emval::as\");\n var destructors = [];\n var rd = __emval_register(destructors);\n HEAP32[destructorsRef >> 2] = rd;\n return returnType[\"toWireType\"](destructors, handle);\n}\n\nfunction __emval_allocateDestructors(destructorsRef) {\n var destructors = [];\n HEAP32[destructorsRef >> 2] = __emval_register(destructors);\n return destructors;\n}\n\nvar emval_symbols = {};\n\nfunction getStringOrSymbol(address) {\n var symbol = emval_symbols[address];\n if (symbol === undefined) {\n  return readLatin1String(address);\n } else {\n  return symbol;\n }\n}\n\nvar emval_methodCallers = [];\n\nfunction __emval_call_method(caller, handle, methodName, destructorsRef, args) {\n caller = emval_methodCallers[caller];\n handle = requireHandle(handle);\n methodName = getStringOrSymbol(methodName);\n return caller(handle, methodName, __emval_allocateDestructors(destructorsRef), args);\n}\n\nfunction __emval_call_void_method(caller, handle, methodName, args) {\n caller = emval_methodCallers[caller];\n handle = requireHandle(handle);\n methodName = getStringOrSymbol(methodName);\n caller(handle, methodName, null, args);\n}\n\nfunction __emval_addMethodCaller(caller) {\n var id = emval_methodCallers.length;\n emval_methodCallers.push(caller);\n return id;\n}\n\nfunction __emval_lookupTypes(argCount, argTypes) {\n var a = new Array(argCount);\n for (var i = 0; i < argCount; ++i) {\n  a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i], \"parameter \" + i);\n }\n return a;\n}\n\nfunction __emval_get_method_caller(argCount, argTypes) {\n var types = __emval_lookupTypes(argCount, argTypes);\n var retType = types[0];\n var signatureName = retType.name + \"_$\" + types.slice(1).map(function(t) {\n  return t.name;\n }).join(\"_\") + \"$\";\n var params = [ \"retType\" ];\n var args = [ retType ];\n var argsList = \"\";\n for (var i = 0; i < argCount - 1; ++i) {\n  argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n  params.push(\"argType\" + i);\n  args.push(types[1 + i]);\n }\n var functionName = makeLegalFunctionName(\"methodCaller_\" + signatureName);\n var functionBody = \"return function \" + functionName + \"(handle, name, destructors, args) {\\n\";\n var offset = 0;\n for (var i = 0; i < argCount - 1; ++i) {\n  functionBody += \"    var arg\" + i + \" = argType\" + i + \".readValueFromPointer(args\" + (offset ? \"+\" + offset : \"\") + \");\\n\";\n  offset += types[i + 1][\"argPackAdvance\"];\n }\n functionBody += \"    var rv = handle[name](\" + argsList + \");\\n\";\n for (var i = 0; i < argCount - 1; ++i) {\n  if (types[i + 1][\"deleteObject\"]) {\n   functionBody += \"    argType\" + i + \".deleteObject(arg\" + i + \");\\n\";\n  }\n }\n if (!retType.isVoid) {\n  functionBody += \"    return retType.toWireType(destructors, rv);\\n\";\n }\n functionBody += \"};\\n\";\n params.push(functionBody);\n var invokerFunction = new_(Function, params).apply(null, args);\n return __emval_addMethodCaller(invokerFunction);\n}\n\nfunction __emval_get_module_property(name) {\n name = getStringOrSymbol(name);\n return __emval_register(Module[name]);\n}\n\nfunction __emval_get_property(handle, key) {\n handle = requireHandle(handle);\n key = requireHandle(key);\n return __emval_register(handle[key]);\n}\n\nfunction __emval_incref(handle) {\n if (handle > 4) {\n  emval_handle_array[handle].refcount += 1;\n }\n}\n\nfunction __emval_new_cstring(v) {\n return __emval_register(getStringOrSymbol(v));\n}\n\nfunction __emval_run_destructors(handle) {\n var destructors = emval_handle_array[handle].value;\n runDestructors(destructors);\n __emval_decref(handle);\n}\n\nfunction __emval_take_value(type, argv) {\n type = requireRegisteredType(type, \"_emval_take_value\");\n var v = type[\"readValueFromPointer\"](argv);\n return __emval_register(v);\n}\n\nfunction _abort() {\n abort();\n}\n\nfunction emscripten_realloc_buffer(size) {\n try {\n  wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n  updateGlobalBufferAndViews(wasmMemory.buffer);\n  return 1;\n } catch (e) {}\n}\n\nfunction _emscripten_resize_heap(requestedSize) {\n var oldSize = HEAPU8.length;\n requestedSize = requestedSize >>> 0;\n var maxHeapSize = 2147483648;\n if (requestedSize > maxHeapSize) {\n  return false;\n }\n for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n  var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n  overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n  var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n  var replacement = emscripten_realloc_buffer(newSize);\n  if (replacement) {\n   return true;\n  }\n }\n return false;\n}\n\nvar SYSCALLS = {\n mappings: {},\n buffers: [ null, [], [] ],\n printChar: function(stream, curr) {\n  var buffer = SYSCALLS.buffers[stream];\n  if (curr === 0 || curr === 10) {\n   (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n   buffer.length = 0;\n  } else {\n   buffer.push(curr);\n  }\n },\n varargs: undefined,\n get: function() {\n  SYSCALLS.varargs += 4;\n  var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n  return ret;\n },\n getStr: function(ptr) {\n  var ret = UTF8ToString(ptr);\n  return ret;\n },\n get64: function(low, high) {\n  return low;\n }\n};\n\nfunction _fd_close(fd) {\n return 0;\n}\n\nfunction _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}\n\nfunction _fd_write(fd, iov, iovcnt, pnum) {\n var num = 0;\n for (var i = 0; i < iovcnt; i++) {\n  var ptr = HEAP32[iov + i * 8 >> 2];\n  var len = HEAP32[iov + (i * 8 + 4) >> 2];\n  for (var j = 0; j < len; j++) {\n   SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\n  }\n  num += len;\n }\n HEAP32[pnum >> 2] = num;\n return 0;\n}\n\nfunction _setTempRet0($i) {\n setTempRet0($i | 0);\n}\n\ninit_emval();\n\nPureVirtualError = Module[\"PureVirtualError\"] = extendError(Error, \"PureVirtualError\");\n\nembind_init_charCodes();\n\ninit_embind();\n\nBindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n\nInternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n\ninit_ClassHandle();\n\ninit_RegisteredPointer();\n\nUnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n\nvar ASSERTIONS = false;\n\nfunction intArrayToString(array) {\n var ret = [];\n for (var i = 0; i < array.length; i++) {\n  var chr = array[i];\n  if (chr > 255) {\n   if (ASSERTIONS) {\n    assert(false, \"Character code \" + chr + \" (\" + String.fromCharCode(chr) + \")  at offset \" + i + \" not in 0x00-0xFF.\");\n   }\n   chr &= 255;\n  }\n  ret.push(String.fromCharCode(chr));\n }\n return ret.join(\"\");\n}\n\nvar decodeBase64 = typeof atob === \"function\" ? atob : function(input) {\n var keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n var output = \"\";\n var chr1, chr2, chr3;\n var enc1, enc2, enc3, enc4;\n var i = 0;\n input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n do {\n  enc1 = keyStr.indexOf(input.charAt(i++));\n  enc2 = keyStr.indexOf(input.charAt(i++));\n  enc3 = keyStr.indexOf(input.charAt(i++));\n  enc4 = keyStr.indexOf(input.charAt(i++));\n  chr1 = enc1 << 2 | enc2 >> 4;\n  chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n  chr3 = (enc3 & 3) << 6 | enc4;\n  output = output + String.fromCharCode(chr1);\n  if (enc3 !== 64) {\n   output = output + String.fromCharCode(chr2);\n  }\n  if (enc4 !== 64) {\n   output = output + String.fromCharCode(chr3);\n  }\n } while (i < input.length);\n return output;\n};\n\nfunction intArrayFromBase64(s) {\n if (typeof ENVIRONMENT_IS_NODE === \"boolean\" && ENVIRONMENT_IS_NODE) {\n  var buf;\n  try {\n   buf = Buffer.from(s, \"base64\");\n  } catch (_) {\n   buf = new Buffer(s, \"base64\");\n  }\n  return new Uint8Array(buf[\"buffer\"], buf[\"byteOffset\"], buf[\"byteLength\"]);\n }\n try {\n  var decoded = decodeBase64(s);\n  var bytes = new Uint8Array(decoded.length);\n  for (var i = 0; i < decoded.length; ++i) {\n   bytes[i] = decoded.charCodeAt(i);\n  }\n  return bytes;\n } catch (_) {\n  throw new Error(\"Converting base64 string to bytes failed.\");\n }\n}\n\nfunction tryParseAsDataURI(filename) {\n if (!isDataURI(filename)) {\n  return;\n }\n return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n}\n\nvar asmLibraryArg = {\n \"n\": __embind_create_inheriting_constructor,\n \"H\": __embind_finalize_value_object,\n \"A\": __embind_register_bool,\n \"c\": __embind_register_class,\n \"i\": __embind_register_class_class_function,\n \"f\": __embind_register_class_class_property,\n \"r\": __embind_register_class_constructor,\n \"a\": __embind_register_class_function,\n \"b\": __embind_register_class_property,\n \"z\": __embind_register_emval,\n \"k\": __embind_register_enum,\n \"j\": __embind_register_enum_value,\n \"p\": __embind_register_float,\n \"K\": __embind_register_function,\n \"h\": __embind_register_integer,\n \"g\": __embind_register_memory_view,\n \"q\": __embind_register_std_string,\n \"m\": __embind_register_std_wstring,\n \"J\": __embind_register_value_object,\n \"I\": __embind_register_value_object_field,\n \"B\": __embind_register_void,\n \"l\": __emval_as,\n \"G\": __emval_call_method,\n \"e\": __emval_call_void_method,\n \"D\": __emval_decref,\n \"d\": __emval_get_method_caller,\n \"L\": __emval_get_module_property,\n \"u\": __emval_get_property,\n \"C\": __emval_incref,\n \"E\": __emval_new_cstring,\n \"F\": __emval_run_destructors,\n \"t\": __emval_take_value,\n \"s\": _abort,\n \"x\": _emscripten_resize_heap,\n \"y\": _fd_close,\n \"v\": _fd_seek,\n \"o\": _fd_write,\n \"w\": _setTempRet0\n};\n\nvar asm = createWasm();\n\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\n return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"N\"]).apply(null, arguments);\n};\n\nvar _malloc = Module[\"_malloc\"] = function() {\n return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"P\"]).apply(null, arguments);\n};\n\nvar ___getTypeName = Module[\"___getTypeName\"] = function() {\n return (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"Q\"]).apply(null, arguments);\n};\n\nvar ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function() {\n return (___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = Module[\"asm\"][\"R\"]).apply(null, arguments);\n};\n\nvar _free = Module[\"_free\"] = function() {\n return (_free = Module[\"_free\"] = Module[\"asm\"][\"S\"]).apply(null, arguments);\n};\n\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\n return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"T\"]).apply(null, arguments);\n};\n\nvar calledRun;\n\nfunction ExitStatus(status) {\n this.name = \"ExitStatus\";\n this.message = \"Program terminated with exit(\" + status + \")\";\n this.status = status;\n}\n\ndependenciesFulfilled = function runCaller() {\n if (!calledRun) run();\n if (!calledRun) dependenciesFulfilled = runCaller;\n};\n\nfunction run(args) {\n args = args || arguments_;\n if (runDependencies > 0) {\n  return;\n }\n preRun();\n if (runDependencies > 0) {\n  return;\n }\n function doRun() {\n  if (calledRun) return;\n  calledRun = true;\n  Module[\"calledRun\"] = true;\n  if (ABORT) return;\n  initRuntime();\n  preMain();\n  readyPromiseResolve(Module);\n  if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n  postRun();\n }\n if (Module[\"setStatus\"]) {\n  Module[\"setStatus\"](\"Running...\");\n  setTimeout(function() {\n   setTimeout(function() {\n    Module[\"setStatus\"](\"\");\n   }, 1);\n   doRun();\n  }, 1);\n } else {\n  doRun();\n }\n}\n\nModule[\"run\"] = run;\n\nif (Module[\"preInit\"]) {\n if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [ Module[\"preInit\"] ];\n while (Module[\"preInit\"].length > 0) {\n  Module[\"preInit\"].pop()();\n }\n}\n\nrun();\n\nfunction makeMatrix(m2d) {\n    const m = new DOMMatrix();\n    m.a = m2d.xx;\n    m.b = m2d.xy;\n    m.c = m2d.yx;\n    m.d = m2d.yy;\n    m.e = m2d.tx;\n    m.f = m2d.ty;\n    return m;\n}\n\nModule.onRuntimeInitialized = function () {\n    const {\n        RenderPaintStyle,\n        FillRule,\n        RenderPath,\n        RenderPaint,\n        Renderer,\n        StrokeCap,\n        StrokeJoin,\n        BlendMode\n    } = Module;\n\n    const {\n        fill,\n        stroke\n    } = RenderPaintStyle;\n\n    const {\n        evenOdd,\n        nonZero\n    } = FillRule;\n\n    var CanvasRenderPath = RenderPath.extend(\"CanvasRenderPath\", {\n        __construct: function () {\n            this.__parent.__construct.call(this);\n            this._path2D = new Path2D();\n        },\n        reset: function () {\n            this._path2D = new Path2D();\n        },\n        addPath: function (path, m2d) {\n            this._path2D.addPath(path._path2D, makeMatrix(m2d));\n        },\n        fillRule: function(fillRule) {\n            this._fillRule = fillRule;\n        },\n        moveTo: function (x, y) {\n            this._path2D.moveTo(x, y);\n        },\n        lineTo: function (x, y) {\n            this._path2D.lineTo(x, y);\n        },\n        cubicTo: function (ox, oy, ix, iy, x, y) {\n            this._path2D.bezierCurveTo(ox, oy, ix, iy, x, y);\n        },\n        close: function () {\n            this._path2D.closePath();\n        }\n    });\n\n    function _colorStyle(value) {\n        return 'rgba(' + ((0x00ff0000 & value) >>>\n                16) + ',' + ((0x0000ff00 &\n                value) >>> 8) + ',' + ((0x000000ff & value) >>> 0) + ',' +\n            (((0xff000000 & value) >>> 24) / 0xFF) + ')'\n    }\n    var CanvasRenderPaint = RenderPaint.extend(\"CanvasRenderPaint\", {\n        color: function (value) {\n            this._value = _colorStyle(value);\n        },\n        thickness: function (value) {\n            this._thickness = value;\n        },\n        join: function (value) {\n            switch (value) {\n                case StrokeJoin.miter:\n                    this._join = 'miter';\n                    break;\n                case StrokeJoin.round:\n                    this._join = 'round';\n                    break;\n                case StrokeJoin.bevel:\n                    this._join = 'bevel';\n                    break;\n            }\n        },\n        cap: function (value) {\n            switch (value) {\n                case StrokeCap.butt:\n                    this._cap = 'butt';\n                    break;\n                case StrokeCap.round:\n                    this._cap = 'round';\n                    break;\n                case StrokeCap.square:\n                    this._cap = 'square';\n                    break;\n            }\n        },\n        style: function (value) {\n            this._style = value;\n        },\n        blendMode: function (value) {\n            switch (value) {\n                case BlendMode.srcOver:\n                    this._blend = 'source-over';\n                    break;\n                case BlendMode.screen:\n                    this._blend = 'screen';\n                    break;\n                case BlendMode.overlay:\n                    this._blend = 'overlay';\n                    break;\n                case BlendMode.darken:\n                    this._blend = 'darken';\n                    break;\n                case BlendMode.lighten:\n                    this._blend = 'lighten';\n                    break;\n                case BlendMode.colorDodge:\n                    this._blend = 'color-dodge';\n                    break;\n                case BlendMode.colorBurn:\n                    this._blend = 'color-burn';\n                    break;\n                case BlendMode.hardLight:\n                    this._blend = 'hard-light';\n                    break;\n                case BlendMode.softLight:\n                    this._blend = 'soft-light';\n                    break;\n                case BlendMode.difference:\n                    this._blend = 'difference';\n                    break;\n                case BlendMode.exclusion:\n                    this._blend = 'exclusion';\n                    break;\n                case BlendMode.multiply:\n                    this._blend = 'multiply';\n                    break;\n                case BlendMode.hue:\n                    this._blend = 'hue';\n                    break;\n                case BlendMode.saturation:\n                    this._blend = 'saturation';\n                    break;\n                case BlendMode.color:\n                    this._blend = 'color';\n                    break;\n                case BlendMode.luminosity:\n                    this._blend = 'luminosity';\n                    break;\n            }\n        },\n        linearGradient: function (sx, sy, ex, ey) {\n            this._gradient = {\n                sx,\n                sy,\n                ex,\n                ey,\n                stops: []\n            };\n        },\n        radialGradient: function (sx, sy, ex, ey) {\n            this._gradient = {\n                sx,\n                sy,\n                ex,\n                ey,\n                stops: [],\n                isRadial: true\n            };\n        },\n        addStop: function (color, stop) {\n            this._gradient.stops.push({\n                color,\n                stop\n            });\n        },\n\n        completeGradient: function () {\n\n        },\n\n        draw: function (ctx, path) {\n            let {\n                _style,\n                _value,\n                _gradient,\n                _blend\n            } = this;\n\n            ctx.globalCompositeOperation = _blend;\n\n            if (_gradient != null) {\n                const {\n                    sx,\n                    sy,\n                    ex,\n                    ey,\n                    stops,\n                    isRadial\n                } = _gradient;\n\n                if (isRadial) {\n                    var dx = ex - sx;\n                    var dy = ey - sy;\n                    var radius = Math.sqrt(dx * dx + dy * dy);\n                    _value = ctx.createRadialGradient(sx, sy, 0, sx, sy, radius);\n                } else {\n                    _value = ctx.createLinearGradient(sx, sy, ex, ey);\n                }\n\n                for (const {\n                        stop,\n                        color\n                    } of stops) {\n                    _value.addColorStop(stop, _colorStyle(color));\n                }\n                this._value = _value;\n                this._gradient = null;\n            }\n            switch (_style) {\n                case stroke:\n                    ctx.strokeStyle = _value;\n                    ctx.lineWidth = this._thickness;\n                    ctx.lineCap = this._cap;\n                    ctx.lineJoin = this._join;\n                    ctx.stroke(path._path2D);\n                    break;\n                case fill:\n                    ctx.fillStyle = _value;\n                    ctx.fill(path._path2D, path._fillRule === evenOdd ? 'evenodd' : 'nonzero');\n                    break;\n            }\n        }\n    });\n\n    Module.CanvasRenderer = Renderer.extend(\"Renderer\", {\n        __construct: function (ctx) {\n            this.__parent.__construct.call(this);\n            this._ctx = ctx;\n        },\n        save: function () {\n            this._ctx.save();\n        },\n        restore: function () {\n            this._ctx.restore();\n        },\n        transform: function (matrix) {\n            this._ctx.transform(matrix.xx, matrix.xy, matrix.yx, matrix.yy, matrix.tx,\n                matrix.ty);\n        },\n        drawPath: function (path, paint) {\n            paint.draw(this._ctx, path);\n        },\n        clipPath: function (path) {\n            this._ctx.clip(path._path2D, path._fillRule === evenOdd ? 'evenodd' : 'nonzero');\n        }\n    });\n\n    Module.renderFactory = {\n        makeRenderPaint: function () {\n            return new CanvasRenderPaint();\n        },\n        makeRenderPath: function () {\n            return new CanvasRenderPath();\n        }\n    };\n};\n\n\n  return Rive.ready\n}\n);\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Rive);\n\n\n/***/ }),\n/* 2 */\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ }),\n/* 3 */\n/***/ (() => {\n\n/* (ignored) */\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_292210__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_292210__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_292210__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_292210__.o(definition, key) && !__nested_webpack_require_292210__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_292210__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_292210__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n(() => {\n\"use strict\";\n__nested_webpack_require_292210__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_292210__.d(__webpack_exports__, {\n/* harmony export */   \"Fit\": () => (/* binding */ Fit),\n/* harmony export */   \"Alignment\": () => (/* binding */ Alignment),\n/* harmony export */   \"Layout\": () => (/* binding */ Layout),\n/* harmony export */   \"RuntimeLoader\": () => (/* binding */ RuntimeLoader),\n/* harmony export */   \"StateMachineInputType\": () => (/* binding */ StateMachineInputType),\n/* harmony export */   \"StateMachineInput\": () => (/* binding */ StateMachineInput),\n/* harmony export */   \"EventType\": () => (/* binding */ EventType),\n/* harmony export */   \"LoopType\": () => (/* binding */ LoopType),\n/* harmony export */   \"Rive\": () => (/* binding */ Rive),\n/* harmony export */   \"Testing\": () => (/* binding */ Testing)\n/* harmony export */ });\n/* harmony import */ var _rive_canvas_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_292210__(1);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n// Tracks playback states; numbers map to the runtime's numerical values\n// i.e. play: 0, pause: 1, stop: 2\nvar PlaybackState;\n(function (PlaybackState) {\n    PlaybackState[PlaybackState[\"Play\"] = 0] = \"Play\";\n    PlaybackState[PlaybackState[\"Pause\"] = 1] = \"Pause\";\n    PlaybackState[PlaybackState[\"Stop\"] = 2] = \"Stop\";\n})(PlaybackState || (PlaybackState = {}));\n// #region layout\n// Fit options for the canvas\nvar Fit;\n(function (Fit) {\n    Fit[\"Cover\"] = \"cover\";\n    Fit[\"Contain\"] = \"contain\";\n    Fit[\"Fill\"] = \"fill\";\n    Fit[\"FitWidth\"] = \"fitWidth\";\n    Fit[\"FitHeight\"] = \"fitHeight\";\n    Fit[\"None\"] = \"none\";\n    Fit[\"ScaleDown\"] = \"scaleDown\";\n})(Fit || (Fit = {}));\n// Alignment options for the canvas\nvar Alignment;\n(function (Alignment) {\n    Alignment[\"Center\"] = \"center\";\n    Alignment[\"TopLeft\"] = \"topLeft\";\n    Alignment[\"TopCenter\"] = \"topCenter\";\n    Alignment[\"TopRight\"] = \"topRight\";\n    Alignment[\"CenterLeft\"] = \"centerLeft\";\n    Alignment[\"CenterRight\"] = \"centerRight\";\n    Alignment[\"BottomLeft\"] = \"bottomLeft\";\n    Alignment[\"BottomCenter\"] = \"bottomCenter\";\n    Alignment[\"BottomRight\"] = \"bottomRight\";\n})(Alignment || (Alignment = {}));\n// Alignment options for Rive animations in a HTML canvas\nvar Layout = /** @class */ (function () {\n    function Layout(params) {\n        var _a, _b, _c, _d, _e, _f;\n        this.fit = (_a = params === null || params === void 0 ? void 0 : params.fit) !== null && _a !== void 0 ? _a : Fit.Contain;\n        this.alignment = (_b = params === null || params === void 0 ? void 0 : params.alignment) !== null && _b !== void 0 ? _b : Alignment.Center;\n        this.minX = (_c = params === null || params === void 0 ? void 0 : params.minX) !== null && _c !== void 0 ? _c : 0;\n        this.minY = (_d = params === null || params === void 0 ? void 0 : params.minY) !== null && _d !== void 0 ? _d : 0;\n        this.maxX = (_e = params === null || params === void 0 ? void 0 : params.maxX) !== null && _e !== void 0 ? _e : 0;\n        this.maxY = (_f = params === null || params === void 0 ? void 0 : params.maxY) !== null && _f !== void 0 ? _f : 0;\n    }\n    // Alternative constructor to build a Layout from an interface/object\n    Layout.new = function (_a) {\n        var fit = _a.fit, alignment = _a.alignment, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n        console.warn('This function is deprecated: please use `new Layout({})` instead');\n        return new Layout({ fit: fit, alignment: alignment, minX: minX, minY: minY, maxX: maxX, maxY: maxY });\n    };\n    /**\n     * Makes a copy of the layout, replacing any specified parameters\n     */\n    Layout.prototype.copyWith = function (_a) {\n        var fit = _a.fit, alignment = _a.alignment, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n        return new Layout({\n            fit: fit !== null && fit !== void 0 ? fit : this.fit,\n            alignment: alignment !== null && alignment !== void 0 ? alignment : this.alignment,\n            minX: minX !== null && minX !== void 0 ? minX : this.minX,\n            minY: minY !== null && minY !== void 0 ? minY : this.minY,\n            maxX: maxX !== null && maxX !== void 0 ? maxX : this.maxX,\n            maxY: maxY !== null && maxY !== void 0 ? maxY : this.maxY\n        });\n    };\n    // Returns fit for the Wasm runtime format\n    Layout.prototype.runtimeFit = function (rive) {\n        if (this.cachedRuntimeFit)\n            return this.cachedRuntimeFit;\n        var fit;\n        if (this.fit === Fit.Cover)\n            fit = rive.Fit.cover;\n        else if (this.fit === Fit.Contain)\n            fit = rive.Fit.contain;\n        else if (this.fit === Fit.Fill)\n            fit = rive.Fit.fill;\n        else if (this.fit === Fit.FitWidth)\n            fit = rive.Fit.fitWidth;\n        else if (this.fit === Fit.FitHeight)\n            fit = rive.Fit.fitHeight;\n        else if (this.fit === Fit.ScaleDown)\n            fit = rive.Fit.scaleDown;\n        else\n            fit = rive.Fit.none;\n        this.cachedRuntimeFit = fit;\n        return fit;\n    };\n    // Returns alignment for the Wasm runtime format\n    Layout.prototype.runtimeAlignment = function (rive) {\n        if (this.cachedRuntimeAlignment)\n            return this.cachedRuntimeAlignment;\n        var alignment;\n        if (this.alignment === Alignment.TopLeft)\n            alignment = rive.Alignment.topLeft;\n        else if (this.alignment === Alignment.TopCenter)\n            alignment = rive.Alignment.topCenter;\n        else if (this.alignment === Alignment.TopRight)\n            alignment = rive.Alignment.topRight;\n        else if (this.alignment === Alignment.CenterLeft)\n            alignment = rive.Alignment.centerLeft;\n        else if (this.alignment === Alignment.CenterRight)\n            alignment = rive.Alignment.centerRight;\n        else if (this.alignment === Alignment.BottomLeft)\n            alignment = rive.Alignment.bottomLeft;\n        else if (this.alignment === Alignment.BottomCenter)\n            alignment = rive.Alignment.bottomCenter;\n        else if (this.alignment === Alignment.BottomRight)\n            alignment = rive.Alignment.bottomRight;\n        else\n            alignment = rive.Alignment.center;\n        this.cachedRuntimeAlignment = alignment;\n        return alignment;\n    };\n    return Layout;\n}());\n\n// Runtime singleton; use getInstance to provide a callback that returns the\n// Rive runtime\nvar RuntimeLoader = /** @class */ (function () {\n    // Class is never instantiated\n    function RuntimeLoader() {\n    }\n    // Loads the runtime\n    RuntimeLoader.loadRuntime = function () {\n        _rive_canvas_js__WEBPACK_IMPORTED_MODULE_0__.default({\n            // Loads Wasm bundle\n            locateFile: function (_) { return RuntimeLoader.wasmURL; }\n        }).then(function (rive) {\n            var _a;\n            RuntimeLoader.runtime = rive;\n            // Fire all the callbacks\n            while (RuntimeLoader.callBackQueue.length > 0) {\n                (_a = RuntimeLoader.callBackQueue.shift()) === null || _a === void 0 ? void 0 : _a(RuntimeLoader.runtime);\n            }\n        });\n    };\n    // Provides a runtime instance via a callback\n    RuntimeLoader.getInstance = function (callback) {\n        // If it's not loading, start loading runtime\n        if (!RuntimeLoader.isLoading) {\n            RuntimeLoader.isLoading = true;\n            RuntimeLoader.loadRuntime();\n        }\n        if (!RuntimeLoader.runtime) {\n            RuntimeLoader.callBackQueue.push(callback);\n        }\n        else {\n            callback(RuntimeLoader.runtime);\n        }\n    };\n    // Provides a runtime instance via a promise\n    RuntimeLoader.awaitInstance = function () {\n        return new Promise(function (resolve, reject) {\n            return RuntimeLoader.getInstance(function (rive) { return resolve(rive); });\n        });\n    };\n    // Manually sets the wasm url\n    RuntimeLoader.setWasmUrl = function (url) {\n        RuntimeLoader.wasmURL = url;\n    };\n    // Flag to indicate that loading has started/completed\n    RuntimeLoader.isLoading = false;\n    // List of callbacks for the runtime that come in while loading\n    RuntimeLoader.callBackQueue = [];\n    // Path to the Wasm file; default path works for testing only;\n    // if embedded wasm is used then this is never used.\n    RuntimeLoader.wasmURL = 'dist/rive.wasm';\n    return RuntimeLoader;\n}());\n\n// #endregion\n// #region animations\n// Wraps animations and instances from the runtime and keeps track of playback\n// state\nvar Animation = /** @class */ (function () {\n    /**\n     * Constructs a new animation\n     * @constructor\n     * @param {any} animation: runtime animation object\n     * @param {any} instance: runtime animation instance object\n     */\n    function Animation(animation, runtime, playing) {\n        this.animation = animation;\n        this.playing = playing;\n        this.loopCount = 0;\n        // Time to which the animation should move to on the next render\n        this.scrubTo = null;\n        this.instance = new runtime.LinearAnimationInstance(animation);\n    }\n    Object.defineProperty(Animation.prototype, \"name\", {\n        // Returns the animation's name\n        get: function () {\n            return this.animation.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"time\", {\n        // Returns the animation's current time\n        get: function () {\n            return this.instance.time;\n        },\n        // Sets the animation's current time\n        set: function (value) {\n            this.instance.time = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"loopValue\", {\n        // Returns the animation's loop type\n        get: function () {\n            return this.animation.loopValue;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Advances the animation by the give time. If the animation needs scrubbing,\n     * time is ignored and the stored scrub value is used.\n     * @param time the time to advance the animation by if no scrubbing required\n     */\n    Animation.prototype.advance = function (time) {\n        if (this.scrubTo === null) {\n            this.instance.advance(time);\n        }\n        else {\n            this.instance.time = 0;\n            this.instance.advance(this.scrubTo);\n            this.scrubTo = null;\n        }\n    };\n    Object.defineProperty(Animation.prototype, \"needsScrub\", {\n        get: function () {\n            return this.scrubTo !== null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Deletes the backing Wasm animation instance; once this is called, this\n     * animation is no more.\n     */\n    Animation.prototype.cleanup = function () {\n        this.instance.delete();\n    };\n    return Animation;\n}());\n// #endregion\n// #region state machines\nvar StateMachineInputType;\n(function (StateMachineInputType) {\n    StateMachineInputType[StateMachineInputType[\"Number\"] = 56] = \"Number\";\n    StateMachineInputType[StateMachineInputType[\"Trigger\"] = 58] = \"Trigger\";\n    StateMachineInputType[StateMachineInputType[\"Boolean\"] = 59] = \"Boolean\";\n})(StateMachineInputType || (StateMachineInputType = {}));\n/**\n * An input for a state machine\n */\nvar StateMachineInput = /** @class */ (function () {\n    function StateMachineInput(type, runtimeInput) {\n        this.type = type;\n        this.runtimeInput = runtimeInput;\n    }\n    Object.defineProperty(StateMachineInput.prototype, \"name\", {\n        /**\n         * Returns the name of the input\n         */\n        get: function () {\n            return this.runtimeInput.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StateMachineInput.prototype, \"value\", {\n        /**\n         * Returns the current value of the input\n         */\n        get: function () {\n            return this.runtimeInput.value;\n        },\n        /**\n         * Sets the value of the input\n         */\n        set: function (value) {\n            this.runtimeInput.value = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Fires a trigger; does nothing on Number or Boolean input types\n     */\n    StateMachineInput.prototype.fire = function () {\n        if (this.type === StateMachineInputType.Trigger) {\n            this.runtimeInput.fire();\n        }\n    };\n    return StateMachineInput;\n}());\n\nvar StateMachine = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param stateMachine runtime state machine object\n     * @param instance runtime state machine instance object\n     */\n    function StateMachine(stateMachine, runtime, playing) {\n        this.stateMachine = stateMachine;\n        this.playing = playing;\n        /**\n         * Caches the inputs from the runtime\n         */\n        this.inputs = [];\n        this.instance = new runtime.StateMachineInstance(stateMachine);\n        this.initInputs(runtime);\n    }\n    Object.defineProperty(StateMachine.prototype, \"name\", {\n        get: function () {\n            return this.stateMachine.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StateMachine.prototype, \"statesChanged\", {\n        /**\n         * Returns a list of state names that have changed on this frame\n         */\n        get: function () {\n            var names = [];\n            for (var i = 0; i < this.instance.stateChangedCount(); i++) {\n                names.push(this.instance.stateChangedNameByIndex(i));\n            }\n            return names;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Fetches references to the state machine's inputs and caches them\n     * @param runtime an instance of the runtime; needed for the SMIInput types\n     */\n    StateMachine.prototype.initInputs = function (runtime) {\n        // Fetch the inputs from the runtime if we don't have them\n        for (var i = 0; i < this.instance.inputCount(); i++) {\n            var input = this.instance.input(i);\n            this.inputs.push(this.mapRuntimeInput(input, runtime));\n        }\n    };\n    /**\n     * Maps a runtime input to it's appropriate type\n     * @param input\n     */\n    StateMachine.prototype.mapRuntimeInput = function (input, runtime) {\n        if (input.type === runtime.SMIInput.bool) {\n            return new StateMachineInput(StateMachineInputType.Boolean, input.asBool());\n        }\n        else if (input.type === runtime.SMIInput.number) {\n            return new StateMachineInput(StateMachineInputType.Number, input.asNumber());\n        }\n        else if (input.type === runtime.SMIInput.trigger) {\n            return new StateMachineInput(StateMachineInputType.Trigger, input.asTrigger());\n        }\n    };\n    /**\n     * Deletes the backing Wasm state machine instance; once this is called, this\n     * state machine is no more.\n     */\n    StateMachine.prototype.cleanup = function () {\n        this.instance.delete();\n    };\n    return StateMachine;\n}());\n// #endregion\n// #region animator\n/**\n * Manages animation\n */\nvar Animator = /** @class */ (function () {\n    /**\n     * Constructs a new animator\n     * @constructor\n     * @param runtime Rive runtime; needed to instance animations & state machines\n     * @param artboard the artboard that holds all animations and state machines\n     * @param animations optional list of animations\n     * @param stateMachines optional list of state machines\n     */\n    function Animator(runtime, artboard, eventManager, animations, stateMachines) {\n        if (animations === void 0) { animations = []; }\n        if (stateMachines === void 0) { stateMachines = []; }\n        this.runtime = runtime;\n        this.artboard = artboard;\n        this.eventManager = eventManager;\n        this.animations = animations;\n        this.stateMachines = stateMachines;\n    }\n    /**\n     * Adds animations and state machines by their names. If names are shared\n     * between animations & state machines, then the first one found will be\n     * created. Best not to use the same names for these in your Rive file.\n     * @param animatable the name(s) of animations and state machines to add\n     * @returns a list of names of the playing animations and state machines\n     */\n    Animator.prototype.add = function (animatables, playing, fireEvent) {\n        if (fireEvent === void 0) { fireEvent = true; }\n        animatables = mapToStringArray(animatables);\n        // If animatables is empty, play or pause everything\n        if (animatables.length === 0) {\n            this.animations.forEach(function (a) { return a.playing = playing; });\n            this.stateMachines.forEach(function (m) { return m.playing = playing; });\n        }\n        else {\n            // Play/pause already instanced items, or create new instances\n            var instancedAnimationNames = this.animations.map(function (a) { return a.name; });\n            var instancedMachineNames = this.stateMachines.map(function (m) { return m.name; });\n            for (var i in animatables) {\n                var aIndex = instancedAnimationNames.indexOf(animatables[i]);\n                var mIndex = instancedMachineNames.indexOf(animatables[i]);\n                if (aIndex >= 0 || mIndex >= 0) {\n                    if (aIndex >= 0) {\n                        // Animation is instanced, play/pause it\n                        this.animations[aIndex].playing = playing;\n                    }\n                    else {\n                        // State machine is instanced, play/pause it\n                        this.stateMachines[mIndex].playing = playing;\n                    }\n                }\n                else {\n                    // Try to create a new animation instance\n                    var anim = this.artboard.animationByName(animatables[i]);\n                    if (anim) {\n                        this.animations.push(new Animation(anim, this.runtime, playing));\n                    }\n                    else {\n                        // Try to create a new state machine instance\n                        var sm = this.artboard.stateMachineByName(animatables[i]);\n                        if (sm) {\n                            this.stateMachines.push(new StateMachine(sm, this.runtime, playing));\n                        }\n                    }\n                }\n            }\n        }\n        // Fire play/paused events for animations\n        if (fireEvent) {\n            if (playing) {\n                this.eventManager.fire({\n                    type: EventType.Play,\n                    data: this.playing,\n                });\n            }\n            else {\n                this.eventManager.fire({\n                    type: EventType.Pause,\n                    data: this.paused,\n                });\n            }\n        }\n        return playing ? this.playing : this.paused;\n    };\n    /**\n     * Play the named animations/state machines\n     * @param animatables the names of the animations/machines to play; plays all if empty\n     * @returns a list of the playing items\n     */\n    Animator.prototype.play = function (animatables) {\n        return this.add(animatables, true);\n    };\n    /**\n   * Pauses named animations and state machines, or everything if nothing is\n   * specified\n   * @param animatables names of the animations and state machines to pause\n   * @returns a list of names of the animations and state machines paused\n   */\n    Animator.prototype.pause = function (animatables) {\n        return this.add(animatables, false);\n    };\n    /**\n     * Set time of named animations\n     * @param animations names of the animations to scrub\n     * @param value time scrub value, a floating point number to which the playhead is jumped\n     * @returns a list of names of the animations that were scrubbed\n     */\n    Animator.prototype.scrub = function (animatables, value) {\n        var forScrubbing = this.animations.filter(function (a) { return animatables.includes(a.name); });\n        forScrubbing.forEach(function (a) { return a.scrubTo = value; });\n        return forScrubbing.map(function (a) { return a.name; });\n    };\n    Object.defineProperty(Animator.prototype, \"playing\", {\n        /**\n         * Returns a list of names of all animations and state machines currently\n         * playing\n         */\n        get: function () {\n            return this.animations.filter(function (a) { return a.playing; }).map(function (a) { return a.name; }).concat(this.stateMachines.filter(function (m) { return m.playing; }).map(function (m) { return m.name; }));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animator.prototype, \"paused\", {\n        /**\n         * Returns a list of names of all animations and state machines currently\n         * paused\n         */\n        get: function () {\n            return this.animations.filter(function (a) { return !a.playing; }).map(function (a) { return a.name; }).concat(this.stateMachines.filter(function (m) { return !m.playing; }).map(function (m) { return m.name; }));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Stops and removes all named animations and state machines\n     * @param animatables animations and state machines to remove\n     * @returns a list of names of removed items\n     */\n    Animator.prototype.stop = function (animatables) {\n        var _this = this;\n        animatables = mapToStringArray(animatables);\n        // If nothing's specified, wipe them out, all of them\n        var removedNames = [];\n        // Stop everything\n        if (animatables.length === 0) {\n            removedNames = this.animations.map(function (a) { return a.name; }).concat(this.stateMachines.map(function (m) { return m.name; }));\n            // Clean up before emptying the arrays\n            this.animations.forEach(function (a) { return a.cleanup(); });\n            this.stateMachines.forEach(function (m) { return m.cleanup(); });\n            // Empty out the arrays\n            this.animations.splice(0, this.animations.length);\n            this.stateMachines.splice(0, this.stateMachines.length);\n        }\n        else {\n            // Remove only the named animations/state machines\n            var animationsToRemove = this.animations.filter(function (a) { return animatables.includes(a.name); });\n            animationsToRemove.forEach(function (a) {\n                a.cleanup();\n                _this.animations.splice(_this.animations.indexOf(a), 1);\n            });\n            var machinesToRemove = this.stateMachines.filter(function (m) { return animatables.includes(m.name); });\n            machinesToRemove.forEach(function (m) {\n                m.cleanup();\n                _this.stateMachines.splice(_this.stateMachines.indexOf(m), 1);\n            });\n            removedNames = animationsToRemove.map(function (a) { return a.name; }).concat(machinesToRemove.map(function (m) { return m.name; }));\n        }\n        this.eventManager.fire({\n            type: EventType.Stop,\n            data: removedNames,\n        });\n        // Return the list of animations removed\n        return removedNames;\n    };\n    Object.defineProperty(Animator.prototype, \"isPlaying\", {\n        /**\n         * Returns true if at least one animation is active\n         */\n        get: function () {\n            return this.animations.reduce(function (acc, curr) { return acc || curr.playing; }, false)\n                || this.stateMachines.reduce(function (acc, curr) { return acc || curr.playing; }, false);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animator.prototype, \"isPaused\", {\n        /**\n         * Returns true if all animations are paused and there's at least one animation\n         */\n        get: function () {\n            return !this.isPlaying &&\n                (this.animations.length > 0 || this.stateMachines.length > 0);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animator.prototype, \"isStopped\", {\n        /**\n         * Returns true if there are no playing or paused animations/state machines\n         */\n        get: function () {\n            return this.animations.length === 0 && this.stateMachines.length === 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * If there are no animations or state machines, add the first one found\n     * @returns the name of the animation or state machine instanced\n     */\n    Animator.prototype.atLeastOne = function (playing, fireEvent) {\n        if (fireEvent === void 0) { fireEvent = true; }\n        var instancedName;\n        if (this.animations.length === 0 && this.stateMachines.length === 0) {\n            if (this.artboard.animationCount() > 0) {\n                // Add the first animation\n                this.add([instancedName = this.artboard.animationByIndex(0).name], playing, fireEvent);\n            }\n            else if (this.artboard.stateMachineCount() > 0) {\n                // Add the first state machine\n                this.add([instancedName = this.artboard.stateMachineByIndex(0).name], playing, fireEvent);\n            }\n        }\n        return instancedName;\n    };\n    /**\n     * Checks if any animations have looped and if so, fire the appropriate event\n     */\n    Animator.prototype.handleLooping = function () {\n        for (var _i = 0, _a = this.animations.filter(function (a) { return a.playing; }); _i < _a.length; _i++) {\n            var animation = _a[_i];\n            // Emit if the animation looped\n            if (animation.loopValue === 0 && animation.loopCount) {\n                animation.loopCount = 0;\n                // This is a one-shot; if it has ended, delete the instance\n                this.stop(animation.name);\n            }\n            else if (animation.loopValue === 1 && animation.loopCount) {\n                this.eventManager.fire({\n                    type: EventType.Loop,\n                    data: { animation: animation.name, type: LoopType.Loop }\n                });\n                animation.loopCount = 0;\n            }\n            // Wasm indicates a loop at each time the animation\n            // changes direction, so a full loop/lap occurs every\n            // two loop counts\n            else if (animation.loopValue === 2 && animation.loopCount > 1) {\n                this.eventManager.fire({\n                    type: EventType.Loop,\n                    data: { animation: animation.name, type: LoopType.PingPong }\n                });\n                animation.loopCount = 0;\n            }\n        }\n    };\n    /**\n     * Checks if states have changed in state machines and fires a statechange\n     * event\n     */\n    Animator.prototype.handleStateChanges = function () {\n        var statesChanged = [];\n        for (var _i = 0, _a = this.stateMachines.filter(function (sm) { return sm.playing; }); _i < _a.length; _i++) {\n            var stateMachine = _a[_i];\n            statesChanged.push.apply(statesChanged, stateMachine.statesChanged);\n        }\n        if (statesChanged.length > 0) {\n            this.eventManager.fire({\n                type: EventType.StateChange,\n                data: statesChanged,\n            });\n        }\n    };\n    return Animator;\n}());\n// #endregion\n// #region events\n/**\n * Supported event types triggered in Rive\n */\nvar EventType;\n(function (EventType) {\n    EventType[\"Load\"] = \"load\";\n    EventType[\"LoadError\"] = \"loaderror\";\n    EventType[\"Play\"] = \"play\";\n    EventType[\"Pause\"] = \"pause\";\n    EventType[\"Stop\"] = \"stop\";\n    EventType[\"Loop\"] = \"loop\";\n    EventType[\"Draw\"] = \"draw\";\n    EventType[\"StateChange\"] = \"statechange\";\n})(EventType || (EventType = {}));\n/**\n * Looping types: one-shot, loop, and ping-pong\n */\nvar LoopType;\n(function (LoopType) {\n    LoopType[\"OneShot\"] = \"oneshot\";\n    LoopType[\"Loop\"] = \"loop\";\n    LoopType[\"PingPong\"] = \"pingpong\"; // has value 2 in runtime\n})(LoopType || (LoopType = {}));\n// Manages Rive events and listeners\nvar EventManager = /** @class */ (function () {\n    function EventManager(listeners) {\n        if (listeners === void 0) { listeners = []; }\n        this.listeners = listeners;\n    }\n    // Gets listeners of specified type\n    EventManager.prototype.getListeners = function (type) {\n        return this.listeners.filter(function (e) { return e.type === type; });\n    };\n    // Adds a listener\n    EventManager.prototype.add = function (listener) {\n        if (!this.listeners.includes(listener)) {\n            this.listeners.push(listener);\n        }\n    };\n    /**\n     * Removes a listener\n     * @param listener the listener with the callback to be removed\n     */\n    EventManager.prototype.remove = function (listener) {\n        // We can't simply look for the listener as it'll be a different instance to\n        // one originally subscribed. Find all the listeners of the right type and\n        // then check their callbacks which should match.\n        for (var i = 0; i < this.listeners.length; i++) {\n            var currentListener = this.listeners[i];\n            if (currentListener.type === listener.type) {\n                if (currentListener.callback === listener.callback) {\n                    this.listeners.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * Clears all listeners of specified type, or every listener if no type is\n     * specified\n     * @param type the type of listeners to clear, or all listeners if not\n     * specified\n     */\n    EventManager.prototype.removeAll = function (type) {\n        var _this = this;\n        if (!type) {\n            this.listeners.splice(0, this.listeners.length);\n        }\n        else {\n            this.listeners\n                .filter(function (l) { return l.type === type; })\n                .forEach(function (l) { return _this.remove(l); });\n        }\n    };\n    // Fires an event\n    EventManager.prototype.fire = function (event) {\n        var eventListeners = this.getListeners(event.type);\n        eventListeners.forEach(function (listener) { return listener.callback(event); });\n    };\n    return EventManager;\n}());\n// Manages a queue of tasks\nvar TaskQueueManager = /** @class */ (function () {\n    function TaskQueueManager(eventManager) {\n        this.eventManager = eventManager;\n        this.queue = [];\n    }\n    // Adds a task top the queue\n    TaskQueueManager.prototype.add = function (task) {\n        this.queue.push(task);\n    };\n    // Processes all tasks in the queue\n    TaskQueueManager.prototype.process = function () {\n        while (this.queue.length > 0) {\n            var task = this.queue.shift();\n            task === null || task === void 0 ? void 0 : task.action();\n            if (task === null || task === void 0 ? void 0 : task.event) {\n                this.eventManager.fire(task.event);\n            }\n        }\n    };\n    return TaskQueueManager;\n}());\nvar Rive = /** @class */ (function () {\n    function Rive(params) {\n        var _a;\n        // Flag to indicate if the layout has changed; used by the renderer to know\n        // when to align\n        this._updateLayout = true;\n        /**\n         * Flag to active/deactivate renderer\n         */\n        this.isRendererActive = true;\n        // Tracks if a Rive file is loaded\n        this.loaded = false;\n        /**\n         * Tracks if a Rive file is loaded; we need this in addition to loaded as some\n         * commands (e.g. contents) can be called as soon as the file is loaded.\n         * However, playback commands need to be queued and run in order once initial\n         * animations and autoplay has been sorted out. This applies to play, pause,\n         * and start.\n         */\n        this.readyForPlaying = false;\n        // Runtime artboard\n        this.artboard = null;\n        /**\n         * Used be draw to track when a second of active rendering time has passed. Used for debugging purposes\n         */\n        this.renderSecondTimer = 0;\n        this.canvas = params.canvas;\n        this.src = params.src;\n        this.buffer = params.buffer;\n        this.layout = (_a = params.layout) !== null && _a !== void 0 ? _a : new Layout();\n        this._updateLayout = true;\n        // Fetch the 2d context from the canvas\n        this.ctx = this.canvas.getContext('2d');\n        // New event management system\n        this.eventManager = new EventManager();\n        if (params.onload)\n            this.on(EventType.Load, params.onload);\n        if (params.onloaderror)\n            this.on(EventType.LoadError, params.onloaderror);\n        if (params.onplay)\n            this.on(EventType.Play, params.onplay);\n        if (params.onpause)\n            this.on(EventType.Pause, params.onpause);\n        if (params.onstop)\n            this.on(EventType.Stop, params.onstop);\n        if (params.onloop)\n            this.on(EventType.Loop, params.onloop);\n        if (params.onstatechange)\n            this.on(EventType.StateChange, params.onstatechange);\n        // Hook up the task queue\n        this.taskQueue = new TaskQueueManager(this.eventManager);\n        this.init({\n            src: this.src,\n            buffer: this.buffer,\n            autoplay: params.autoplay,\n            animations: params.animations,\n            stateMachines: params.stateMachines,\n            artboard: params.artboard\n        });\n    }\n    // Alternative constructor to build a Rive instance from an interface/object\n    Rive.new = function (params) {\n        console.warn('This function is deprecated: please use `new Rive({})` instead');\n        return new Rive(params);\n    };\n    // Initializes the Rive object either from constructor or load()\n    Rive.prototype.init = function (_a) {\n        var _this = this;\n        var src = _a.src, buffer = _a.buffer, animations = _a.animations, stateMachines = _a.stateMachines, artboard = _a.artboard, _b = _a.autoplay, autoplay = _b === void 0 ? false : _b;\n        this.src = src;\n        this.buffer = buffer;\n        // If no source file url specified, it's a bust\n        if (!this.src && !this.buffer) {\n            throw new Error(Rive.missingErrorMessage);\n        }\n        // List of animations that should be initialized.\n        var startingAnimationNames = mapToStringArray(animations);\n        // List of state machines that should be initialized\n        var startingStateMachineNames = mapToStringArray(stateMachines);\n        // Ensure loaded is marked as false if loading new file\n        this.loaded = false;\n        this.readyForPlaying = false;\n        // Ensure the runtime is loaded\n        RuntimeLoader.awaitInstance().then(function (runtime) {\n            _this.runtime = runtime;\n            // Load Rive data from a source uri or a data buffer\n            _this.initData(artboard, startingAnimationNames, startingStateMachineNames, autoplay).catch(function (e) {\n                console.error(e);\n            });\n        }).catch(function (e) {\n            console.error(e);\n        });\n    };\n    // Initializes runtime with Rive data and preps for playing\n    Rive.prototype.initData = function (artboardName, animationNames, stateMachineNames, autoplay) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var _b, _c, msg;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        if (!this.src) return [3 /*break*/, 2];\n                        _b = this;\n                        return [4 /*yield*/, loadRiveFile(this.src)];\n                    case 1:\n                        _b.buffer = _d.sent();\n                        _d.label = 2;\n                    case 2:\n                        // Load the Rive file\n                        _c = this;\n                        return [4 /*yield*/, this.runtime.load(new Uint8Array(this.buffer))];\n                    case 3:\n                        // Load the Rive file\n                        _c.file = _d.sent();\n                        if (this.file) {\n                            // Initialize and draw frame\n                            this.initArtboard(artboardName, animationNames, stateMachineNames, autoplay);\n                            // Everything's set up, emit a load event\n                            this.loaded = true;\n                            this.eventManager.fire({\n                                type: EventType.Load,\n                                data: (_a = this.src) !== null && _a !== void 0 ? _a : 'buffer'\n                            });\n                            // Flag ready for playback commands and clear the task queue; this order\n                            // is important or it may infinitely recurse\n                            this.readyForPlaying = true;\n                            this.taskQueue.process();\n                            this.drawFrame();\n                            return [2 /*return*/, Promise.resolve()];\n                        }\n                        else {\n                            msg = 'Problem loading file; may be corrupt!';\n                            console.warn(msg);\n                            this.eventManager.fire({ type: EventType.LoadError, data: msg });\n                            return [2 /*return*/, Promise.reject(msg)];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // Initialize for playback\n    Rive.prototype.initArtboard = function (artboardName, animationNames, stateMachineNames, autoplay) {\n        // Fetch the artboard\n        var rootArtboard = artboardName ?\n            this.file.artboardByName(artboardName) :\n            this.file.defaultArtboard();\n        // Check we have a working artboard\n        if (!rootArtboard) {\n            var msg = 'Invalid artboard name or no default artboard';\n            console.warn(msg);\n            this.eventManager.fire({ type: EventType.LoadError, data: msg });\n            return;\n        }\n        // Instance the artboard\n        this.artboard = rootArtboard.instance();\n        // Check that the artboard has at least 1 animation\n        if (this.artboard.animationCount() < 1) {\n            var msg = 'Artboard has no animations';\n            this.eventManager.fire({ type: EventType.LoadError, data: msg });\n            throw msg;\n        }\n        // Initialize the animator\n        this.animator = new Animator(this.runtime, this.artboard, this.eventManager);\n        // Get the canvas where you want to render the animation and create a renderer\n        this.renderer = new this.runtime.CanvasRenderer(this.ctx);\n        // Initialize the animations; as loaded hasn't happened yet, we need to\n        // suppress firing the play/pause events until the load event has fired. To\n        // do this we tell the animator to suppress firing events, and add event\n        // firing to the task queue.\n        var instanceNames;\n        if (animationNames.length > 0 || stateMachineNames.length > 0) {\n            instanceNames = animationNames.concat(stateMachineNames);\n            this.animator.add(instanceNames, autoplay, false);\n        }\n        else {\n            instanceNames = [this.animator.atLeastOne(autoplay, false)];\n        }\n        // Queue up firing the playback events\n        this.taskQueue.add({\n            action: function () { },\n            event: {\n                type: autoplay ? EventType.Play : EventType.Pause,\n                data: instanceNames,\n            }\n        });\n    };\n    // Draws the current artboard frame\n    Rive.prototype.drawFrame = function () {\n        this.startRendering();\n    };\n    /**\n     * Draw rendering loop; renders animation frames at the correct time interval.\n     * @param time the time at which to render a frame\n     */\n    Rive.prototype.draw = function (time, onSecond) {\n        // Clear the frameRequestId, as we're now rendering a fresh frame\n        this.frameRequestId = null;\n        // On the first pass, make sure lastTime has a valid value\n        if (!this.lastRenderTime) {\n            this.lastRenderTime = time;\n        }\n        // Handle the onSecond callback\n        this.renderSecondTimer += (time - this.lastRenderTime);\n        if (this.renderSecondTimer > 5000) {\n            this.renderSecondTimer = 0;\n            onSecond === null || onSecond === void 0 ? void 0 : onSecond();\n        }\n        // Calculate the elapsed time between frames in seconds\n        var elapsedTime = (time - this.lastRenderTime) / 1000;\n        this.lastRenderTime = time;\n        // Advance non-paused animations by the elapsed number of seconds\n        // Also advance any animations that require scrubbing\n        var activeAnimations = this.animator.animations.filter(function (a) { return a.playing || a.needsScrub; })\n            // The scrubbed animations must be applied first to prevent weird artifacts\n            // if the playing animations conflict with the scrubbed animating attribuates.\n            .sort(function (first, second) { return first.needsScrub ? -1 : 1; });\n        for (var _i = 0, activeAnimations_1 = activeAnimations; _i < activeAnimations_1.length; _i++) {\n            var animation = activeAnimations_1[_i];\n            animation.advance(elapsedTime);\n            if (animation.instance.didLoop) {\n                animation.loopCount += 1;\n            }\n            animation.instance.apply(this.artboard, 1.0);\n        }\n        // Advance non-paused state machines by the elapsed number of seconds\n        var activeStateMachines = this.animator.stateMachines.filter(function (a) { return a.playing; });\n        for (var _a = 0, activeStateMachines_1 = activeStateMachines; _a < activeStateMachines_1.length; _a++) {\n            var stateMachine = activeStateMachines_1[_a];\n            stateMachine.instance.advance(this.artboard, elapsedTime);\n            // stateMachine.instance.apply(this.artboard);\n        }\n        // Once the animations have been applied to the artboard, advance it\n        // by the elapsed time.\n        this.artboard.advance(elapsedTime);\n        // Update the renderer alignment if necessary\n        this.alignRenderer();\n        var bounds = this.artboard.bounds;\n        this.ctx.clearRect(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n        this.artboard.draw(this.renderer);\n        // Check for any animations that looped\n        this.animator.handleLooping();\n        // Check for any state machines that had a state change\n        this.animator.handleStateChanges();\n        // Calling requestAnimationFrame will rerun draw() at the correct rate:\n        // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations\n        if (this.animator.isPlaying) {\n            // Request a new rendering frame\n            this.startRendering();\n        }\n        else if (this.animator.isPaused) {\n            // Reset the end time so on playback it starts at the correct frame\n            this.lastRenderTime = 0;\n        }\n        else if (this.animator.isStopped) {\n            // Reset animation instances, artboard and time\n            // TODO: implement this properly when we have instancing\n            // this.initArtboard();\n            // this.drawFrame();\n            this.lastRenderTime = 0;\n        }\n    };\n    /**\n     * Align the renderer\n     */\n    Rive.prototype.alignRenderer = function () {\n        // Update the renderer alignment if necessary\n        if (this._updateLayout) {\n            // Restore from previous save in case a previous align occurred\n            this.ctx.restore();\n            // Canvas must be wiped to prevent artifacts\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            // Now save so that future changes to align can restore\n            this.ctx.save();\n            // Align things up safe in the knowledge we can restore if changed\n            this.renderer.align(this._layout.runtimeFit(this.runtime), this._layout.runtimeAlignment(this.runtime), {\n                minX: this._layout.minX,\n                minY: this._layout.minY,\n                maxX: this._layout.maxX,\n                maxY: this._layout.maxY\n            }, this.artboard.bounds);\n            this._updateLayout = false;\n        }\n    };\n    /**\n     * Cleans up any Wasm-generated objects that need to be manually destroyed:\n     * artboard instances, animation instances, state machine instances.\n     *\n     * Once this is called, things will need to be reinitialized or bad things\n     * might happen.\n     */\n    Rive.prototype.cleanup = function () {\n        this.artboard.delete();\n        // TODO: delete animation and state machine instances\n    };\n    // Plays specified animations; if none specified, it unpauses everything.\n    Rive.prototype.play = function (animationNames, autoplay) {\n        var _this = this;\n        animationNames = mapToStringArray(animationNames);\n        // If the file's not loaded, queue up the play\n        if (!this.readyForPlaying) {\n            this.taskQueue.add({\n                action: function () { return _this.play(animationNames, autoplay); },\n            });\n            return;\n        }\n        this.animator.play(animationNames);\n        this.startRendering();\n    };\n    // Pauses specified animations; if none specified, pauses all.\n    Rive.prototype.pause = function (animationNames) {\n        var _this = this;\n        animationNames = mapToStringArray(animationNames);\n        // If the file's not loaded, early out, nothing to pause\n        if (!this.readyForPlaying) {\n            this.taskQueue.add({\n                action: function () { return _this.pause(animationNames); },\n            });\n            return;\n        }\n        this.animator.pause(animationNames);\n    };\n    Rive.prototype.scrub = function (animationNames, value) {\n        var _this = this;\n        animationNames = mapToStringArray(animationNames);\n        // If the file's not loaded, early out, nothing to pause\n        if (!this.readyForPlaying) {\n            this.taskQueue.add({\n                action: function () { return _this.scrub(animationNames, value); },\n            });\n            return;\n        }\n        // Scrub the animation time; we draw a single frame here so that if\n        // nothing's currently playing, the scrubbed animation is still rendered/\n        this.animator.scrub(animationNames, value || 0);\n        this.drawFrame();\n    };\n    // Stops specified animations; if none specifies, stops them all.\n    Rive.prototype.stop = function (animationNames) {\n        var _this = this;\n        animationNames = mapToStringArray(animationNames);\n        // If the file's not loaded, early out, nothing to pause\n        if (!this.readyForPlaying) {\n            this.taskQueue.add({\n                action: function () { return _this.stop(animationNames); },\n            });\n            return;\n        }\n        this.animator.stop(animationNames);\n    };\n    /**\n     * Resets the animation\n     * @param artboard the name of the artboard, or default if none given\n     * @param animations the names of animations for playback\n     * @param stateMachines the names of state machines for playback\n     * @param autoplay whether to autoplay when reset, defaults to false\n     *\n     */\n    Rive.prototype.reset = function (params) {\n        var _a;\n        // Get the current artboard, animations, state machines, and playback states\n        var artBoardName = params === null || params === void 0 ? void 0 : params.artboard;\n        var animationNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.animations);\n        var stateMachineNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.stateMachines);\n        var autoplay = (_a = params === null || params === void 0 ? void 0 : params.autoplay) !== null && _a !== void 0 ? _a : false;\n        // Stop everything and clean up\n        this.stop();\n        this.cleanup();\n        // Reinitialize an artboard instance with the state\n        this.initArtboard(artBoardName, animationNames, stateMachineNames, autoplay);\n    };\n    // Loads a new Rive file, keeping listeners in place\n    Rive.prototype.load = function (params) {\n        // Stop all animations\n        this.stop();\n        // Update the layout to account for new renderer\n        this._updateLayout = true;\n        // Reinitialize\n        this.init(params);\n    };\n    Object.defineProperty(Rive.prototype, \"layout\", {\n        /**\n         * Returns the current layout. Note that layout should be treated as\n         * immutable. If you want to change the layout, create a new one use the\n         * layout setter\n         */\n        get: function () {\n            return this._layout;\n        },\n        // Sets a new layout\n        set: function (layout) {\n            this._layout = layout;\n            this._updateLayout = true;\n            // If the maxX or maxY are 0, then set them to the canvas width and height\n            if (!layout.maxX || !layout.maxY) {\n                this.resizeToCanvas();\n            }\n            if (this.loaded && !this.animator.isPlaying) {\n                this.drawFrame();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Sets the layout bounds to the current canvas size; this is typically called\n     * when the canvas is resized\n     */\n    Rive.prototype.resizeToCanvas = function () {\n        this._layout = this.layout.copyWith({\n            minX: 0,\n            minY: 0,\n            maxX: this.canvas.width,\n            maxY: this.canvas.height\n        });\n        this._updateLayout = true;\n    };\n    Object.defineProperty(Rive.prototype, \"source\", {\n        // Returns the animation source, which may be undefined\n        get: function () {\n            return this.src;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"activeArtboard\", {\n        /**\n         * Returns the name of the active artboard\n         */\n        get: function () {\n            return this.artboard.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"animationNames\", {\n        // Returns a list of animation names on the chosen artboard\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            var animationNames = [];\n            for (var i = 0; i < this.artboard.animationCount(); i++) {\n                animationNames.push(this.artboard.animationByIndex(i).name);\n            }\n            return animationNames;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"stateMachineNames\", {\n        /**\n         * Returns a list of state machine names from the current artboard\n         */\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            var stateMachineNames = [];\n            for (var i = 0; i < this.artboard.stateMachineCount(); i++) {\n                stateMachineNames.push(this.artboard.stateMachineByIndex(i).name);\n            }\n            return stateMachineNames;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the inputs for the specified instanced state machine, or an empty\n     * list if the name is invalid or the state machine is not instanced\n     * @param name the state machine name\n     * @returns the inputs for the named state machine\n     */\n    Rive.prototype.stateMachineInputs = function (name) {\n        // If the file's not loaded, early out, nothing to pause\n        if (!this.loaded) {\n            return;\n        }\n        var stateMachine = this.animator.stateMachines.find(function (m) { return m.name === name; });\n        return stateMachine === null || stateMachine === void 0 ? void 0 : stateMachine.inputs;\n    };\n    Object.defineProperty(Rive.prototype, \"playingStateMachineNames\", {\n        // Returns a list of playing machine names\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            return this.animator.stateMachines\n                .filter(function (m) { return m.playing; })\n                .map(function (m) { return m.name; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"playingAnimationNames\", {\n        // Returns a list of playing animation names\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            return this.animator.animations\n                .filter(function (a) { return a.playing; })\n                .map(function (a) { return a.name; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"pausedAnimationNames\", {\n        // Returns a list of paused animation names\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            return this.animator.animations\n                .filter(function (a) { return !a.playing; })\n                .map(function (a) { return a.name; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"pausedStateMachineNames\", {\n        /**\n         *  Returns a list of paused machine names\n         * @returns a list of state machine names that are paused\n         */\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            return this.animator.stateMachines\n                .filter(function (m) { return !m.playing; })\n                .map(function (m) { return m.name; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"isPlaying\", {\n        /**\n         * @returns true if any animation is playing\n         */\n        get: function () {\n            return this.animator.isPlaying;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"isPaused\", {\n        /**\n         * @returns true if all instanced animations are paused\n         */\n        get: function () {\n            return this.animator.isPaused;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"isStopped\", {\n        /**\n         * @returns true if no animations are playing or paused\n         */\n        get: function () {\n            return this.animator.isStopped;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"bounds\", {\n        /**\n         * @returns the bounds of the current artboard, or undefined if the artboard\n         * isn't loaded yet.\n         */\n        get: function () {\n            return this.artboard ? this.artboard.bounds : undefined;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Subscribe to Rive-generated events\n     * @param type the type of event to subscribe to\n     * @param callback callback to fire when the event occurs\n     */\n    Rive.prototype.on = function (type, callback) {\n        this.eventManager.add({\n            type: type,\n            callback: callback,\n        });\n    };\n    /**\n     * Unsubscribes from a Rive-generated event\n     * @param callback the callback to unsubscribe from\n     */\n    Rive.prototype.unsubscribe = function (type, callback) {\n        this.eventManager.remove({\n            type: type,\n            callback: callback,\n        });\n    };\n    /**\n     * Unsubscribes all listeners from an event type, or everything if no type is\n     * given\n     * @param type the type of event to unsubscribe from, or all types if\n     * undefined\n     */\n    Rive.prototype.unsubscribeAll = function (type) {\n        this.eventManager.removeAll(type);\n    };\n    /**\n     * Stops the rendering loop; this is different from pausing in that it doesn't\n     * change the state of any animation. It stops rendering from occurring. This\n     * is designed for situations such as when Rive isn't visible.\n     *\n     * The only way to start rendering again is to call `startRendering`.\n     * Animations that are marked as playing will start from the position that\n     * they would have been at if rendering had not been stopped.\n     */\n    Rive.prototype.stopRendering = function () {\n        if (this.loaded && this.frameRequestId) {\n            cancelAnimationFrame(this.frameRequestId);\n            this.frameRequestId = null;\n        }\n    };\n    /**\n     * Starts the rendering loop if it has been previously stopped. If the\n     * renderer is already active, then this will have zero effect.\n     */\n    Rive.prototype.startRendering = function () {\n        if (this.loaded && !this.frameRequestId) {\n            this.frameRequestId = requestAnimationFrame(this.draw.bind(this));\n        }\n    };\n    Object.defineProperty(Rive.prototype, \"contents\", {\n        /**\n         * Returns the contents of a Rive file: the artboards, animations, and state machines\n         */\n        get: function () {\n            if (!this.loaded) {\n                return undefined;\n            }\n            var riveContents = {\n                artboards: [],\n            };\n            for (var i = 0; i < this.file.artboardCount(); i++) {\n                var artboard = this.file.artboardByIndex(i);\n                var artboardContents = {\n                    name: artboard.name,\n                    animations: [],\n                    stateMachines: [],\n                };\n                for (var j = 0; j < artboard.animationCount(); j++) {\n                    var animation = artboard.animationByIndex(j);\n                    artboardContents.animations.push(animation.name);\n                }\n                for (var k = 0; k < artboard.stateMachineCount(); k++) {\n                    var stateMachine = artboard.stateMachineByIndex(k);\n                    var name_1 = stateMachine.name;\n                    var instance = new this.runtime.StateMachineInstance(stateMachine);\n                    var inputContents = [];\n                    for (var l = 0; l < instance.inputCount(); l++) {\n                        var input = instance.input(l);\n                        inputContents.push({ name: input.name, type: input.type });\n                    }\n                    artboardContents.stateMachines.push({ name: name_1, inputs: inputContents });\n                }\n                riveContents.artboards.push(artboardContents);\n            }\n            return riveContents;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // Error message for missing source or buffer\n    Rive.missingErrorMessage = 'Rive source file or data buffer required';\n    return Rive;\n}());\n\n// Loads Rive data from a URI via fetch.\nvar loadRiveFile = function (src) { return __awaiter(void 0, void 0, void 0, function () {\n    var req, res, buffer;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                req = new Request(src);\n                return [4 /*yield*/, fetch(req)];\n            case 1:\n                res = _a.sent();\n                return [4 /*yield*/, res.arrayBuffer()];\n            case 2:\n                buffer = _a.sent();\n                return [2 /*return*/, buffer];\n        }\n    });\n}); };\n// #endregion\n// #region utility functions\n/*\n * Utility function to ensure an object is a string array\n */\nvar mapToStringArray = function (obj) {\n    if (typeof obj === 'string') {\n        return [obj];\n    }\n    else if (obj instanceof Array) {\n        return obj;\n    }\n    // If obj is undefined, return empty array\n    return [];\n};\n// #endregion\n// #region testing utilities\n// Exports to only be used for tests\nvar Testing = {\n    EventManager: EventManager,\n    TaskQueueManager: TaskQueueManager,\n};\n// #endregion\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=rive.dev.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcml2ZS1qcy9kaXN0L3JpdmUuZGV2LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLcUI7QUFDM0IsQ0FBQztBQUNELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsOEJBQW1COztBQUV6RTtBQUNBO0FBQ0E7QUFDQSw4QkFBbUI7QUFDbkIscUJBQXFCLDhCQUFtQjtBQUN4QztBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUFtQjtBQUN2QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQW1CO0FBQzNDLDRCQUE0Qiw4QkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxrR0FBa0cseURBQXlELDZJQUE2SSxRQUFRO0FBQ2hUO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DLDBHQUEwRztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQSxnREFBZ0Q7QUFDaEQsR0FBRztBQUNILDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFLEdBQUc7QUFDSCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0EsOERBQThEO0FBQzlELGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUNBQXFDO0FBQzNFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0Q0FBNEM7QUFDbEYsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9DQUFvQztBQUMxRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNU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QTBELHFDQUFxQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBLFVBQVU7QUFDVjtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL0B3ZWFyZWF0aGxvbi9mcm9udGVuZC13ZWJwYWNrLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL3JpdmUtanMvZGlzdC9yaXZlLmRldi5qcz82Y2IxIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJpdmVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicml2ZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoW1xuLyogMCAqLyxcbi8qIDEgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19maWxlbmFtZSA9IFwiL2luZGV4LmpzXCI7XG52YXIgX19kaXJuYW1lID0gXCIvXCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImRlZmF1bHRcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG5cbnZhciBSaXZlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgX3NjcmlwdERpciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIDogdW5kZWZpbmVkO1xuICBpZiAodHJ1ZSkgX3NjcmlwdERpciA9IF9zY3JpcHREaXIgfHwgX19maWxlbmFtZTtcbiAgcmV0dXJuIChcbmZ1bmN0aW9uKFJpdmUpIHtcbiAgUml2ZSA9IFJpdmUgfHwge307XG5cbm51bGw7XG5cbnZhciBNb2R1bGUgPSB0eXBlb2YgUml2ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IFJpdmUgOiB7fTtcblxudmFyIHJlYWR5UHJvbWlzZVJlc29sdmUsIHJlYWR5UHJvbWlzZVJlamVjdDtcblxuTW9kdWxlW1wicmVhZHlcIl0gPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiByZWFkeVByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiByZWFkeVByb21pc2VSZWplY3QgPSByZWplY3Q7XG59KTtcblxudmFyIG1vZHVsZU92ZXJyaWRlcyA9IHt9O1xuXG52YXIga2V5O1xuXG5mb3IgKGtleSBpbiBNb2R1bGUpIHtcbiBpZiAoTW9kdWxlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgbW9kdWxlT3ZlcnJpZGVzW2tleV0gPSBNb2R1bGVba2V5XTtcbiB9XG59XG5cbnZhciBhcmd1bWVudHNfID0gW107XG5cbnZhciB0aGlzUHJvZ3JhbSA9IFwiLi90aGlzLnByb2dyYW1cIjtcblxudmFyIHF1aXRfID0gZnVuY3Rpb24oc3RhdHVzLCB0b1Rocm93KSB7XG4gdGhyb3cgdG9UaHJvdztcbn07XG5cbnZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSBmYWxzZTtcblxudmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IGZhbHNlO1xuXG52YXIgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IGZhbHNlO1xuXG52YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSBmYWxzZTtcblxuRU5WSVJPTk1FTlRfSVNfV0VCID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIjtcblxuRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09IFwiZnVuY3Rpb25cIjtcblxuRU5WSVJPTk1FTlRfSVNfTk9ERSA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPT09IFwic3RyaW5nXCI7XG5cbkVOVklST05NRU5UX0lTX1NIRUxMID0gIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSO1xuXG52YXIgc2NyaXB0RGlyZWN0b3J5ID0gXCJcIjtcblxuZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKSB7XG4gaWYgKE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0pIHtcbiAgcmV0dXJuIE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0ocGF0aCwgc2NyaXB0RGlyZWN0b3J5KTtcbiB9XG4gcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG59XG5cbnZhciByZWFkXywgcmVhZEFzeW5jLCByZWFkQmluYXJ5LCBzZXRXaW5kb3dUaXRsZTtcblxudmFyIG5vZGVGUztcblxudmFyIG5vZGVQYXRoO1xuXG5pZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5kaXJuYW1lKHNjcmlwdERpcmVjdG9yeSkgKyBcIi9cIjtcbiB9IGVsc2Uge1xuICBzY3JpcHREaXJlY3RvcnkgPSBfX2Rpcm5hbWUgKyBcIi9cIjtcbiB9XG4gcmVhZF8gPSBmdW5jdGlvbiBzaGVsbF9yZWFkKGZpbGVuYW1lLCBiaW5hcnkpIHtcbiAgdmFyIHJldCA9IHRyeVBhcnNlQXNEYXRhVVJJKGZpbGVuYW1lKTtcbiAgaWYgKHJldCkge1xuICAgcmV0dXJuIGJpbmFyeSA/IHJldCA6IHJldC50b1N0cmluZygpO1xuICB9XG4gIGlmICghbm9kZUZTKSBub2RlRlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuICBpZiAoIW5vZGVQYXRoKSBub2RlUGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIGZpbGVuYW1lID0gbm9kZVBhdGhbXCJub3JtYWxpemVcIl0oZmlsZW5hbWUpO1xuICByZXR1cm4gbm9kZUZTW1wicmVhZEZpbGVTeW5jXCJdKGZpbGVuYW1lLCBiaW5hcnkgPyBudWxsIDogXCJ1dGY4XCIpO1xuIH07XG4gcmVhZEJpbmFyeSA9IGZ1bmN0aW9uIHJlYWRCaW5hcnkoZmlsZW5hbWUpIHtcbiAgdmFyIHJldCA9IHJlYWRfKGZpbGVuYW1lLCB0cnVlKTtcbiAgaWYgKCFyZXQuYnVmZmVyKSB7XG4gICByZXQgPSBuZXcgVWludDhBcnJheShyZXQpO1xuICB9XG4gIGFzc2VydChyZXQuYnVmZmVyKTtcbiAgcmV0dXJuIHJldDtcbiB9O1xuIGlmIChwcm9jZXNzW1wiYXJndlwiXS5sZW5ndGggPiAxKSB7XG4gIHRoaXNQcm9ncmFtID0gcHJvY2Vzc1tcImFyZ3ZcIl1bMV0ucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG4gfVxuIGFyZ3VtZW50c18gPSBwcm9jZXNzW1wiYXJndlwiXS5zbGljZSgyKTtcbiBwcm9jZXNzW1wib25cIl0oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBmdW5jdGlvbihleCkge1xuICBpZiAoIShleCBpbnN0YW5jZW9mIEV4aXRTdGF0dXMpKSB7XG4gICB0aHJvdyBleDtcbiAgfVxuIH0pO1xuIHByb2Nlc3NbXCJvblwiXShcInVuaGFuZGxlZFJlamVjdGlvblwiLCBhYm9ydCk7XG4gcXVpdF8gPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgcHJvY2Vzc1tcImV4aXRcIl0oc3RhdHVzKTtcbiB9O1xuIE1vZHVsZVtcImluc3BlY3RcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIjtcbiB9O1xufSBlbHNlIGlmIChFTlZJUk9OTUVOVF9JU19TSEVMTCkge1xuIGlmICh0eXBlb2YgcmVhZCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIHJlYWRfID0gZnVuY3Rpb24gc2hlbGxfcmVhZChmKSB7XG4gICB2YXIgZGF0YSA9IHRyeVBhcnNlQXNEYXRhVVJJKGYpO1xuICAgaWYgKGRhdGEpIHtcbiAgICByZXR1cm4gaW50QXJyYXlUb1N0cmluZyhkYXRhKTtcbiAgIH1cbiAgIHJldHVybiByZWFkKGYpO1xuICB9O1xuIH1cbiByZWFkQmluYXJ5ID0gZnVuY3Rpb24gcmVhZEJpbmFyeShmKSB7XG4gIHZhciBkYXRhO1xuICBkYXRhID0gdHJ5UGFyc2VBc0RhdGFVUkkoZik7XG4gIGlmIChkYXRhKSB7XG4gICByZXR1cm4gZGF0YTtcbiAgfVxuICBpZiAodHlwZW9mIHJlYWRidWZmZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZikpO1xuICB9XG4gIGRhdGEgPSByZWFkKGYsIFwiYmluYXJ5XCIpO1xuICBhc3NlcnQodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpO1xuICByZXR1cm4gZGF0YTtcbiB9O1xuIGlmICh0eXBlb2Ygc2NyaXB0QXJncyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGFyZ3VtZW50c18gPSBzY3JpcHRBcmdzO1xuIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50cyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGFyZ3VtZW50c18gPSBhcmd1bWVudHM7XG4gfVxuIGlmICh0eXBlb2YgcXVpdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIHF1aXRfID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICBxdWl0KHN0YXR1cyk7XG4gIH07XG4gfVxuIGlmICh0eXBlb2YgcHJpbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlID0ge307XG4gIGNvbnNvbGUubG9nID0gcHJpbnQ7XG4gIGNvbnNvbGUud2FybiA9IGNvbnNvbGUuZXJyb3IgPSB0eXBlb2YgcHJpbnRFcnIgIT09IFwidW5kZWZpbmVkXCIgPyBwcmludEVyciA6IHByaW50O1xuIH1cbn0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikge1xuIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xuIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gfVxuIGlmIChfc2NyaXB0RGlyKSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IF9zY3JpcHREaXI7XG4gfVxuIGlmIChzY3JpcHREaXJlY3RvcnkuaW5kZXhPZihcImJsb2I6XCIpICE9PSAwKSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCwgc2NyaXB0RGlyZWN0b3J5Lmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuIH0gZWxzZSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IFwiXCI7XG4gfVxuIHtcbiAgcmVhZF8gPSBmdW5jdGlvbih1cmwpIHtcbiAgIHRyeSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdmFyIGRhdGEgPSB0cnlQYXJzZUFzRGF0YVVSSSh1cmwpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgIHJldHVybiBpbnRBcnJheVRvU3RyaW5nKGRhdGEpO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gICB9XG4gIH07XG4gIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgIHJlYWRCaW5hcnkgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB0cnkge1xuICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgIHhoci5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpO1xuICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgIHZhciBkYXRhID0gdHJ5UGFyc2VBc0RhdGFVUkkodXJsKTtcbiAgICAgaWYgKGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgICB9XG4gICAgIHRocm93IGVycjtcbiAgICB9XG4gICB9O1xuICB9XG4gIHJlYWRBc3luYyA9IGZ1bmN0aW9uKHVybCwgb25sb2FkLCBvbmVycm9yKSB7XG4gICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICB4aHIub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgfHwgeGhyLnN0YXR1cyA9PSAwICYmIHhoci5yZXNwb25zZSkge1xuICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKTtcbiAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRyeVBhcnNlQXNEYXRhVVJJKHVybCk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgb25sb2FkKGRhdGEuYnVmZmVyKTtcbiAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvbmVycm9yKCk7XG4gICB9O1xuICAgeGhyLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgeGhyLnNlbmQobnVsbCk7XG4gIH07XG4gfVxuIHNldFdpbmRvd1RpdGxlID0gZnVuY3Rpb24odGl0bGUpIHtcbiAgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcbiB9O1xufSBlbHNlIHt9XG5cbnZhciBvdXQgPSBNb2R1bGVbXCJwcmludFwiXSB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuXG52YXIgZXJyID0gTW9kdWxlW1wicHJpbnRFcnJcIl0gfHwgY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG5cbmZvciAoa2V5IGluIG1vZHVsZU92ZXJyaWRlcykge1xuIGlmIChtb2R1bGVPdmVycmlkZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBNb2R1bGVba2V5XSA9IG1vZHVsZU92ZXJyaWRlc1trZXldO1xuIH1cbn1cblxubW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcblxuaWYgKE1vZHVsZVtcImFyZ3VtZW50c1wiXSkgYXJndW1lbnRzXyA9IE1vZHVsZVtcImFyZ3VtZW50c1wiXTtcblxuaWYgKE1vZHVsZVtcInRoaXNQcm9ncmFtXCJdKSB0aGlzUHJvZ3JhbSA9IE1vZHVsZVtcInRoaXNQcm9ncmFtXCJdO1xuXG5pZiAoTW9kdWxlW1wicXVpdFwiXSkgcXVpdF8gPSBNb2R1bGVbXCJxdWl0XCJdO1xuXG52YXIgdGVtcFJldDAgPSAwO1xuXG52YXIgc2V0VGVtcFJldDAgPSBmdW5jdGlvbih2YWx1ZSkge1xuIHRlbXBSZXQwID0gdmFsdWU7XG59O1xuXG52YXIgd2FzbUJpbmFyeTtcblxuaWYgKE1vZHVsZVtcIndhc21CaW5hcnlcIl0pIHdhc21CaW5hcnkgPSBNb2R1bGVbXCJ3YXNtQmluYXJ5XCJdO1xuXG52YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVtcIm5vRXhpdFJ1bnRpbWVcIl0gfHwgdHJ1ZTtcblxuaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIikge1xuIGFib3J0KFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTtcbn1cblxudmFyIHdhc21NZW1vcnk7XG5cbnZhciBBQk9SVCA9IGZhbHNlO1xuXG52YXIgRVhJVFNUQVRVUztcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgdGV4dCkge1xuIGlmICghY29uZGl0aW9uKSB7XG4gIGFib3J0KFwiQXNzZXJ0aW9uIGZhaWxlZDogXCIgKyB0ZXh0KTtcbiB9XG59XG5cbnZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBUZXh0RGVjb2RlcihcInV0ZjhcIikgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXAsIGlkeCwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiB2YXIgZW5kSWR4ID0gaWR4ICsgbWF4Qnl0ZXNUb1JlYWQ7XG4gdmFyIGVuZFB0ciA9IGlkeDtcbiB3aGlsZSAoaGVhcFtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwLnN1YmFycmF5ICYmIFVURjhEZWNvZGVyKSB7XG4gIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcC5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuIH0gZWxzZSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICB3aGlsZSAoaWR4IDwgZW5kUHRyKSB7XG4gICB2YXIgdTAgPSBoZWFwW2lkeCsrXTtcbiAgIGlmICghKHUwICYgMTI4KSkge1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcbiAgICBjb250aW51ZTtcbiAgIH1cbiAgIHZhciB1MSA9IGhlYXBbaWR4KytdICYgNjM7XG4gICBpZiAoKHUwICYgMjI0KSA9PSAxOTIpIHtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodTAgJiAzMSkgPDwgNiB8IHUxKTtcbiAgICBjb250aW51ZTtcbiAgIH1cbiAgIHZhciB1MiA9IGhlYXBbaWR4KytdICYgNjM7XG4gICBpZiAoKHUwICYgMjQwKSA9PSAyMjQpIHtcbiAgICB1MCA9ICh1MCAmIDE1KSA8PCAxMiB8IHUxIDw8IDYgfCB1MjtcbiAgIH0gZWxzZSB7XG4gICAgdTAgPSAodTAgJiA3KSA8PCAxOCB8IHUxIDw8IDEyIHwgdTIgPDwgNiB8IGhlYXBbaWR4KytdICYgNjM7XG4gICB9XG4gICBpZiAodTAgPCA2NTUzNikge1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcbiAgIH0gZWxzZSB7XG4gICAgdmFyIGNoID0gdTAgLSA2NTUzNjtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IGNoID4+IDEwLCA1NjMyMCB8IGNoICYgMTAyMyk7XG4gICB9XG4gIH1cbiB9XG4gcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiByZXR1cm4gcHRyID8gVVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LCBwdHIsIG1heEJ5dGVzVG9SZWFkKSA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgaGVhcCwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHtcbiBpZiAoIShtYXhCeXRlc1RvV3JpdGUgPiAwKSkgcmV0dXJuIDA7XG4gdmFyIHN0YXJ0SWR4ID0gb3V0SWR4O1xuIHZhciBlbmRJZHggPSBvdXRJZHggKyBtYXhCeXRlc1RvV3JpdGUgLSAxO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIGlmICh1ID49IDU1Mjk2ICYmIHUgPD0gNTczNDMpIHtcbiAgIHZhciB1MSA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XG4gICB1ID0gNjU1MzYgKyAoKHUgJiAxMDIzKSA8PCAxMCkgfCB1MSAmIDEwMjM7XG4gIH1cbiAgaWYgKHUgPD0gMTI3KSB7XG4gICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICBoZWFwW291dElkeCsrXSA9IHU7XG4gIH0gZWxzZSBpZiAodSA8PSAyMDQ3KSB7XG4gICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xuICAgaGVhcFtvdXRJZHgrK10gPSAxOTIgfCB1ID4+IDY7XG4gICBoZWFwW291dElkeCsrXSA9IDEyOCB8IHUgJiA2MztcbiAgfSBlbHNlIGlmICh1IDw9IDY1NTM1KSB7XG4gICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrO1xuICAgaGVhcFtvdXRJZHgrK10gPSAyMjQgfCB1ID4+IDEyO1xuICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCB1ID4+IDYgJiA2MztcbiAgIGhlYXBbb3V0SWR4KytdID0gMTI4IHwgdSAmIDYzO1xuICB9IGVsc2Uge1xuICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhaztcbiAgIGhlYXBbb3V0SWR4KytdID0gMjQwIHwgdSA+PiAxODtcbiAgIGhlYXBbb3V0SWR4KytdID0gMTI4IHwgdSA+PiAxMiAmIDYzO1xuICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCB1ID4+IDYgJiA2MztcbiAgIGhlYXBbb3V0SWR4KytdID0gMTI4IHwgdSAmIDYzO1xuICB9XG4gfVxuIGhlYXBbb3V0SWR4XSA9IDA7XG4gcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xuIHJldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVBVOCwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xufVxuXG5mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKSB7XG4gdmFyIGxlbiA9IDA7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgaWYgKHUgPj0gNTUyOTYgJiYgdSA8PSA1NzM0MykgdSA9IDY1NTM2ICsgKCh1ICYgMTAyMykgPDwgMTApIHwgc3RyLmNoYXJDb2RlQXQoKytpKSAmIDEwMjM7XG4gIGlmICh1IDw9IDEyNykgKytsZW47IGVsc2UgaWYgKHUgPD0gMjA0NykgbGVuICs9IDI7IGVsc2UgaWYgKHUgPD0gNjU1MzUpIGxlbiArPSAzOyBlbHNlIGxlbiArPSA0O1xuIH1cbiByZXR1cm4gbGVuO1xufVxuXG52YXIgVVRGMTZEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IFRleHREZWNvZGVyKFwidXRmLTE2bGVcIikgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIFVURjE2VG9TdHJpbmcocHRyLCBtYXhCeXRlc1RvUmVhZCkge1xuIHZhciBlbmRQdHIgPSBwdHI7XG4gdmFyIGlkeCA9IGVuZFB0ciA+PiAxO1xuIHZhciBtYXhJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZCAvIDI7XG4gd2hpbGUgKCEoaWR4ID49IG1heElkeCkgJiYgSEVBUFUxNltpZHhdKSArK2lkeDtcbiBlbmRQdHIgPSBpZHggPDwgMTtcbiBpZiAoZW5kUHRyIC0gcHRyID4gMzIgJiYgVVRGMTZEZWNvZGVyKSB7XG4gIHJldHVybiBVVEYxNkRlY29kZXIuZGVjb2RlKEhFQVBVOC5zdWJhcnJheShwdHIsIGVuZFB0cikpO1xuIH0gZWxzZSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgIShpID49IG1heEJ5dGVzVG9SZWFkIC8gMik7ICsraSkge1xuICAgdmFyIGNvZGVVbml0ID0gSEVBUDE2W3B0ciArIGkgKiAyID4+IDFdO1xuICAgaWYgKGNvZGVVbml0ID09IDApIGJyZWFrO1xuICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVVuaXQpO1xuICB9XG4gIHJldHVybiBzdHI7XG4gfVxufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjE2KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiBpZiAobWF4Qnl0ZXNUb1dyaXRlID09PSB1bmRlZmluZWQpIHtcbiAgbWF4Qnl0ZXNUb1dyaXRlID0gMjE0NzQ4MzY0NztcbiB9XG4gaWYgKG1heEJ5dGVzVG9Xcml0ZSA8IDIpIHJldHVybiAwO1xuIG1heEJ5dGVzVG9Xcml0ZSAtPSAyO1xuIHZhciBzdGFydFB0ciA9IG91dFB0cjtcbiB2YXIgbnVtQ2hhcnNUb1dyaXRlID0gbWF4Qnl0ZXNUb1dyaXRlIDwgc3RyLmxlbmd0aCAqIDIgPyBtYXhCeXRlc1RvV3JpdGUgLyAyIDogc3RyLmxlbmd0aDtcbiBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoYXJzVG9Xcml0ZTsgKytpKSB7XG4gIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICBIRUFQMTZbb3V0UHRyID4+IDFdID0gY29kZVVuaXQ7XG4gIG91dFB0ciArPSAyO1xuIH1cbiBIRUFQMTZbb3V0UHRyID4+IDFdID0gMDtcbiByZXR1cm4gb3V0UHRyIC0gc3RhcnRQdHI7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGMTYoc3RyKSB7XG4gcmV0dXJuIHN0ci5sZW5ndGggKiAyO1xufVxuXG5mdW5jdGlvbiBVVEYzMlRvU3RyaW5nKHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiB2YXIgaSA9IDA7XG4gdmFyIHN0ciA9IFwiXCI7XG4gd2hpbGUgKCEoaSA+PSBtYXhCeXRlc1RvUmVhZCAvIDQpKSB7XG4gIHZhciB1dGYzMiA9IEhFQVAzMltwdHIgKyBpICogNCA+PiAyXTtcbiAgaWYgKHV0ZjMyID09IDApIGJyZWFrO1xuICArK2k7XG4gIGlmICh1dGYzMiA+PSA2NTUzNikge1xuICAgdmFyIGNoID0gdXRmMzIgLSA2NTUzNjtcbiAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgY2ggPj4gMTAsIDU2MzIwIHwgY2ggJiAxMDIzKTtcbiAgfSBlbHNlIHtcbiAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHV0ZjMyKTtcbiAgfVxuIH1cbiByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjMyKHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiBpZiAobWF4Qnl0ZXNUb1dyaXRlID09PSB1bmRlZmluZWQpIHtcbiAgbWF4Qnl0ZXNUb1dyaXRlID0gMjE0NzQ4MzY0NztcbiB9XG4gaWYgKG1heEJ5dGVzVG9Xcml0ZSA8IDQpIHJldHVybiAwO1xuIHZhciBzdGFydFB0ciA9IG91dFB0cjtcbiB2YXIgZW5kUHRyID0gc3RhcnRQdHIgKyBtYXhCeXRlc1RvV3JpdGUgLSA0O1xuIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICBpZiAoY29kZVVuaXQgPj0gNTUyOTYgJiYgY29kZVVuaXQgPD0gNTczNDMpIHtcbiAgIHZhciB0cmFpbFN1cnJvZ2F0ZSA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XG4gICBjb2RlVW5pdCA9IDY1NTM2ICsgKChjb2RlVW5pdCAmIDEwMjMpIDw8IDEwKSB8IHRyYWlsU3Vycm9nYXRlICYgMTAyMztcbiAgfVxuICBIRUFQMzJbb3V0UHRyID4+IDJdID0gY29kZVVuaXQ7XG4gIG91dFB0ciArPSA0O1xuICBpZiAob3V0UHRyICsgNCA+IGVuZFB0cikgYnJlYWs7XG4gfVxuIEhFQVAzMltvdXRQdHIgPj4gMl0gPSAwO1xuIHJldHVybiBvdXRQdHIgLSBzdGFydFB0cjtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYzMihzdHIpIHtcbiB2YXIgbGVuID0gMDtcbiBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICB2YXIgY29kZVVuaXQgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgaWYgKGNvZGVVbml0ID49IDU1Mjk2ICYmIGNvZGVVbml0IDw9IDU3MzQzKSArK2k7XG4gIGxlbiArPSA0O1xuIH1cbiByZXR1cm4gbGVuO1xufVxuXG5mdW5jdGlvbiBhbGlnblVwKHgsIG11bHRpcGxlKSB7XG4gaWYgKHggJSBtdWx0aXBsZSA+IDApIHtcbiAgeCArPSBtdWx0aXBsZSAtIHggJSBtdWx0aXBsZTtcbiB9XG4gcmV0dXJuIHg7XG59XG5cbnZhciBidWZmZXIsIEhFQVA4LCBIRUFQVTgsIEhFQVAxNiwgSEVBUFUxNiwgSEVBUDMyLCBIRUFQVTMyLCBIRUFQRjMyLCBIRUFQRjY0O1xuXG5mdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyhidWYpIHtcbiBidWZmZXIgPSBidWY7XG4gTW9kdWxlW1wiSEVBUDhcIl0gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYnVmKTtcbiBNb2R1bGVbXCJIRUFQMTZcIl0gPSBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShidWYpO1xuIE1vZHVsZVtcIkhFQVAzMlwiXSA9IEhFQVAzMiA9IG5ldyBJbnQzMkFycmF5KGJ1Zik7XG4gTW9kdWxlW1wiSEVBUFU4XCJdID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiBNb2R1bGVbXCJIRUFQVTE2XCJdID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShidWYpO1xuIE1vZHVsZVtcIkhFQVBVMzJcIl0gPSBIRUFQVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1Zik7XG4gTW9kdWxlW1wiSEVBUEYzMlwiXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1Zik7XG4gTW9kdWxlW1wiSEVBUEY2NFwiXSA9IEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGJ1Zik7XG59XG5cbnZhciBJTklUSUFMX01FTU9SWSA9IE1vZHVsZVtcIklOSVRJQUxfTUVNT1JZXCJdIHx8IDE2Nzc3MjE2O1xuXG52YXIgd2FzbVRhYmxlO1xuXG52YXIgX19BVFBSRVJVTl9fID0gW107XG5cbnZhciBfX0FUSU5JVF9fID0gW107XG5cbnZhciBfX0FUTUFJTl9fID0gW107XG5cbnZhciBfX0FUUE9TVFJVTl9fID0gW107XG5cbnZhciBydW50aW1lSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gcHJlUnVuKCkge1xuIGlmIChNb2R1bGVbXCJwcmVSdW5cIl0pIHtcbiAgaWYgKHR5cGVvZiBNb2R1bGVbXCJwcmVSdW5cIl0gPT0gXCJmdW5jdGlvblwiKSBNb2R1bGVbXCJwcmVSdW5cIl0gPSBbIE1vZHVsZVtcInByZVJ1blwiXSBdO1xuICB3aGlsZSAoTW9kdWxlW1wicHJlUnVuXCJdLmxlbmd0aCkge1xuICAgYWRkT25QcmVSdW4oTW9kdWxlW1wicHJlUnVuXCJdLnNoaWZ0KCkpO1xuICB9XG4gfVxuIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xuIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XG4gY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyk7XG59XG5cbmZ1bmN0aW9uIHByZU1haW4oKSB7XG4gY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVE1BSU5fXyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RSdW4oKSB7XG4gaWYgKE1vZHVsZVtcInBvc3RSdW5cIl0pIHtcbiAgaWYgKHR5cGVvZiBNb2R1bGVbXCJwb3N0UnVuXCJdID09IFwiZnVuY3Rpb25cIikgTW9kdWxlW1wicG9zdFJ1blwiXSA9IFsgTW9kdWxlW1wicG9zdFJ1blwiXSBdO1xuICB3aGlsZSAoTW9kdWxlW1wicG9zdFJ1blwiXS5sZW5ndGgpIHtcbiAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbXCJwb3N0UnVuXCJdLnNoaWZ0KCkpO1xuICB9XG4gfVxuIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pO1xufVxuXG5mdW5jdGlvbiBhZGRPblByZVJ1bihjYikge1xuIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25Jbml0KGNiKSB7XG4gX19BVElOSVRfXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKSB7XG4gX19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG5cbnZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG5cbnZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuXG5mdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKSB7XG4gcnVuRGVwZW5kZW5jaWVzKys7XG4gaWYgKE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0pIHtcbiAgTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXShydW5EZXBlbmRlbmNpZXMpO1xuIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkge1xuIHJ1bkRlcGVuZGVuY2llcy0tO1xuIGlmIChNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKSB7XG4gIE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKTtcbiB9XG4gaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XG4gIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciAhPT0gbnVsbCkge1xuICAgY2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7XG4gICBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG4gIH1cbiAgaWYgKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCkge1xuICAgdmFyIGNhbGxiYWNrID0gZGVwZW5kZW5jaWVzRnVsZmlsbGVkO1xuICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcbiAgIGNhbGxiYWNrKCk7XG4gIH1cbiB9XG59XG5cbk1vZHVsZVtcInByZWxvYWRlZEltYWdlc1wiXSA9IHt9O1xuXG5Nb2R1bGVbXCJwcmVsb2FkZWRBdWRpb3NcIl0gPSB7fTtcblxuZnVuY3Rpb24gYWJvcnQod2hhdCkge1xuIGlmIChNb2R1bGVbXCJvbkFib3J0XCJdKSB7XG4gIE1vZHVsZVtcIm9uQWJvcnRcIl0od2hhdCk7XG4gfVxuIHdoYXQgKz0gXCJcIjtcbiBlcnIod2hhdCk7XG4gQUJPUlQgPSB0cnVlO1xuIEVYSVRTVEFUVVMgPSAxO1xuIHdoYXQgPSBcImFib3J0KFwiICsgd2hhdCArIFwiKS4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby5cIjtcbiB2YXIgZSA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7XG4gcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuIHRocm93IGU7XG59XG5cbmZ1bmN0aW9uIGhhc1ByZWZpeChzdHIsIHByZWZpeCkge1xuIHJldHVybiBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPyBzdHIuc3RhcnRzV2l0aChwcmVmaXgpIDogc3RyLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbn1cblxudmFyIGRhdGFVUklQcmVmaXggPSBcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIjtcblxuZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKSB7XG4gcmV0dXJuIGhhc1ByZWZpeChmaWxlbmFtZSwgZGF0YVVSSVByZWZpeCk7XG59XG5cbnZhciBmaWxlVVJJUHJlZml4ID0gXCJmaWxlOi8vXCI7XG5cbmZ1bmN0aW9uIGlzRmlsZVVSSShmaWxlbmFtZSkge1xuIHJldHVybiBoYXNQcmVmaXgoZmlsZW5hbWUsIGZpbGVVUklQcmVmaXgpO1xufVxuXG52YXIgd2FzbUJpbmFyeUZpbGUgPSBcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxBR0Z6YlFFQUFBQUI1QU5DWUFGL0FYOWdBWDhBWUFKL2Z3Ri9ZQUovZndCZ0EzOS9md0YvWUFOL2YzOEFZQUYvQVgxZ0EzOTlmUUJnQW45OUFHQUhmMzE5ZlgxOWZRQmdBMzkvZlFCZ0JIOS9mMzBBWUFOL2ZYOEFZQUFBWUFSL2YzOS9BR0FGZjM5L2YzOEFZQVIvZjM5L0FYOWdCWDk5ZlgxOUFHQUdmMzkvZjM5L0FHQUFBWDlnQTM5L2ZRRi9ZQVovZjM5OWYzMEFZQVIvZjMxOUFHQUZmMzkvZjM4QmYyQUJmUUY5WUFKL2ZRRi9ZQUovZndGOVlBTjlmWDBCZldBSWYzOS9mMzkvZjM4QVlBcC9mMzkvZjM5L2YzOS9BR0FDZjN3QmYyQUdmM3gvZjM5L0FYOWdBMzkrZndGK1lBRjhBWDFnQVh3QmZHQUNmSDhCZkdBSGYzOS9mMzkvZndCZ0RYOS9mMzkvZjM5L2YzOS9mMzhBWUFaL2YzOS9mWDhBWUFWL2YzOTlmUUJnQkg5L2ZYOEFZQVovZjMxOWYzOEFZQVovZjMxOWZYMEFZQWgvZjMxOWZYMTlmUUJnQlg5OWZYOS9BR0FIZlgxL2YzOS9md0JnQVh3QmYyQUdmMzkvZjM5L0FYOWdCMzkvZjM5L2YzOEJmMkFFZjM5L2ZRRi9ZQU4vZjN3QmYyQURmMzE5QVg5Z0FuNS9BWDlnQW4xL0FYOWdBbngvQVg5Z0FYOEJmbUFEZjM5L0FYMWdDSDkvZjM5OWZYMS9BWDFnQW45OUFYMWdBbjE5QVgxZ0FYOEJmR0FEZjM5L0FYeGdCWDkvZjM5L0FYeGdBbjEvQVh4Z0FueDhBWHhnQTN4OGZ3RjhBdVVCSmdGaEFXRUFIQUZoQVdJQUhRRmhBV01BSlFGaEFXUUFBZ0ZoQVdVQURnRmhBV1lBSEFGaEFXY0FCUUZoQVdnQUR3RmhBV2tBSkFGaEFXb0FCUUZoQVdzQURnRmhBV3dBUFFGaEFXMEFCUUZoQVc0QUJBRmhBVzhBRUFGaEFYQUFCUUZoQVhFQUF3RmhBWElBRWdGaEFYTUFEUUZoQVhRQUFnRmhBWFVBQWdGaEFYWUFGd0ZoQVhjQUFRRmhBWGdBQUFGaEFYa0FBQUZoQVhvQUF3RmhBVUVBRHdGaEFVSUFBd0ZoQVVNQUFRRmhBVVFBQVFGaEFVVUFBQUZoQVVZQUFRRmhBVWNBUGdGaEFVZ0FBUUZoQVVrQUhRRmhBVW9BRWdGaEFVc0FFZ0ZoQVV3QUFBTzZDYmdKQWdBQUFRQUFBZ0FCQWp3QUFBUUJBd0FBQUFNQUFnRUFBUUF6QWdFQUFBMEFCUVVEQVFJREFnQUZBZ0lCQUFBQUNBZ0NEd1FFQ0FFRUFnRUNBUUlCQXdRQ0F3RWhJUXNCQUFFTkF3QUFBUUVGQXdBYUF3QUFBd0FMQVFBM0NBQUFBQUVEQUFBQUFBQUFCZ1lBQVFBQ0FCTURBUUFEQUFRRUVBSUVBd0FEQWdBQ0FBSVRBRFFZR0FJS0FBUUVCQUVDQVFJQUF3RUZCUVVCQUFFQUFRQUFRRUVUQVFFQkZBTUNBUUFEQkFVQUF3TUFBZ0VtQVFNREFBWUFBZ01BQ0JzQURBRURBdzRFQUFBRUF3QUFJd0FFQXdNRExnUUJBZ0lDTHhjRkFRQUJBQUFBQXdFQkFnSUNBZ0FEQUFBQUFBQUJBQUFRQlFFQkVBSUVBUUFwTERrQUFRQUFBUUVCQUFBRkFBQXRBQUFBQVFVREdRSUdGZ01HQVFBQ0F3VUFBZ0FBQWdNREFBSUVDZ0FEQVFRQkFRQUFBQVFEQkFRREJRUUZBQVVEQlFBRkJEQWlCQ0lDQWdNREFRTUNCQVFOQXdVQkFRSUFBQUVDQUFRQkFRRVVHUkFCQUFNQUF3RUJBd0FEQXdNQkJBTUZFd0lFQlFBRER3SUFBd1VEQVFFQkFCRUNBd0VBQUFBQUFBQUNBQUFCQUFNQkFBQUFBd0VEQXdFQkJRQUJEZ0lDQWdFREF3RUZBUVVERUFNQkF3QUZBZ0FCQVJzQ0NRTUVCd2NEQlFNQkF3RUJHQUFEQUFFQUFBQUFBUUFBQUFBREdnRUNBanNEQUFNQUFBQUJBUUFEQXdBQUJBRURBUUVGQVFBQ0FBUUNBRGdBQUFJQUVBZ0NBd01BQ0FBL0JnQUNBd01EQXdNRkNBTUlDQWdJQ0JZREtBQUJBQUk2R3dFQ0FnRURBZ01CQVFBS0NBWUNBQUlFQWdJQ0FBSUFBQUFCQVFJRUJBTUFCQUFBQUFNQkFBQUFBQUFEQXdBQUFBQUFBQUFCQkFBRUFBTUFBUUFBQVFNQUFRRURBQUVBQkFNQkFBQVlCQUlEQXdBREJBWU9BQThqQWpVMkZ3RUJBUUVCQVEwQ0FBSUFFZ01MRGdBREFBQU9BQUFBQXdNR0F3RUVCQU1ERHdBQUFnRUNBZ0VCQUFFQkJRQUNBQUVCQWdJQ0JRQUJBUVVDQXdFQ0FRRUNCUUlCQkFBQ0FRSUNBUUlBQVFFQUFnQUNBZ01ESGdNREJBSUNBUUVBQXdNQkFBRUJBZ0VEQXdBQkF3SUJBQUVBQVFBQkF3QUJBZ0FEQVFRREFBSUNBZ0VBQUFNQkNRY0FCd0VGQVFRQ0FBSUFBUU1GQVFFQkFRQUJBd0VDQmdJR0JBQUFBQUFBQUFJQ0FBUUNBQUFBQkFJQUFBSUFBQVFDQUFJQ0FnTUJBd0FDQVFJQkJnWUJBZ0lDQWdJQ0FBSUNDZ3dDQWdJQ0FnRUVBZ0lDQVFJQUFoUUJBUUFJQXdBQ0FnSUNBUUFBQWdJQUFnRUFBZ0lCRlFzR0JnWVZCZ3NBRlFzQ0FnSUNBZ1lCQWdJQ0FRWUdBZ1FDQUFJQ0FRRU1BZ0FBQUFFQkRBSUFBUVFDQUFBQ0FBUUNBQUlFQWdJQUFBSUFBUW9NQUFBQ0FBQUVBZ0FBQWdBQ0FBSUFBQUlBQUFJQUFBUUNBQUFDQUFBQ0FRSUFBZ0FFQWdBQUFBSUFBQVFDQUFBRUFnQUFCQUlBQUFJQUJBSUNBQUFFQWdBQUFBUUNBQUFDQUFBQ0FBQUVBZ0FBQWdBQUFnQUNBQVFDQUFBQ0FBRUFCQUlBQUFRQ0FnQUFCQUlBQUFBQ0FBQUVBZ0FBQkFJQUFBSUFBQVFDQUFBQ0JnQUFCQUlBQUFRQ0FBQUNBQVFDQUFBRUFnQUFBZ0FBQWdBRUFnQUFGdzBHQkNBQUF4OEVBQUlBQkFBeEZDY3lBUUVLRVJFREF3TUlBd01xQ2dVQkNRY0hCUU1CQVNzV0FBSURCUU1CQVFFRUVnSUtHaE1BQUFBQUFBVUFBQUFBQUFJQUJRQUJBQUFBQUFBQUFnQUFBQUFBQkFBQ0FBSUNBZ0lDQUFFQUFBVUFBQUFBQlFBQUFBVUVBQUFBQUFBRUJ3RndBZkVJOFFnRkJ3RUJnQUtBZ0FJR0NRRi9BVUdneGNFQ0N3Y21DQUZOQWdBQlRnRHlBZ0ZQQVFBQlVBRHpBUUZSQVBnSUFWSUFuUVVCVXdBdUFWUUE3UWdKaWc4QkFFRUJDL0FJUTBMY0NaZ0pod1hkQ1YvTkFiY0VLU21JQXRjQ2h3S1NBWklCa2dIYUJjOEk3Z2dwUXJzSXN3allBcGtCUWp5UUNJa0lZeW5YQWlrcEtTazg4d2ZyQjFzOGxBTExCOGdIeGdkall6OUNQUHNHOVFid0JvZ0gwUVlwS1NrcEtTazhyd0wvQThZR3Z3YTRCdGNHM3dhM0JyVUczZ1lwS1R5bUJxVUdwQWF3QmlrcEtTa3BLVHlaQnBVR2tnYWZCaWtwS1NrcEtTazhpUWFEQnBBRWp3WTg5UVh5QmZBRmdBWXBLU2xDNHdYZ0Jkc0Y2QVdPQnVrRDZRT3JCaWtwS1R6TkJjb0ZzUUdWQXBVQ3ZnTTh3QVc2QlNrcFF0QUp5UW5CQ2RzSktTa3BLVUtsQ2FFSm53bTNDU2twaXdHSEFmb0k5d2puQXBjSmx3YVdCc2dEa3dhakFZNEY3d2lTQVpJQktaUUd4UVBlQW1CZ1lHQ0hBZXNJNmdqcENPd0lLVHpvQ09jSTVBTEJCb2NCNVFqa0NJRUY1Z2dwS1ljQjRnamhDT0FJNHdncEtTa3BLWUFGUXQ0STNRamNDTjhJS1NsQzJ3amFDSklDL3dUWUNOY0kxZ2paQ0xzRFlHQ0ZCb1FHS1R6VUNOTUkwZ2pWQ0NtSEFkQUl6Z2pSQ1B3Q1Fzd0l5d2pLQ00wSXl3WEpDQ245QVNrOHlBakhDTllDUE1VSXhBakRDTVlJS1NrOHdRakFDTDhJd2dncEtTa3BLZFFDOVFTOUNMd0l2Z2pVQmRNRjBnWEtBY29CeWdIS0FmNEMvZ0xRQmM4RlBMa0l1QWkzQ0xvSUtVSzFDTFFJc2dpMkNDa3BLU2s4c0FpdkNLNElzUWdwS1NrcHd3R3NDS3NJcWdqeEJLMElLZElDNGdGMXFBaW5DS1lJcVFpTkI0d0hvd1NMQnlrMHBRaWtDTzhFTktNSW9nZzBkYUFJbndpaENIVTBuUWljQ0pzSW5nZ3BLU2twZFprSW1BaWFDSFYxbGdpVkNKY0lkVFNUQ0pJSWtRaVVDQ2swamdpTkNJd0lqd2dwUW9vSWlBaUhDSXNJbXdlYUJ5a3BLU2swaGdpRkNPNEJRb01JZ2dpQkNJUUlLVUwvQi80SC9RZUFDQ25TQXZzSCtnZjVCL3dIS1NrcEtTa3BLZElDOXdmMkIvZ0g3UUZ0OUFmeUIvRUg5UWRqWS84R0tTbHRiZkFIN3dmUUFtM3VCKzBIN0FkdDZRZm9CK29IYmVZSDVRZmtCK2NIS1cxdDRnZmhCK01IYlRUZkI5NEgyZ1RnQnlrcEtTazAzQWZiQjljRTNRZGpZK1FHS2RVRTFRUXBOTm9IMlFjME5OZ0gxd2ZXQkRUVkI5UUgwd2ZXQnlrMDBRZlFCOUlIZGM4SFB6VE5COHdIMEFRMHlnZkpCOHNDendRcE5NY0h4UWZFQjJOaktUVENCOEVId0Fkalk4TUhLY1VDNXdHOEI3c0h1Z2UrQjc4SEtia0h1QWUzQjhJQ3RRZTJCOFFFd3dTMEIrWUI1d0d4QjdBSHNnZStBcTRIcndmRUJNTUVyUWZtQWJNQ3VnU3FCNmtIcUFmdUJ1MEc3QWFzQjZzSEtUU25CN2NFdGdTa0I2TUhvZ2VoQjdRRW9BZWVCNTBIbkFkQ05Ka0htQWMwbGdlVUJ6U1FCNDhIamdlaUJJb0hpUWVIQjRZSFFwMEVnd2VDQjRFSGdBZHRLVDgwTkRUNUJqU1VCUFFHOHdieUJ2RUc3d2JyQnVvR05Pa0c2QWFaQVRUbUJ1Y0dORFRpQnVNR05PQUc0UWJiQnQwRzNBYi9BOW9Ha2dHU0FZOEUyUWJZQnRVRzFBYldCanpUQnRJR1BEemVBczhHemdiUUJpa3BLU2twS1RUTUJzc0c3d1ROQmpROHlRYklCc2NHeWdZcFBNUUd3d2JDQnNVR0tTazgvQVBBQnRrQ0tTay9OTDRHdlFZMG1RR1pBVFEwM2dJMHZBWTBOSmtCdXdZMHVnYTVCalNaQWU4RHNRYTBCcllHc3dheUJqenVBNjhHcWdLcEFxZ0NQSzRHclFhcEFxa0NxQUtvQWp6dUE2d0dxZ0txQWtMbUE2a0dxZ2FIQWFnR3B3WXBLU2twMUFPakJxRUdtd2FpQnFBR25nYWRCcHdHbWdhZ0FrTGtBOThEM1FQY0E5a0RLVDlDaHdHWUJwY0NrUWJBQTVBR1BJY0JqUWFMQm93R2lnYUhCbUNJQm9ZR3RnT0JCb0lHWUdCZ1lMSUQrd1g4QmYwRi93WCtCVHo2QmRjQ21RSC9CUGNGK1FYNEJXQThsUUtzQS9RRjlnV3JBL01GN3dYdUJhVUQ4UVhrQlR6aUJXUGhCVHpmQldQZUJUUTA1d0YxNXdHNkJEUThRb0FEMlFYOEE5Z0ZQTmNGMWdYVkJkRUZ6Z1gxQk13RlFqekpCY2NGK2dMSUJZQUR4QVhGQmNZRnd3WENCY0VGdndYNEFyNEZ2UVhKQWNrQnlRSEpBZmNDOWdLOEJic0Z1UVc0QldTM0Jkb0paUHdCMlFuWUNkY0oxZ2xrMVFsay9BSFVDZE1KMGdteUJkRUpzZ1g4QWM4Snpnbk5DVFN3QlhtOEFxWUh4Z1NsQjU4SHpBbkxDZHdGM1FXV0JKY0V5Z2xrUGZzQjdRWHNCY2dKeHduR0NjVUpqQUxxQmM0RTV3WHBCY1FKNndYRENlWUZ3Z2xra2dkV2VhOEJrUWV3QkpNSFY4QUpaT01CZWE4QnJ3Uy9DV1NPQmVNQmVhOEJ2Z2xrckFSNXJ3R3FCTDBKWkQzN0Fid0paUHNCemdlN0NaY0hoUWVFQjlBRTd3SzlCNVVIZWJvQ3VnazB1UW04QXA0RWVhOEJ1QW52QXJjQ3pBSzJDV1MxQ2JRSnN3bjRCck1IOXdiMkJySUpzUW42QWQ4QnNBbitCdnNCcndtdUNhMEpyQW1yQ2ZvQjVRYjlCdThDcWdtcENmb0J4Z1Q4Qm5tdkFhZ0orZ0g2QnFjSk5MQUZlYndDcGduOEFmWUJkcW9GZHFBSlB6L3RBdXdDOWdHcUJYYVdDWlVKUHovdEF1d0NkbmFMQ1haMmRvb0pwQVgyQVQ4LzdRTHNBcUFGbkFIMEFlb0MvZ2gybkFHY0Fad0JuQUgwQVp3QjZnTDBBWndCb0FVL1B6OC9QejgvUC8wSW5nWDhDS1FGUHorZUJmc0k2Z0wwQWZrSTZRTHBBdWtDUHo4L1B6OC85Z0drQ1RTakNhSUpxUVdlQ1owSm5BbWJDWm9KbVFsQ1AwS21CWlFKa3dtU0NaRUprQW1QQ1k0SmpRay9qQWxDUW9rSmlBbUhDWVlKaFFtRUNZTUpnZ21CQ1lBSm9RWC9DRUkvUXZZSTlRajBDUE1JOGdqd0NQRUlDcnpIQjdnSkNnQWdBQ0FCUVFKMGFnczBBUUYvSUFCQkFTQUFHeUVBQWtBRFFDQUFFUE1CSWdFTkFVR3N3UUVvQWdBaUFRUkFJQUVSRFFBTUFRc0xFQklBQ3lBQkN3Y0FJQUJCQ0dvTEF3QUJDd29BSUFBb0FnQVE1UUVMQ2dBZ0FDZ0NCQkRsQVFzTkFDQUFLQUlBSUFFb0FnQkhDeEVBSUFBZ0FDZ0NBRUVFYWpZQ0FDQUFDOHdNQVFkL0FrQWdBRVVOQUNBQVFRaHJJZ01nQUVFRWF5Z0NBQ0lCUVhoeElnQnFJUVVDUUNBQlFRRnhEUUFnQVVFRGNVVU5BU0FESUFNb0FnQWlBV3NpQTBIQXdRRW9BZ0JKRFFFZ0FDQUJhaUVBSUFOQnhNRUJLQUlBUndSQUlBRkIvd0ZOQkVBZ0F5Z0NDQ0lDSUFGQkEzWWlCRUVEZEVIWXdRRnFSaG9nQWlBREtBSU1JZ0ZHQkVCQnNNRUJRYkRCQVNnQ0FFRitJQVIzY1RZQ0FBd0RDeUFDSUFFMkFnd2dBU0FDTmdJSURBSUxJQU1vQWhnaEJnSkFJQU1nQXlnQ0RDSUJSd1JBSUFNb0FnZ2lBaUFCTmdJTUlBRWdBallDQ0F3QkN3SkFJQU5CRkdvaUFpZ0NBQ0lFRFFBZ0EwRVFhaUlDS0FJQUlnUU5BRUVBSVFFTUFRc0RRQ0FDSVFjZ0JDSUJRUlJxSWdJb0FnQWlCQTBBSUFGQkVHb2hBaUFCS0FJUUlnUU5BQXNnQjBFQU5nSUFDeUFHUlEwQkFrQWdBeUFES0FJY0lnSkJBblJCNE1NQmFpSUVLQUlBUmdSQUlBUWdBVFlDQUNBQkRRRkJ0TUVCUWJUQkFTZ0NBRUYrSUFKM2NUWUNBQXdEQ3lBR1FSQkJGQ0FHS0FJUUlBTkdHMm9nQVRZQ0FDQUJSUTBDQ3lBQklBWTJBaGdnQXlnQ0VDSUNCRUFnQVNBQ05nSVFJQUlnQVRZQ0dBc2dBeWdDRkNJQ1JRMEJJQUVnQWpZQ0ZDQUNJQUUyQWhnTUFRc2dCU2dDQkNJQlFRTnhRUU5IRFFCQnVNRUJJQUEyQWdBZ0JTQUJRWDV4TmdJRUlBTWdBRUVCY2pZQ0JDQUFJQU5xSUFBMkFnQVBDeUFESUFWUERRQWdCU2dDQkNJQlFRRnhSUTBBQWtBZ0FVRUNjVVVFUUNBRlFjakJBU2dDQUVZRVFFSEl3UUVnQXpZQ0FFRzh3UUZCdk1FQktBSUFJQUJxSWdBMkFnQWdBeUFBUVFGeU5nSUVJQU5CeE1FQktBSUFSdzBEUWJqQkFVRUFOZ0lBUWNUQkFVRUFOZ0lBRHdzZ0JVSEV3UUVvQWdCR0JFQkJ4TUVCSUFNMkFnQkJ1TUVCUWJqQkFTZ0NBQ0FBYWlJQU5nSUFJQU1nQUVFQmNqWUNCQ0FBSUFOcUlBQTJBZ0FQQ3lBQlFYaHhJQUJxSVFBQ1FDQUJRZjhCVFFSQUlBVW9BZ2dpQWlBQlFRTjJJZ1JCQTNSQjJNRUJha1lhSUFJZ0JTZ0NEQ0lCUmdSQVFiREJBVUd3d1FFb0FnQkJmaUFFZDNFMkFnQU1BZ3NnQWlBQk5nSU1JQUVnQWpZQ0NBd0JDeUFGS0FJWUlRWUNRQ0FGSUFVb0Fnd2lBVWNFUUNBRktBSUlJZ0pCd01FQktBSUFTUm9nQWlBQk5nSU1JQUVnQWpZQ0NBd0JDd0pBSUFWQkZHb2lBaWdDQUNJRURRQWdCVUVRYWlJQ0tBSUFJZ1FOQUVFQUlRRU1BUXNEUUNBQ0lRY2dCQ0lCUVJScUlnSW9BZ0FpQkEwQUlBRkJFR29oQWlBQktBSVFJZ1FOQUFzZ0IwRUFOZ0lBQ3lBR1JRMEFBa0FnQlNBRktBSWNJZ0pCQW5SQjRNTUJhaUlFS0FJQVJnUkFJQVFnQVRZQ0FDQUJEUUZCdE1FQlFiVEJBU2dDQUVGK0lBSjNjVFlDQUF3Q0N5QUdRUkJCRkNBR0tBSVFJQVZHRzJvZ0FUWUNBQ0FCUlEwQkN5QUJJQVkyQWhnZ0JTZ0NFQ0lDQkVBZ0FTQUNOZ0lRSUFJZ0FUWUNHQXNnQlNnQ0ZDSUNSUTBBSUFFZ0FqWUNGQ0FDSUFFMkFoZ0xJQU1nQUVFQmNqWUNCQ0FBSUFOcUlBQTJBZ0FnQTBIRXdRRW9BZ0JIRFFGQnVNRUJJQUEyQWdBUEN5QUZJQUZCZm5FMkFnUWdBeUFBUVFGeU5nSUVJQUFnQTJvZ0FEWUNBQXNnQUVIL0FVMEVRQ0FBUVFOMklnRkJBM1JCMk1FQmFpRUFBbjlCc01FQktBSUFJZ0pCQVNBQmRDSUJjVVVFUUVHd3dRRWdBU0FDY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJUUlnQUNBRE5nSUlJQUlnQXpZQ0RDQURJQUEyQWd3Z0F5QUNOZ0lJRHd0Qkh5RUNJQU5DQURjQ0VDQUFRZi8vL3dkTkJFQWdBRUVJZGlJQklBRkJnUDQvYWtFUWRrRUljU0lCZENJQ0lBSkJnT0FmYWtFUWRrRUVjU0lDZENJRUlBUkJnSUFQYWtFUWRrRUNjU0lFZEVFUGRpQUJJQUp5SUFSeWF5SUJRUUYwSUFBZ0FVRVZhblpCQVhGeVFSeHFJUUlMSUFNZ0FqWUNIQ0FDUVFKMFFlRERBV29oQVFKQUFrQUNRRUcwd1FFb0FnQWlCRUVCSUFKMElnZHhSUVJBUWJUQkFTQUVJQWR5TmdJQUlBRWdBellDQUNBRElBRTJBaGdNQVFzZ0FFRUFRUmtnQWtFQmRtc2dBa0VmUmh0MElRSWdBU2dDQUNFQkEwQWdBU0lFS0FJRVFYaHhJQUJHRFFJZ0FrRWRkaUVCSUFKQkFYUWhBaUFFSUFGQkJIRnFJZ2RCRUdvb0FnQWlBUTBBQ3lBSElBTTJBaEFnQXlBRU5nSVlDeUFESUFNMkFnd2dBeUFETmdJSURBRUxJQVFvQWdnaUFDQUROZ0lNSUFRZ0F6WUNDQ0FEUVFBMkFoZ2dBeUFFTmdJTUlBTWdBRFlDQ0F0QjBNRUJRZERCQVNnQ0FFRUJheUlBUVg4Z0FCczJBZ0FMQ3cwQUlBQW9BZ0FnQVVFQ2RHb0xWQUlDZndGOUl3QkJFR3NpQVNRQUFuMGdBQ2dDQUNBQUtBSUVJQUZCREdvUWhnUWlBa1VFUUNBQUVNQUJRd0FBQUFBTUFRc2dBQ0FBS0FJQUlBSnFOZ0lBSUFFcUFnd0xJUU1nQVVFUWFpUUFJQU83Q3djQUlBQkJER29MRUFBZ0FDZ0NCQ0FBS0FJQWEwRUNkUXNwQVFGL0lBSUVRQ0FBSVFNRFFDQURJQUU2QUFBZ0EwRUJhaUVESUFKQkFXc2lBZzBBQ3dzZ0FBc0dBQ0FBRUM0TE5RRUJmeU1BUVJCcklnSWtBQ0FDSUFBb0FnQTJBZ3dnQUNBQktBSUFOZ0lBSUFFZ0FrRU1haWdDQURZQ0FDQUNRUkJxSkFBTENBQWdBQkNDQWFjTEZBRUJmMEVJRUNjaUFTQUFLUUlBTndNQUlBRUxLUUVCZnlNQVFSQnJJZ0VrQUNBQklBQXBBZ0EzQXdnZ0FVRUlhaEEzSVFBZ0FVRVFhaVFBSUFBTERBQWdBQ0FCS1FJQU53SUFDd2tBSUFBUSt3UWdBQXNvQVFGL0lBRWdBVUVCYXlJQ2NVVUVRQ0FBSUFKeER3c2dBQ0FCVHdSL0lBQWdBWEFGSUFBTEN3c0FJQUFRUXhvZ0FCQXVDd2NBSUFCQkJHb0xMQUVCZnlBQUVMMENJQUFvQWdBRVFDQUFFTFVFSUFBUUtCb2dBQ2dDQUNFQklBQVFsUUVhSUFFUUxnc0xCQUFnQUFzU0FDQUFJQUk0QWdRZ0FDQUJPQUlBSUFBTEN3QWdBQ0FCTmdJQUlBQUxBd0FBQ3hvQUlBQkJpT2dBTmdJQUlBQkJHR29RUGlBQUVKUUNHaUFBQ3dzQUlBQkNBRGNDQUNBQUN3VUFFQklBQ3djQUlBQkJFR29MRXdBZ0FDQUJFTUFDSUFCQkJHb2dBaERvQVFzTUFDQUJJQUlvQWdBMkFnQUxQUUVDZnlNQVFSQnJJZ01rQUNBRElBQkJBUkRyQVNFQ0lBQVFLQ0FDS0FJRUlBRVFTQ0FDSUFJb0FnUkJCR28yQWdRZ0FoQnBJQU5CRUdva0FBdFZBUUYvSUFBb0FnUWhBUU5BSUFFZ0FDZ0NDRWNFUUNBQUtBSVFHaUFBSUFBb0FnaEJCR3MyQWdnTUFRc0xJQUFvQWdBRVFDQUFLQUlRR2lBQUtBSUFJUUVnQUJBeEtBSUFJQUFvQWdCckdpQUJFQzRMQzFrQkFuOGpBRUVRYXlJQ0pBQWdBaUFCTmdJTUlBRWdBQkRJQkNJRFRRUkFJQUFRbFFFaUFDQURRUUYyU1FSQUlBSWdBRUVCZERZQ0NDQUNRUWhxSUFKQkRHb1FXQ2dDQUNFREN5QUNRUkJxSkFBZ0F3OExFSEFBQzFBQkFYOGdBQkM5QWlBQUVDZ2dBQ2dDQUNBQUtBSUVJQUZCQkdvaUFoRHFBU0FBSUFJUU5TQUFRUVJxSUFGQkNHb1FOU0FBRUNnZ0FSQXhFRFVnQVNBQktBSUVOZ0lBSUFBZ0FCQXlFTWNDQ3cwQUlBQW9BZ0FnQVVFRGRHb0xFQUFnQUNnQ0JDQUFLQUlBYTBFRGRRc1lBQ0FBTFFBQVFTQnhSUVJBSUFFZ0FpQUFFTndDR2dzTEN3QWdBQ0FCRUdGQkFFY0xVZ0VCZnlNQVFSQnJJZ0lrQUNBQ0lBRTdBUTRnQWlBQUlBSkJEbW9RelFRMkFnZ2dBaENwQVRZQ0FFRUFJUUFnQWtFSWFpQUNFTXdFUlFSQUlBSkJDR29RY3lnQ0JDRUFDeUFDUVJCcUpBQWdBQXRMQVFKL0l3QkJFR3NpQVNRQUlBRWdBQkNJQlNFQUl3QkJFR3NpQWlRQUlBSkJDR29nQUNnQ0JCQkJLQUlBUVFFNkFBQWdBQ2dDQ0VFQk9nQUFJQUpCRUdva0FDQUJRUkJxSkFBTGRRRURmeU1BUVJCcklnSWtBQ0FDSUFBUWlBVWhBQ01BUVJCcklnTWtBQ0FEUVFocUlBQW9BZ1FRUVNnQ0FDMEFBRVVFUUFKL0FrQWdBQ2dDQ0NJQUxRQUFJZ0ZCQVVjRWZ5QUJRUUp4RFFFZ0FFRUNPZ0FBUVFFRlFRQUxEQUVMQUFzaEFRc2dBMEVRYWlRQUlBSkJFR29rQUNBQkN5Z0FJQUJCNE5BQUtRSUFOd0lRSUFCQjJOQUFLUUlBTndJSUlBQkIwTkFBS1FJQU53SUFJQUFMQ1FBZ0FCQTlLQUlBQ3lFQUlBRWdBQ29DTkZ3RVFDQUFJQUU0QWpRZ0FDQUFLQUlBS0FJOEVRRUFDd3NoQUNBQklBQXFBakJjQkVBZ0FDQUJPQUl3SUFBZ0FDZ0NBQ2dDT0JFQkFBc0xKQUVDZnlNQVFSQnJJZ0lrQUNBQUlBRVF4Z0loQXlBQ1FSQnFKQUFnQVNBQUlBTWJDMjBCQVg4akFFR0FBbXNpQlNRQUlBUkJnTUFFY1NBQ0lBTk1ja1VFUUNBRklBRkIvd0Z4SUFJZ0Eyc2lBa0dBQWlBQ1FZQUNTU0lCR3hBekdpQUJSUVJBQTBBZ0FDQUZRWUFDRUU4Z0FrR0FBbXNpQWtIL0FVc05BQXNMSUFBZ0JTQUNFRThMSUFWQmdBSnFKQUFMRGdCQnk3OEJJQUVnQWhBSklBQUxVQUVDZnlNQVFSQnJJZ01rQUFKQUFrQUNRQUpBSUFGQkJHc09BZ0FCQXdzZ0F5QUNFTXdCSUFCQkJHb2dBeERPQWlBREVHOE1BUXNnQUNBQ0VEWTJBaEFMUVFFaEJBc2dBMEVRYWlRQUlBUUxHUUFnQUNnQ0FDQUJPQUlBSUFBZ0FDZ0NBRUVJYWpZQ0FBc0pBQ0FBS0FJQUVCMEx1d0VCQW44akFFRVFheUlESkFBQ2YwRUFJQUF2QVN3Z0FSQmhJQUZHRFFBYUlBQkJMR29nQVJEVkFTQUFJQUF2QVN3Z0FDZ0NBQ2dDTUJFREFDQUFLQUlvSWdSQkxHcEJBaERWQVNBQUtBSWtJQVFvQXFRQlNRUkFJQVFnQUNnQ0pEWUNwQUVMUVFFZ0FrVU5BQm9nQXlBQVFSaHFJZ0FRS2pZQ0NDQURJQUFRS3pZQ0FBTi9JQU5CQ0dvZ0F4QXNCSDhnQXlnQ0NDZ0NBQ0FCUVFFUVhob2dBMEVJYWhBdEdnd0JCVUVCQ3dzTElRQWdBMEVRYWlRQUlBQUxXZ0VDZnlBQUlBRkJ5QUJyUVFBZ0FSc2lBellDS0FKQUlBQWdBMFlOQUVFQklRSWdBU0FBS0FJUUlBRW9BZ0FvQWdBUkFnQWlBVVVOQUNBQlFRc2dBU2dDQUNnQ0RCRUNBRVVOQUNBQUlBRTJBaFJCQUNFQ0N5QUNDdzhBSUFBZ0FDZ0NBQ2dDWkJFQkFBc0hBQ0FBSUFGeEN3b0FJQUJCcUF3MkFnQUxCQUJCQUFzVUFDQUFCRUFnQUNBQUtBSUFLQUlFRVFFQUN3c3BBUUYvSXdCQkVHc2lBaVFBSUFJZ0FUWUNEQ0FBUVl3QmFpQUNRUXhxRU1jRElBSkJFR29rQUFzekFRRi9JQUlFUUNBQUlRTURRQ0FESUFFdEFBQTZBQUFnQTBFQmFpRURJQUZCQVdvaEFTQUNRUUZySWdJTkFBc0xJQUFMR0FBZ0FDQUJLZ0lBT0FJQUlBQWdBU29DQkRnQ0JDQUFDeGtBSUFCQkJHb2dBVUVFYWhDSkJTQUFJQUVvQWhBMkFoQUxEd0FnQUNnQ0FDQUFLQUlFTmdJRUMwOEJBWHdnQUNBQW9pSUFSSUZlRFAzLy85Ky9va1FBQUFBQUFBRHdQNkFnQUNBQW9pSUJSRUk2QmVGVFZhVS9vcUFnQUNBQm9pQUFSR2xRN3VCQ2svaytva1FuSGcvb2g4Qld2NkNpb0xZTFN3RUNmQ0FBSUFDaUlnRWdBS0lpQWlBQklBR2lvaUFCUktkR080eUh6Y1krb2tSMDU4cmkrUUFxdjZDaUlBSWdBVVN5KzI2SkVCR0JQNkpFZDZ6TFZGVlZ4Yitnb2lBQW9LQzJDMUlCQW4wZ0FVRUFFQ1lxQWdBaEJDQUNRUUFRSmlvQ0FDRUZJQUJCQUJBbUlBUWdCU0FEbEpJNEFnQWdBVUVCRUNZcUFnQWhCQ0FDUVFFUUppb0NBQ0VGSUFCQkFSQW1JQVFnQlNBRGxKSTRBZ0FMREFBZ0FCRHRBUm9nQUJBdUN5RUFJQUFRL3dJZ0FFRUFOZ0k4SUFCQjlCdzJBZ0FnQUVHODVBQTJBZ0FnQUFzZEFRRi9JQUFRaFFFRVFDQUFLQUlBSVFFZ0FCREVBaG9nQVJBdUN3c0ZBQkJGQUFzb0FRRi9Jd0JCRUdzaUFpUUFJQUlnQVRZQ0RDQUFRUmhxSUFKQkRHb1F4d01nQWtFUWFpUUFDeElBSUFBUWhRRUVRQ0FBS0FJQUR3c2dBQXNLQUNBQUtBSUFRUWhxQzBnQUlBQVFZaUFBUWZBTE5nSUFJQUJCQkdwQm5Bd1Fsd0VnQUVFQU5nSVFJQUJCQURZQ0ZDQUFRWWpvQURZQ0FDQUFRUmhxRURvYUlBQkIvLzhET3dFc0lBQkJBRFlDS0FzTUFDQUFFT0lCR2lBQUVDNExOd0VCZnlBQUtBSUVJZ05CQVhVZ0FXb2hBU0FBS0FJQUlRQWdBU0FDSUFOQkFYRUVmeUFCS0FJQUlBQnFLQUlBQlNBQUN4RURBQXNaQUNBQUtBSUFJQUUyQWdBZ0FDQUFLQUlBUVFocU5nSUFDeFFCQVg5QkJCQW5JZ0VnQUNnQ0FEWUNBQ0FCQzFNQ0FuOEJmU01BUVJCcklnSWtBQ0FBS0FJQUlRTWdBaUFCSUFBb0FnUWlBRUVCZFdvaUFTQUFRUUZ4Qkg4Z0FTZ0NBQ0FEYWlnQ0FBVWdBd3NSQmdBNEFnd2dBaW9DRENFRUlBSkJFR29rQUNBRUN5QUJBWDhnQUNnQ0FDRUNJQUFnQVRZQ0FDQUNCRUFnQUJBOUlBSVFuUU1MQ3hFQUlBQWdBRUVCYTNGRklBQkJBa3R4Q3hBQUlBQW9BZ1FnQUNnQ0FHdEJCblVMSndBZ0FSQ25BZ1JBSUFBZ0FTZ0NPQkMvQXhCbkdnOExJQUFnQVNvQ01DQUJLZ0kwRUVBYUN3Z0FJQUJCMkFCcUMxZ0JBMzBnQVVFQUVDWXFBZ0FoQkNBQlFRRVFKaW9DQUNFRklBSkJBQkFtS2dJQUlRWWdBRUVBRUNZZ0JDQUdJQVNUSUFPVWtqZ0NBQ0FDUVFFUUppb0NBQ0VFSUFCQkFSQW1JQVVnQkNBRmt5QURsSkk0QWdBTEN3QWdBRUdZendBMkFnQUxEUUFnQUNnQ0JDQUFLQUlBYXd1ZkFRSUhmd0YrSXdCQkVHc2lBeVFBQW40Q2Z5QUFLQUlFSVFVZ0FDZ0NBQ0lHSVFFQ1FBTkFJQUVnQlU4TkFTQUJMUUFBSWdkQi93QnhyU0FDUWY4QmNTSUNyWVlnQ0lRaENDQUJRUUZxSVFFZ0FrRUhhaUVDSUFkQmdBRnhEUUFMSUFNZ0NEY0RDQ0FCSUFacklRUUxJQVFpQVVVTEJFQWdBQkRBQVVJQURBRUxJQUFnQUNnQ0FDQUJhallDQUNBREtRTUlDeUVJSUFOQkVHb2tBQ0FJQ3lFQUlBRWdBQ29DUEZ3RVFDQUFJQUU0QWp3Z0FDQUFLQUlBS0FKRUVRRUFDd3NRQUNBQUtBSUVJQUFvQWdCclFTaHRDd29BSUFBdEFBdEJCM1lMN2d3QkNIOGpBRUVRYXlJRUpBQWdCQ0FBTmdJTUFrQWdBRUhUQVUwRVFFR2d0d0ZCNExnQklBUkJER29RalFVb0FnQWhBQXdCQ3lBQVFYeFBCRUFRUlFBTElBUWdBQ0FBUWRJQmJpSUhRZElCYkNJRGF6WUNDRUhndUFGQm9Mb0JJQVJCQ0dvUWpRVkI0TGdCYTBFQ2RTRUZBa0FEUUNBRlFRSjBRZUM0QVdvb0FnQWdBMm9oQUVFRklRTWdCaUVCQWtBQ1FBTkFJQUVoQmlBRFFTOUdCRUJCMHdFaEF3TkFJQUFnQTI0aUFTQURTUTBFSUFBZ0FTQURiRVlOQXlBQUlBTkJDbW9pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJER29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJFR29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJFbW9pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJGbW9pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJIR29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJIbW9pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJKR29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJLR29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJLbW9pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJMbW9pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJOR29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJPbW9pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJQR29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJ3Z0JxSWdGdUlnSWdBVWtOQkNBQUlBRWdBbXhHRFFNZ0FDQURRY1lBYWlJQmJpSUNJQUZKRFFRZ0FDQUJJQUpzUmcwRElBQWdBMEhJQUdvaUFXNGlBaUFCU1EwRUlBQWdBU0FDYkVZTkF5QUFJQU5CemdCcUlnRnVJZ0lnQVVrTkJDQUFJQUVnQW14R0RRTWdBQ0FEUWRJQWFpSUJiaUlDSUFGSkRRUWdBQ0FCSUFKc1JnMERJQUFnQTBIWUFHb2lBVzRpQWlBQlNRMEVJQUFnQVNBQ2JFWU5BeUFBSUFOQjRBQnFJZ0Z1SWdJZ0FVa05CQ0FBSUFFZ0FteEdEUU1nQUNBRFFlUUFhaUlCYmlJQ0lBRkpEUVFnQUNBQklBSnNSZzBESUFBZ0EwSG1BR29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkI2Z0JxSWdGdUlnSWdBVWtOQkNBQUlBRWdBbXhHRFFNZ0FDQURRZXdBYWlJQmJpSUNJQUZKRFFRZ0FDQUJJQUpzUmcwRElBQWdBMEh3QUdvaUFXNGlBaUFCU1EwRUlBQWdBU0FDYkVZTkF5QUFJQU5CK0FCcUlnRnVJZ0lnQVVrTkJDQUFJQUVnQW14R0RRTWdBQ0FEUWY0QWFpSUJiaUlDSUFGSkRRUWdBQ0FCSUFKc1JnMERJQUFnQTBHQ0FXb2lBVzRpQWlBQlNRMEVJQUFnQVNBQ2JFWU5BeUFBSUFOQmlBRnFJZ0Z1SWdJZ0FVa05CQ0FBSUFFZ0FteEdEUU1nQUNBRFFZb0JhaUlCYmlJQ0lBRkpEUVFnQUNBQklBSnNSZzBESUFBZ0EwR09BV29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJsQUZxSWdGdUlnSWdBVWtOQkNBQUlBRWdBbXhHRFFNZ0FDQURRWllCYWlJQmJpSUNJQUZKRFFRZ0FDQUJJQUpzUmcwRElBQWdBMEdjQVdvaUFXNGlBaUFCU1EwRUlBQWdBU0FDYkVZTkF5QUFJQU5Cb2dGcUlnRnVJZ0lnQVVrTkJDQUFJQUVnQW14R0RRTWdBQ0FEUWFZQmFpSUJiaUlDSUFGSkRRUWdBQ0FCSUFKc1JnMERJQUFnQTBHb0FXb2lBVzRpQWlBQlNRMEVJQUFnQVNBQ2JFWU5BeUFBSUFOQnJBRnFJZ0Z1SWdJZ0FVa05CQ0FBSUFFZ0FteEdEUU1nQUNBRFFiSUJhaUlCYmlJQ0lBRkpEUVFnQUNBQklBSnNSZzBESUFBZ0EwRzBBV29pQVc0aUFpQUJTUTBFSUFBZ0FTQUNiRVlOQXlBQUlBTkJ1Z0ZxSWdGdUlnSWdBVWtOQkNBQUlBRWdBbXhHRFFNZ0FDQURRYjRCYWlJQmJpSUNJQUZKRFFRZ0FDQUJJQUpzUmcwRElBQWdBMEhBQVdvaUFXNGlBaUFCU1EwRUlBQWdBU0FDYkVZTkF5QUFJQU5CeEFGcUlnRnVJZ0lnQVVrTkJDQUFJQUVnQW14R0RRTWdBQ0FEUWNZQmFpSUJiaUlDSUFGSkRRUWdBQ0FCSUFKc1JnMERJQUFnQTBIUUFXb2lBVzRpQWlBQlNRMEVJQU5CMGdGcUlRTWdBQ0FCSUFKc1J3MEFDd3dDQ3lBQUlBTkJBblJCb0xjQmFpZ0NBQ0lCYmlJQ0lBRnNJUWdnQVNBQ1N5SUNSUVJBSUFBZ0JpQUNHeUVCSUFOQkFXb2hBeUFBSUFoSERRRUxDeUFDSUFBZ0NFZHlEUU1MUVFBZ0JVRUJhaUlBSUFCQk1FWWlBQnNoQlNBQUlBZHFJZ2RCMGdGc0lRTU1BUXNMSUFRZ0FEWUNEQXdCQ3lBRUlBQTJBZ3dnQUNBR0lBSWJJUUFMSUFSQkVHb2tBQ0FBQ3d3QUlBQVFpd0VhSUFBUUxndDBBUU4vSUFBb0FnZ2hBaU1BUVJCcklnQWtBQUovQWtCQmhMOEJMUUFBUVFGeERRQkJoTDhCRUZORkRRQWpBRUVRYXlJREpBQkJBVUhBaXdFUUF5RUVJQU5CRUdva0FFR0F2d0VnQkRZQ0FFR0V2d0VRVWd0QmdMOEJLQUlBQ3lBQ0lBRWdBRUVJYWhDc0JSQUVJQUJCRUdva0FBc0tBQ0FBRUlVRVFRRkdDeElBSUFBUUtDZ0NBQ0FBS0FJQWEwRUdkUXMwQVFGL0lBQkIxTmtBTmdJQUlBQW9Bb2dCSWdFRVFDQUJJQUVvQWdBb0FnUVJBUUFMSUFCQmpBRnFFRDRnQUJCREdpQUFDeElBSUFBUUtDZ0NBQ0FBS0FJQWEwRURiUXNTQUNBQUVDZ29BZ0FnQUNnQ0FHdEJBM1VMRUFBZ0FDZ0NCQ0FBS0FJQWEwRURiUXNOQUNBQUtnSU1JQUFxQWdTVEN3MEFJQUFxQWdnZ0FDb0NBSk1MRHdBZ0FCQW9LQUlBSUFBb0FnQnJDd2NBSUFBUWhBTUxGUUFnQUJDRkFRUkFJQUFvQWdRUEN5QUFMUUFMQzYwQkFRUi9Ba0FnQUJDVEFTSUNJQUVRa3dGSERRQWdBQkJ5SVFNZ0FSQnlJUUVnQUJDRkFVVUVRQU5BSUFKRklRUWdBa1VOQWlBRExRQUFJQUV0QUFCSERRSWdBVUVCYWlFQklBTkJBV29oQXlBQ1FRRnJJUUlNQUFzQUN5QUNCSDlCQUNFQUFrQWdBa1VOQUFOQUlBTXRBQUFpQkNBQkxRQUFJZ1ZHQkVBZ0FVRUJhaUVCSUFOQkFXb2hBeUFDUVFGcklnSU5BUXdDQ3dzZ0JDQUZheUVBQ3lBQUJVRUFDMFVoQkFzZ0JBc1NBQ0FBRUNnb0FnQWdBQ2dDQUd0QkFuVUxKQUVDZnlNQVFSQnJJZ0FrQUNBQVFRaHFRUUFRUVNnQ0FDRUJJQUJCRUdva0FDQUJDeUFCQVg4akFFRVFheUlDSkFBZ0FDQUJJQUVRaFFVUTRRSWdBa0VRYWlRQUN4WUFJQUFRZENBQVFiQUxOZ0lBSUFCQjhBbzJBZ0FMQkFCQkFBc1BBQ0FBUVFScUlBRkJCR29RaVFVTFVnRUNmMEdNdmdFb0FnQWlBU0FBUVFOcVFYeHhJZ0pxSVFBQ1FDQUNRUUFnQUNBQlRSc05BQ0FBUHdCQkVIUkxCRUFnQUJBWFJRMEJDMEdNdmdFZ0FEWUNBQ0FCRHd0QjRNQUJRVEEyQWdCQmZ3dFhBUUovSXdCQkVHc2lBeVFBSUFBb0FnUWlCRUVCZFNBQmFpRUJJQUFvQWdBaEFDQUVRUUZ4QkVBZ0FTZ0NBQ0FBYWlnQ0FDRUFDeUFESUFJUXB3VWdBU0FESUFBUkFnQWhBQ0FERUc4Z0EwRVFhaVFBSUFBTERnQkIvTDRCSUFFZ0FoQUpJQUFMbWdFQkFuOGdBU2dDQUNBQUtBSUFJQU1vQWdBUkFnQWhCU0FDS0FJQUlBRW9BZ0FnQXlnQ0FCRUNBQ0VFQW44Q1FDQUZSUVJBUVFBZ0JFVU5BaG9nQVNBQ0VEVkJBU0FCS0FJQUlBQW9BZ0FnQXlnQ0FCRUNBRVVOQWhvZ0FDQUJFRFVNQVFzZ0JBUkFJQUFnQWhBMVFRRVBDeUFBSUFFUU5VRUJJQUlvQWdBZ0FTZ0NBQ0FES0FJQUVRSUFSUTBCR2lBQklBSVFOUXRCQWdzTERnQWdBQ0FCS0FJQU5nSUFJQUFMQ3dBZ0FDQUJJQUlRMFFFTElBQWdBQ2dDQkNBQUVDZ29BZ0JIQkVBZ0FDQUJFRWtQQ3lBQUlBRVFwZ01MQndBZ0FFRUNSd3ZuRFFJTGZ3bDlJQUFnQVJDSEFpQUJRUWdRVUFSQUlBQW9Bb2dCSVFNZ0FDQUFLQUlBS0FKb0VRQUFJUXNqQUVHUUFXc2lBaVFBSUFNZ0F5Z0NBQ2dDQ0JFQkFBSkFJQUJCakFGcUlnZ1FNaUlKUVFKSkRRQUNRQ0FJUVFBUUx5Z0NBQ0lBRUxnQklnb0VRQ0FDUVVCcklBQVEzUUVRWnlJQlFRQVFKaW9DQUNFUklBRkJBUkFtS2dJQUlSSWdBa0dJQVdvZ0FCQ21BaEJuSWdGQkFCQW1LZ0lBSVEwZ0FVRUJFQ1lxQWdBaER5QUNRWUFCYWlBQUVIMGdBeUFDUVlBQmFrRUFFQ1lxQWdBaUV5QUNRWUFCYWtFQkVDWXFBZ0FpRkNBREtBSUFLQUlVRVFjQURBRUxJQUlnQWtGQWF5QUFFTVFESWdRcUFqd2lEVGdDUEFKQUlBMURBQUFBQUY0RVFDQUlJQWxCQVdzUUx5Z0NBQ0VCSUFKQmlBRnFJQVFRZlNBQ1FZQUJhaEJFSVFBQ1FDQUJFTGdCQkVBZ0FrRXdhaUFCRUtZQ0VHY2FEQUVMSUFKQk1Hb2dBUkI5Q3lBQUlBSkJNR29nQWtHSUFXb1F1d0VnQWlBQUVONEJJZzA0QWl3Z0FFRUFFQ1lpQVNBQktnSUFJQTJWT0FJQUlBSXFBaXdoRFNBQVFRRVFKaUlCSUFFcUFnQWdEWlU0QWdBZ0NFRUJFQzhvQWdBaEJTQUNRVEJxRUVRaEFRSkFJQVVRdUFFRVFDQUNRU0JxSUFVUTNRRVFaeG9NQVFzZ0FrRWdhaUFGRUgwTElBRWdBa0VnYWlBQ1FZZ0JhaEM3QVNBQ0lBRVEzZ0VpRFRnQ0hDQUJRUUFRSmlJRklBVXFBZ0FnRFpVNEFnQWdBaW9DSENFTklBRkJBUkFtSWdVZ0JTb0NBQ0FObFRnQ0FDQUNRU3hxSUFKQkhHb2dBa0U4YWhDbUFSQ21BU29DQUNFTklBSkJJR29RUkNJRklBSkJpQUZxSUFBZ0RSQnNJQU1nQlVFQUVDWXFBZ0FpRVNBRlFRRVFKaW9DQUNJU0lBTW9BZ0FvQWhRUkJ3QWdBa0VRYWhCRUlnVWdBa0dJQVdvZ0FDQU5RKzQ2NVQ2VUlnOFFiQ0FDUVFocUVFUWlBQ0FDUVlnQmFpQUJJQThRYkNBQ0VFUWlCeUFDUVlnQmFpQUJJQTBRYkNBRElBVkJBQkFtS2dJQUlBVkJBUkFtS2dJQUlBQkJBQkFtS2dJQUlBQkJBUkFtS2dJQUlBZEJBQkFtS2dJQUlnMGdCMEVCRUNZcUFnQWlEeUFES0FJQUtBSWNFUWtBREFFTElBSkJpQUZxSUFRUWZTQURJQUpCaUFGcVFRQVFKaW9DQUNJUklBSkJpQUZxUVFFUUppb0NBQ0lTSUFNb0FnQW9BaFFSQndBZ0VpRVBJQkVoRFFzZ0JCQkRHaUFTSVJRZ0VTRVRDeUFKUVFFZ0NVRUJTeHNoREVFQklRVWdDaUVBQWtBRFFDQUZJQXhHQkVBQ1FDQUxSUTBFSUFBZ0NuSkJBWEZGRFFBZ0F5QU5JQThnRVNBU0lCTWdGQ0FES0FJQUtBSWNFUWtBREFNTEJRSkFJQWdnQlJBdktBSUFJZ1FRdUFFaUFRUkFJQUpCUUdzZ0JCRGRBUkJuSVFBZ0FrR0lBV29nQkJCOUlBTWdEU0FQSUFCQkFCQW1LZ0lBSUFCQkFSQW1LZ0lBSUFKQmlBRnFRUUFRSmlvQ0FDQUNRWWdCYWtFQkVDWXFBZ0FnQXlnQ0FDZ0NIQkVKQUNBQ1FZQUJhaUFFRUtZQ0VHY2lBRUVBRUNZcUFnQWhEU0FBUVFFUUppb0NBQ0VQREFFTElBSkJRR3NnQkJERUF4b2dBa0dJQVdvZ0FrRkFheEI5SUFJZ0FrRkFheW9DUENJT09BSThBa0FnRGtNQUFBQUFYZ1JBSUFKQmdBRnFFRVFpQnlBQ1FUQnFJQTBnRHhCQUlBSkJpQUZxRUxzQklBSWdCeERlQVNJT09BSXNJQWRCQUJBbUlnUWdCQ29DQUNBT2xUZ0NBQ0FDS2dJc0lRNGdCMEVCRUNZaUJDQUVLZ0lBSUE2Vk9BSUFJQWdnQlVFQmFpQUpjQkF2S0FJQUlRWWdBa0V3YWhCRUlRUUNRQ0FHRUxnQkJFQWdBa0VnYWlBR0VOMEJFR2NhREFFTElBSkJJR29nQmhCOUN5QUVJQUpCSUdvZ0FrR0lBV29RdXdFZ0FpQUVFTjRCSWc0NEFod2dCRUVBRUNZaUJpQUdLZ0lBSUE2Vk9BSUFJQUlxQWh3aERpQUVRUUVRSmlJR0lBWXFBZ0FnRHBVNEFnQWdBa0VzYWlBQ1FSeHFJQUpCUEdvUXBnRVFwZ0VxQWdBaERpQUNRU0JxRUVRaUJpQUNRWWdCYWlBSElBNFFiQ0FHUVFBUUppb0NBQ0VRSUFaQkFSQW1LZ0lBSVJVQ1FDQUFRUUZ4QkVBZ0F5QU5JQThnRUNBVklBWkJBQkFtS2dJQUlBWkJBUkFtS2dJQUlBTW9BZ0FvQWh3UkNRQU1BUXNnQXlBUUlCVWdBeWdDQUNnQ0dCRUhBQXNnQWtFUWFoQkVJZ0FnQWtHSUFXb2dCeUFPUSs0NjVUNlVJZzBRYkNBQ1FRaHFFRVFpQnlBQ1FZZ0JhaUFFSUEwUWJDQUNFRVFpQmlBQ1FZZ0JhaUFFSUE0UWJDQURJQUJCQUJBbUtnSUFJQUJCQVJBbUtnSUFJQWRCQUJBbUtnSUFJQWRCQVJBbUtnSUFJQVpCQUJBbUtnSUFJZzBnQmtFQkVDWXFBZ0FpRHlBREtBSUFLQUljRVFrQURBRUxJQUpCaUFGcVFRQVFKaW9DQUNFT0lBSkJpQUZxUVFFUUppb0NBQ0VRQWtBZ0FFRUJjUVJBSUFNZ0RTQVBJQTRnRUNBT0lCQWdBeWdDQUNnQ0hCRUpBQXdCQ3lBRElBNGdFQ0FES0FJQUtBSVlFUWNBQ3lBUUlROGdEaUVOQ3lBQ1FVQnJFRU1hQ3lBRlFRRnFJUVVnQVNFQURBRUxDeUFESUJNZ0ZDQURLQUlBS0FJWUVRY0FDeUFESUFNb0FnQW9BaUFSQVFBTElBSkJrQUZxSkFBTEN3Y0FJQUFnQVhJTEVRQWdBRUU5SUFBb0FnQW9BZ3dSQWdBTEpBRUNmeU1BUVJCcklnSWtBQ0FCSUFBUXZBUWhBeUFDUVJCcUpBQWdBU0FBSUFNYkN4SUFJQUFRS0NnQ0FDQUFLQUlBYTBFb2JRc2tBUUovSXdCQkVHc2lBaVFBSUFFZ0FCREdBaUVESUFKQkVHb2tBQ0FCSUFBZ0F4c0xKUUVDZnlNQVFSQnJJZ0FrQUNBQVFRaHFFSllCRUVFb0FnQWhBU0FBUVJCcUpBQWdBUXNoQUNBQUVPNEVJQUJCaUNVMkFnQWdBRUdFUGpZQ0FDQUFRUVJxRURvYUlBQUxnd0VDQTM4QmZnSkFJQUJDZ0lDQWdCQlVCRUFnQUNFRkRBRUxBMEFnQVVFQmF5SUJJQUFnQUVJS2dDSUZRZ3ArZmFkQk1ISTZBQUFnQUVMLy8vLy9ud0ZXSVFJZ0JTRUFJQUlOQUFzTElBV25JZ0lFUUFOQUlBRkJBV3NpQVNBQ0lBSkJDbTRpQTBFS2JHdEJNSEk2QUFBZ0FrRUpTeUVFSUFNaEFpQUVEUUFMQ3lBQkMrZ0NBZ04vQVh3akFFRVFheUlCSkFBQ2ZTQUF2Q0lEUWYvLy8vOEhjU0lDUWRxZnBQb0RUUVJBUXdBQWdEOGdBa0dBZ0lETUEwa05BUm9nQUxzUWFnd0JDeUFDUWRHbjdZTUVUUVJBSUFDN0lRUWdBa0hrbDl1QUJFOEVRRVFZTFVSVSt5RUp3RVFZTFVSVSt5RUpRQ0FEUVg5S0d5QUVvQkJxakF3Q0N5QURRWDlNQkVBZ0JFUVlMVVJVK3lINVA2QVFhd3dDQzBRWUxVUlUreUg1UHlBRW9SQnJEQUVMSUFKQjFlT0lod1JOQkVBZ0FrSGcyNytGQkU4RVFFUVlMVVJVK3lFWndFUVlMVVJVK3lFWlFDQURRWDlLR3lBQXU2QVFhZ3dDQ3lBRFFYOU1CRUJFMGlFemYzelpFc0FnQUx1aEVHc01BZ3NnQUx0RTBpRXpmM3paRXNDZ0VHc01BUXNnQUNBQWt5QUNRWUNBZ1B3SFR3MEFHZ0pBQWtBQ1FBSkFJQUFnQVVFSWFoQ1VCVUVEY1E0REFBRUNBd3NnQVNzRENCQnFEQU1MSUFFckF3aWFFR3NNQWdzZ0FTc0RDQkJxakF3QkN5QUJLd01JRUdzTElRQWdBVUVRYWlRQUlBQUwvZ0lDQVh3RGZ5TUFRUkJySWdJa0FBSkFJQUM4SWdSQi8vLy8vd2R4SWdOQjJwK2srZ05OQkVBZ0EwR0FnSURNQTBrTkFTQUF1eEJySVFBTUFRc2dBMEhScCsyREJFMEVRQ0FBdXlFQklBTkI0NWZiZ0FSTkJFQWdCRUYvVEFSQUlBRkVHQzFFVlBzaCtUK2dFR3FNSVFBTUF3c2dBVVFZTFVSVSt5SDV2NkFRYWlFQURBSUxSQmd0UkZUN0lRbkFSQmd0UkZUN0lRbEFJQVJCZjBvYklBR2dtaEJySVFBTUFRc2dBMEhWNDRpSEJFMEVRQ0FBdXlFQklBTkIzOXUvaFFSTkJFQWdCRUYvVEFSQUlBRkUwaUV6ZjN6WkVrQ2dFR29oQUF3REN5QUJSTkloTTM5ODJSTEFvQkJxakNFQURBSUxSQmd0UkZUN0lSbkFSQmd0UkZUN0lSbEFJQVJCZjBvYklBR2dFR3NoQUF3QkN5QURRWUNBZ1B3SFR3UkFJQUFnQUpNaEFBd0JDd0pBQWtBQ1FBSkFJQUFnQWtFSWFoQ1VCVUVEY1E0REFBRUNBd3NnQWlzRENCQnJJUUFNQXdzZ0Fpc0RDQkJxSVFBTUFnc2dBaXNEQ0pvUWF5RUFEQUVMSUFJckF3Z1Fhb3doQUFzZ0FrRVFhaVFBSUFBTEtRRUJmeU1BUVJCcklnSWtBQ0FDSUFBMkFnd2dBa0VNYWlBQktBSUFFSGNnQWtFUWFpUUFJQUFMTndFQmZ5QUJJQUFvQWdRaUEwRUJkV29oQVNBQUtBSUFJUUFnQVNBQ0lBTkJBWEVFZnlBQktBSUFJQUJxS0FJQUJTQUFDeEVJQUFzb0FDQUFFSU1DSUFCQ0FEY0NVQ0FBUWFnVE5nSUFJQUJDQURjQ1dDQUFRZURTQURZQ0FDQUFDemNBQWtBQ1FBSkFJQUZCR0dzT0FnQUJBZ3NnQUNBQ0VEQzJPQUl3UVFFUEN5QUFJQUlRTUxZNEFqUkJBUThMSUFBZ0FTQUNFRnNMTVFFQmZ5TUFRUkJySWdNa0FDQURJQUUyQWd3Z0FDQURRUXhxRU5RQklBQWdBaWtDQURjQ0JDQURRUkJxSkFBZ0FBc1NBQ0FBSUFJNkFBUWdBQ0FCTmdJQUlBQUxMZ0VDZnlBQUtBSUlJUUVnQUJBb0dnTkFJQUVFUUNBQktBSUFJUUlnQVJBdUlBSWhBUXdCQ3dzZ0FCRGxCUXY4QVFFRGZ5TUFRUkJySWdJa0FDQUJJQUF0QUFBUXBBRkJFQkJoSVFNZ0FpQUFRUVJxSWdBUUtqWUNDQ0FDSUFBUUt6WUNBQ0FEUVJCR0lRUkJBQ0VBQW44RFFDQUNRUWhxSUFJUUxBUkFJQUlvQWdnb0FnQWhBd0ovQWtBZ0FRUkFJQUVnQXlBREtBSUFLQUpFRVFBQUVHRWdBVWNOQVFzZ0F4Q1JBZ1JBUVFFZ0F5Z0NTQTBDR2d0QkFTRUVDeUFBQ3lFQUlBSkJDR29RTFJvTUFRVWdBQ0FFY1FSQVFld0FFQ2NpQUJEV0F5QUFRZnpXQURZQ0FDQUFFTWNCTmdKb0lBQU1Bd3NMQ3lBQVFRRnhCRUJCNkFBUUowRUFRZWdBRURNaUFCRFdBeUFBUWJEaUFEWUNBQ0FBREFFTEVNY0JDeUVBSUFKQkVHb2tBQ0FBQ3h3QUlBQW9BaFFFUUNBQUtBSVVJZ0FnQUNnQ0FDZ0NaQkVCQUFzTEdBQWdBVUgvLy8vL0Ewc0VRQkJGQUFzZ0FVRUNkQkFuQ3hFQUlBQkJKQ0FBS0FJQUtBSU1FUUlBQzZJQkFRSi9JQUFvQWdRZ0FCQW9LQUlBU1FSQUl3QkJFR3NpQXlRQUlBTWdBRUVCRUo0Q0lRSWdBQkFvSUFJb0FnUWdBUkNaQWlBQ0lBSW9BZ1JCQ0dvMkFnUWdBaEJwSUFOQkVHb2tBQThMSXdCQklHc2lBeVFBSUFBUUtDSUNJQU5CQ0dvZ0FDQUFFRTVCQVdvUW5RSWdBQkJPSUFJUW5BSWlBaWdDQ0NBQkVKa0NJQUlnQWlnQ0NFRUlhallDQ0NBQUlBSVF6QU1nQWhDYkFpQURRU0JxSkFBTEZnRUJmeUFBRURJaEFTQUFFTFVFSUFBZ0FSRGdBd3RNQVFKOUlBRkJBQkFtS2dJQUlRTWdBa0VBRUNZcUFnQWhCQ0FBUVFBUUppQURJQVNUT0FJQUlBRkJBUkFtS2dJQUlRTWdBa0VCRUNZcUFnQWhCQ0FBUVFFUUppQURJQVNUT0FJQUMwd0JBbjBnQVVFQUVDWXFBZ0FoQXlBQ1FRQVFKaW9DQUNFRUlBQkJBQkFtSUFNZ0JKSTRBZ0FnQVVFQkVDWXFBZ0FoQXlBQ1FRRVFKaW9DQUNFRUlBQkJBUkFtSUFNZ0JKSTRBZ0FMaGdJQkRIMGdBVUVBRUNZcUFnQWhBeUFCUVFFUUppb0NBQ0VFSUFGQkFoQW1LZ0lBSVFVZ0FVRURFQ1lxQWdBaEJpQUJRUVFRSmlvQ0FDRU5JQUZCQlJBbUtnSUFJUTRnQWtFQUVDWXFBZ0FoQnlBQ1FRRVFKaW9DQUNFSUlBSkJBaEFtS2dJQUlRa2dBa0VERUNZcUFnQWhDaUFDUVFRUUppb0NBQ0VMSUFKQkJSQW1LZ0lBSVF3Z0FFRUFFQ1lnQXlBSGxDQUZJQWlVa2pnQ0FDQUFRUUVRSmlBRUlBZVVJQVlnQ0pTU09BSUFJQUJCQWhBbUlBTWdDWlFnQlNBS2xKSTRBZ0FnQUVFREVDWWdCQ0FKbENBR0lBcVVramdDQUNBQVFRUVFKaUFOSUFNZ0M1UWdCU0FNbEpLU09BSUFJQUJCQlJBbUlBNGdCQ0FMbENBR0lBeVVrcEk0QWdBTENRQWdBRUVBT2dBQUMwNEJBbjhqQUVFUWF5SUJKQUFDZnlBQUtBSUFJQUFvQWdRZ0FVRU1haENHQkNJQ1JRUkFJQUFRd0FGQkFBd0JDeUFBSUFBb0FnQWdBbW8yQWdBZ0FTZ0NEQXNoQUNBQlFSQnFKQUFnQUFzVEFDQUFRUUU2QUFnZ0FDQUFLQUlFTmdJQUN3c0FJQUFvQWdoQi93RnhDdzhBSUFBZ0FDZ0NBRUVvYWpZQ0FBc1RBQ0FBUWZBak5nSUFJQUJCQkdvUWJ5QUFDd29BSUFCQk1HdEJDa2tMa2dFQkEzeEVBQUFBQUFBQThEOGdBQ0FBb2lJQ1JBQUFBQUFBQU9BL29pSURvU0lFUkFBQUFBQUFBUEEvSUFTaElBT2hJQUlnQWlBQ0lBSkVrQlhMR2FBQitqNmlSSGRSd1Jac3dWYS9vS0pFVEZWVlZWVlZwVCtnb2lBQ0lBS2lJZ01nQTZJZ0FpQUNSTlE0aUw3cCtxaTlva1RFc2JTOW51NGhQcUNpUksxU25JQlBmcEsrb0tLZ29pQUFJQUdpb2FDZ0M1a0JBUU44SUFBZ0FLSWlBeUFESUFPaW9pQURSSHpWejFvNjJlVTlva1RybkN1SzV1VmF2cUNpSUFNZ0EwUjkvckZYNHgzSFBxSkUxV0hCR2FBQktyK2dva1NtK0JBUkVSR0JQNkNnSVFVZ0F5QUFvaUVFSUFKRkJFQWdCQ0FESUFXaVJFbFZWVlZWVmNXL29LSWdBS0FQQ3lBQUlBTWdBVVFBQUFBQUFBRGdQNklnQkNBRm9xR2lJQUdoSUFSRVNWVlZWVlZWeFQraW9LRUxjZ0lFZndGOEl3QkJFR3NpQUNRQUlBQVE5UUlnQUVFSWFpQUFRWkw5QUJEMEFpQUFFRjBqQUVFUWF5SUJKQUFnQUNnQ0NFR3NpQUVvQWdBZ0FVRUVhaEFMSVFRZ0FTQUJLQUlFRUVFaEFpQUVFUGdCSVFNZ0FoRElBU0FCUVJCcUpBQWdBRUVJYWhCZElBQkJFR29rQUNBREN3a0FJQUFvQWdBUUh3c1BBQ0FBSUFBb0FnQW9Ba3dSQVFBTEN3QWdBRUVnUVFBUVhob0xMd0FnQWJNZ0FwUkRBQUNBUHlBQ2t5QUFzNVNTSWdKREFBQ0FUMTBnQWtNQUFBQUFZSEVFUUNBQ3FROExRUUFMa0FJQ0JuOEJmaU1BUVJCcklnSWtBQ0FCRUlJQklRZ0NRQ0FCTFFBSUJFQWdBQkNNQkF3QkN3SkFBbjhnQWhEN0JDQUlweUlHUVFGcUlnTUVRQ0FDRUlRRUlBTkpCRUFRY0FBTElBSVFLQm9nQWlBREVDY2lCVFlDQUNBQ0lBVTJBZ1FnQWhBb0lBTWdCV28yQWdBZ0FrRUFFSU1FSUFJZ0F4Q0lCQXNnQWlnQ0FDRUhRUUFnQmtIL0FYRWlBeUFCS0FJRUlBRW9BZ0FpQld0S0RRQWFBMzhnQXlBRVJnUi9JQU1nQjJwQkFEb0FBQ0FEQlNBRUlBZHFJQVV0QUFBNkFBQWdCRUVCYWlFRUlBVkJBV29oQlF3QkN3c0xJZ1N0SUFoU0JFQWdBUkRBQVNBQUVJd0VEQUVMSUFFZ0FTZ0NBQ0FFYWpZQ0FDQUFJQUlvQWdBZ0JoQ0xCQXNnQWhDS0JBc2dBa0VRYWlRQUN5b0FJQUFDZjBFQUlBQW9BaFJGRFFBYVFRQWdBQ2dDRkJDRkEwVU5BQm9nQUNnQ0ZBczJBblJCQUFzNEFRRi9JQUFvQWdBaEFTQUFRUUEyQWdBZ0FRUkFJQUFRUFNJQUxRQUVCRUFnQUNnQ0FCb0xJQUVFUUNBQUtBSUFHaUFCRUM0TEN3c1dBRUVCUVNBZ0FFRUJhMmRyZENBQUlBQkJBazhiQ3h3QUlBQWdBU29DTURnQ01DQUFJQUVxQWpRNEFqUWdBQ0FCRUdnTERRQWdBU2dDQUNBQ0tBSUFSZ3NXQUNBQUlBRW9BZ0EyQWdBZ0FDQUNMUUFBT2dBRUN4UUJBWDhnQUNnQ0FDRUJJQUJCQURZQ0FDQUJDd3dBSUFBZ0FTZ0NBRFlDQUFzUEFDQUFJQUF2QVFBZ0FYSTdBUUFMRVFBZ0FFRXdJQUFvQWdBb0Fnd1JBZ0FMQ1FBZ0FDQUJFSTBDQ3c4QUlBQW9BZ2dnQUNnQ0FEWUNBQXRWQUNBRklBQWdBU0FFRUg4Z0JVRUlhaUlBSUFFZ0FpQUVFSDhnQlVFUWFpSUJJQUlnQXlBRUVIOGdCVUVZYWlJQ0lBVWdBQ0FFRUg4Z0JVRWdhaUlESUFBZ0FTQUVFSDhnQlVFb2FpQUNJQU1nQkJCL0N6RUFJQUFRZ3dVZ0FFS0FnSUQ0ZzRDQWdEODNBcUFCSUFCQ0FEY0NtQUVnQUVINDFRQTJBZ0FnQUVIUTJBQTJBZ0FMRXdBZ0FFRkFheUFCRVBNRElBQkJBVG9BUEFzVUFDQUFRY2dBYWlBQkVQTURJQUJCQVRvQVBRc1lBQ0FBRUtjQ0JFQWdBQ2dDT0JEc0F3OExJQUFRNndNTElnRUJmU0FBUVFBUUppb0NBQ0lCSUFHVUlBQkJBUkFtS2dJQUlnRWdBWlNTa1FzVUFDQUFLQUlJSWdBZ0FDZ0NBQ2dDQ0JFQUFBc2ZBUUYvSUFCQkhHb2lBQkF5SUFGTEJIOGdBQ0FCRUM4b0FnQUZRUUFMQ3hJQUlBQWdBVFlDQkNBQVFZakFBRFlDQUF0c0FRTi9Jd0JCRUdzaUFTUUFJQUJCaEQ0MkFnQWdBU0FBUVFScUlnSVFLallDQ0NBQklBSVFLellDQUFOQUlBRkJDR29nQVJBc0JFQWdBU2dDQ0NnQ0FDSURCRUFnQXlBREtBSUFLQUlFRVFFQUN5QUJRUWhxRUMwYURBRUxDeUFDRUQ0Z0FVRVFhaVFBSUFBTElRQWdBU0FBS2dKNFhBUkFJQUFnQVRnQ2VDQUFJQUFvQWdBb0FsUVJBUUFMQ3pjQkFYMGdBVU1BQUVCQWxDSURJQUpEQUFCQVFKUWlBaUFCUXdBQXdNQ1VraUFEUXdBQWdEOGdBcE9TSUFDVWtpQUFsSklnQUpRTEpBRUJmeU1BUVJCcklnRWtBQ0FCUVFocUlBQVFRU2dDQUNFQUlBRkJFR29rQUNBQUMySUJBWDhqQUVFUWF5SUNKQUFnQUVFQU9nQVVJQUlnQUVFSWFpSURFQ28yQWdnZ0FpQURFQ3MyQWdBRFFDQUNRUWhxSUFJUUxBUkFJQUlvQWdoQkJHb2dBUkMzQWdSQUlBQkJBVG9BRkFzZ0FrRUlhaERDQVF3QkN3c2dBa0VRYWlRQUN3d0FJQUFReFFJYUlBQVFMZ3NKQUNBQUlBRTJBZ0FMREFBZ0FDQUJMUUFBT2dBQUN5Y0FJQU1nQXlnQ0FDQUNJQUZySWdCcklnSTJBZ0FnQUVFQlRnUkFJQUlnQVNBQUVHWWFDd3NrQUNBQUlBRTJBZ0FnQUNBQktBSUVJZ0UyQWdRZ0FDQUJJQUpCQW5ScU5nSUlJQUFMQ1FBZ0FFRWNhaEF5Q3hNQUlBQkJrQzQyQWdBZ0FFRUVhaEJ2SUFBTFJBRUJmd0pBQWtBQ1FBSkFBa0FnQVVIREFHc09Bd0FCQWdRTElBQWdBaEEyTmdJRURBSUxJQUFnQWhBMk5nSUlEQUVMSUFBZ0FoQTJOZ0lNQzBFQklRTUxJQU1MREFBZ0FDQUJLQUlFTmdJRUN5TUFJQUFRWWlBQVFmQWpOZ0lBSUFCQkJHcEJ5Q1FRbHdFZ0FFR2dKRFlDQUNBQUN5SUFJQUFRK0FRZ0FFSUFOd0o0SUFCQm5NNEFOZ0lBSUFCQmhQVUFOZ0lBSUFBTHFBRUFBa0FnQVVHQUNFNEVRQ0FBUkFBQUFBQUFBT0Ivb2lFQUlBRkIvdzlJQkVBZ0FVSC9CMnNoQVF3Q0N5QUFSQUFBQUFBQUFPQi9vaUVBSUFGQi9SY2dBVUg5RjBnYlFmNFBheUVCREFFTElBRkJnWGhLRFFBZ0FFUUFBQUFBQUFBUUFLSWhBQ0FCUVlOd1NnUkFJQUZCL2dkcUlRRU1BUXNnQUVRQUFBQUFBQUFRQUtJaEFDQUJRWVpvSUFGQmhtaEtHMEg4RDJvaEFRc2dBQ0FCUWY4SGFxMUNOSWEvb2d1V0xnRU1meU1BUVJCcklnd2tBQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFRZlFCVFFSQVFiREJBU2dDQUNJRlFSQWdBRUVMYWtGNGNTQUFRUXRKR3lJSVFRTjJJZ0oySWdGQkEzRUVRQ0FCUVg5elFRRnhJQUpxSWdOQkEzUWlBVUhnd1FGcUtBSUFJZ1JCQ0dvaEFBSkFJQVFvQWdnaUFpQUJRZGpCQVdvaUFVWUVRRUd3d1FFZ0JVRitJQU4zY1RZQ0FBd0JDeUFDSUFFMkFnd2dBU0FDTmdJSUN5QUVJQU5CQTNRaUFVRURjallDQkNBQklBUnFJZ0VnQVNnQ0JFRUJjallDQkF3TkN5QUlRYmpCQVNnQ0FDSUtUUTBCSUFFRVFBSkFRUUlnQW5RaUFFRUFJQUJyY2lBQklBSjBjU0lBUVFBZ0FHdHhRUUZySWdBZ0FFRU1ka0VRY1NJQ2RpSUJRUVYyUVFoeElnQWdBbklnQVNBQWRpSUJRUUoyUVFSeElnQnlJQUVnQUhZaUFVRUJka0VDY1NJQWNpQUJJQUIySWdGQkFYWkJBWEVpQUhJZ0FTQUFkbW9pQTBFRGRDSUFRZURCQVdvb0FnQWlCQ2dDQ0NJQklBQkIyTUVCYWlJQVJnUkFRYkRCQVNBRlFYNGdBM2R4SWdVMkFnQU1BUXNnQVNBQU5nSU1JQUFnQVRZQ0NBc2dCRUVJYWlFQUlBUWdDRUVEY2pZQ0JDQUVJQWhxSWdJZ0EwRURkQ0lCSUFocklnTkJBWEkyQWdRZ0FTQUVhaUFETmdJQUlBb0VRQ0FLUVFOMklnRkJBM1JCMk1FQmFpRUhRY1RCQVNnQ0FDRUVBbjhnQlVFQklBRjBJZ0Z4UlFSQVFiREJBU0FCSUFWeU5nSUFJQWNNQVFzZ0J5Z0NDQXNoQVNBSElBUTJBZ2dnQVNBRU5nSU1JQVFnQnpZQ0RDQUVJQUUyQWdnTFFjVEJBU0FDTmdJQVFiakJBU0FETmdJQURBMExRYlRCQVNnQ0FDSUdSUTBCSUFaQkFDQUdhM0ZCQVdzaUFDQUFRUXgyUVJCeElnSjJJZ0ZCQlhaQkNIRWlBQ0FDY2lBQklBQjJJZ0ZCQW5aQkJIRWlBSElnQVNBQWRpSUJRUUYyUVFKeElnQnlJQUVnQUhZaUFVRUJka0VCY1NJQWNpQUJJQUIyYWtFQ2RFSGd3d0ZxS0FJQUlnRW9BZ1JCZUhFZ0NHc2hBeUFCSVFJRFFBSkFJQUlvQWhBaUFFVUVRQ0FDS0FJVUlnQkZEUUVMSUFBb0FnUkJlSEVnQ0dzaUFpQURJQUlnQTBraUFoc2hBeUFBSUFFZ0Foc2hBU0FBSVFJTUFRc0xJQUVnQ0dvaUNTQUJUUTBDSUFFb0FoZ2hDeUFCSUFFb0Fnd2lCRWNFUUNBQktBSUlJZ0JCd01FQktBSUFTUm9nQUNBRU5nSU1JQVFnQURZQ0NBd01DeUFCUVJScUlnSW9BZ0FpQUVVRVFDQUJLQUlRSWdCRkRRUWdBVUVRYWlFQ0N3TkFJQUloQnlBQUlnUkJGR29pQWlnQ0FDSUFEUUFnQkVFUWFpRUNJQVFvQWhBaUFBMEFDeUFIUVFBMkFnQU1Dd3RCZnlFSUlBQkJ2MzlMRFFBZ0FFRUxhaUlBUVhoeElRaEJ0TUVCS0FJQUlnbEZEUUJCSHlFRlFRQWdDR3NoQXdKQUFrQUNRQUovSUFoQi8vLy9CMDBFUUNBQVFRaDJJZ0FnQUVHQS9qOXFRUkIyUVFoeElnSjBJZ0FnQUVHQTRCOXFRUkIyUVFSeElnRjBJZ0FnQUVHQWdBOXFRUkIyUVFKeElnQjBRUTkySUFFZ0FuSWdBSEpySWdCQkFYUWdDQ0FBUVJWcWRrRUJjWEpCSEdvaEJRc2dCVUVDZEVIZ3d3RnFLQUlBSWdKRkN3UkFRUUFoQUF3QkMwRUFJUUFnQ0VFQVFSa2dCVUVCZG1zZ0JVRWZSaHQwSVFFRFFBSkFJQUlvQWdSQmVIRWdDR3NpQnlBRFR3MEFJQUloQkNBSElnTU5BRUVBSVFNZ0FpRUFEQU1MSUFBZ0FpZ0NGQ0lISUFjZ0FpQUJRUjEyUVFSeGFpZ0NFQ0lDUmhzZ0FDQUhHeUVBSUFGQkFYUWhBU0FDRFFBTEN5QUFJQVJ5UlFSQVFRSWdCWFFpQUVFQUlBQnJjaUFKY1NJQVJRMERJQUJCQUNBQWEzRkJBV3NpQUNBQVFReDJRUkJ4SWdKMklnRkJCWFpCQ0hFaUFDQUNjaUFCSUFCMklnRkJBblpCQkhFaUFISWdBU0FBZGlJQlFRRjJRUUp4SWdCeUlBRWdBSFlpQVVFQmRrRUJjU0lBY2lBQklBQjJha0VDZEVIZ3d3RnFLQUlBSVFBTElBQkZEUUVMQTBBZ0FDZ0NCRUY0Y1NBSWF5SUJJQU5KSVFJZ0FTQURJQUliSVFNZ0FDQUVJQUliSVFRZ0FDZ0NFQ0lCQkg4Z0FRVWdBQ2dDRkFzaUFBMEFDd3NnQkVVTkFDQURRYmpCQVNnQ0FDQUlhMDhOQUNBRUlBaHFJZ1lnQkUwTkFTQUVLQUlZSVFVZ0JDQUVLQUlNSWdGSEJFQWdCQ2dDQ0NJQVFjREJBU2dDQUVrYUlBQWdBVFlDRENBQklBQTJBZ2dNQ2dzZ0JFRVVhaUlDS0FJQUlnQkZCRUFnQkNnQ0VDSUFSUTBFSUFSQkVHb2hBZ3NEUUNBQ0lRY2dBQ0lCUVJScUlnSW9BZ0FpQUEwQUlBRkJFR29oQWlBQktBSVFJZ0FOQUFzZ0IwRUFOZ0lBREFrTElBaEJ1TUVCS0FJQUlnSk5CRUJCeE1FQktBSUFJUU1DUUNBQ0lBaHJJZ0ZCRUU4RVFFRzR3UUVnQVRZQ0FFSEV3UUVnQXlBSWFpSUFOZ0lBSUFBZ0FVRUJjallDQkNBQ0lBTnFJQUUyQWdBZ0F5QUlRUU55TmdJRURBRUxRY1RCQVVFQU5nSUFRYmpCQVVFQU5nSUFJQU1nQWtFRGNqWUNCQ0FDSUFOcUlnQWdBQ2dDQkVFQmNqWUNCQXNnQTBFSWFpRUFEQXNMSUFoQnZNRUJLQUlBSWdaSkJFQkJ2TUVCSUFZZ0NHc2lBVFlDQUVISXdRRkJ5TUVCS0FJQUlnSWdDR29pQURZQ0FDQUFJQUZCQVhJMkFnUWdBaUFJUVFOeU5nSUVJQUpCQ0dvaEFBd0xDMEVBSVFBZ0NFRXZhaUlKQW45QmlNVUJLQUlBQkVCQmtNVUJLQUlBREFFTFFaVEZBVUovTndJQVFZekZBVUtBb0lDQWdJQUVOd0lBUVlqRkFTQU1RUXhxUVhCeFFkaXExYW9GY3pZQ0FFR2N4UUZCQURZQ0FFSHN4QUZCQURZQ0FFR0FJQXNpQVdvaUJVRUFJQUZySWdkeElnSWdDRTBOQ2tIb3hBRW9BZ0FpQkFSQVFlREVBU2dDQUNJRElBSnFJZ0VnQTAwZ0FTQUVTM0lOQ3d0QjdNUUJMUUFBUVFSeERRVUNRQUpBUWNqQkFTZ0NBQ0lEQkVCQjhNUUJJUUFEUUNBRElBQW9BZ0FpQVU4RVFDQUJJQUFvQWdScUlBTkxEUU1MSUFBb0FnZ2lBQTBBQ3d0QkFCQ2JBU0lCUVg5R0RRWWdBaUVGUVl6RkFTZ0NBQ0lEUVFGcklnQWdBWEVFUUNBQ0lBRnJJQUFnQVdwQkFDQURhM0ZxSVFVTElBVWdDRTBnQlVIKy8vLy9CMHR5RFFaQjZNUUJLQUlBSWdRRVFFSGd4QUVvQWdBaUF5QUZhaUlBSUFOTklBQWdCRXR5RFFjTElBVVFtd0VpQUNBQlJ3MEJEQWdMSUFVZ0Jtc2dCM0VpQlVIKy8vLy9CMHNOQlNBRkVKc0JJZ0VnQUNnQ0FDQUFLQUlFYWtZTkJDQUJJUUFMSUFCQmYwWWdDRUV3YWlBRlRYSkZCRUJCa01VQktBSUFJZ0VnQ1NBRmEycEJBQ0FCYTNFaUFVSCsvLy8vQjBzRVFDQUFJUUVNQ0FzZ0FSQ2JBVUYvUndSQUlBRWdCV29oQlNBQUlRRU1DQXRCQUNBRmF4Q2JBUm9NQlFzZ0FDSUJRWDlIRFFZTUJBc0FDMEVBSVFRTUJ3dEJBQ0VCREFVTElBRkJmMGNOQWd0QjdNUUJRZXpFQVNnQ0FFRUVjallDQUFzZ0FrSCsvLy8vQjBzTkFTQUNFSnNCSWdGQmYwWkJBQkNiQVNJQVFYOUdjaUFBSUFGTmNnMEJJQUFnQVdzaUJTQUlRU2hxVFEwQkMwSGd4QUZCNE1RQktBSUFJQVZxSWdBMkFnQkI1TVFCS0FJQUlBQkpCRUJCNU1RQklBQTJBZ0FMQWtBQ1FBSkFRY2pCQVNnQ0FDSUhCRUJCOE1RQklRQURRQ0FCSUFBb0FnQWlBeUFBS0FJRUlnSnFSZzBDSUFBb0FnZ2lBQTBBQ3d3Q0MwSEF3UUVvQWdBaUFFRUFJQUFnQVUwYlJRUkFRY0RCQVNBQk5nSUFDMEVBSVFCQjlNUUJJQVUyQWdCQjhNUUJJQUUyQWdCQjBNRUJRWDgyQWdCQjFNRUJRWWpGQVNnQ0FEWUNBRUg4eEFGQkFEWUNBQU5BSUFCQkEzUWlBMEhnd1FGcUlBTkIyTUVCYWlJQ05nSUFJQU5CNU1FQmFpQUNOZ0lBSUFCQkFXb2lBRUVnUncwQUMwRzh3UUVnQlVFb2F5SURRWGdnQVd0QkIzRkJBQ0FCUVFocVFRZHhHeUlBYXlJQ05nSUFRY2pCQVNBQUlBRnFJZ0EyQWdBZ0FDQUNRUUZ5TmdJRUlBRWdBMnBCS0RZQ0JFSE13UUZCbU1VQktBSUFOZ0lBREFJTElBRWdCMDBOQUNBQUtBSU1RUWh4SUFNZ0IwdHlEUUFnQUNBQ0lBVnFOZ0lFUWNqQkFTQUhRWGdnQjJ0QkIzRkJBQ0FIUVFocVFRZHhHeUlBYWlJQ05nSUFRYnpCQVVHOHdRRW9BZ0FnQldvaUFTQUFheUlBTmdJQUlBSWdBRUVCY2pZQ0JDQUJJQWRxUVNnMkFnUkJ6TUVCUVpqRkFTZ0NBRFlDQUF3QkMwSEF3UUVvQWdBZ0FVc0VRRUhBd1FFZ0FUWUNBQXNnQVNBRmFpRUNRZkRFQVNFQUFrQUNRQUpBQWtBQ1FBSkFBMEFnQWlBQUtBSUFSd1JBSUFBb0FnZ2lBQTBCREFJTEN5QUFMUUFNUVFoeFJRMEJDMEh3eEFFaEFBTkFJQWNnQUNnQ0FDSUNUd1JBSUFJZ0FDZ0NCR29pQkNBSFN3MERDeUFBS0FJSUlRQU1BQXNBQ3lBQUlBRTJBZ0FnQUNBQUtBSUVJQVZxTmdJRUlBRkJlQ0FCYTBFSGNVRUFJQUZCQ0dwQkIzRWJhaUlKSUFoQkEzSTJBZ1FnQWtGNElBSnJRUWR4UVFBZ0FrRUlha0VIY1J0cUlnVWdDQ0FKYWlJR2F5RUNJQVVnQjBZRVFFSEl3UUVnQmpZQ0FFRzh3UUZCdk1FQktBSUFJQUpxSWdBMkFnQWdCaUFBUVFGeU5nSUVEQU1MSUFWQnhNRUJLQUlBUmdSQVFjVEJBU0FHTmdJQVFiakJBVUc0d1FFb0FnQWdBbW9pQURZQ0FDQUdJQUJCQVhJMkFnUWdBQ0FHYWlBQU5nSUFEQU1MSUFVb0FnUWlBRUVEY1VFQlJnUkFJQUJCZUhFaEJ3SkFJQUJCL3dGTkJFQWdCU2dDQ0NJRElBQkJBM1lpQUVFRGRFSFl3UUZxUmhvZ0F5QUZLQUlNSWdGR0JFQkJzTUVCUWJEQkFTZ0NBRUYrSUFCM2NUWUNBQXdDQ3lBRElBRTJBZ3dnQVNBRE5nSUlEQUVMSUFVb0FoZ2hDQUpBSUFVZ0JTZ0NEQ0lCUndSQUlBVW9BZ2dpQUNBQk5nSU1JQUVnQURZQ0NBd0JDd0pBSUFWQkZHb2lBQ2dDQUNJRERRQWdCVUVRYWlJQUtBSUFJZ01OQUVFQUlRRU1BUXNEUUNBQUlRUWdBeUlCUVJScUlnQW9BZ0FpQXcwQUlBRkJFR29oQUNBQktBSVFJZ01OQUFzZ0JFRUFOZ0lBQ3lBSVJRMEFBa0FnQlNBRktBSWNJZ05CQW5SQjRNTUJhaUlBS0FJQVJnUkFJQUFnQVRZQ0FDQUJEUUZCdE1FQlFiVEJBU2dDQUVGK0lBTjNjVFlDQUF3Q0N5QUlRUkJCRkNBSUtBSVFJQVZHRzJvZ0FUWUNBQ0FCUlEwQkN5QUJJQWcyQWhnZ0JTZ0NFQ0lBQkVBZ0FTQUFOZ0lRSUFBZ0FUWUNHQXNnQlNnQ0ZDSUFSUTBBSUFFZ0FEWUNGQ0FBSUFFMkFoZ0xJQVVnQjJvaEJTQUNJQWRxSVFJTElBVWdCU2dDQkVGK2NUWUNCQ0FHSUFKQkFYSTJBZ1FnQWlBR2FpQUNOZ0lBSUFKQi93Rk5CRUFnQWtFRGRpSUFRUU4wUWRqQkFXb2hBZ0ovUWJEQkFTZ0NBQ0lCUVFFZ0FIUWlBSEZGQkVCQnNNRUJJQUFnQVhJMkFnQWdBZ3dCQ3lBQ0tBSUlDeUVBSUFJZ0JqWUNDQ0FBSUFZMkFnd2dCaUFDTmdJTUlBWWdBRFlDQ0F3REMwRWZJUUFnQWtILy8vOEhUUVJBSUFKQkNIWWlBQ0FBUVlEK1AycEJFSFpCQ0hFaUEzUWlBQ0FBUVlEZ0gycEJFSFpCQkhFaUFYUWlBQ0FBUVlDQUQycEJFSFpCQW5FaUFIUkJEM1lnQVNBRGNpQUFjbXNpQUVFQmRDQUNJQUJCRldwMlFRRnhja0VjYWlFQUN5QUdJQUEyQWh3Z0JrSUFOd0lRSUFCQkFuUkI0TU1CYWlFRUFrQkJ0TUVCS0FJQUlnTkJBU0FBZENJQmNVVUVRRUcwd1FFZ0FTQURjallDQUNBRUlBWTJBZ0FnQmlBRU5nSVlEQUVMSUFKQkFFRVpJQUJCQVhacklBQkJIMFliZENFQUlBUW9BZ0FoQVFOQUlBRWlBeWdDQkVGNGNTQUNSZzBESUFCQkhYWWhBU0FBUVFGMElRQWdBeUFCUVFSeGFpSUVLQUlRSWdFTkFBc2dCQ0FHTmdJUUlBWWdBellDR0FzZ0JpQUdOZ0lNSUFZZ0JqWUNDQXdDQzBHOHdRRWdCVUVvYXlJRFFYZ2dBV3RCQjNGQkFDQUJRUWhxUVFkeEd5SUFheUlDTmdJQVFjakJBU0FBSUFGcUlnQTJBZ0FnQUNBQ1FRRnlOZ0lFSUFFZ0EycEJLRFlDQkVITXdRRkJtTVVCS0FJQU5nSUFJQWNnQkVFbklBUnJRUWR4UVFBZ0JFRW5hMEVIY1J0cVFTOXJJZ0FnQUNBSFFSQnFTUnNpQWtFYk5nSUVJQUpCK01RQktRSUFOd0lRSUFKQjhNUUJLUUlBTndJSVFmakVBU0FDUVFocU5nSUFRZlRFQVNBRk5nSUFRZkRFQVNBQk5nSUFRZnpFQVVFQU5nSUFJQUpCR0dvaEFBTkFJQUJCQnpZQ0JDQUFRUWhxSVFFZ0FFRUVhaUVBSUFFZ0JFa05BQXNnQWlBSFJnMERJQUlnQWlnQ0JFRitjVFlDQkNBSElBSWdCMnNpQkVFQmNqWUNCQ0FDSUFRMkFnQWdCRUgvQVUwRVFDQUVRUU4ySWdCQkEzUkIyTUVCYWlFQ0FuOUJzTUVCS0FJQUlnRkJBU0FBZENJQWNVVUVRRUd3d1FFZ0FDQUJjallDQUNBQ0RBRUxJQUlvQWdnTElRQWdBaUFITmdJSUlBQWdCellDRENBSElBSTJBZ3dnQnlBQU5nSUlEQVFMUVI4aEFDQUhRZ0EzQWhBZ0JFSC8vLzhIVFFSQUlBUkJDSFlpQUNBQVFZRCtQMnBCRUhaQkNIRWlBblFpQUNBQVFZRGdIMnBCRUhaQkJIRWlBWFFpQUNBQVFZQ0FEMnBCRUhaQkFuRWlBSFJCRDNZZ0FTQUNjaUFBY21zaUFFRUJkQ0FFSUFCQkZXcDJRUUZ4Y2tFY2FpRUFDeUFISUFBMkFod2dBRUVDZEVIZ3d3RnFJUU1DUUVHMHdRRW9BZ0FpQWtFQklBQjBJZ0Z4UlFSQVFiVEJBU0FCSUFKeU5nSUFJQU1nQnpZQ0FDQUhJQU0yQWhnTUFRc2dCRUVBUVJrZ0FFRUJkbXNnQUVFZlJodDBJUUFnQXlnQ0FDRUJBMEFnQVNJQ0tBSUVRWGh4SUFSR0RRUWdBRUVkZGlFQklBQkJBWFFoQUNBQ0lBRkJCSEZxSWdNb0FoQWlBUTBBQ3lBRElBYzJBaEFnQnlBQ05nSVlDeUFISUFjMkFnd2dCeUFITmdJSURBTUxJQU1vQWdnaUFDQUdOZ0lNSUFNZ0JqWUNDQ0FHUVFBMkFoZ2dCaUFETmdJTUlBWWdBRFlDQ0FzZ0NVRUlhaUVBREFVTElBSW9BZ2dpQUNBSE5nSU1JQUlnQnpZQ0NDQUhRUUEyQWhnZ0J5QUNOZ0lNSUFjZ0FEWUNDQXRCdk1FQktBSUFJZ0FnQ0UwTkFFRzh3UUVnQUNBSWF5SUJOZ0lBUWNqQkFVSEl3UUVvQWdBaUFpQUlhaUlBTmdJQUlBQWdBVUVCY2pZQ0JDQUNJQWhCQTNJMkFnUWdBa0VJYWlFQURBTUxRZURBQVVFd05nSUFRUUFoQUF3Q0N3SkFJQVZGRFFBQ1FDQUVLQUljSWdKQkFuUkI0TU1CYWlJQUtBSUFJQVJHQkVBZ0FDQUJOZ0lBSUFFTkFVRzB3UUVnQ1VGK0lBSjNjU0lKTmdJQURBSUxJQVZCRUVFVUlBVW9BaEFnQkVZYmFpQUJOZ0lBSUFGRkRRRUxJQUVnQlRZQ0dDQUVLQUlRSWdBRVFDQUJJQUEyQWhBZ0FDQUJOZ0lZQ3lBRUtBSVVJZ0JGRFFBZ0FTQUFOZ0lVSUFBZ0FUWUNHQXNDUUNBRFFROU5CRUFnQkNBRElBaHFJZ0JCQTNJMkFnUWdBQ0FFYWlJQUlBQW9BZ1JCQVhJMkFnUU1BUXNnQkNBSVFRTnlOZ0lFSUFZZ0EwRUJjallDQkNBRElBWnFJQU0yQWdBZ0EwSC9BVTBFUUNBRFFRTjJJZ0JCQTNSQjJNRUJhaUVDQW45QnNNRUJLQUlBSWdGQkFTQUFkQ0lBY1VVRVFFR3d3UUVnQUNBQmNqWUNBQ0FDREFFTElBSW9BZ2dMSVFBZ0FpQUdOZ0lJSUFBZ0JqWUNEQ0FHSUFJMkFnd2dCaUFBTmdJSURBRUxRUjhoQUNBRFFmLy8vd2ROQkVBZ0EwRUlkaUlBSUFCQmdQNC9ha0VRZGtFSWNTSUNkQ0lBSUFCQmdPQWZha0VRZGtFRWNTSUJkQ0lBSUFCQmdJQVBha0VRZGtFQ2NTSUFkRUVQZGlBQklBSnlJQUJ5YXlJQVFRRjBJQU1nQUVFVmFuWkJBWEZ5UVJ4cUlRQUxJQVlnQURZQ0hDQUdRZ0EzQWhBZ0FFRUNkRUhnd3dGcUlRSUNRQUpBSUFsQkFTQUFkQ0lCY1VVRVFFRzB3UUVnQVNBSmNqWUNBQ0FDSUFZMkFnQWdCaUFDTmdJWURBRUxJQU5CQUVFWklBQkJBWFpySUFCQkgwWWJkQ0VBSUFJb0FnQWhDQU5BSUFnaUFTZ0NCRUY0Y1NBRFJnMENJQUJCSFhZaEFpQUFRUUYwSVFBZ0FTQUNRUVJ4YWlJQ0tBSVFJZ2dOQUFzZ0FpQUdOZ0lRSUFZZ0FUWUNHQXNnQmlBR05nSU1JQVlnQmpZQ0NBd0JDeUFCS0FJSUlnQWdCallDRENBQklBWTJBZ2dnQmtFQU5nSVlJQVlnQVRZQ0RDQUdJQUEyQWdnTElBUkJDR29oQUF3QkN3SkFJQXRGRFFBQ1FDQUJLQUljSWdKQkFuUkI0TU1CYWlJQUtBSUFJQUZHQkVBZ0FDQUVOZ0lBSUFRTkFVRzB3UUVnQmtGK0lBSjNjVFlDQUF3Q0N5QUxRUkJCRkNBTEtBSVFJQUZHRzJvZ0JEWUNBQ0FFUlEwQkN5QUVJQXMyQWhnZ0FTZ0NFQ0lBQkVBZ0JDQUFOZ0lRSUFBZ0JEWUNHQXNnQVNnQ0ZDSUFSUTBBSUFRZ0FEWUNGQ0FBSUFRMkFoZ0xBa0FnQTBFUFRRUkFJQUVnQXlBSWFpSUFRUU55TmdJRUlBQWdBV29pQUNBQUtBSUVRUUZ5TmdJRURBRUxJQUVnQ0VFRGNqWUNCQ0FKSUFOQkFYSTJBZ1FnQXlBSmFpQUROZ0lBSUFvRVFDQUtRUU4ySWdCQkEzUkIyTUVCYWlFRVFjVEJBU2dDQUNFQ0FuOUJBU0FBZENJQUlBVnhSUVJBUWJEQkFTQUFJQVZ5TmdJQUlBUU1BUXNnQkNnQ0NBc2hBQ0FFSUFJMkFnZ2dBQ0FDTmdJTUlBSWdCRFlDRENBQ0lBQTJBZ2dMUWNUQkFTQUpOZ0lBUWJqQkFTQUROZ0lBQ3lBQlFRaHFJUUFMSUF4QkVHb2tBQ0FBQ3pjQkFYOGdBQ2dDQkNJRFFRRjFJQUZxSVFFZ0FDZ0NBQ0VBSUFFZ0FpQURRUUZ4Qkg4Z0FTZ0NBQ0FBYWlnQ0FBVWdBQXNSQWdBTE9RQWdBQ0FCS2dLWUFUZ0NtQUVnQUNBQktnS2NBVGdDbkFFZ0FDQUJLZ0tnQVRnQ29BRWdBQ0FCS2dLa0FUZ0NwQUVnQUNBQkVLTUZDek1CQVg4Z0FDZ0NBQ0VDSUFBb0FnUWlBRUVCZFNBQmFpSUJJQUJCQVhFRWZ5QUJLQUlBSUFKcUtBSUFCU0FDQ3hFQkFBc0pBQ0FBSUFFUVFSb0xKQUFnQUVRQUFBQUFBQUR3UVdNZ0FFUUFBQUFBQUFBQUFHWnhCRUFnQUtzUEMwRUFDMGtCQVg4akFFRVFheUlESkFBZ0F5QUNOZ0lNUWY2K0FTQUJRYWEvQVVHQWtnRkJ3Z2dnQTBFTWFoQjRRYWEvQVVIOGpnRkJ3d2dnQTBFTWFoQjRFQ0lnQTBFUWFpUUFJQUFMRkFBZ0FBUkFJQUFnQUNnQ0FDZ0NDQkVCQUFzTE9BRUJmeUFCSUFBb0FnUWlBa0VCZFdvaEFTQUFLQUlBSVFBZ0FTQUNRUUZ4Qkg4Z0FTZ0NBQ0FBYWlnQ0FBVWdBQXNSQUFBUW53VUxNd0VCZnlNQVFSQnJJZ0lrQUNBQ1FRaHFJQUVRN2dJZ0FrRUlhaUFBRVFBQUlRQWdBa0VJYWhCZElBSkJFR29rQUNBQUM0TUJBZ0ovQVh3Z0FDQUJOZ0kwSUFBQ2Z5TUFRUkJySWdBa0FDQUFFUFVDSUFCQkNHb2dBRUdDL1FBUTlBSWdBQkJkSXdCQkVHc2lBU1FBSUFBb0FnaEJxSWdCS0FJQUlBRkJCR29RQ3lFRUlBRWdBU2dDQkJCQklRTWdCQkQ0QVNFQ0lBTVF5QUVnQVVFUWFpUUFJQUJCQ0dvUVhTQUFRUkJxSkFBZ0FnczJBakFnQWd1Y0FRRUJmeUFBSUFFZ0FpQURJQVVRL3dFaEJpQUVLQUlBSUFNb0FnQWdCU2dDQUJFQ0FBUi9JQU1nQkJBMUlBTW9BZ0FnQWlnQ0FDQUZLQUlBRVFJQVJRUkFJQVpCQVdvUEN5QUNJQU1RTlNBQ0tBSUFJQUVvQWdBZ0JTZ0NBQkVDQUVVRVFDQUdRUUpxRHdzZ0FTQUNFRFVnQVNnQ0FDQUFLQUlBSUFVb0FnQVJBZ0JGQkVBZ0JrRURhZzhMSUFBZ0FSQTFJQVpCQkdvRklBWUxDM2dCQVg4Z0FDQUJJQUlnQkJDZUFTRUZJQU1vQWdBZ0FpZ0NBQ0FFS0FJQUVRSUFCSDhnQWlBREVEVWdBaWdDQUNBQktBSUFJQVFvQWdBUkFnQkZCRUFnQlVFQmFnOExJQUVnQWhBMUlBRW9BZ0FnQUNnQ0FDQUVLQUlBRVFJQVJRUkFJQVZCQW1vUEN5QUFJQUVRTlNBRlFRTnFCU0FGQ3d1K0J3RUdmd05BSUFGQkJHc2hCd05BSUFBaEF3TkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJJQU5ySWdCQkFuVWlCQTRHQndjQUJBRUNBd3NnQVVFRWF5SUFLQUlBSUFNb0FnQWdBaWdDQUJFQ0FFVU5CaUFESUFBUU5ROExJQU1nQTBFRWFpQURRUWhxSUFGQkJHc2dBaEQvQVJvUEN5QURJQU5CQkdvZ0EwRUlhaUFEUVF4cUlBRkJCR3NnQWhEK0FSb1BDeUFBUWZzQVRBUkFJQUVoQlNNQVFSQnJJZ1lrQUNBRElnUWdBMEVFYWlBRFFRaHFJZ01nQWlJSEVKNEJHaUFFUVF4cUlRRURRQ0FCSUFWSEJFQWdBU2dDQUNBREtBSUFJQWNvQWdBUkFnQUVRQ0FHSUFFb0FnQTJBZ3dnQVNFQ0EwQUNRQ0FDSUFNaUFDZ0NBRFlDQUNBRElBUkdCRUFnQkNFQURBRUxJQVlvQWd3Z0FDSUNRUVJySWdNb0FnQWdCeWdDQUJFQ0FBMEJDd3NnQUNBR1FReHFLQUlBTmdJQUN5QUJJZ05CQkdvaEFRd0JDd3NnQmtFUWFpUUFEd3NnQXlBRVFRSnRRUUowYWlFR0FuOGdBRUdkSDA0RVFDQURJQU1nQkVFRWJVRUNkQ0lBYWlBR0lBQWdCbW9nQnlBQ0VQNEJEQUVMSUFNZ0JpQUhJQUlRbmdFTElRZ2dCeUVBSUFNb0FnQWdCaWdDQUNBQ0tBSUFFUUlBUlFSQUEwQWdBRUVFYXlJQUlBTkdCRUFnQTBFRWFpRUZJQU1vQWdBZ0J5Z0NBQ0FDS0FJQUVRSUFEUVVEUUNBRklBZEdEUWNnQXlnQ0FDQUZLQUlBSUFJb0FnQVJBZ0FFUUNBRklBY1FOU0FGUVFScUlRVU1Cd1VnQlVFRWFpRUZEQUVMQUFzQUN5QUFLQUlBSUFZb0FnQWdBaWdDQUJFQ0FFVU5BQXNnQXlBQUVEVWdDRUVCYWlFSUN5QURRUVJxSWdRZ0FFOE5BUU5BSUFRaUJVRUVhaUVFSUFVb0FnQWdCaWdDQUNBQ0tBSUFFUUlBRFFBRFFDQUFRUVJySWdBb0FnQWdCaWdDQUNBQ0tBSUFFUUlBUlEwQUN5QUFJQVZKQkVBZ0JTRUVEQU1GSUFVZ0FCQTFJQUFnQmlBRklBWkdHeUVHSUFoQkFXb2hDQXdCQ3dBTEFBc2dBeUFEUVFScUlBRkJCR3NnQWhDZUFSb01BZ3NDUUNBRUlBWkdEUUFnQmlnQ0FDQUVLQUlBSUFJb0FnQVJBZ0JGRFFBZ0JDQUdFRFVnQ0VFQmFpRUlDeUFJUlFSQUlBTWdCQ0FDRVAwQ0lRVWdCRUVFYWlJQUlBRWdBaEQ5QWdSQUlBUWhBU0FESVFBZ0JVVU5CZ3dEQ3lBRkRRUUxJQVFnQTJzZ0FTQUVhMGdFUUNBRElBUWdBaENBQWlBRVFRUnFJUUFNQkFzZ0JFRUVhaUFCSUFJUWdBSWdCQ0VCSUFNaEFBd0VDeUFGSUFjaUFFWU5BQU5BSUFVaUJFRUVhaUVGSUFNb0FnQWdCQ2dDQUNBQ0tBSUFFUUlBUlEwQUEwQWdBeWdDQUNBQVFRUnJJZ0FvQWdBZ0FpZ0NBQkVDQUEwQUN5QUFJQVJOQkVBZ0JDRUREQU1GSUFRZ0FCQTFEQUVMQUFzQUN3c0xDd3NNQUNBQVFZQUNRUUFRWGhvTEJ3QWdBRUVZZGdzd0FDQUFFUDhDSUFCQmxCSTJBZ0FnQUVFQU93RThJQUJCb05RQU5nSUFJQUJCUUdzUVJCb2dBRUhJQUdvUVJCb0xDQUFnQUVIL0FYRUxDd0FnQUVFSWRrSC9BWEVMQ3dBZ0FFRVFka0gvQVhFTGlnUUNBbjhDZlNBQlFTQVFVQVJBSUFCQlFHc2hBZ0pBSUFBcUFqQkRBQUFBQUZ3RVFDQUFLZ0l3SWdVUXJRRWhCQ0FGRUt3QklRVWdBa0VBRUNZZ0JUZ0NBQ0FDUVFFUUppQUVPQUlBSUFKQkFoQW1JQVNNT0FJQUlBSkJBeEFtSUFVNEFnQWdBa0VFRUNaQkFEWUNBQ0FDUVFVUUprRUFOZ0lBREFFTElBSVE5UU1MSUFBZ0FDZ0NBQ2dDVEJFR0FDRUVJQUJCUUdzaUFrRUVFQ1lnQkRnQ0FDQUFJQUFvQWdBb0FsQVJCZ0FoQkNBQ1FRVVFKaUFFT0FJQUlBQXFBalFoQkNBQUtnSTRJUVVnQWtFQUVDWWlBeUFES2dJQUlBU1VPQUlBSUFKQkFSQW1JZ01nQXlvQ0FDQUVsRGdDQUNBQ1FRSVFKaUlESUFNcUFnQWdCWlE0QWdBZ0FrRURFQ1lpQWlBQ0tnSUFJQVdVT0FJQUN5QUJRY0FBRUZBRVFBSkFJQUJCMkFCcUlRSWdBQ2dDZENJREJFQWdBaUFEUWRnQWFpQUFRVUJyRUwwQkRBRUxJQUJCUUdzaUEwRUFFQ1lxQWdBaEJDQUNRUUFRSmlBRU9BSUFJQU5CQVJBbUtnSUFJUVFnQWtFQkVDWWdCRGdDQUNBRFFRSVFKaW9DQUNFRUlBSkJBaEFtSUFRNEFnQWdBMEVERUNZcUFnQWhCQ0FDUVFNUUppQUVPQUlBSUFOQkJCQW1LZ0lBSVFRZ0FrRUVFQ1lnQkRnQ0FDQURRUVVRSmlvQ0FDRUVJQUpCQlJBbUlBUTRBZ0FMQ3dKQUlBRkJnQUVRVUVVTkFDQUFJQUFxQWp3NEFuQWdBQ2dDZENJQlJRMEFJQUFnQVNBQktBSUFLQUpJRVFZQUlBQXFBbkNVT0FKd0N3c1RBQ0FBS0FJVUJFQWdBQ2dDRkNBQUVIRUxDdzhBSUFBZ0FDZ0NBQ2dDQURZQ0FBc1FBQ0FBS0FJQUlBRW9BZ0JyUVFKMUM4VUJBUU4vSXdCQkVHc2lBQ1FBSUFBZ0FUWUNDQ0FBUVFocUlRSkJCQ0VCUVFRaEF3TkFJQU5CQkU4RVFDQUNLQUFBUVpYVHg5NEZiQ0lFUVJoMklBUnpRWlhUeDk0RmJDQUJRWlhUeDk0RmJITWhBU0FEUVFScklRTWdBa0VFYWlFQ0RBRUxDd0pBQWtBQ1FBSkFJQU5CQVdzT0F3SUJBQU1MSUFJdEFBSkJFSFFnQVhNaEFRc2dBaTBBQVVFSWRDQUJjeUVCQ3lBQklBSXRBQUJ6UVpYVHg5NEZiQ0VCQ3lBQVFSQnFKQUFnQVVFTmRpQUJjMEdWMDhmZUJXd2lBRUVQZGlBQWN3c2dBUUYvSUFCQjZBQnFJZ0FRTWlBQlN3Ui9JQUFnQVJBdktBSUFCVUVBQ3dzTUFDQUFJQUVReWdKQkFYTUxKd0VCZnlNQVFSQnJJZ0VrQUNBQlFRaHFJQUFRNkFFZ0FTZ0NDQ0VBSUFGQkVHb2tBQ0FBQ3lBQUlBQW9BZ1FnQUJBb0tBSUFTUVJBSUFBZ0FSQkpEd3NnQUNBQkVLWURDMVFCQVg4akFFRVFheUlCSkFBZ0FCQ2hBeUFBUVFocUVLQURJQUZCQURZQ0RDQUFRUXhxSUFGQkRHb2dBVUVJYWhDZUF5QUJRWUNBZ1B3RE5nSUVJQUJCRUdvZ0FVRUVhaENmQXlBQlFSQnFKQUFnQUFzUkFDQUFRUmdnQUNnQ0FDZ0NEQkVDQUF0SUFRSi9JQUJCb04wQU5nSUFJQUJCc0FGcUlnRVF2UU1nQVNnQ0FBUkFJQUVnQVNnQ0FCQzZBeUFCRUNnYUlBRW9BZ0FoQWlBQkVJb0JHaUFDRUM0TElBQVFpd0VhSUFBTEt3QWdBQkRhQVNBQVFnVTNBcWdCSUFCQjJCYzJBZ0FnQUVHZzNRQTJBZ0FnQUVHd0FXb1FPaG9nQUFzVEFDQUFRZkFMTmdJQUlBQkJCR29RYnlBQUN3Y0FJQUFRdGdFTENBQWdBRUhzQVdvTFFnRUJmeUFBUVl6YkFEWUNBQ0FBS0FJMElnRUVRQ0FCSUFFb0FnQW9BZ1FSQVFBTElBQW9BamdpQVFSQUlBRWdBU2dDQUNnQ0JCRUJBQXNnQUJCREdpQUFDMmdCQW44akFFRVFheUlFSkFBZ0JFRUFOZ0lNSUFCQkRHb2dCRUVNYWlBREVFY2dBUVJBSUFBb0FoQWdBUkMzQVNFRkN5QUFJQVUyQWdBZ0FDQUZJQUpCQW5ScUlnSTJBZ2dnQUNBQ05nSUVJQUFRTVNBRklBRkJBblJxTmdJQUlBUkJFR29rQUNBQUN3a0FJQUVnQWhCbkdnczBBQ0FBS0FJQUdpQUFLQUlBSUFBUWpRRkJBM1JxR2lBQUtBSUFJQUFRVGtFRGRHb2FJQUFvQWdBZ0FCQ05BVUVEZEdvYUMxVUJBWDhnQUNnQ0JDRUJBMEFnQVNBQUtBSUlSd1JBSUFBb0FoQWFJQUFnQUNnQ0NFRUlhellDQ0F3QkN3c2dBQ2dDQUFSQUlBQW9BaEFhSUFBb0FnQWhBU0FBRURFb0FnQWdBQ2dDQUdzYUlBRVFMZ3NMZWdFQ2Z5TUFRUkJySWdRa0FDQUVRUUEyQWd3Z0FFRU1haUFFUVF4cUlBTVFSeUFCQkVBZ0FDZ0NFQm9nQVVILy8vLy9BVXNFUUJCRkFBc2dBVUVEZEJBbklRVUxJQUFnQlRZQ0FDQUFJQVVnQWtFRGRHb2lBallDQ0NBQUlBSTJBZ1FnQUJBeElBVWdBVUVEZEdvMkFnQWdCRUVRYWlRQUlBQUxsQUVCQTM4akFFRVFheUlDSkFBZ0FpQUJOZ0lNQW44akFFRVFheUlESkFBZ0FCQW9HaUFEUWYvLy8vOEJOZ0lNSUFOQi8vLy8vd2MyQWdnZ0EwRU1haUFEUVFocUVLZ0JLQUlBSVFRZ0EwRVFhaVFBSUFFZ0JFMExCRUFnQUJDTkFTSUFJQVJCQVhaSkJFQWdBaUFBUVFGME5nSUlJQUpCQ0dvZ0FrRU1haEJZS0FJQUlRUUxJQUpCRUdva0FDQUVEd3NRY0FBTEpBQWdBQ0FCTmdJQUlBQWdBU2dDQkNJQk5nSUVJQUFnQVNBQ1FRTjBhallDQ0NBQUN5d0JBWDhnQUJDYUFpQUFLQUlBQkVBZ0FCRGpBeUFBRUNnYUlBQW9BZ0FoQVNBQUVJMEJHaUFCRUM0TEMySUJBbjhnQUVHczF3QTJBZ0FnQUVGQWF4QStJQUJCTkdvUVBpQUFRU2hxSWdFUXp3TWdBU2dDQUFSQUlBRVE0UU1nQVJBb0dpQUJLQUlBSVFJZ0FSQ01BUm9nQWhBdUN5QUFRUnhxRUo4Q0lBQkJFR29RbndJZ0FFRUVhaENmQWlBQUM0VUlBZ2gvQTMwakFFRkFhaUlHSkFBQ1FDQUFRU2hxSUFFUTJBTWlDUzBBQUNJTFJRUkFJQUJCRUdvaUFDQUpMUUFCUVFGckVFMGhBU0FBSUFrdEFBRVFUU0VISUFZUVJDSUFJQWNnQVJDN0FTQUVCRUFnQmtFNGFoQkVJZ1FnQVNBQUlBSVFiQ0FGSUFSQkFCQW1LZ0lBSUFSQkFSQW1LZ0lBSUFVb0FnQW9BaFFSQndBTElBQWdBU0FBSUFNUWJDQUZJQUJCQUJBbUtnSUFJQUJCQVJBbUtnSUFJQVVvQWdBb0FoZ1JCd0FNQVFzZ0MwRUJheUVISUFrdEFBSWhEU0FBUVRScUlBRVFMeW9DQUNFUEFrQUNRQ0FDUXdBQUFBQmJEUUFnQnlBTmFpRU1JQUJCSEdvaENDQVBJQUtVSVE0Z0J5RUJBMEFnQVNBTVRnMEJBa0FnRGlBSUlBRVFUU0lLS2dJRUloQmZCRUFnQVNBSFJ3MEJJQTRnRUpVZ0Npb0NBSlFoQWd3REN5QUJRUUZxSVFFTUFRc0xJQWdnQVVFQmF5SU1FRTBxQWdRaEFpQUtLZ0lFSVJBZ0NDQU1FRTBxQWdBZ0Npb0NBQ0FPSUFLVElCQWdBcE9WRU5jRElRSU1BUXNnQnlFQkN3SjlRd0FBZ0Q4Z0EwTUFBSUEvV3cwQUdpQUJJQXNnRFdwQkFXc2lDQ0FCSUFoS0d5RUxJQUJCSEdvaENDQVBJQU9VSVE0RFFDQURJQUVnQzBZTkFSb0NRQ0FPSUFnZ0FSQk5JZ29xQWdRaUQxOEVRQ0FCSUFkSERRRWdEaUFQbFNBS0tnSUFsQXdEQ3lBQlFRRnFJUUVNQVFzTElBZ2dBVUVCYXlJQkVFMHFBZ1FoQXlBS0tnSUVJUThnQ0NBQkVFMHFBZ0FnQ2lvQ0FDQU9JQU9USUE4Z0E1T1ZFTmNEQ3lFT0lBWkJNR29oQnlBR0lRRURRQ0FCRUVSQkNHb2lBU0FIUncwQUN5QUFRUkJxSWdBZ0NTMEFBVUVCYXhCTklRRWdBQ0FKTFFBQkVFMGhCeUFBSUFrdEFBRkJBV29RVFNFSUlBQWdDUzBBQVVFQ2FoQk5JUUFnQWtNQUFBQUFXd1JBSUFFZ0J5QUlJQUFnRGlBR0VOa0JJQVFFUUNBRklBRkJBQkFtS2dJQUlBRkJBUkFtS2dJQUlBVW9BZ0FvQWhRUkJ3QUxJQVVnQmtFQUVDWXFBZ0FnQmtFQkVDWXFBZ0FnQmtFWWFpSUFRUUFRSmlvQ0FDQUFRUUVRSmlvQ0FDQUdRU2hxSWdCQkFCQW1LZ0lBSUFCQkFSQW1LZ0lBSUFVb0FnQW9BaHdSQ1FBTUFRc2dBU0FISUFnZ0FDQUNJQVlRMlFFZ0JBUkFJQVVnQmtFb2FpSUJRUUFRSmlvQ0FDQUJRUUVRSmlvQ0FDQUZLQUlBS0FJVUVRY0FDeUFPUXdBQWdEOWJCRUFnQlNBR1FTQnFJZ0ZCQUJBbUtnSUFJQUZCQVJBbUtnSUFJQVpCRUdvaUFVRUFFQ1lxQWdBZ0FVRUJFQ1lxQWdBZ0FFRUFFQ1lxQWdBZ0FFRUJFQ1lxQWdBZ0JTZ0NBQ2dDSEJFSkFBd0JDeUFHUVNocUlnRWdCa0VnYWlBR1FSQnFJQUFnRGlBQ2swTUFBSUEvSUFLVGxTQUdFTmtCSUFVZ0JrRUFFQ1lxQWdBZ0JrRUJFQ1lxQWdBZ0JrRVlhaUlBUVFBUUppb0NBQ0FBUVFFUUppb0NBQ0FCUVFBUUppb0NBQ0FCUVFFUUppb0NBQ0FGS0FJQUtBSWNFUWtBQ3lBR1FVQnJKQUFMN1FNQ0JuOERmUU5BSUFCQlFHc2lCUkNrQWtVRVFDQUZLQUlBS0FJQUlRQU1BUXNMQWtBZ0FTQUNXdzBBSUFCQktHb2lDaENPQVNJRlFRQWdCVUVBU2hzaENDQUFRVFJxSVFjRFFDQUdJQWhHRFFFZ0N5QUhJQVlRTHlvQ0FDSU1raUlOSUFGZVJRUkFJQVpCQVdvaEJpQU5JUXNNQVFzTElBWkJmMFlOQUNBRlFRRnJJUWdnQVNBTGt5QU1sU0VOSUFVZ0JpQUZJQVpLR3lFSklBWWhCUU5BQWtBQ2ZTQUZJQWxHQkVBZ0NDRUZRd0FBZ0Q4TUFRc2dDeUFISUFVUUx5b0NBQ0lNa2lJQklBSmdSUTBCSUFJZ0M1TWdESlVMSVFJZ0RSRGxBeUVCSUFJUTVRTWhBaUFGSUFaR0JFQWdBQ0FHSUFFZ0FpQURJQVFRb1FJUEN5QUFJQVlnQVVNQUFJQS9JQU1nQkJDaEFpQUFRUkJxSVFnRFFDQUZJQVpCQVdvaUJrd0VRQ0FBSUFWREFBQUFBQ0FDUVFBZ0JCQ2hBZ3dFQ3lBS0lBWVEyQU1pQnkwQUFDRUpJQWdnQnkwQUFSQk5JUU1nQ1FSQUlBZ2dCeTBBQVVFQmFoQk5JUWtnQ0NBSExRQUJRUUpxRUUwaEJ5QUVJQU5CQUJBbUtnSUFJQU5CQVJBbUtnSUFJQWxCQUJBbUtnSUFJQWxCQVJBbUtnSUFJQWRCQUJBbUtnSUFJQWRCQVJBbUtnSUFJQVFvQWdBb0Fod1JDUUFGSUFRZ0EwRUFFQ1lxQWdBZ0EwRUJFQ1lxQWdBZ0JDZ0NBQ2dDR0JFSEFBc01BQXNBQ3lBRlFRRnFJUVVnQVNFTERBQUxBQXNMOFFNQ0JYOEJmU01BUVRCcklnZ2tBQUpBQW44akFFRVFheUlMSkFBZ0MwRUlhaEJFSVF3Z0N4QkVJUW9nRENBQUlBTkRxNnFxUGhCL0lBb2dBQ0FEUTZ1cUtqOFFmMEVCSVFrZ0FTQU1FTk1EUlFSQUlBSWdDaERUQXlFSkN5QUxRUkJxSkFBZ0NRc0VRQ0FGSUFhU0lRMGdDRUV3YWlFS0lBZ2hDUU5BSUFrUVJFRUlhaUlKSUFwSERRQUxJQUFnQVNBQ0lBTkRBQUFBUHlBSUVOa0JJQWhCS0dvaUFTQUlRU0JxSUFoQkVHb2dBeUFBSUFnZ0NFRVlhaUFCSUFRZ0JTQU5Rd0FBQUQrVUlnUWdCeENqQWlBRUlBWWdCeENqQWlFRURBRUxJQUFnQXhEMEF5SUZJQVNTSVFRZ0JVUE56RXc5WGtVTkFDQUlJQVlnQkJCQUlRSUNRQ0FIS0FJRUlBY1FLQ2dDQUVrRVFDTUFRUkJySWdBa0FDQUFJQWRCQVJDZUFpRUJJQWNRS0NBQktBSUVJQUlRMGdNZ0FTQUJLQUlFUVFocU5nSUVJQUVRYVNBQVFSQnFKQUFNQVFzakFFRWdheUlCSkFBZ0J4QW9JZ0FnQVVFSWFpQUhJQWNRVGtFQmFoQ2RBaUFIRUU0Z0FCQ2NBaUlES0FJSUlBSVEwZ01nQXlBREtBSUlRUWhxTmdJSUlBY1FtZ0lnQnhBb0lBY29BZ0FnQnlnQ0JDQURRUVJxSWdBUTZnRWdCeUFBRURVZ0IwRUVhaUFEUVFocUVEVWdCeEFvSUFNUU1SQTFJQU1nQXlnQ0JEWUNBQ0FISUFjUVRoRFFBeUFERUpzQ0lBRkJJR29rQUFzTElBaEJNR29rQUNBRUN3MEFJQUFvQWdBZ0FDZ0NCRVlMRmdFQmZ5QUFFRTRoQVNBQUVPTURJQUFnQVJEaUF3c1hBQ0FBRUtjQ0JFQWdBQ2dDT0JCK0R3c2dBQkRxQXdzS0FDQUFLQUk0UVFCSEN3NEFJQUJCQURvQVBTQUFFTFlCQ3c0QUlBQkJBRG9BUENBQUVMWUJDdzRBSUFCQkFEc0JQQ0FBRUxZQkN4RUFJQUJCQWlBQUtBSUFLQUlNRVFJQUN4RUFJQUJCRFNBQUtBSUFLQUlNRVFJQUM0b0JBUVY5SUFGQkFCQW1LZ0lBSVFZZ0FVRUJFQ1lxQWdBaEJ5QUNRUUFRSmlvQ0FDRURJQUpCQWhBbUtnSUFJUVFnQWtFRUVDWXFBZ0FoQlNBQVFRQVFKaUFGSUFZZ0E1UWdCeUFFbEpLU09BSUFJQUpCQVJBbUtnSUFJUU1nQWtFREVDWXFBZ0FoQkNBQ1FRVVFKaW9DQUNFRklBQkJBUkFtSUFVZ0JpQURsQ0FISUFTVWtwSTRBZ0FMTXdBZ0FCQjBJQUJDLy8vLy93ODNBakFnQUVIVXpRQTJBZ0FnQUVFQU5nSkFJQUJDQURjQ09DQUFRZVRwQURZQ0FDQUFDeG9BSUFCQnhNWUFOZ0lBSUFCQi9BQnFFRDRnQUJCREdpQUFDNThDQWcxOUFYOGdCRUVBRUNZcUFnQWhEaUFFUVFJUUppb0NBQ0VQSUFSQkJCQW1LZ0lBSVJBZ0JFRUJFQ1lxQWdBaEVTQUVRUU1RSmlvQ0FDRVNJQVJCQlJBbUtnSUFJUk1EUUNBVVFRUkdSUVJBSUJRZ0F4Q09CQ0lFQkVBZ0RTQUVza01BQUg5RGxTSUhJQVVnRkNBQ0VJNEVRUmhzSWdScUtnSUFsSkloRFNBTUlBY2dCU0FFUVFSeWFpSUVLZ0lBbEpJaERDQUpJQWNnQkNvQ0RKU1NJUWtnQ2lBSElBUXFBZ2lVa2lFS0lBc2dCeUFFS2dJRWxKSWhDeUFJSUFjZ0JDb0NFSlNTSVFnTElCUkJBV29oRkF3QkN3c2dCa0VBRUNZZ0NTQVJJQUNVSUJJZ0FaU1NJQk9TSWdjZ0M1UWdEaUFBbENBUElBR1VraUFRa2lJQUlBMlVrcEk0QWdBZ0JrRUJFQ1lnQ0NBSElBcVVJQUFnREpTU2tqZ0NBQXNSQUNBQVFTZ2dBQ2dDQUNnQ0RCRUNBQXNzQUNBQUVIUWdBRUwvZ1lDQUVEY0NNQ0FBUWFBUU5nSUFJQUJCeU1vQU5nSUFJQUJCT0dvUVJCb2dBQXR0QVFOL0l3QkJFR3NpQVNRQUlBQkJ0TU1BTmdJQUlBRWdBRUVZYWlJQ0VDbzJBZ2dnQVNBQ0VDczJBZ0FEUUNBQlFRaHFJQUVRTEFSQUlBRW9BZ2dvQWdBaUF3UkFJQU1nQXlnQ0FDZ0NCQkVCQUFzZ0FVRUlhaEF0R2d3QkN3c2dBaEErSUFGQkVHb2tBQ0FBQ3d3QUlBQW9BZ1JCQVRvQUJBc1pBQ0FBSUFFMkFnZ2dBQ0FDTmdJRUlBQkJ5TUVBTmdJQUN4d0FJQUFnQVNnQ01EWUNNQ0FBSUFFb0FqUTJBalFnQUNBQkVHZ0w0Z1FDQlg4RGZTQUFLQUlBSWdJcUFoZ2hDU0FBSUFBcUFnZ2lCemdDRENBQUlBY2dBWkk0QWdnZ0FDQUFLZ0lFSUFrZ0FaUWdBQ2dDRkxLVWtqZ0NCQ0FDS0FJUUlRTWdBQ29DQkNFQklBSXRBQ2dFUUNBQ0tBSWdJUVFMSUFPeUlRZ0NmeUFDTFFBb0JFQWdBaWdDSkF3QkN5QUNLQUlVQ3lFRklBRWdDSlFoQVVFQUlRTWdBRUVBTmdJUUFrQUNRQUpBQWtBQ1FBSkFBa0FnQUNnQ0hDSUNRWDlHQkg4Z0FDZ0NBQ2dDSEFVZ0Fnc09Bd0FCQXdJTElBQW9BaFFoQXdKQUlBRWdCYklpQjE1RkRRQkJBU0VDSUFOQkFVY05BQ0FBSUFjZ0NKVTRBZ1FnQUNBQklBZVRJQWlWT0FJUURBWUxJQUVnQkxJaUIxMUZJQU5CZjBkeURRRWdBQ0FISUFpVk9BSUVJQUFnQnlBQmt5QUlsVGdDRUF3RUN5QUZJQVJySVFJZ0FDZ0NGQ0VEQWtBZ0FTQUZzaUlIWUVVTkFFRUJJUVlnQTBFQlJ3MEFJQUFnQVNBSGt5QUlsVGdDRUNBQUlBQXFBZ1FnQ0pRZ0JMS1RJQUlRb0FRZ0JMZWd0aUFJbFRnQ0JBd0VDeUFCSUFTeUlnZGZSUTBBSUFOQmYwWU5BZ3RCQVNFR1FRQWhBZ3dEQ3lBQUtBSVVJUUlnQkxJaEJ5QUZzaUVKQTBBZ0FBSjlJQUVnQ1dCRklBSkJBVWR5UlFSQVFYOGhBaUFBUVg4MkFoUWdBQ0FCSUFtVElBaVZPQUlRSUFrZ0FaTWdDWklNQVFzZ0FTQUhYVUVBSUFKQmYwWWJSUVJBUVFFaEJpQURJUUlNQlF0QkFTRUNJQUJCQVRZQ0ZDQUFJQWNnQVpNaUFTQUlsVGdDRUNBQklBZVNDeUlCSUFpVk9BSUVRUUVoQXd3QUN3QUxJQUFnQnlBQmt5QUlsVGdDRUNBQUlBVzNJQWNnQUNvQ0JDQUlsSk1nQWhDZ0JKbWh0aUFJbFRnQ0JFRUJJUVlMUVFFaEFnc2dBQ0FDT2dBWUlBWUxSQUVCZlNBQUlBRTJBZ0FnQVMwQUtBUkFJQUVvQWlDeUlBRW9BaEN5bFNFQ0N5QUFRWDgyQWh3Z0FFS0FnSUNBRURjQ0VDQUFRZ0EzQWdnZ0FDQUNPQUlFSUFBTEp3QUNmeUFBTFFBb0JFQWdBQ2dDSkF3QkN5QUFLQUlVQzdJZ0FDZ0NFTEtWSUFBUW9RU1RDOG9EQWdsL0FYMGpBRUVRYXlJR0pBQWdCaUFBUVN4cUlnQVFLallDQ0NBR0lBQVFLellDQUFOQUlBWkJDR29nQmhBc0JFQWdCaWdDQ0NnQ0FDRUFJd0JCRUdzaUJ5UUFBa0FnQVNBQUtBSUVJQUVvQWdBb0FsQVJBZ0FpQ0VVTkFDQUhJQUJCQ0dvaUFCQXFOZ0lJSUFjZ0FCQXJOZ0lBQTBBZ0IwRUlhaUFIRUN4RkRRRkJBQ0VFSUFjb0FnZ29BZ0FpQ2tFSWFpSUpFRElpQ3lFRkEwQWdCVUVCYXlFTUFrQURRQ0FFSUFWT0JFQWdCQ0VBREFJTElBSWdDU0FFSUF4cVFRRjFJZ0FRTHlnQ0FDb0NGQ0lOWGdSQUlBQkJBV29oQkF3QkN3c2dBQ0VGSUFJZ0RWME5BUXNMSUFvb0FnUWhCUUpBSUFCRkJFQWdDVUVBRUM4b0FnQWlBQ0FJSUFVZ0F5QUFLQUlBS0FJd0VRc0FEQUVMSUFrZ0FFRUJheEF2S0FJQUlRUWdBQ0FMU0FSQUlBSWdDU0FBRUM4b0FnQWlBQ29DRkZzRVFDQUFJQWdnQlNBRElBQW9BZ0FvQWpBUkN3QU1BZ3NnQkNnQ0NFVUVRQ0FFSUFnZ0JTQURJQVFvQWdBb0FqQVJDd0FNQWdzZ0JDQUlJQVVnQWlBQUlBTWdCQ2dDQUNnQ05CRVZBQXdCQ3lBRUlBZ2dCU0FESUFRb0FnQW9BakFSQ3dBTElBZEJDR29RTFJvTUFBc0FDeUFIUVJCcUpBQWdCa0VJYWhBdEdnd0JCU0FHUVJCcUpBQUxDd3NoQUNBQklBQW9BakJIQkVBZ0FDQUJOZ0l3SUFBZ0FDZ0NBQ2dDT0JFQkFBc0xCd0FnQUNvQ0JBczBBQ0FBS0FJQUdpQUFLQUlBSUFBUWxRRkJBblJxR2lBQUtBSUFJQUFRTWtFQ2RHb2FJQUFvQWdBZ0FCQ1ZBVUVDZEdvYUN4UUFJQUJCckRnMkFnQWdBRUVJYWhEQ0JDQUFDeVFCQW44akFFRVFheUlDSkFBZ0FDQUJFTHdFSVFNZ0FrRVFhaVFBSUFFZ0FDQURHd3NKQUNBQVFRQTJBZ0FMQ3dBZ0FTQUNRU2dRWmhvTEZBQWdBRUdBTnpZQ0FDQUFRUWhxRU1JRUlBQUxEUUFnQUNnQ0FDQUJRU2hzYWdzT0FDQUFLQUlJUWYvLy8vOEhjUXNaQUNBQVFiUTJOZ0lBSUFCQkVHb1FQaUFBRU9JQkdpQUFDdzBBSUFBb0FnQWdBU2dDQUVrTExBQWdBQ2dDQUJvZ0FDZ0NBQ0FBRUpVQlFRSjBhaG9nQUNnQ0FDQUFFSlVCUVFKMGFob2dBQ2dDQUJvTENRQWdBQ0FCT2dBTEN4RUFJQUJCT0NBQUtBSUFLQUlNRVFJQUN3MEFJQUFvQWdBZ0FTZ0NBRVlMR2dBZ0FVR2xBVVlFUUNBQUlBSVFOallDQkFzZ0FVR2xBVVlMRXdBZ0FDZ0NBQ0FCSUFBcUFnUWdBaEM2QWdzN0FDQUFFTzRFSUFCQ0FEY0NEQ0FBUXYvLy8vOFBOd0lFSUFCQnZEQTJBZ0FnQUVFQU5nSVVJQUJCdE1NQU5nSUFJQUJCR0dvUU9ob2dBQXRaQVFKL0l3QkJFR3NpQWlRQUlBQVFoUUVFUUNBQUtBSUFJUU1nQUJERUFob2dBeEF1Q3lBQUlBRW9BZ2cyQWdnZ0FDQUJLUUlBTndJQUlBRkJBQkRJQWlBQ1FRQTZBQThnQVNBQ1FROXFFT2tCSUFKQkVHb2tBQXNZQUNBQUVOOEVJQUJCc0MwMkFnQWdBRUdZd1FBMkFnQUxPQUVCZnlNQVFSQnJJZ01rQUNBQlFZb0JSZ1JBSUFNZ0FoRE1BU0FBUVFScUlBTVF6Z0lnQXhCdkN5QURRUkJxSkFBZ0FVR0tBVVlMS3dBZ0FCQmlJQUJCZnpZQ0RDQUFRZ0EzQWdRZ0FFR01LallDQUNBQVFRQTJBaEFnQUVINE96WUNBQXNNQUNBQUVNTUJHaUFBRUM0TE9nQWdBQkQ0QkNBQVFjUUpOZ0lBSUFCQjZBZzJBZ0FnQUVFQU5nSjRJQUJCaUFnMkFnQWdBRUhFeGdBMkFnQWdBRUg4QUdvUU9ob2dBQXNqQUNBQVFjRDRBRFlDUkNBQVFlVDNBRFlDQUNBQVFkUUFhaEErSUFBUVF4b2dBQXRaQVFGL0lBQVFtQUVnQUVJQU53SXdJQUJCc0NBMkFnQWdBRUlBTndJNElBQkJnSUNBL0FNMkFrQWdBRUhFQUdvUTl3UWhBU0FBUWVUM0FEWUNBQ0FCUWNENEFEWUNBQ0FBUWRRQWFoQTZHaUFBUVFBMkFtQWdBQXNmQUNBQlFTbEdCRUFnQUNBQ0VJa0JPZ0F1UVFFUEN5QUFJQUVnQWhCYkN3TUFBUXRaQUFKQUFrQUNRQUpBQWtBZ0FVRVBhdzRFQUFFQ0F3UUxJQUFnQWhBd3RqZ0NNRUVCRHdzZ0FDQUNFREMyT0FJMFFRRVBDeUFBSUFJUU1MWTRBamhCQVE4TElBQWdBaEF3dGpnQ1BFRUJEd3NnQUNBQklBSVFXd3M0QUFKQUFrQUNRQ0FCUVExckRnSUFBUUlMSUFBZ0FoQXd0amdDZUVFQkR3c2dBQ0FDRURDMk9BSjhRUUVQQ3lBQUlBRWdBaERZQWdzZEFDQUFJQUVxQW5nNEFuZ2dBQ0FCS2dKOE9BSjhJQUFnQVJDa0JBc3pBQ0FCQW44Z0FpZ0NURUYvVEFSQUlBQWdBU0FDRU53Q0RBRUxJQUFnQVNBQ0VOd0NDeUlBUmdSQUR3c2dBQ0FCYmhvTGtBSUJBMzhDUUNBQklBSW9BaEFpQkFSL0lBUUZRUUFoQkFKL0lBSWdBaTBBU2lJRFFRRnJJQU55T2dCS0lBSW9BZ0FpQTBFSWNRUkFJQUlnQTBFZ2NqWUNBRUYvREFFTElBSkNBRGNDQkNBQ0lBSW9BaXdpQXpZQ0hDQUNJQU0yQWhRZ0FpQURJQUlvQWpCcU5nSVFRUUFMRFFFZ0FpZ0NFQXNnQWlnQ0ZDSUZhMHNFUUNBQ0lBQWdBU0FDS0FJa0VRUUFEd3NDZnlBQ0xBQkxRWDlLQkVBZ0FTRUVBMEFnQVNBRUlnTkZEUUlhSUFBZ0EwRUJheUlFYWkwQUFFRUtSdzBBQ3lBQ0lBQWdBeUFDS0FJa0VRUUFJZ1FnQTBrTkFpQUFJQU5xSVFBZ0FpZ0NGQ0VGSUFFZ0Eyc01BUXNnQVFzaEJDQUZJQUFnQkJCbUdpQUNJQUlvQWhRZ0JHbzJBaFFnQVNFRUN5QUVDMGNBSUFBZ0FVa0VRQ0FBSUFFZ0FoQm1HZzhMSUFJRVFDQUFJQUpxSVFBZ0FTQUNhaUVCQTBBZ0FFRUJheUlBSUFGQkFXc2lBUzBBQURvQUFDQUNRUUZySWdJTkFBc0xDd1FBUVFFTEVBQWdBZ1JBSUFBZ0FTQUNFR1lhQ3dzSkFDQUFJQUUyQWdRTGRnRURmeU1BUVJCcklnTWtBQ0FDUVc5TkJFQUNRQ0FDUVFwTkJFQWdBQ0FDRU1nQ0lBQWhCQXdCQ3lBQUlBSVFpd1ZCQVdvaUJSQW5JZ1FRNkFFZ0FDQUZFSW9GSUFBZ0FoRGdBZ3NnQkNBQklBSVEzd0lnQTBFQU9nQVBJQUlnQkdvZ0EwRVBhaERwQVNBRFFSQnFKQUFQQ3hCd0FBc1dBQ0FBUlFSQVFRQVBDMEhnd0FFZ0FEWUNBRUYvQ3lnQkFYOGpBRUVRYXlJREpBQWdBeUFDTmdJTUlBQWdBU0FDUVFCQkFCQ1JCU0FEUVJCcUpBQUxJUUFnQVVHQUFVWUVRQ0FBSUFJUU5qWUNnQUZCQVE4TElBQWdBU0FDRU5rQ0M3RVRBZzkvQVg0akFFSFFBR3NpQ0NRQUlBZ2dBVFlDVENBSVFUZHFJUlVnQ0VFNGFpRVNRUUFoQVFKQUEwQUNRQ0FPUVFCSURRQkIvLy8vL3djZ0Rtc2dBVWdFUUVIZ3dBRkJQVFlDQUVGL0lRNE1BUXNnQVNBT2FpRU9DeUFJS0FKTUlnc2hBUUpBQWtBQ1FDQUxMUUFBSWdjRVFBTkFBa0FDUUNBSFFmOEJjU0lIUlFSQUlBRWhCd3dCQ3lBSFFTVkhEUUVnQVNFSEEwQWdBUzBBQVVFbFJ3MEJJQWdnQVVFQ2FpSUpOZ0pNSUFkQkFXb2hCeUFCTFFBQ0lROGdDU0VCSUE5QkpVWU5BQXNMSUFjZ0Myc2hBU0FBQkVBZ0FDQUxJQUVRVHdzZ0FRMEdJQWdvQWt3c0FBRVF4QUVoQnlBSUtBSk1JUUVnQ0FKL0FrQWdCMFVOQUNBQkxRQUNRU1JIRFFBZ0FTd0FBVUV3YXlFUlFRRWhFeUFCUVFOcURBRUxRWDhoRVNBQlFRRnFDeUlCTmdKTVFRQWhDUUpBSUFFc0FBQWlFRUVnYXlJSFFSOUxEUUJCQVNBSGRDSUhRWW5SQkhGRkRRQURRQUpBSUFnZ0FVRUJhaUlKTmdKTUlBRXNBQUVpRUVFZ2F5SUJRU0JQRFFCQkFTQUJkQ0lCUVluUkJIRkZEUUFnQVNBSGNpRUhJQWtoQVF3QkN3c2dDU0VCSUFjaENRc0NRQ0FRUVNwR0JFQWdDQUovQWtBZ0FTd0FBUkRFQVVVTkFDQUlLQUpNSWdFdEFBSkJKRWNOQUNBQkxBQUJRUUowSUFScVFjQUJhMEVLTmdJQUlBRXNBQUZCQTNRZ0EycEJnQU5yS0FJQUlReEJBU0VUSUFGQkEyb01BUXNnRXcwR1FRQWhFMEVBSVF3Z0FBUkFJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBRW9BZ0FoREFzZ0NDZ0NURUVCYWdzaUFUWUNUQ0FNUVg5S0RRRkJBQ0FNYXlFTUlBbEJnTUFBY2lFSkRBRUxJQWhCekFCcUVKQUZJZ3hCQUVnTkJDQUlLQUpNSVFFTFFYOGhDZ0pBSUFFdEFBQkJMa2NOQUNBQkxRQUJRU3BHQkVBQ1FDQUJMQUFDRU1RQlJRMEFJQWdvQWt3aUFTMEFBMEVrUncwQUlBRXNBQUpCQW5RZ0JHcEJ3QUZyUVFvMkFnQWdBU3dBQWtFRGRDQURha0dBQTJzb0FnQWhDaUFJSUFGQkJHb2lBVFlDVEF3Q0N5QVREUVVnQUFSL0lBSWdBaWdDQUNJQlFRUnFOZ0lBSUFFb0FnQUZRUUFMSVFvZ0NDQUlLQUpNUVFKcUlnRTJBa3dNQVFzZ0NDQUJRUUZxTmdKTUlBaEJ6QUJxRUpBRklRb2dDQ2dDVENFQkMwRUFJUWNEUUNBSElSUkJmeUVOSUFFc0FBQkJ3UUJyUVRsTERRZ2dDQ0FCUVFGcUloQTJBa3dnQVN3QUFDRUhJQkFoQVNBSElCUkJPbXhxUWIreUFXb3RBQUFpQjBFQmEwRUlTUTBBQ3dKQUFrQWdCMEVUUndSQUlBZEZEUW9nRVVFQVRnUkFJQVFnRVVFQ2RHb2dCellDQUNBSUlBTWdFVUVEZEdvcEF3QTNBMEFNQWdzZ0FFVU5DQ0FJUVVCcklBY2dBaUFHRUk4RklBZ29Ba3doRUF3Q0N5QVJRWDlLRFFrTFFRQWhBU0FBUlEwSEN5QUpRZi8vZTNFaUR5QUpJQWxCZ01BQWNSc2hCMEVBSVExQjRMSUJJUkVnRWlFSkFrQUNRQUpBQW44Q1FBSkFBa0FDUUFKL0FrQUNRQUpBQWtBQ1FBSkFBa0FnRUVFQmF5d0FBQ0lCUVY5eElBRWdBVUVQY1VFRFJoc2dBU0FVR3lJQlFkZ0FhdzRoQkJRVUZCUVVGQlFVRGhRUEJnNE9EaFFHRkJRVUZBSUZBeFFVQ1JRQkZCUUVBQXNDUUNBQlFjRUFhdzRIRGhRTEZBNE9EZ0FMSUFGQjB3QkdEUWtNRXdzZ0NDa0RRQ0VXUWVDeUFRd0ZDMEVBSVFFQ1FBSkFBa0FDUUFKQUFrQUNRQ0FVUWY4QmNRNElBQUVDQXdRYUJRWWFDeUFJS0FKQUlBNDJBZ0FNR1FzZ0NDZ0NRQ0FPTmdJQURCZ0xJQWdvQWtBZ0RxdzNBd0FNRndzZ0NDZ0NRQ0FPT3dFQURCWUxJQWdvQWtBZ0Rqb0FBQXdWQ3lBSUtBSkFJQTQyQWdBTUZBc2dDQ2dDUUNBT3JEY0RBQXdUQ3lBS1FRZ2dDa0VJU3hzaENpQUhRUWh5SVFkQitBQWhBUXNnRWlFTElBRkJJSEVoRHlBSUtRTkFJaFpRUlFSQUEwQWdDMEVCYXlJTElCYW5RUTl4UWRDMkFXb3RBQUFnRDNJNkFBQWdGa0lFaUNJV1FnQlNEUUFMQ3lBSFFRaHhSUTBESUFncEEwQlFEUU1nQVVFRWRrSGdzZ0ZxSVJGQkFpRU5EQU1MSUJJaEFTQUlLUU5BSWhaUVJRUkFBMEFnQVVFQmF5SUJJQmFuUVFkeFFUQnlPZ0FBSUJaQ0E0Z2lGa0lBVWcwQUN3c2dBU0VMSUFkQkNIRkZEUUlnQ2lBU0lBdHJJZ0ZCQVdvZ0FTQUtTQnNoQ2d3Q0N5QUlLUU5BSWhaQ2YxY0VRQ0FJUWdBZ0ZuMGlGamNEUUVFQklRMUI0TElCREFFTElBZEJnQkJ4QkVCQkFTRU5RZUd5QVF3QkMwSGlzZ0ZCNExJQklBZEJBWEVpRFJzTElSRWdGaUFTRUtzQklRc0xJQWRCLy85N2NTQUhJQXBCZjBvYklRY2dDaUFJS1FOQUloWlFSWEpGQkVCQkFDRUtJQkloQ3d3TUN5QUtJQlpRSUJJZ0MydHFJZ0VnQVNBS1NCc2hDZ3dMQ3dKL0lBb2lBVUVBUnlFSkFrQUNRQUpBSUFGRklBZ29Ba0FpQjBIcXNnRWdCeHNpQ3lJSFFRTnhSWElOQUFOQUlBY3RBQUJGRFFJZ0IwRUJhaUVISUFGQkFXc2lBVUVBUnlFSklBRkZEUUVnQjBFRGNRMEFDd3NnQ1VVTkFRc0NRQ0FITFFBQVJTQUJRUVJKY2cwQUEwQWdCeWdDQUNJSlFYOXpJQWxCZ1lLRUNHdHhRWUNCZ29SNGNRMEJJQWRCQkdvaEJ5QUJRUVJySWdGQkEwc05BQXNMSUFGRkRRQURRQ0FISUFjdEFBQkZEUUlhSUFkQkFXb2hCeUFCUVFGcklnRU5BQXNMUVFBTElnRWdDaUFMYWlBQkd5RUpJQThoQnlBQklBdHJJQW9nQVJzaENnd0tDeUFLQkVBZ0NDZ0NRQXdDQzBFQUlRRWdBRUVnSUF4QkFDQUhFRmtNQWdzZ0NFRUFOZ0lNSUFnZ0NDa0RRRDRDQ0NBSUlBaEJDR28yQWtCQmZ5RUtJQWhCQ0dvTElRbEJBQ0VCQWtBRFFDQUpLQUlBSWd0RkRRRWdDRUVFYWlBTEVKTUZJZ3RCQUVnaUR5QUxJQW9nQVd0TGNrVUVRQ0FKUVFScUlRa2dDaUFCSUF0cUlnRkxEUUVNQWdzTFFYOGhEU0FQRFFzTElBQkJJQ0FNSUFFZ0J4QlpJQUZGQkVCQkFDRUJEQUVMUVFBaENTQUlLQUpBSVJBRFFDQVFLQUlBSWd0RkRRRWdDRUVFYWlBTEVKTUZJZ3NnQ1dvaUNTQUJTZzBCSUFBZ0NFRUVhaUFMRUU4Z0VFRUVhaUVRSUFFZ0NVc05BQXNMSUFCQklDQU1JQUVnQjBHQXdBQnpFRmtnRENBQklBRWdERWdiSVFFTUNBc2dBQ0FJS3dOQUlBd2dDaUFISUFFZ0JSRWZBQ0VCREFjTElBZ2dDQ2tEUUR3QU4wRUJJUW9nRlNFTElBOGhCd3dFQ3lBSUlBRkJBV29pQ1RZQ1RDQUJMUUFCSVFjZ0NTRUJEQUFMQUFzZ0RpRU5JQUFOQkNBVFJRMENRUUVoQVFOQUlBUWdBVUVDZEdvb0FnQWlBQVJBSUFNZ0FVRURkR29nQUNBQ0lBWVFqd1ZCQVNFTklBRkJBV29pQVVFS1J3MEJEQVlMQzBFQklRMGdBVUVLVHcwRUEwQWdCQ0FCUVFKMGFpZ0NBQTBCSUFGQkFXb2lBVUVLUncwQUN3d0VDMEYvSVEwTUF3c2dBRUVnSUEwZ0NTQUxheUlQSUFvZ0NpQVBTQnNpQ21vaUNTQU1JQWtnREVvYklnRWdDU0FIRUZrZ0FDQVJJQTBRVHlBQVFUQWdBU0FKSUFkQmdJQUVjeEJaSUFCQk1DQUtJQTlCQUJCWklBQWdDeUFQRUU4Z0FFRWdJQUVnQ1NBSFFZREFBSE1RV1F3QkN3dEJBQ0VOQ3lBSVFkQUFhaVFBSUEwTHl3RUJBbjhqQUVFUWF5SUJKQUFDUUNBQXZVSWdpS2RCLy8vLy93ZHhJZ0pCKzhPay93Tk5CRUFnQWtHQWdNRHlBMGtOQVNBQVJBQUFBQUFBQUFBQVFRQVF4Z0VoQUF3QkN5QUNRWUNBd1A4SFR3UkFJQUFnQUtFaEFBd0JDd0pBQWtBQ1FBSkFJQUFnQVJDVkJVRURjUTREQUFFQ0F3c2dBU3NEQUNBQkt3TUlRUUVReGdFaEFBd0RDeUFCS3dNQUlBRXJBd2dReFFFaEFBd0NDeUFCS3dNQUlBRXJBd2hCQVJER0Fab2hBQXdCQ3lBQkt3TUFJQUVyQXdnUXhRR2FJUUFMSUFGQkVHb2tBQ0FBQzJvQUFrQUNRQUpBQWtBQ1FBSkFJQUZCRkdzT0FnRUNBQXNnQVVIN0FHc09BZ0lEQkFzZ0FDQUNFREMyT0FLWUFVRUJEd3NnQUNBQ0VEQzJPQUtjQVVFQkR3c2dBQ0FDRURDMk9BS2dBVUVCRHdzZ0FDQUNFREMyT0FLa0FVRUJEd3NnQUNBQklBSVE1QUlMeHdFQkFuOGpBRUVRYXlJQkpBQUNmQ0FBdlVJZ2lLZEIvLy8vL3dkeElnSkIrOE9rL3dOTkJFQkVBQUFBQUFBQThEOGdBa0dld1pyeUEwa05BUm9nQUVRQUFBQUFBQUFBQUJERkFRd0JDeUFBSUFDaElBSkJnSURBL3dkUERRQWFBa0FDUUFKQUFrQWdBQ0FCRUpVRlFRTnhEZ01BQVFJREN5QUJLd01BSUFFckF3Z1F4UUVNQXdzZ0FTc0RBQ0FCS3dNSVFRRVF4Z0dhREFJTElBRXJBd0FnQVNzRENCREZBWm9NQVFzZ0FTc0RBQ0FCS3dNSVFRRVF4Z0VMSVFBZ0FVRVFhaVFBSUFBTERBQWdBU0FBS0FJQUVRQUFDMUVCQW44akFFRVFheUlDSkFBZ0FDZ0NBQ0VESUFJZ0FDZ0NCQ0lBUVFGMUlBRnFJZ0VnQUVFQmNRUi9JQUVvQWdBZ0Eyb29BZ0FGSUFNTEVRQUFOZ0lNSUFJb0Fnd2hBQ0FDUVJCcUpBQWdBQXNUQUNBQUlBRW9BZ0EyQWdBZ0FVRUFOZ0lBQ3d3QUlBRWdBQ2dDQUJFQkFBc0pBQ0FBUVFFNkFBUUxDUUFnQUNBQkVQY0JDek1CQVg4Z0FDZ0NBQ0VDSUFFZ0FDZ0NCQ0lBUVFGMWFpSUJJQUJCQVhFRWZ5QUJLQUlBSUFKcUtBSUFCU0FDQ3hFQUFBc09BRUhLdndFZ0FTQUNFQWtnQUFzT0FFSEp2d0VnQVNBQ0VBa2dBQXVGVmdJRmZ3RitRWkMrQVJCVUdrR292Z0VRVkJwQndMNEJFRlFhSXdCQm9BMXJJZ0FrQUNNQVFSQnJJZ0VrQUVHdy9RQkJBa0dBaVFGQmlJa0JRZk1IUWRjR0VDUWdBVUVRYWlRQVFmYStBVUgzdmdGQitMNEJRUUJCaklrQlFkZ0dRWStKQVVFQVFZK0pBVUVBUWJYOUFFR1JpUUZCMlFZUUFpQUFRb2lBZ0lBUU53T1lDQ0FBUW9pQWdJQVFOd09ZRFVHKy9RQWdBRUdZQ0dvUTh3SWdBRUtNZ0lDQUVEY0RrQWdnQUVLTWdJQ0FFRGNEbUExQncvMEFJQUJCa0FocUVQTUNJQUJDa0lDQWdCQTNBNGdJSUFCQ2tJQ0FnQkEzQTVnTkl3QkJFR3NpQVNRQUlBRWdBRUdJQ0dvcEFnQTNBd2hCK2I0QlFjdjlBRUVEUWFDSkFVR3NpUUZCOVFjZ0FVRUlhaEEzUVFFUUFDQUJRUkJxSkFBZ0FFS1VnSUNBRURjRGdBZ2dBRUtVZ0lDQUVEY0RtQTBqQUVFUWF5SUJKQUFnQVNBQVFZQUlhaWtDQURjRENFSDV2Z0ZCMWYwQVFRUkJ3SWtCUWRDSkFVSDJCeUFCUVFocUVEZEJBUkFBSUFGQkVHb2tBQ0FBUXBpQWdJQVFOd1A0QnlBQVFwaUFnSUFRTndPWURTTUFRUkJySWdFa0FDQUJJQUFwQXZnSE53TUlRZm0rQVVIZS9RQkJBMEhZaVFGQnJJa0JRZmNISUFGQkNHb1FOMEVCRUFBZ0FVRVFhaVFBSUFCQkFEWUNuQTBnQUVIYUJqWUNtQTBnQUNBQUtRT1lEVGNEOEFjakFFRVFheUlCSkFBZ0FTQUFLUUx3QnpjRENFSDJ2Z0ZCNS8wQVFRWkI4SWtCUVlpS0FVSDRCeUFCUVFocUVEZEJBQkFBSUFGQkVHb2tBRUg1dmdGQityNEJRZisrQVVIMnZnRkJqSWtCUWRzR1FZeUpBVUg1QjBHTWlRRkIrZ2RCN2YwQVFaR0pBVUhjQmhBQ0l3QkJFR3NpQVNRQUlBRkIrd2MyQWd4QitiNEJRWkNLQVVFQ1FiaUtBVUdjaVFGQi9BY2dBVUVNYWhCNFFRQVFBQ0FCUVJCcUpBQkI5cjRCUWFTS0FVRUNRY0NLQVVHSWlRRkIzUVpCM2dZUUNFSDJ2Z0ZCcm9vQlFRTkI0SXNCUWV5TEFVSGZCa0hnQmhBSVFhRy9BVUhtdmdGQm9yOEJRUUJCaklrQlFlRUdRWStKQVVFQVFZK0pBVUVBUWYzOUFFR1JpUUZCNGdZUUFpQUFRb2lBZ0lBUU53UG9CeUFBUW9pQWdJQVFOd09ZRFVHSS9nQWdBRUhvQjJvUXRnVWdBRUtvZ0lDQUVEY0Q0QWNnQUVLb2dJQ0FFRGNEbUEwakFFRVFheUlCSkFBZ0FTQUFLUUxnQnpjRENFR2p2d0ZCanY0QVFRUkJnSXdCUWRDSkFVSCtCeUFCUVFocUVEZEJBUkFBSUFGQkVHb2tBQ0FBUW95QWdJQVFOd1BZQnlBQVFveUFnSUFRTndPWURTTUFRUkJySWdFa0FDQUJJQUFwQXRnSE53TUlRYU8vQVVHVy9nQkJBMEdRakFGQnJJa0JRZjhISUFGQkNHb1FOMEVCRUFBZ0FVRVFhaVFBSUFCQ2xJQ0FnQkEzQTlBSElBQkNsSUNBZ0JBM0E1Z05RWi8rQUNBQVFkQUhhaEMxQlNBQVFwaUFnSUFRTndQSUJ5QUFRcGlBZ0lBUU53T1lEVUdtL2dBZ0FFSElCMm9RdFFVZ0FFS2NnSUNBRURjRHdBY2dBRUtjZ0lDQUVEY0RtQTBqQUVFUWF5SUJKQUFnQVNBQUtRTEFCemNEQ0VHanZ3RkJyZjRBUVFoQndJd0JRZUNNQVVHQkNDQUJRUWhxRURkQkFSQUFJQUZCRUdva0FDQUFRcUNBZ0lBUU53TzRCeUFBUXFDQWdJQVFOd09ZRFVHMS9nQWdBRUc0QjJvUXRnVkJvNzhCUWFTL0FVR252d0ZCb2I4QlFZeUpBVUhqQmtHTWlRRkJnZ2hCaklrQlFZTUlRYnYrQUVHUmlRRkI1QVlRQWlNQVFSQnJJZ0VrQUNBQlFZUUlOZ0lNUWFPL0FVR1FpZ0ZCQWtIc2pBRkJuSWtCUVlVSUlBRkJER29RZUVFQUVBQWdBVUVRYWlRQVFhRy9BVUdraWdGQkFrSDBqQUZCaUlrQlFlVUdRZVlHRUFoQm9iOEJRYTZLQVVFRFFlQ0xBVUhzaXdGQjN3WkI1d1lRQ0FKL1FjaS9BVUhOL2dCQkJFRUJFQW9nQUVHWURXb0xRZDcrQUVFQkVMUUZRZVArQUVFQUVMUUZHZ0ovUWFXL0FVSHEvZ0JCQkVFQkVBb2dBRUdZRFdvTFFmUCtBRUVBRUxNRlFmditBRUVCRUxNRkdnSi9RY20vQVVHRC93QkJCRUVBRUFvZ0FFR1lEV29MUVkzL0FFRUFFUEVDUVpML0FFRUJFUEVDUVpqL0FFRUNFUEVDR2dKL1FjcS9BVUdmL3dCQkJFRUFFQW9nQUVHWURXb0xRYXIvQUVFQUVQQUNRWkwvQUVFQkVQQUNRYkQvQUVFQ0VQQUNHZ0ovUWN1L0FVRzIvd0JCQkVFQUVBb2dBRUdZRFdvTFFjRC9BRUVERUZwQnlQOEFRUTRRV2tIUC93QkJEeEJhUWRmL0FFRVFFRnBCM3Y4QVFSRVFXa0htL3dCQkVoQmFRZkgvQUVFVEVGcEIrLzhBUVJRUVdrR0ZnQUZCRlJCYVFZK0FBVUVXRUZwQm1vQUJRUmNRV2tHa2dBRkJHQkJhUWEyQUFVRVpFRnBCc1lBQlFSb1FXa0c4Z0FGQkd4QmFRY0tBQVVFY0VGb2FRY3kvQVVIbHZnRkJ6YjhCUVFCQmpJa0JRZWdHUVkrSkFVRUFRWStKQVVFQVFjMkFBVUdSaVFGQjZRWVFBaUFBUW9TQWdJQVFOd093QnlBQVFvU0FnSUFRTndPWURTTUFRUkJySWdFa0FDQUJJQUFwQXJBSE53TUlRYzYvQVVHOGdBRkJBMEhZamdGQnJJa0JRWVlJSUFGQkNHb1FOMEVCRUFBZ0FVRVFhaVFBSUFCQ2dJQ0FnQkEzQTZnSElBQkNnSUNBZ0JBM0E1Z05Jd0JCRUdzaUFTUUFJQUVnQUNrQ3FBYzNBd2hCenI4QlFkbUFBVUVEUWVTT0FVR3NpUUZCaHdnZ0FVRUlhaEEzUVFFUUFDQUJRUkJxSkFBZ0FFS0lnSUNBRURjRG9BY2dBRUtJZ0lDQUVEY0RtQTBqQUVFUWF5SUJKQUFnQVNBQUtRS2dCemNEQ0VIT3Z3RkIzNEFCUVFOQjhJNEJRZnlPQVVHSUNDQUJRUWhxRURkQkFSQUFJQUZCRUdva0FDQUFRb3lBZ0lBUU53T1lCeUFBUW95QWdJQVFOd09ZRFNNQVFSQnJJZ0VrQUNBQklBQXBBcGdITndNSVFjNi9BVUhwZ0FGQkEwR0Vqd0ZCcklrQlFZa0lJQUZCQ0dvUU4wRUJFQUFnQVVFUWFpUUFJQUJDa0lDQWdCQTNBNUFISUFCQ2tJQ0FnQkEzQTVnTkl3QkJFR3NpQVNRQUlBRWdBQ2tDa0FjM0F3aEJ6cjhCUWU2QUFVRURRWkNQQVVHc2lRRkJpZ2dnQVVFSWFoQTNRUUVRQUNBQlFSQnFKQUFnQUVLVWdJQ0FFRGNEaUFjZ0FFS1VnSUNBRURjRG1BMGpBRUVRYXlJQkpBQWdBU0FBS1FLSUJ6Y0RDRUhPdndGQjhvQUJRUU5Cbkk4QlFheUpBVUdMQ0NBQlFRaHFFRGRCQVJBQUlBRkJFR29rQUNBQVFwaUFnSUFRTndPQUJ5QUFRcGlBZ0lBUU53T1lEVUg4Z0FFZ0FFR0FCMm9Rc1FVZ0FFS2NnSUNBRURjRCtBWWdBRUtjZ0lDQUVEY0RtQTFCaTRFQklBQkIrQVpxRUxFRklBQkNvSUNBZ0JBM0EvQUdJQUJDb0lDQWdCQTNBNWdOSXdCQkVHc2lBU1FBSUFFZ0FDa0M4QVkzQXdoQnpyOEJRWnFCQVVFRVFkQ1BBVUhnandGQmpRZ2dBVUVJYWhBM1FRRVFBQ0FCUVJCcUpBQWdBRUtrZ0lDQUVEY0Q2QVlnQUVLa2dJQ0FFRGNEbUEwakFFRVFheUlCSkFBZ0FTQUFLUUxvQmpjRENFSE92d0ZCb29FQlFRSkI2SThCUVp5SkFVR09DQ0FCUVFocUVEZEJBUkFBSUFGQkVHb2tBRUhPdndGQno3OEJRZEMvQVVITXZ3RkJqSWtCUWVvR1FZeUpBVUdQQ0VHTWlRRkJrQWhCczRFQlFaR0pBVUhyQmhBQ0l3QkJFR3NpQVNRQUlBRkJrUWcyQWd4QnpyOEJRWkNLQVVFQ1FmQ1BBVUdjaVFGQmtnZ2dBVUVNYWhCNFFRQVFBQ0FCUVJCcUpBQkJ6TDhCUWFTS0FVRUNRZmlQQVVHSWlRRkI3QVpCN1FZUUNFSE12d0ZCcm9vQlFRTkI0SXNCUWV5TEFVSGZCa0h1QmhBSVFmdStBVUdVd0FGQmxjQUJRUUJCaklrQlFlOEdRWStKQVVFQVFZK0pBVUVBUWNhQkFVR1JpUUZCOEFZUUFpQUFRUUEyQXB3TklBQkI4UVkyQXBnTklBQWdBQ2tEbUEwM0ErQUdRZnUrQVVITWdRRkJwcjhCUVlDU0FVSHlCaUFBUWVBR2FoQTRRUUJCQUVFQVFRQVFBU0FBUVFBMkFwd05JQUJCOHdZMkFwZ05JQUFnQUNrRG1BMDNBOWdHUWZ1K0FVSFBnUUZCcHI4QlFZQ1NBVUh5QmlBQVFkZ0dhaEE0UVFCQkFFRUFRUUFRQVNBQVFRQTJBcHdOSUFCQjlBWTJBcGdOSUFBZ0FDa0RtQTAzQTlBR1FmdStBVUhTZ1FGQnByOEJRWUNTQVVIeUJpQUFRZEFHYWhBNFFRQkJBRUVBUVFBUUFTQUFRUUEyQXB3TklBQkI5UVkyQXBnTklBQWdBQ2tEbUEwM0E4Z0dRZnUrQVVIVmdRRkJwcjhCUVlDU0FVSHlCaUFBUWNnR2FoQTRRUUJCQUVFQVFRQVFBU0FBUVFBMkFwd05JQUJCOWdZMkFwZ05JQUFnQUNrRG1BMDNBOEFHUWZ1K0FVSFlnUUZCcHI4QlFZQ1NBVUh5QmlBQVFjQUdhaEE0UVFCQkFFRUFRUUFRQVNBQVFRQTJBcHdOSUFCQjl3WTJBcGdOSUFBZ0FDa0RtQTAzQTdnR1FmdStBVUhiZ1FGQnByOEJRWUNTQVVIeUJpQUFRYmdHYWhBNFFRQkJBRUVBUVFBUUFVR1d3QUZCOWI0QlFaZkFBVUVBUVl5SkFVSDRCa0dQaVFGQkFFR1BpUUZCQUVIZWdRRkJrWWtCUWZrR0VBSWdBRUVBTmdLRURTQUFRZm9HTmdLQURTQUFJQUFwQTRBTk53T3dCaUFBUVlnTmFpQUFRYkFHYWhBNUlBQWdBQ2tEaUEwaUJUY0RxQVlnQUNBRk53T1lEU01BUVJCcklnRWtBQ0FCSUFBcEFxZ0dOd01JUVpiQUFVSGpnUUZCQWtHRWtnRkJpSWtCUVpNSUlBRkJDR29RTjBFQUVBQWdBVUVRYWlRQUlBQkJBRFlDOUF3Z0FFSDdCallDOEF3Z0FDQUFLUVB3RERjRG9BWWdBRUg0REdvZ0FFR2dCbW9RT1NBQUlBQXBBL2dNSWdVM0E1Z0dJQUFnQlRjRG1BMGpBRUVRYXlJQkpBQWdBU0FBS1FLWUJqY0RDRUdXd0FGQjg0RUJRUU5CakpJQlFleUxBVUdVQ0NBQlFRaHFFRGRCQUJBQUlBRkJFR29rQUNBQVFRQTJBdVFNSUFCQi9BWTJBdUFNSUFBZ0FDa0Q0QXczQTVBR0lBQkI2QXhxSUFCQmtBWnFFRGtnQUNnQzZBd2hBU0FBSUFBb0F1d01OZ0tjRFNBQUlBRTJBcGdOSUFBZ0FDa0RtQTAzQTRnR0l3QkJFR3NpQVNRQUlBRWdBQ2tDaUFZM0F3aEJsc0FCUVlLQ0FVRURRWmlTQVVIc2l3RkJsUWdnQVVFSWFoQTNRUUFRQUNBQlFSQnFKQUFnQUVFQU5nS2NEU0FBUWYwR05nS1lEU0FBSUFBcEE1Z05Od09BQmlNQVFSQnJJZ0VrQUNBQklBQXBBb0FHTndNSVFaYkFBVUdTZ2dGQkFrR2trZ0ZCaUlrQlFaWUlJQUZCQ0dvUU4wRUFFQUFnQVVFUWFpUUFRWnJBQVVHWXdBRkJtOEFCUVFCQmpJa0JRZjRHUVkrSkFVRUFRWStKQVVFQVFhQ0NBVUdSaVFGQi93WVFBaUFBUVFBMkF0UU1JQUJCZ0FjMkF0QU1JQUFnQUNrRDBBdzNBL2dGSUFCQjJBeHFJQUJCK0FWcUVEa2dBQ2dDMkF3aEFTQUFJQUFvQXR3TU5nS2NEU0FBSUFFMkFwZ05JQUFnQUNrRG1BMDNBL0FGUVpyQUFVR3BnZ0ZCb0w4QlFZaUpBVUdCQnlBQVFmQUZhaEE0UVFCQkFFRUFRUUFRQVNBQVFRQTJBcHdOSUFCQmdnYzJBcGdOSUFBZ0FDa0RtQTAzQStnRkl3QkJFR3NpQVNRQUlBRWdBQ2tDNkFVM0F3aEJtc0FCUWE2Q0FVRURRYXlTQVVHNGtnRkJsd2dnQVVFSWFoQTNRUUFRQUNBQlFSQnFKQUFnQUVFQU5nS2NEU0FBUVlNSE5nS1lEU0FBSUFBcEE1Z05Od1BnQlNNQVFSQnJJZ0VrQUNBQklBQXBBdUFGTndNSVFackFBVUcyZ2dGQkEwSEFrZ0ZCcklrQlFaZ0lJQUZCQ0dvUU4wRUFFQUFnQVVFUWFpUUFJQUJCQURZQ25BMGdBRUdFQnpZQ21BMGdBQ0FBS1FPWURUY0QyQVVqQUVFUWF5SUJKQUFnQVNBQUtRTFlCVGNEQ0VHYXdBRkJ1NElCUVFOQnpKSUJRZXlMQVVHWkNDQUJRUWhxRURkQkFCQUFJQUZCRUdva0FDQUFRUUEyQXB3TklBQkJoUWMyQXBnTklBQWdBQ2tEbUEwM0E5QUZJd0JCRUdzaUFTUUFJQUVnQUNrQzBBVTNBd2hCbXNBQlFjNkNBVUVEUWRpU0FVSHNpd0ZCbWdnZ0FVRUlhaEEzUVFBUUFDQUJRUkJxSkFBZ0FFRUFOZ0tjRFNBQVFZWUhOZ0tZRFNBQUlBQXBBNWdOTndQSUJTTUFRUkJySWdFa0FDQUJJQUFwQXNnRk53TUlRWnJBQVVIVGdnRkJBMEhra2dGQjdJc0JRWnNJSUFGQkNHb1FOMEVBRUFBZ0FVRVFhaVFBSUFCQkFEWUNuQTBnQUVHSEJ6WUNtQTBnQUNBQUtRT1lEVGNEd0FVakFFRVFheUlCSkFBZ0FTQUFLUUxBQlRjRENFR2F3QUZCMklJQlFRTkI4SklCUWV5TEFVR2NDQ0FCUVFocUVEZEJBQkFBSUFGQkVHb2tBQ0FBUVFBMkFzUU1JQUJCaUFjMkFzQU1JQUFnQUNrRHdBdzNBN2dGSUFCQnlBeHFJQUJCdUFWcUVEa2dBQ2dDeUF3aEFTQUFJQUFvQXN3TU5nS2NEU0FBSUFFMkFwZ05JQUFnQUNrRG1BMDNBN0FGSXdCQkVHc2lBU1FBSUFFZ0FDa0NzQVUzQXdoQm1zQUJRZUdDQVVFRFFmeVNBVUhzaXdGQm5RZ2dBVUVJYWhBM1FRQVFBQ0FCUVJCcUpBQWdBRUVBTmdLMERDQUFRWWtITmdLd0RDQUFJQUFwQTdBTU53T29CU0FBUWJnTWFpQUFRYWdGYWhBNUlBQW9BcmdNSVFFZ0FDQUFLQUs4RERZQ25BMGdBQ0FCTmdLWURTQUFJQUFwQTVnTk53T2dCU01BUVJCcklnRWtBQ0FCSUFBcEFxQUZOd01JUVpyQUFVSHlnZ0ZCQTBHSWt3RkI3SXNCUVo0SUlBRkJDR29RTjBFQUVBQWdBVUVRYWlRQUlBQkJBRFlDbkEwZ0FFR0tCellDbUEwZ0FDQUFLUU9ZRFRjRG1BVkJnb01CSUFCQm1BVnFFSzhGSUFCQkFEWUNwQXdnQUVHTEJ6WUNvQXdnQUNBQUtRT2dERGNEa0FVZ0FFR29ER29nQUVHUUJXb1FPU0FBS0FLb0RDRUJJQUFnQUNnQ3JBdzJBcHdOSUFBZ0FUWUNtQTBnQUNBQUtRT1lEVGNEaUFVakFFRVFheUlCSkFBZ0FTQUFLUUtJQlRjRENFR2F3QUZCa1lNQlFRTkJuSk1CUWV5TEFVR2dDQ0FCUVFocUVEZEJBQkFBSUFGQkVHb2tBQ0FBUVFBMkFwUU1JQUJCakFjMkFwQU1JQUFnQUNrRGtBdzNBNEFGSUFCQm1BeHFJQUJCZ0FWcUVEa2dBQ2dDbUF3aEFTQUFJQUFvQXB3TU5nS2NEU0FBSUFFMkFwZ05JQUFnQUNrRG1BMDNBL2dFSXdCQkVHc2lBU1FBSUFFZ0FDa0MrQVEzQXdoQm1zQUJRYVdEQVVFRFFhaVRBVUhzaXdGQm9RZ2dBVUVJYWhBM1FRQVFBQ0FCUVJCcUpBQWdBRUVBTmdLY0RTQUFRWTBITmdLWURTQUFJQUFwQTVnTk53UHdCRUc0Z3dFZ0FFSHdCR29RcndVZ0FFRUFOZ0tjRFNBQVFZNEhOZ0tZRFNBQUlBQXBBNWdOTndQb0JFR2F3QUZCeW9NQlFmNitBVUdJaVFGQmp3Y2dBRUhvQkdvUU9FRUFRUUJCQUVFQUVBRWdBRUVBTmdLY0RTQUFRWkFITmdLWURTQUFJQUFwQTVnTk53UGdCQ01BUVJCcklnRWtBQ0FCSUFBcEF1QUVOd01JUVpyQUFVSFJnd0ZCQWtHMGt3RkJpSWtCUWFJSUlBRkJDR29RTjBFQUVBQWdBVUVRYWlRQVFhVEFBVUdld0FGQnBjQUJRUUJCaklrQlFaRUhRWStKQVVFQVFZK0pBVUVBUWRxREFVR1JpUUZCa2djUUFpQUFRUUEyQW9RTUlBQkJrd2MyQW9BTUlBQWdBQ2tEZ0F3M0E5Z0VJQUJCaUF4cUlBQkIyQVJxRURrZ0FFRUFOZ0wwQ3lBQVFaUUhOZ0x3Q3lBQUlBQXBBL0FMTndQUUJDQUFLQUtJRENFQklBQW9Bb3dNSVFJZ0FFSDRDMm9nQUVIUUJHb1FPU0FBS0FMNEN5RURJQUFvQXZ3TElRUWdBQ0FDTmdLY0RTQUFJQUUyQXBnTklBQWdBQ2tEbUEwM0E4Z0VJQUJCeUFScUVEZ2hBU0FBSUFRMkFwUU5JQUFnQXpZQ2tBMGdBQ0FBS1FPUURUY0R3QVJCcE1BQlFlMkRBVUdtdndGQmdKSUJRWlVISUFGQnByOEJRZnlPQVVHV0J5QUFRY0FFYWhBNEVBRWdBRUVBTmdMa0N5QUFRWmNITmdMZ0N5QUFJQUFwQStBTE53TzRCQ0FBUWVnTGFpQUFRYmdFYWhBNUlBQkJBRFlDMUFzZ0FFR1lCellDMEFzZ0FDQUFLUVBRQ3pjRHNBUWdBQ2dDNkFzaEFTQUFLQUxzQ3lFQ0lBQkIyQXRxSUFCQnNBUnFFRGtnQUNnQzJBc2hBeUFBS0FMY0N5RUVJQUFnQWpZQ25BMGdBQ0FCTmdLWURTQUFJQUFwQTVnTk53T29CQ0FBUWFnRWFoQTRJUUVnQUNBRU5nS1VEU0FBSUFNMkFwQU5JQUFnQUNrRGtBMDNBNkFFUWFUQUFVSDBnd0ZCcHI4QlFZQ1NBVUdWQnlBQlFhYS9BVUg4amdGQmxnY2dBRUdnQkdvUU9CQUJJQUJCQURZQ3hBc2dBRUdaQnpZQ3dBc2dBQ0FBS1FQQUN6Y0RtQVFnQUVISUMyb2dBRUdZQkdvUU9TQUFRUUEyQXJRTElBQkJtZ2MyQXJBTElBQWdBQ2tEc0FzM0E1QUVJQUFvQXNnTElRRWdBQ2dDekFzaEFpQUFRYmdMYWlBQVFaQUVhaEE1SUFBb0FyZ0xJUU1nQUNnQ3ZBc2hCQ0FBSUFJMkFwd05JQUFnQVRZQ21BMGdBQ0FBS1FPWURUY0RpQVFnQUVHSUJHb1FPQ0VCSUFBZ0JEWUNsQTBnQUNBRE5nS1FEU0FBSUFBcEE1QU5Od09BQkVHa3dBRkIrNE1CUWFhL0FVR0FrZ0ZCbFFjZ0FVR212d0ZCL0k0QlFaWUhJQUJCZ0FScUVEZ1FBVUdtd0FGQm44QUJRYWZBQVVHa3dBRkJqSWtCUVpzSFFZeUpBVUdqQ0VHTWlRRkJwQWhCaElRQlFaR0pBVUdjQnhBQ0lBQkN6SUNBZ0JBM0E2QUxJQUJDeklDQWdCQTNBL2dESUFCQnFBdHFJQUJCK0FOcUVEa2dBRUVBTmdLVUN5QUFRWjBITmdLUUN5QUFJQUFwQTVBTE53UHdBeUFBS0FLb0N5RUJJQUFvQXF3TElRSWdBRUdZQzJvZ0FFSHdBMm9RT1NBQUtBS1lDeUVESUFBb0Fwd0xJUVFnQUNBQ05nS2NEU0FBSUFFMkFwZ05JQUFnQUNrRG1BMDNBK2dESUFCQjZBTnFFRGdoQVNBQUlBUTJBcFFOSUFBZ0F6WUNrQTBnQUNBQUtRT1FEVGNENEFOQnBzQUJRWW1FQVVHbXZ3RkJnSklCUVo0SElBRkJwcjhCUWZ5T0FVR2ZCeUFBUWVBRGFoQTRFQUVnQUVMUWdJQ0FFRGNEZ0FzZ0FFTFFnSUNBRURjRDJBTWdBRUdJQzJvZ0FFSFlBMm9RT1NBQVFRQTJBdlFLSUFCQm9BYzJBdkFLSUFBZ0FDa0Q4QW8zQTlBRElBQW9Bb2dMSVFFZ0FDZ0NqQXNoQWlBQVFmZ0thaUFBUWRBRGFoQTVJQUFvQXZnS0lRTWdBQ2dDL0FvaEJDQUFJQUkyQXB3TklBQWdBVFlDbUEwZ0FDQUFLUU9ZRFRjRHlBTWdBRUhJQTJvUU9DRUJJQUFnQkRZQ2xBMGdBQ0FETmdLUURTQUFJQUFwQTVBTk53UEFBMEdtd0FGQmk0UUJRYWEvQVVHQWtnRkJuZ2NnQVVHbXZ3RkIvSTRCUVo4SElBQkJ3QU5xRURnUUFVR293QUZCb01BQlFhbkFBVUdrd0FGQmpJa0JRYUVIUVl5SkFVR2xDRUdNaVFGQnBnaEJqWVFCUVpHSkFVR2lCeEFDSUFCQkFEWUM1QW9nQUVHakJ6WUM0QW9nQUNBQUtRUGdDamNEdUFNZ0FFSG9DbW9nQUVHNEEyb1FPU0FBUVFBMkF0UUtJQUJCcEFjMkF0QUtJQUFnQUNrRDBBbzNBN0FESUFBb0F1Z0tJUUVnQUNnQzdBb2hBaUFBUWRnS2FpQUFRYkFEYWhBNUlBQW9BdGdLSVFNZ0FDZ0MzQW9oQkNBQUlBSTJBcHdOSUFBZ0FUWUNtQTBnQUNBQUtRT1lEVGNEcUFNZ0FFR29BMm9RT0NFQklBQWdCRFlDbEEwZ0FDQUROZ0tRRFNBQUlBQXBBNUFOTndPZ0EwR293QUZCa29RQlFhYS9BVUdBa2dGQnBRY2dBVUdtdndGQi9JNEJRYVlISUFCQm9BTnFFRGdRQVVHcXdBRkJvY0FCUWF2QUFVR293QUZCaklrQlFhY0hRWXlKQVVHbkNFR01pUUZCcUFoQm1ZUUJRWkdKQVVHb0J4QUNJQUJDeklDQWdCQTNBOEFLSUFCQ3pJQ0FnQkEzQTVnRElBQkJ5QXBxSUFCQm1BTnFFRGtnQUVFQU5nSzBDaUFBUWFrSE5nS3dDaUFBSUFBcEE3QUtOd09RQXlBQUtBTElDaUVCSUFBb0Fzd0tJUUlnQUVHNENtb2dBRUdRQTJvUU9TQUFLQUs0Q2lFRElBQW9BcndLSVFRZ0FDQUNOZ0tjRFNBQUlBRTJBcGdOSUFBZ0FDa0RtQTAzQTRnRElBQkJpQU5xRURnaEFTQUFJQVEyQXBRTklBQWdBellDa0EwZ0FDQUFLUU9RRFRjRGdBTkJxc0FCUVltRUFVR212d0ZCZ0pJQlFhb0hJQUZCcHI4QlFmeU9BVUdyQnlBQVFZQURhaEE0RUFFZ0FFTFFnSUNBRURjRG9Bb2dBRUxRZ0lDQUVEY0QrQUlnQUVHb0Ntb2dBRUg0QW1vUU9TQUFRUUEyQXBRS0lBQkJyQWMyQXBBS0lBQWdBQ2tEa0FvM0EvQUNJQUFvQXFnS0lRRWdBQ2dDckFvaEFpQUFRWmdLYWlBQVFmQUNhaEE1SUFBb0FwZ0tJUU1nQUNnQ25Bb2hCQ0FBSUFJMkFwd05JQUFnQVRZQ21BMGdBQ0FBS1FPWURUY0Q2QUlnQUVIb0Ftb1FPQ0VCSUFBZ0JEWUNsQTBnQUNBRE5nS1FEU0FBSUFBcEE1QU5Od1BnQWtHcXdBRkJpNFFCUWFhL0FVR0FrZ0ZCcWdjZ0FVR212d0ZCL0k0QlFhc0hJQUJCNEFKcUVEZ1FBVUdzd0FGQnJjQUJRYTdBQVVFQVFZeUpBVUd0QjBHUGlRRkJBRUdQaVFGQkFFR2loQUZCa1lrQlFhNEhFQUlnQUVFQU5nS0VDaUFBUWE4SE5nS0FDaUFBSUFBcEE0QUtOd1BZQWlBQVFZZ0thaUFBUWRnQ2FoQTVJQUFvQW9nS0lRRWdBQ0FBS0FLTUNqWUNuQTBnQUNBQk5nS1lEU0FBSUFBcEE1Z05Od1BRQWtHc3dBRkJxWUlCUWFDL0FVR0lpUUZCc0FjZ0FFSFFBbW9RT0VFQVFRQkJBRUVBRUFGQnI4QUJRYUxBQVVHd3dBRkJyTUFCUVl5SkFVR3hCMEdNaVFGQnFRaEJqSWtCUWFvSVFheUVBVUdSaVFGQnNnY1FBaUFBUVFBMkF2UUpJQUJCcndjMkF2QUpJQUFnQUNrRDhBazNBOGdDSUFCQitBbHFJQUJCeUFKcUVEa2dBQ2dDK0FraEFTQUFJQUFvQXZ3Sk5nS2NEU0FBSUFFMkFwZ05JQUFnQUNrRG1BMDNBOEFDUWEvQUFVR3BnZ0ZCb0w4QlFZaUpBVUd6QnlBQVFjQUNhaEE0UVFCQkFFRUFRUUFRQVNBQVFRQTJBdVFKSUFCQnRBYzJBdUFKSUFBZ0FDa0Q0QWszQTdnQ0lBQkI2QWxxSUFCQnVBSnFFRGtnQUNnQzZBa2hBU0FBSUFBb0F1d0pOZ0tjRFNBQUlBRTJBcGdOSUFBZ0FDa0RtQTAzQTdBQ1FhL0FBVUc4aEFGQnNjQUJRWWlKQVVHMUJ5QUFRYkFDYWhBNFFRQkJBRUVBUVFBUUFTQUFRUUEyQXRRSklBQkJ0Z2MyQXRBSklBQWdBQ2tEMEFrM0E2Z0NJQUJCMkFscUlBQkJxQUpxRURrZ0FDZ0MyQWtoQVNBQUlBQW9BdHdKTmdLY0RTQUFJQUUyQXBnTklBQWdBQ2tEbUEwM0E2QUNRYS9BQVVIRmhBRkJzY0FCUVlpSkFVRzFCeUFBUWFBQ2FoQTRRUUJCQUVFQVFRQVFBU0FBUVFBMkFzUUpJQUJCdHdjMkFzQUpJQUFnQUNrRHdBazNBNWdDSUFCQnlBbHFJQUJCbUFKcUVEa2dBQ2dDeUFraEFTQUFJQUFvQXN3Sk5nS2NEU0FBSUFFMkFwZ05JQUFnQUNrRG1BMDNBNUFDUWEvQUFVSEpoQUZCc2NBQlFZaUpBVUcxQnlBQVFaQUNhaEE0UVFCQkFFRUFRUUFRQVNBQVFRQTJBclFKSUFCQnVBYzJBckFKSUFBZ0FDa0RzQWszQTRnQ0lBQkJ1QWxxSUFCQmlBSnFFRGtnQUNnQ3VBa2hBU0FBSUFBb0Fyd0pOZ0tjRFNBQUlBRTJBcGdOSUFBZ0FDa0RtQTAzQTRBQ1FhL0FBVUhUaEFGQnNjQUJRWWlKQVVHMUJ5QUFRWUFDYWhBNFFRQkJBRUVBUVFBUUFTQUFRUUEyQXFRSklBQkJ1UWMyQXFBSklBQWdBQ2tEb0FrM0EvZ0JJQUJCcUFscUlBQkIrQUZxRURrZ0FDZ0NxQWtoQVNBQUlBQW9BcXdKTmdLY0RTQUFJQUUyQXBnTklBQWdBQ2tEbUEwM0EvQUJRYS9BQVVIYmhBRkJuTUFCUVlpSkFVRzZCeUFBUWZBQmFoQTRRUUJCQUVFQVFRQVFBU0FBUVFBMkFwUUpJQUJCdXdjMkFwQUpJQUFnQUNrRGtBazNBK2dCSUFCQm1BbHFJQUJCNkFGcUVEa2dBQ2dDbUFraEFTQUFJQUFvQXB3Sk5nS2NEU0FBSUFFMkFwZ05JQUFnQUNrRG1BMDNBK0FCUWEvQUFVSHFoQUZCc2NBQlFZaUpBVUcxQnlBQVFlQUJhaEE0UVFCQkFFRUFRUUFRQVNBQVFRQTJBb1FKSUFCQnZBYzJBb0FKSUFBZ0FDa0RnQWszQTlnQklBQkJpQWxxSUFCQjJBRnFFRGtnQUNnQ2lBa2hBU0FBSUFBb0Fvd0pOZ0tjRFNBQUlBRTJBcGdOSUFBZ0FDa0RtQTAzQTlBQlFhL0FBVUgwaEFGQnByOEJRWUNTQVVHOUJ5QUFRZEFCYWhBNFFRQkJBRUVBUVFBUUFTQUFRUUEyQXB3TklBQkJ2Z2MyQXBnTklBQWdBQ2tEbUEwM0E4Z0JJd0JCRUdzaUFTUUFJQUVnQUNrQ3lBRTNBd2hCcjhBQlFmcUVBVUVGUWNDVEFVSFVrd0ZCcXdnZ0FVRUlhaEEzUVFBUUFDQUJRUkJxSkFCQnNzQUJRYlBBQVVHMHdBRkJBRUdNaVFGQnZ3ZEJqNGtCUVFCQmo0a0JRUUJCZ0lVQlFaR0pBVUhBQnhBQ0l3QkJFR3NpQVNRQVFiTEFBVUVDUWR5VEFVR0lpUUZCckFoQndRY1FFU0FCUVJCcUpBQWdBRUVBTmdMMENDQUFRY0lITmdMd0NDQUFJQUFwQS9BSU53UEFBU0FBUWZnSWFpQUFRY0FCYWhBNUlBQkJBRFlDNUFnZ0FFSERCellDNEFnZ0FDQUFLUVBnQ0RjRHVBRWdBQ2dDK0FnaEFTQUFLQUw4Q0NFQ0lBQkI2QWhxSUFCQnVBRnFFRGtnQUNnQzZBZ2hBeUFBS0FMc0NDRUVJQUFnQWpZQ25BMGdBQ0FCTmdLWURTQUFJQUFwQTVnTk53T3dBU0FBUWJBQmFoQTRJUUVnQUNBRU5nS1VEU0FBSUFNMkFwQU5JQUFnQUNrRGtBMDNBNmdCUWJMQUFVR1loUUZCcHI4QlFZQ1NBVUhFQnlBQlFhYS9BVUg4amdGQnhRY2dBRUdvQVdvUU9CQUJJQUJCQURZQ25BMGdBRUhHQnpZQ21BMGdBQ0FBS1FPWURUY0RvQUZCc3NBQlFaMkZBVUdjd0FGQmlJa0JRY2NISUFCQm9BRnFFRGhCQUVFQVFRQkJBQkFCSUFCQkFEWUNuQTBnQUVISUJ6WUNtQTBnQUNBQUtRT1lEVGNEbUFFakFFRVFheUlCSkFBZ0FTQUFLUUtZQVRjRENFR3l3QUZCcm9JQlFRTkI1Sk1CUWZDVEFVR3RDQ0FCUVFocUVEZEJBQkFBSUFGQkVHb2tBQ0FBUVFBMkFwd05JQUJCeVFjMkFwZ05JQUFnQUNrRG1BMDNBNUFCSXdCQkVHc2lBU1FBSUFFZ0FDa0NrQUUzQXdoQnNzQUJRZnFFQVVFRVFZQ1VBVUhnandGQnJnZ2dBVUVJYWhBM1FRQVFBQ0FCUVJCcUpBQkJ0Y0FCUWFQQUFVRzJ3QUZCck1BQlFZeUpBVUhLQjBHTWlRRkJyd2hCaklrQlFiQUlRYVdGQVVHUmlRRkJ5d2NRQWtHM3dBRkJ1TUFCUWJuQUFVRUFRWXlKQVVITUIwR1BpUUZCQUVHUGlRRkJBRUd5aFFGQmtZa0JRYzBIRUFJakFFRVFheUlCSkFCQnQ4QUJRUUpCa0pRQlFZaUpBVUd4Q0VIT0J4QVJJQUZCRUdva0FDQUFRUUEyQXB3TklBQkJ6d2MyQXBnTklBQWdBQ2tEbUEwM0E0Z0JJd0JCRUdzaUFTUUFJQUVnQUNrQ2lBRTNBd2hCdDhBQlFhNkNBVUVFUWFDVUFVR3dsQUZCc2dnZ0FVRUlhaEEzUVFBUUFDQUJRUkJxSkFBZ0FFRUFOZ0tjRFNBQVFkQUhOZ0tZRFNBQUlBQXBBNWdOTndPQUFVSEhoUUVnQUVHQUFXb1FyZ1VnQUVFQU5nS2NEU0FBUWRFSE5nS1lEU0FBSUFBcEE1Z05Od040SXdCQkVHc2lBU1FBSUFFZ0FDa0NlRGNEQ0VHM3dBRkIwb1VCUVFOQndKUUJRZXlMQVVHMENDQUJRUWhxRURkQkFCQUFJQUZCRUdva0FDQUFRUUEyQXB3TklBQkIwZ2MyQXBnTklBQWdBQ2tEbUEwM0EzQkIySVVCSUFCQjhBQnFFSzRGSXdCQkVHc2lBU1FBSUFGQjB3YzJBZ3hCdDhBQlFlcUZBVUVEUWVTVUFVSHNpd0ZCdFFnZ0FVRU1haEI0UVFBUUFDQUJRUkJxSkFCQnU4QUJRYnJBQVVHOHdBRkJBRUdNaVFGQjFBZEJqNGtCUVFCQmo0a0JRUUJCZ29ZQlFaR0pBVUhWQnhBQ0lBQkJBRFlDbkEwZ0FFSFdCellDbUEwZ0FDQUFLUU9ZRFRjRGFFRzd3QUZCaTRZQlFiM0FBVUdJaVFGQjF3Y2dBRUhvQUdvUU9FRUFRUUJCQUVFQUVBRWdBRUVBTmdLY0RTQUFRZGdITmdLWURTQUFJQUFwQTVnTk53TmdRYnZBQVVHcGdnRkJvTDhCUVlpSkFVSFpCeUFBUWVBQWFoQTRRUUJCQUVFQVFRQVFBVUc3d0FGQmtJWUJRYjNBQVVHV2hnRkJqSWtCUWRvSFFRQkJBQkFGUWJ2QUFVR1loZ0ZCdmNBQlFhQ0dBVUdNaVFGQjJnZEJBRUVBRUFWQnU4QUJRYUtHQVVHOXdBRkJxb1lCUVl5SkFVSGFCMEVBUVFBUUJTTUFRUkJySWdFa0FDQUJRZHNITmdJTVFidkFBVUdzaGdGQkFrSHdsQUZCaUlrQlFiWUlJQUZCREdvUWVFRUFFQUFnQVVFUWFpUUFJd0JCRUdzaUFTUUFJQUZCM0FjMkFneEJ1OEFCUWJPR0FVRUNRZmlVQVVHSWlRRkJ0d2dnQVVFTWFoQjRRUUFRQUNBQlFSQnFKQUFqQUVFUWF5SUJKQUFnQVVIZEJ6WUNERUc3d0FGQnZJWUJRUUpCZ0pVQlFZaUpBVUc0Q0NBQlFReHFFSGhCQUJBQUlBRkJFR29rQUVIQndBRkJ2c0FCUWNMQUFVRzd3QUZCaklrQlFkNEhRWXlKQVVHNUNFR01pUUZCdWdoQnhvWUJRWkdKQVVIZkJ4QUNJQUJCQURZQzFBZ2dBRUhnQnpZQzBBZ2dBQ0FBS1FQUUNEY0RXQ0FBUWRnSWFpQUFRZGdBYWhBNUlBQkJBRFlDeEFnZ0FFSGhCellDd0FnZ0FDQUFLUVBBQ0RjRFVDQUFLQUxZQ0NFQklBQW9BdHdJSVFJZ0FFSElDR29nQUVIUUFHb1FPU0FBS0FMSUNDRURJQUFvQXN3SUlRUWdBQ0FDTmdLY0RTQUFJQUUyQXBnTklBQWdBQ2tEbUEwM0EwZ2dBRUhJQUdvUU9DRUJJQUFnQkRZQ2xBMGdBQ0FETmdLUURTQUFJQUFwQTVBTk53TkFRY0hBQVVIT2hnRkJuTUFCUVlpSkFVSGlCeUFCUVp6QUFVR3NpUUZCNHdjZ0FFRkFheEE0RUFGQnc4QUJRYi9BQVVIRXdBRkJ1OEFCUVl5SkFVSGtCMEdNaVFGQnV3aEJqSWtCUWJ3SVFkU0dBVUdSaVFGQjVRY1FBaUFBUVFBMkFyUUlJQUJCNWdjMkFyQUlJQUFnQUNrRHNBZzNBemdnQUVHNENHb2dBRUU0YWhBNUlBQkJBRFlDcEFnZ0FFSG5CellDb0FnZ0FDQUFLUU9nQ0RjRE1DQUFLQUs0Q0NFQklBQW9BcndJSVFJZ0FFR29DR29nQUVFd2FoQTVJQUFvQXFnSUlRTWdBQ2dDckFnaEJDQUFJQUkyQXB3TklBQWdBVFlDbUEwZ0FDQUFLUU9ZRFRjREtDQUFRU2hxRURnaEFTQUFJQVEyQXBRTklBQWdBellDa0EwZ0FDQUFLUU9RRFRjRElFSER3QUZCem9ZQlFhYS9BVUdBa2dGQjZBY2dBVUdtdndGQi9JNEJRZWtISUFCQklHb1FPQkFCUWNYQUFVSEF3QUZCeHNBQlFidkFBVUdNaVFGQjZnZEJqSWtCUWIwSVFZeUpBVUcrQ0VIZWhnRkJrWWtCUWVzSEVBSWdBRUVBTmdLY0RTQUFRZXdITmdLWURTQUFJQUFwQTVnTk53TVlJd0JCRUdzaUFTUUFJQUVnQUNrQ0dEY0RDRUhGd0FGQjZZWUJRUUpCaUpVQlFaeUpBVUcvQ0NBQlFRaHFFRGRCQUJBQUlBRkJFR29rQUFKL1FmeStBVUh1aGdGQkFVRUFFQW9nQUVHWURXb0xRZDcrQUVFQUVKMEJRZktHQVVFQkVKMEJRZnFHQVVFQ0VKMEJRWUNIQVVFREVKMEJRWW1IQVVFRUVKMEJRWk9IQVVFRkVKMEJRWmlIQVVFR0VKMEJHa0g5dmdGQng4QUJRY2pBQVVFQVFZeUpBVUh0QjBHUGlRRkJBRUdQaVFGQkFFR2lod0ZCa1lrQlFlNEhFQUlnQUVFQU5nS2NEU0FBUWU4SE5nS1lEU0FBSUFBcEE1Z05Od01RUWYyK0FVR0poQUZCcHI4QlFZQ1NBVUh3QnlBQVFSQnFFRGhCQUVFQVFRQkJBQkFCSUFCQkFEWUNuQTBnQUVIeEJ6WUNtQTBnQUNBQUtRT1lEVGNEQ0VIOXZnRkJpNFFCUWFhL0FVR0FrZ0ZCOEFjZ0FFRUlhaEE0UVFCQkFFRUFRUUFRQVVIOXZnRkJySWNCUWYyK0FVRzA5QUJCaklrQlFmSUhRUUJCQUJBRlFmMitBVUcwaHdGQi9iNEJRYnowQUVHTWlRRkI4Z2RCQUVFQUVBVkIvYjRCUWI2SEFVSDl2Z0ZCeFBRQVFZeUpBVUh5QjBFQVFRQVFCVUg5dmdGQng0Y0JRZjIrQVVITTlBQkJqSWtCUWZJSFFRQkJBQkFGUWYyK0FVSFNod0ZCL2I0QlFkVDBBRUdNaVFGQjhnZEJBRUVBRUFWQi9iNEJRZG1IQVVIOXZnRkIzUFFBUVl5SkFVSHlCMEVBUVFBUUJVSDl2Z0ZCNVljQlFmMitBVUhrOUFCQmpJa0JRZklIUVFCQkFCQUZRZjIrQVVId2h3RkIvYjRCUWV6MEFFR01pUUZCOGdkQkFFRUFFQVZCL2I0QlFmMkhBVUg5dmdGQjlQUUFRWXlKQVVIeUIwRUFRUUFRQlFKL1FmNitBVUdKaUFGQmtKVUJRY0FJUVpHSkFVSEJDQkFqSUFCQm1BMXFDMEdPaUFGQkFCRDVBVUdUaUFGQkJCRDVBVUdZaUFGQkNCRDVBVUdkaUFGQkRCRDVBUnBCL3I0QkVDRWdBRUdnRFdva0FFSEp3QUZCNmdnUkFBQWFDendCQVg4akFFRVFheUlDSkFBZ0FpQUJLUUlBTndNSVFmbStBU0FBUVFKQmxJa0JRWnlKQVVIMEJ5QUNRUWhxRURkQkFSQUFJQUpCRUdva0FBdVhBUUlEZndGOElBRW9BZ0FoQXlNQVFSQnJJZ0VrQUFKL0FrQkI0TDRCTFFBQVFRRnhEUUJCNEw0QkVGTkZEUUFqQUVFUWF5SUVKQUJCQVVHa2lBRVFBeUVGSUFSQkVHb2tBRUhjdmdFZ0JUWUNBRUhndmdFUVVndEIzTDRCS0FJQUN5QURJQUlnQVVFRWFpQUJRUWhxRUt3RkVDQWhCaUFCSUFFb0FnUVFRU0VDSUFBZ0JoRDRBUkR1QWlBQ0VNZ0JJQUZCRUdva0FBc05BQ0FBUWZUOEFCQWxFRUVhQ3hrQUlBQkJBRFlDU0NBQUtBSVVLQUlVUVlBQ1FRQVFYaG9MendNQ0JYMEVmeU1BUVJCcklnZ2tBQ0FBS0FKSUlnZEZCRUFnQVVGQWF5RUpJQUFvQWtRaUJ5QUhLQUlBS0FJSUVRRUFJQUFxQWpnUWhnVkRBQUNBUDVJUWhnVWhCQUpBQWtBQ1FDQUFLQUk4UVFGckRnSUFBUUlMSUFFcUFrd2lBaUFFSUFBcUFqU1NsQ0lGSUFJZ0JDQUFLZ0l3a3BRaUJDQUVJQVZlSWdFYklnTWdBcE1nQXlBQ0lBTmRJZ2NiSVFNZ0JDQUZJQUViSWdRZ0FwTWdCQ0FIR3lFQ1FRQWhCeUFKRURJaEFRTkFJQUpEQUFBQUFGNUZEUUlDZlNBSklBY2dBVzhRTHlnQ0FDSUtLZ0pNSWdRZ0ExNEVRQ0FLSUFNZ0FrRUJJQUFvQWtRUW9nSkRBQUFBQUF3QkN5QURJQVNUQ3lFRElBZEJBV29oQnlBQ0lBU1RJUUlNQUFzQUN5QUlJQWtRS2pZQ0NDQUlJQWtRS3pZQ0FBTkFJQWhCQ0dvZ0NCQXNSUTBCSUFnb0FnZ29BZ0FpQVNvQ1RDRURJQUVnQXlBRUlBQXFBalNTbENJQ0lBTWdCQ0FBS2dJd2twUWlCU0FDSUFWZElnY2JJZ1lnQTVNZ0JpQURJQVpkSWdrYklBVWdBaUFIR3lJQ0lBT1RJQUlnQ1JzaUFrRUJJQUFvQWtRUW9nSURRQ0FDSUFOZUJFQWdBVU1BQUFBQUlBSWdBNU1pQWtFQUlBQW9Ba1FRb2dJTUFRc0xJQWhCQ0dvUUxSb01BQXNBQ3lBQUlBQW9Ba1FpQnpZQ1NBc2dDRUVRYWlRQUlBY0xOQUVCZnlBQVFkejhBRFlDUUNBQVFZVDhBRFlDQUNBQUtBSkVJZ0VFUUNBQklBRW9BZ0FvQWdRUkFRQUxJQUFRUXhvZ0FBdFRBUUYvSUFBUWRDQUFRZ0EzQWpBZ0FFR2dJellDQUNBQVFnQTNBamdnQUVGQWF5SUJRZXo4QURZQ0FDQUFRWVQ4QURZQ0FDQUJRZHo4QURZQ0FCREhBU0VCSUFCQkFEWUNTQ0FBSUFFMkFrUWdBQXN3QVFKL0lBQkJOR29pQVNnQ0NBUkFJQUVvQWdnaUFpQUFLQUl3SUFFcUFnUVFnZ01nQWlnQ0FDZ0NCQkVEQUFzTFBBRUJmeUFCS0FJVUlRSWdBQ0FCTmdJTUlBSkJGU0FDS0FJQUtBSU1FUUlBSWdFRVFDQUFJQUlnQUNBQ0tBSUFLQUpBRVFJQU5nSUlDeUFCQ3lzQkFYOGdBRUg0K1FBMkFnQWdBQ2dDTUNJQkJFQWdBU0FCS0FJQUtBSXNFUUVBQ3lBQUVFTWFJQUFMN3dJQkIzOGpBRUVRYXlJRkpBQkJBU0VEQWtBQ1FBSkFBa0FDUUFKQUlBRWdBR3RCQW5VT0JnVUZBQUVDQXdRTElBRkJCR3NpQVNnQ0FDQUFLQUlBSUFJb0FnQVJBZ0JGRFFRZ0FDQUJFRFVNQkFzZ0FDQUFRUVJxSUFGQkJHc2dBaENlQVJvTUF3c2dBQ0FBUVFScUlBQkJDR29nQVVFRWF5QUNFUDhCR2d3Q0N5QUFJQUJCQkdvZ0FFRUlhaUFBUVF4cUlBRkJCR3NnQWhEK0FSb01BUXNnQUNBQVFRUnFJQUJCQ0dvaUJpQUNFSjRCR2lBQVFReHFJUVFDUUFOQUlBRWdCRVlpQ0EwQkFrQWdCQ2dDQUNBR0tBSUFJQUlvQWdBUkFnQUVRQ0FGSUFRb0FnQTJBZ3dnQkNFSEEwQUNRQ0FISUFZaUF5Z0NBRFlDQUNBQUlBTkdCRUFnQUNFRERBRUxJQU1oQnlBRktBSU1JQU5CQkdzaUJpZ0NBQ0FDS0FJQUVRSUFEUUVMQ3lBRElBVkJER29vQWdBMkFnQWdDVUVCYWlJSlFRaEdEUUVMSUFRaUJrRUVhaUVFREFFTEN5QUVRUVJxSUFGR0lRTUxJQU1nQ0hJaEF3c2dCVUVRYWlRQUlBTkJBWEVMQndBZ0FCQ0JBZ3NtQUNBQUVKZ0JJQUJDQURjQ01DQUFRZUFTTmdJQUlBQkJBRFlDT0NBQVFjemJBRFlDQUFzTUFDQUFFUHdDR2lBQUVDNExRUUFnQUJDQ0FpQUJFSUlDSUFJUXl3RWdBQkNHQWlBQkVJWUNJQUlReXdFZ0FCQ0ZBaUFCRUlVQ0lBSVF5d0VnQUJDRUFpQUJFSVFDSUFJUXl3RVFnd01MMUFFQ0FYMENmd0ovQW44Z0FCQ0NBck5EQUFCL1E1VkRBQUIvUTVRZ0FaUWlBYndpQTBFWGRrSC9BWEVpQkVHVkFVMEVRQ0FFUWYwQVRRUjlJQUZEQUFBQUFKUUZBbjBnQVNBQmpDQURRWDlLR3lJQlF3QUFBRXVTUXdBQUFNdVNJQUdUSWdKREFBQUFQMTRFUUNBQklBS1NRd0FBZ0wrU0RBRUxJQUVnQXBJaUFTQUNRd0FBQUw5ZlJRMEFHaUFCUXdBQWdEK1NDeUlCSUFHTUlBTkJmMG9iQ3lFQkN5QUJRd0FBZ0U5ZElBRkRBQUFBQUdCeEN3UkFJQUdwREFFTFFRQUxJQUFRaGdJZ0FCQ0ZBaUFBRUlRQ0VJTURDeVVBSUFOQi93RnhJQUpCQ0hSQmdQNERjU0FCUVJCMFFZQ0EvQWR4SUFCQkdIUnljbklMRndBZ0FFRWdRUUFRWGdSQUlBQkJ3QUJCQVJCZUdnc0xFUUFnQUVFbUlBQW9BZ0FvQWd3UkFnQUxxQUlCQjM4Z0FCQTlJUUlDUUNBQkJFQWdBQ0FDSUFFUXR3RVFlaUFBRUQwZ0FUWUNBRUVBSVFJRFFDQUJJQUpHQkVBZ0FFRUlhaUlDS0FJQUlnTkZEUU1nQUNBREtBSUVJQUVRT3lJSEVDOGdBallDQUFOQUlBTW9BZ0FpQWtVTkJBSkFJQUlvQWdRZ0FSQTdJZ1FnQjBZTkFDQUNJUVVnQUNBRUVDOG9BZ0JGQkVBZ0FDQUVFQzhnQXpZQ0FDQUVJUWNNQVFzRFFBSkFJQVVpQmlnQ0FFVUVRRUVBSVFVTUFRc2dBQkJHR2lBQ1FRaHFJQVlvQWdCQkNHb1F5UVFoQ0NBR0tBSUFJUVVnQ0EwQkN3c2dBeUFGTmdJQUlBWWdBQ0FFRUM4b0FnQW9BZ0EyQWdBZ0FDQUVFQzhvQWdBZ0FqWUNBQXdCQ3lBQ0lRTU1BQXNBQlNBQUlBSVFMMEVBTmdJQUlBSkJBV29oQWd3QkN3QUxBQXNnQUVFQUVIb2dBQkE5UVFBMkFnQUxDeEVBSUFBZ0FDZ0NBRUVFYXpZQ0FDQUFDeEFBSUFBZ0FUWUNCQ0FBSUFFMkFnQUxJUUFnQUJDcUFSb2dBRUc4N1FBMkFnQWdBRUcwTmpZQ0FDQUFRUkJxRURvYUN5VUFJQUFRWWlBQVFYODJBZ1FnQUVIYzdBQTJBZ0FnQUVFQU5nSUlJQUJCcERRMkFnQUxwd0lCQjM4Z0FCQTlJUUlDUUNBQkJFQWdBQ0FDSUFFUXR3RVFlaUFBRUQwZ0FUWUNBRUVBSVFJRFFDQUJJQUpHQkVBZ0FFRUlhaUlDS0FJQUlnTkZEUU1nQUNBREtBSUVJQUVRT3lJSEVDOGdBallDQUFOQUlBTW9BZ0FpQWtVTkJBSkFJQUlvQWdRZ0FSQTdJZ1FnQjBZTkFDQUNJUVVnQUNBRUVDOG9BZ0JGQkVBZ0FDQUVFQzhnQXpZQ0FDQUVJUWNNQVFzRFFBSkFJQVVpQmlnQ0FFVUVRRUVBSVFVTUFRc2dBQkJHSUFKQkNHb2dCaWdDQUVFSWFoQ2dBU0VJSUFZb0FnQWhCU0FJRFFFTEN5QURJQVUyQWdBZ0JpQUFJQVFRTHlnQ0FDZ0NBRFlDQUNBQUlBUVFMeWdDQUNBQ05nSUFEQUVMSUFJaEF3d0FDd0FGSUFBZ0FoQXZRUUEyQWdBZ0FrRUJhaUVDREFFTEFBc0FDeUFBUVFBUWVpQUFFRDFCQURZQ0FBc0xTd0VDZnlNQVFSQnJJZ0VrQUNBQlFRaHFBbjhqQUVFUWF5SUNKQUFnQWtFSWFpQUFRUWhxS0FJQUVFRW9BZ0FoQUNBQ1FSQnFKQUFnQUFzUVFTZ0NBQ0VBSUFGQkVHb2tBQ0FBQzdjQkFRZC9Jd0JCSUdzaUJ5UUFJQUFRS0NJREFuOGdBQ0FBRURKQkFXb1FTeUVFSUFBUU1pRUlJd0JCRUdzaUJTUUFJQVZCQURZQ0RDQUhRUWhxSWdKQkRHb2dCVUVNYWlBREVFY2dCQVJBSUFJb0FoQWdCQkMzQVNFR0N5QUNJQVkyQWdBZ0FpQUdJQWhCQW5ScUlnTTJBZ2dnQWlBRE5nSUVJQUlRTVNBR0lBUkJBblJxTmdJQUlBVkJFR29rQUNBQ0tBSUlDeUFCRUVnZ0FpQUNLQUlJUVFScU5nSUlJQUFnQWhCTUlBSVFTaUFIUVNCcUpBQUwyQUlCQ1g4akFFRWdheUlFSkFBZ0JDQUFJQUVReXdRMkFoZ2dCQkNXQVRZQ0VDQUVRUmhxSUFSQkVHb1F5Z0pGQkVBZ0JFRUlhaUFFUVJocUVKOEJLQUlBSVFJakFFRWdheUlGSkFBZ0JVRVlhaUFDRUVFaUNSQ0pBaUFGUVFocUlRb2pBRUVRYXlJSUpBQWdBQkJWSVFZZ0FDQUNLQUlFSUFZUU95SUhFQzhvQWdBaEF3TkFJQU1pQVNnQ0FDSURJQUpIRFFBTEFrQWdBU0FBUVFocVJ3UkFJQUVvQWdRZ0JoQTdJQWRHRFFFTElBSW9BZ0FpQXdSQUlBTW9BZ1FnQmhBN0lBZEdEUUVMSUFBZ0J4QXZRUUEyQWdBTEFrQWdBaWdDQUNJRFJRMEFJQU1vQWdRZ0JoQTdJZ01nQjBZTkFDQUFJQU1RTHlBQk5nSUFDeUFCSUFJb0FnQTJBZ0FnQWtFQU5nSUFJQUFRTVNJQklBRW9BZ0JCQVdzMkFnQWdDaUFDSUFoQkNHb2dBQkFvUVFFUXN3RVFzZ0VhSUFoQkVHb2tBQ0FGUVFocUVNNEJJQWtvQWdBYUlBVkJJR29rQUFzZ0JFRWdhaVFBQ3lBQUlBQW9BZ1FnQUJBb0tBSUFSd1JBSUFBZ0FSQkpEd3NnQUNBQkVJMERDM3dCQTM4akFFRVFheUlCSkFBZ0FTQUFRUVJxSWdJUUtqWUNDQ0FCSUFJUUt6WUNBQU5BSUFGQkNHb2dBUkFzUlFSQUlBQW9BZ0FpQUFSQUlBQWdBQ2dDQUNnQ0JCRUJBQXNnQWhBK0lBRkJFR29rQUE4TElBRW9BZ2dvQWdBaUF3UkFJQU1nQXlnQ0FDZ0NCQkVCQUFzZ0FVRUlhaEF0R2d3QUN3QUxHZ0FnQVNBQWF5SUJCRUFnQWlBQUlBRVEzUUlMSUFFZ0Ftb0x0Z0lCQjM4Z0FCQTlHZ0pBSUFFRVFDQUFBbjhnQVNJRFFmLy8vLzhEU3dSQUVFVUFDeUFEUVFKMEVDY0xFSG9nQUJBOUlBTTJBZ0FEUUNBQ0lBTkdCRUFnQUVFSWFpSUJLQUlBSWdSRkRRTWdBQ0FFS0FJRUlBTVFPeUlIRUM4Z0FUWUNBQU5BSUFRb0FnQWlBVVVOQkFKQUlBRW9BZ1FnQXhBN0lnVWdCMFlOQUNBQklRSWdBQ0FGRUM4b0FnQkZCRUFnQUNBRkVDOGdCRFlDQUNBRklRY01BUXNEUUFKQUlBSWlCaWdDQUVVRVFFRUFJUUlNQVFzZ0FCQkdJQUZCQ0dvZ0JpZ0NBRUVJYWhEUkFTRUlJQVlvQWdBaEFpQUlEUUVMQ3lBRUlBSTJBZ0FnQmlBQUlBVVFMeWdDQUNnQ0FEWUNBQ0FBSUFVUUx5Z0NBQ0FCTmdJQURBRUxJQUVoQkF3QUN3QUZJQUFnQWhBdlFRQTJBZ0FnQWtFQmFpRUNEQUVMQUFzQUN5QUFRUUFRZWlBQUVEMUJBRFlDQUFzTHp3WUNDSDhCZlNNQVFSQnJJZ2NrQUNBSFFRaHFJUW9qQUVFZ2F5SURKQUFnQVJBeElBSW9BZ0FRaXdJaENDQUJFRlVoQkNBRFFRQTZBQjhDUUFKQUlBUkZEUUFnQVNBSUlBUVFPeUlHRUM4b0FnQWlCVVVOQUFOQUlBVW9BZ0FpQlVVTkFTQUlJQVVvQWdSSEJFQWdCU2dDQkNBRUVEc2dCa2NOQWdzZ0FSQkdJQVZCQ0dvZ0FoRFJBVVVOQUFzTUFRc2pBRUVRYXlJSkpBQWdBUkFvSWdVZ0EwRVFha0VNRUNjZ0NVRUlhaUFGUVFBUXN3RVFzZ0VpQlNnQ0FFRUlhaUFDRUVnZ0JSQTlRUUU2QUFRZ0JTZ0NBQ0FJTmdJRUlBVW9BZ0JCQURZQ0FDQUpRUkJxSkFBQ1FDQUJBbjhnQVJBeEtBSUFRUUZxc3lBQkVFWXFBZ0FnQkxPVVhrVkJBQ0FFRzBVRVFDQURJQVFRZTBFQmN5QUVRUUYwY2pZQ0RDQURBbjhnQVJBeEtBSUFRUUZxc3lBQkVFWXFBZ0NWalNJTFF3QUFnRTlkSUF0REFBQUFBR0J4QkVBZ0M2a01BUXRCQUFzMkFnZ2dBMEVNYWlBRFFRaHFFRmdvQWdBaEFpTUFRUkJySWdRa0FDQUVJQUkyQWd3Q1FDQUVJQUpCQVVZRWYwRUNCU0FDSUFKQkFXdHhSUTBCSUFJUWhnRUxJZ0kyQWd3TEFrQWdBUkJWSWdVZ0Fra0VRQ0FCSUFJUWtnTU1BUXNnQWlBRlR3MEFJQVVRZXlFR0FuOGdBUkF4S0FJQXN5QUJFRVlxQWdDVmpTSUxRd0FBZ0U5ZElBdERBQUFBQUdCeEJFQWdDNmtNQVF0QkFBc2hBaUFFQW44Z0JnUkFJQUlRendFTUFRc2dBaENHQVFzMkFnZ2dCQ0FFUVF4cUlBUkJDR29RV0NnQ0FDSUNOZ0lNSUFJZ0JVOE5BQ0FCSUFJUWtnTUxJQVJCRUdva0FDQUlJQUVRVlNJRUVEc2hCZ3NnQmdzUUx5Z0NBQ0lDUlFSQUlBTW9BaEFnQVVFSWFpSUNLQUlBTmdJQUlBRWdBeWdDRURZQ0NDQUJJQVlRTHlBQ05nSUFJQU1vQWhBb0FnQkZEUUVnQXlnQ0VDRUNJQUVnQXlnQ0VDZ0NBQ2dDQkNBRUVEc1FMeUFDTmdJQURBRUxJQU1vQWhBZ0FpZ0NBRFlDQUNBQ0lBTW9BaEEyQWdBTElBTkJFR29RMHdFaEJTQUJFREVpQVNBQktBSUFRUUZxTmdJQUlBTkJBVG9BSHlBRFFSQnFJZ0lvQWdBaEFTQUNRUUEyQWdBZ0FRUkFJQUlRUFNJQ0xRQUVCRUFnQWlnQ0FCb0xJQUVFUUNBQ0tBSUFHaUFCRUM0TEN3c2dDaUFEUVJCcUlBVVFRU0FEUVI5cUVOSUJJQU5CSUdva0FDQUFJQWRCQ0dvUW53RWFJQUFnQnkwQUREb0FCQ0FIUVJCcUpBQUxMUUVDZnlNQVFSQnJJZ0FrQUNBQUVKWUJOZ0lBSUFCQkNHb2dBQkNmQVNnQ0FDRUJJQUJCRUdva0FDQUJDOGdCQVFaL0l3QkJFR3NpQXlRQUl3QkJFR3NpQkNRQUlBQVFNU0FCS0FJQUVJc0NJUVVDUUFKQUlBQVFWU0lHUlEwQUlBQWdCU0FHRURzaUJ4QXZLQUlBSWdKRkRRQURRQ0FDS0FJQUlnSkZEUUVnQlNBQ0tBSUVSd1JBSUFJb0FnUWdCaEE3SUFkSERRSUxJQVVnQWlnQ0JFY05BQ0FBRUVZZ0FrRUlhaUFCRU5FQlJRMEFDeUFFUVFocUlBSVFRU2dDQUNFQ0RBRUxJQVFRbGdFaUFqWUNDQXNnQkVFUWFpUUFJQU1nQWpZQ0FDQURRUWhxSUFNUW53RW9BZ0FoQUNBRFFSQnFKQUFnQUF1UkNRRU9meU1BUVRCcklnUWtBQ0FFSUFFMkFpd2dCQ0FBSUFSQkxHb1FsUU0yQWlBZ0JCQ1VBellDRUFKL1FRRWdCRUVnYWlBRVFSQnFFSTBDRFFBYUlBUWdBRUVVYWlJQklBUkJMR29RbFFNMkFpQWdCQkNVQXpZQ0VDQUVRU0JxSUFSQkVHb1FqUUlFUUVIQTZBQkJFa0dJdHdFb0FnQVEyd0pCQUF3QkN5QUVRU0JxSUFFZ0JFRXNhaENUQXlBRUlBUkJJR29nQkNnQ0xFRVlhaEREQXlJUEVDbzJBaEFnQkNBUEVDczJBaGdDUUFOQUlBUkJFR29nQkVFWWFoQXNJaEFFUUNBQUlBUW9BaEFvQWdBZ0FoQ1dBMFVOQWlBRVFSQnFFQzBhREFFTEN5QUVRUkJxSUFBZ0JFRXNhaENUQXlBRUlBSVFLallDRUNBRVFRaHFJQVJCRUdvUW53RW9BZ0FoQUNBRVFTeHFJUUVqQUVFZ2F5SUtKQUFnQ2lBQU5nSVlJQUlvQWdBaEFDQUtJQUlRS2pZQ0FDQUFJQXBCR0dvZ0NoQ0tBa0VDZEdvaEFBSkFJQUlvQWdRZ0FoQW9LQUlBU1FSQUlBSW9BZ1FpQlNBQVJnUkFJQUlnQVJCSkRBSUxJd0JCRUdzaUNDUUFJQWdnQWlBRklBQWdBaWdDQkNJSklBQkJCR3ByYWlJR2EwRUNkUkRyQVNFSElBWWhBd05BSUFNZ0JVa0VRQ0FDRUNnZ0J5Z0NCQ0FERUVnZ0J5QUhLQUlFUVFScU5nSUVJQU5CQkdvaEF3d0JDd3NnQnhCcElBWWdBR3NpQXdSQUlBa2dBMnNnQUNBREVOMENDeUFJUVJCcUpBQWdBQ0FBSUFGTkJIOGdBVUVFYWlBQklBRWdBaWdDQkVrYkJTQUJDeWdDQURZQ0FBd0JDeUFDRUNnaEF5QUtJQUlnQWhBeVFRRnFFRXNnQUNBQ0tBSUFhMEVDZFNBREVKZ0NJZ2NoQXlNQVFUQnJJZ2trQUFKQUlBTW9BZ2dnQXhBeEtBSUFSdzBBSUFOQkNHb2hEQ0FEUVFScUlRMGdBeWdDQkNJR0lBTW9BZ0FpQlVzRVFDQU1JQVlnRENnQ0FDQUdJQVlnQld0QkFuVkJBV3BCZm0xQkFuUWlCV29Ra1FNMkFnQWdEU0FOS0FJQUlBVnFOZ0lBREFFTElBa2dBeEF4S0FJQUlBTW9BZ0JyUVFGMU5nSVlJQWxCQVRZQ0xDQUpRUmhxSUFsQkdHb2dDVUVzYWhCWUtBSUFJZ1lnQmtFQ2RpQURLQUlRRUpnQ0lRWWdDVUVRYWlBREtBSUVFRUVoQlNBSlFRaHFJQU1vQWdnUVFTRUlJQVVvQWdBaEN5QUlLQUlBSVE0akFFRWdheUlJSkFBZ0NDQUxOZ0lZSXdCQkVHc2lCU1FBSUFVZ0RqWUNBQ0FGSUFzMkFnZ2dCU0FGUVFocUVJb0NJUXNnQlVFUWFpUUFJQWhCQ0dvaUJTQUdLQUlJTmdJQUlBWW9BZ2doRGlBRklBWkJDR28yQWdnZ0JTQU9JQXRCQW5ScU5nSUVBMEFnQlNnQ0FDQUZLQUlFUndSQUlBWW9BaEFnQlNnQ0FDQUlLQUlZRUVnZ0JTQUZLQUlBUVFScU5nSUFJQWhCR0dvUUxSb01BUXNMSUFVUTJBRWdDRUVnYWlRQUlBTWdCaEExSUEwZ0JrRUVhaEExSUF3Z0JrRUlhaEExSUFNUU1TQUdFREVRTlNBR0VFb0xJQU1vQWhBZ0F5Z0NDQ0FCRUVnZ0F5QURLQUlJUVFScU5nSUlJQWxCTUdva0FDQUNFTDBDSUFjb0FnUWhBU0FDRUNnZ0FpZ0NBQ0FBSUFkQkJHb2lBeERxQVNBQ0VDZ2dBQ0FDS0FJRUlBZEJDR29pQUJEQkF5QUNJQU1RTlNBQ1FRUnFJQUFRTlNBQ0VDZ2dCeEF4RURVZ0J5QUhLQUlFTmdJQUlBSWdBaEF5RU1jQ0lBRWhBQ0FIRUVvTElBQVE1UUVhSUFwQklHb2tBQXNnRHhBK0lCQkJBWE1MSVFBZ0JFRXdhaVFBSUFBTEVRQWdBaEM2QVNBQUlBRWdBaENXQXhvTEdBQWdBRUgvLy8vL0Ewc0VRQkJGQUFzZ0FFRUNkQkFuQzZBQ0FRZC9JQUFRUFJvQ1FDQUJCRUFnQUNBQkVKZ0RFSG9nQUJBOUlBRTJBZ0FEUUNBQklBSkdCRUFnQUVFSWFpSUNLQUlBSWdORkRRTWdBQ0FES0FJRUlBRVFPeUlIRUM4Z0FqWUNBQU5BSUFNb0FnQWlBa1VOQkFKQUlBSW9BZ1FnQVJBN0lnUWdCMFlOQUNBQ0lRVWdBQ0FFRUM4b0FnQkZCRUFnQUNBRUVDOGdBellDQUNBRUlRY01BUXNEUUFKQUlBVWlCaWdDQUVVRVFFRUFJUVVNQVFzZ0FCQkdJQUpCQ0dvZ0JpZ0NBRUVJYWhDZ0FTRUlJQVlvQWdBaEJTQUlEUUVMQ3lBRElBVTJBZ0FnQmlBQUlBUVFMeWdDQUNnQ0FEWUNBQ0FBSUFRUUx5Z0NBQ0FDTmdJQURBRUxJQUloQXd3QUN3QUZJQUFnQWhBdlFRQTJBZ0FnQWtFQmFpRUNEQUVMQUFzQUN5QUFRUUFRZWlBQUVEMUJBRFlDQUFzTE9BQWdBeWdDQUNFQ0l3QkJFR3NpQUNRQUlBQWdBallDQ0NBQUtBSUlLQUlBSVFJZ0FVRUFOZ0lFSUFFZ0FqWUNBQ0FBUVJCcUpBQUxEQUFnQUNBQktBSUFFSXNDQ3lnQUlBQVFnd0lnQUVFQU5nSllJQUJDQURjQ1VDQUFRYlFSTmdJQUlBQkJnTklBTmdJQUlBQUxEQUFnQUNnQ0FCb2dBUkF1Q3drQUlBQWdBUkRVQVFzTUFDQUFJQUVxQWdBNEFnQUxDUUFnQUVFQU5nSUFDMDRCQW44akFFRVFheUlDSkFBZ0FrRUFOZ0lNSUFBZ0FrRU1haERVQVNNQVFSQnJJZ0VrQUNBQlFRQTJBZ3dnQUVFRWFpQUJRUXhxSUFGQkNHb1FuZ01nQVVFUWFpUUFJQUpCRUdva0FBdE5BUUYvSXdCQkVHc2lBU1FBSUFBUW9RTWdBRUVJYWhDZ0F5QUJRUUEyQWd3Z0FFRU1haUFCUVF4cUVOUUJJQUZCZ0lDQS9BTTJBZ1FnQUVFUWFpQUJRUVJxRUo4RElBRkJFR29rQUFzT0FDQUFMd0VzUVFJUVlVRUNSZ3RkQUNBQUlBRWdBaUFBS0FJQUtBSVVFUWNBSUFBZ0FTQURraUlESUFJZ0FDZ0NBQ2dDR0JFSEFDQUFJQU1nQWlBRWtpSUNJQUFvQWdBb0FoZ1JCd0FnQUNBQklBSWdBQ2dDQUNnQ0dCRUhBQ0FBSUFBb0FnQW9BaUFSQVFBTEtnRUJmd0pBSUFGQkFFZ05BQ0FBUWR3QWFpSUFFRElnQVV3TkFDQUFJQUVRTHlnQ0FDRUNDeUFDQzdnQkFRZC9Jd0JCSUdzaUJ5UUFJQUFRS0NJREFuOGdBQ0FBRURKQkFXb1FTeUVFSUFBUU1pRUlJd0JCRUdzaUJTUUFJQVZCQURZQ0RDQUhRUWhxSWdKQkRHb2dCVUVNYWlBREVFY2dCQVJBSUFJb0FoQWFJQVFRbUFNaEJnc2dBaUFHTmdJQUlBSWdCaUFJUVFKMGFpSUROZ0lJSUFJZ0F6WUNCQ0FDRURFZ0JpQUVRUUowYWpZQ0FDQUZRUkJxSkFBZ0FpZ0NDQXNnQVJCSUlBSWdBaWdDQ0VFRWFqWUNDQ0FBSUFJUVRDQUNFRW9nQjBFZ2FpUUFDdzhBSUFCQkZHb1F0QUVnQUJDMEFRc1NBUUYvSUFBb0FnQWhBU0FBRUMwYUlBRUxFUUFnQUJDaUF5QUFRUlJxRUtJRElBQUx5Qk1DRTM4QmZTTUFRY0FCYXlJQkpBQWdBQ0FBUWN3QWFpSUNRUUFRdFFFMkFxZ0JJQUFnQWtFQUVMVUJOZ0tzQVNBQklBQkIzQUJxSWdrUUtqWUNVQ0FCSUFrUUt6WUNLQ0FBUWNnQWFpRUtBMEFDUUNBQlFkQUFhaUFCUVNocUVDd2lBMFVOQUNBQktBSlFLQUlBSWdJRVFDQUNJQW9nQWlnQ0FDZ0NHQkVDQUNJQ0VLSUJSUTBCQ3lBQlFkQUFhaEF0R2d3QkN3c0NRQ0FERFFBZ0FTQUFRZWdBYWlJT0VDbzJBbEFnQVNBT0VDczJBaWdEUUFKQUlBRkIwQUJxSUFGQktHb1FMQ0lHUlFSQUlBSWhBd3dCQ3lBQktBSlFLQUlBSWdNZ0NpQURLQUlBS0FJWUVRSUFJZ01Rb2dGRkRRQWdBVUhRQUdvUUxSb01BUXNMSUFZRVFDQURJUUlNQVFzZ0FTQUFRZlFBYWlJUEVDbzJBbEFnQVNBUEVDczJBaWdEUUFKQUlBRkIwQUJxSUFGQktHb1FMQ0lDUlFSQUlBTWhCZ3dCQ3lBQktBSlFLQUlBSWdZZ0NpQUdLQUlBS0FJWUVRSUFJZ1lRb2dGRkRRQWdBVUhRQUdvUUxSb01BUXNMSUFJRVFDQUdJUUlNQVFzZ0FVR29BV29Ra0FJaEJTQUJJQWtRS2pZQ1VDQUJJQWtRS3pZQ0tFR0l0d0VvQWdBaEVBTkFBa0FnQVVIUUFHb2dBVUVvYWhBc0lnTkZCRUFnQmlFQ0RBRUxBa0FnQVNnQ1VDZ0NBQ0lIUlEwQUlBY2dDaUFIS0FJQUtBSWNFUUlBSWdJUW9nRkZEUUVnQjBFeElBY29BZ0FvQWd3UkFnQkZEUUFnQVNBQUlBY29BaEFnQUNnQ0FDZ0NVQkVDQUNJQ05nSVlJQUlFUUNNQVFTQnJJZ3NrQUNBTElBRkJHR29pREJDT0FqWUNFQ0FMUVJocUlSRWdDMEVRYWlFU0lBdEJDR29oRTBFQUlRZ2pBRUVnYXlJREpBQWdCUkF4SUF3UW13TWhEU0FGRUZVaEFpQURRUUE2QUI4Q1FBSkFJQUpGRFFBZ0JTQU5JQUlRT3lJSUVDOG9BZ0FpQkVVTkFBTkFJQVFvQWdBaUJFVU5BU0FOSUFRb0FnUkhCRUFnQkNnQ0JDQUNFRHNnQ0VjTkFnc2dCUkJHSUFSQkNHb2dEQkNnQVVVTkFBc01BUXNqQUVFUWF5SU1KQUFnQlJBb0lnUWdBMEVRYWtFUUVDY2dERUVJYWlBRVFRQVFzd0VRc2dFaUJDZ0NBRUVJYWtIODV3QWdFaUFURUpvRElBUVFQVUVCT2dBRUlBUW9BZ0FnRFRZQ0JDQUVLQUlBUVFBMkFnQWdERUVRYWlRQUFrQWdCUUovSUFVUU1TZ0NBRUVCYXJNZ0JSQkdLZ0lBSUFLemxGNUZRUUFnQWh0RkJFQWdBeUFDRUh0QkFYTWdBa0VCZEhJMkFnd2dBd0ovSUFVUU1TZ0NBRUVCYXJNZ0JSQkdLZ0lBbFkwaUZFTUFBSUJQWFNBVVF3QUFBQUJnY1FSQUlCU3BEQUVMUVFBTE5nSUlJQU5CREdvZ0EwRUlhaEJZS0FJQUlRSWpBRUVRYXlJRUpBQWdCQ0FDTmdJTUFrQWdCQ0FDUVFGR0JIOUJBZ1VnQWlBQ1FRRnJjVVVOQVNBQ0VJWUJDeUlDTmdJTUN3SkFJQVVRVlNJSUlBSkpCRUFnQlNBQ0VKa0REQUVMSUFJZ0NFOE5BQ0FJRUhzaERBSi9JQVVRTVNnQ0FMTWdCUkJHS2dJQWxZMGlGRU1BQUlCUFhTQVVRd0FBQUFCZ2NRUkFJQlNwREFFTFFRQUxJUUlnQkFKL0lBd0VRQ0FDRU04QkRBRUxJQUlRaGdFTE5nSUlJQVFnQkVFTWFpQUVRUWhxRUZnb0FnQWlBallDRENBQ0lBaFBEUUFnQlNBQ0VKa0RDeUFFUVJCcUpBQWdEU0FGRUZVaUFoQTdJUWdMSUFnTEVDOG9BZ0FpQkVVRVFDQURLQUlRSUFWQkNHb2lCQ2dDQURZQ0FDQUVJQU1vQWhBMkFnQWdCU0FJRUM4Z0JEWUNBQ0FES0FJUUtBSUFSUTBCSUFNb0FoQWhCQ0FGSUFNb0FoQW9BZ0FvQWdRZ0FoQTdFQzhnQkRZQ0FBd0JDeUFES0FJUUlBUW9BZ0EyQWdBZ0JDQURLQUlRTmdJQUN5QURRUkJxRU5NQklRUWdCUkF4SWdJZ0FpZ0NBRUVCYWpZQ0FDQURRUUU2QUI4Z0EwRVFhaERPQVFzZ0VTQURRUkJxSUFRUVFTQURRUjlxRU5JQklBTkJJR29rQUNBTFFSaHFFSE1oQWlBTFFTQnFKQUFnQWlBSE5nSUVEQUVMSUFFZ0J5Z0NFRFlDQUNBUVFmRG1BQ0FCRU9NQ0N5QUJRZEFBYWhBdEdnd0JDd3NDUUNBRERRQWdBU0FPRUNvMkFsQWdBU0FPRUNzMkFpZ0RRQUpBSUFGQjBBQnFJQUZCS0dvUUxDSUdSUVJBSUFJaEF3d0JDeUFCS0FKUUtBSUFJZ01nQ2lBREtBSUFLQUljRVFJQUlnTVFvZ0ZGRFFBZ0FVSFFBR29RTFJvTUFRc0xJQVlFUUNBRElRSU1BUXNnQVNBUEVDbzJBbEFnQVNBUEVDczJBaWdEUUFKQUlBRkIwQUJxSUFGQktHb1FMQ0lHUlFSQUlBTWhBZ3dCQ3lBQktBSlFLQUlBSWdJZ0NpQUNLQUlBS0FJY0VRSUFJZ0lRb2dGRkRRQWdBVUhRQUdvUUxSb01BUXNMSUFZTkFDQUJJQWtRS2pZQ1VDQUJJQWtRS3pZQ0tDQUFRWXdCYWlFTEEwQUNRQUpBSUFGQjBBQnFJQUZCS0dvUUxFVUVRQ01BUVVCcUlnTWtBQ0FEUVJocUVLa0RJZ1lnQUNJQ0lBSkJnQUZxSWdBUWx3TWdBeUFBRUNvMkFoQWdBeUFBRUNzMkFnaEJBQ0VBQTBBZ0EwRVFhaUFEUVFocUVDd0VRQ0FES0FJUUtBSUFJQUEyQWlRZ0FFRUJhaUVBSUFOQkVHb1FMUm9NQVFVZ0FrRXNha0VDRU5VQklBWVFwd01nQTBGQWF5UUFDd3NnQVVIUUFHb1FyZ0loQXlBQklBa1FLallDS0NBQklBa1FLellDR0F3QkN5QUJLQUpRS0FJQUlnSkZEUUVnQWtFS0lBSW9BZ0FvQWd3UkFnQUVRQ0FDSUFJb0FnQW9BaXdSQVFBTElBSVFyQUpGRFFFZ0FTQUNOZ0lZSUFzZ0FVRVlhaENoQVNBQktBSVlJUUlEUUNBQ1JRMENJQUVnQWpZQ21BRWpBRUVRYXlJRUpBQWdCRUVJYWdKL0l3QkJFR3NpQmlRQUlBVVFNU0FCUVpnQmFpSUlFSnNESVFjQ1FBSkFJQVVRVlNJS1JRMEFJQVVnQnlBS0VEc2lEUkF2S0FJQUlnTkZEUUFEUUNBREtBSUFJZ05GRFFFZ0J5QURLQUlFUndSQUlBTW9BZ1FnQ2hBN0lBMUhEUUlMSUFjZ0F5Z0NCRWNOQUNBRkVFWWdBMEVJYWlBSUVLQUJSUTBBQ3lBR1FRaHFJQU1RUVNnQ0FDRUREQUVMSUFZUWxnRWlBellDQ0FzZ0JrRVFhaVFBSUFNTEVFRW9BZ0FoQXlBRVFSQnFKQUFnQVNBRE5nS2dBU0FCRUtrQk5nS1lBU0FCUWFBQmFpQUJRWmdCYWhEWEFRUkFJQUZCb0FGcUVITWhBaUFCS0FJWUlBSW9BZ1EyQXBRQkRBTUZJQUlvQWhRaEFnd0JDd0FMQUFzRFFBSkFBa0FnQVVFb2FpQUJRUmhxRUN4RkJFQWdBVUVvYWhDcEF5SUdJQU1nQVVFWWFoQTZJZ0FRbHdNZ0FTQUFFQ28yQXFBQklBRkJvQUZxRUtnREdpQUNRWmdCYWlFQ0EwQWdBU0FBRUNzMkFwZ0JJQUZCb0FGcUlBRkJtQUZxRUN4RkRRSWdBU0FCUWFBQmFoQ29BellDRUNBQklBRW9BaEFvQWdBMkFwZ0JJQUlnQVVHWUFXb1Fqd0lNQUFzQUN5QUJLQUlvS0FJQUlnQkZEUUVnQUJEV0FVVU5BU0FESUFBUWNTQUFLQUk0S0FLVUFTSUhSUTBCSUFFZ0NSQXFOZ0tnQVNBQklBa1FLellDbUFFRFFDQUJRYUFCYWlBQlFaZ0JhaEFzUlEwQ0FrQWdBU2dDb0FFb0FnQWlCa1VOQUNBR0VOWUJSUTBBSUFjZ0JpZ0NGRWNOQUNBR0lBQVFjUXNnQVVHZ0FXb1FMUm9NQUFzQUN5QUFFRDRnQmhDbkF5QURFRU1hUVFBaEFnd0VDeUFCUVNocUVDMGFEQUFMQUFzZ0FVSFFBR29RTFJvTUFBc0FDeUFGRUxRQkN5QUJRY0FCYWlRQUlBSkIvd0Z4QzR3REFRTi9Jd0JCRUdzaUFTUUFJQUJCN09ZQU5nSklJQUJCa09ZQU5nSUFJQUVnQUVIY0FHb2lBeEFxTmdJSUlBRWdBeEFyTmdJQUEwQWdBVUVJYWlBQkVDeEZCRUFDUUNBQUxRQzBBUTBBSUFFZ0FFSG9BR29pQWhBcU5nSUlJQUVnQWhBck5nSUFBMEFnQVVFSWFpQUJFQ3hGQkVBZ0FTQUFRZlFBYWlJQ0VDbzJBZ2dnQVNBQ0VDczJBZ0FEUUNBQlFRaHFJQUVRTEVVTkF5QUJLQUlJS0FJQUlnSUVRQ0FDSUFJb0FnQW9BZ1FSQVFBTElBRkJDR29RTFJvTUFBc0FDeUFCS0FJSUtBSUFJZ0lFUUNBQ0lBSW9BZ0FvQWdRUkFRQUxJQUZCQ0dvUUxSb01BQXNBQ3lBQUtBS3NBU0lDQkVBZ0FpQUNLQUlBS0FJRUVRRUFDeUFBS0FLb0FTSUNCRUFnQWlBQ0tBSUFLQUlFRVFFQUN5QUFRWmdCYWhBK0lBQkJqQUZxRUQ0Z0FFR0FBV29RUGlBQVFmUUFhaEErSUFCQjZBQnFFRDRnQXhBK0lBQkJ6QUJxRUxFRElBQVFReG9nQVVFUWFpUUFJQUFQQ3lBQktBSUlLQUlBSWdJZ0FFWWdBa1Z5UlFSQUlBSWdBaWdDQUNnQ0JCRUJBQXNnQVVFSWFoQXRHZ3dBQ3dBTExnQWdBRUdNNVFBMkFnQWdBRUdvQW1vUVF4b2dBRUhvQVdvUVF4b2dBRUdvQVdvUVF4b2dBQkNMQVJvZ0FBdE1BUU4vSUFBUTJnRWdBRUhFSFRZQ0FDQUFRWXpsQURZQ0FDQUFRYWdCYWhCdUlRRWdBRUhvQVdvUWJpRUNJQUJCcUFKcUVHNGhBeUFBSUFFUVpTQUFJQUlRWlNBQUlBTVFaU0FBQ3cwQUlBQW9BZ0FnQVVFR2RHb0xKd0FnQUJDVEFob2dBRUdBZ0lENEF6WUN2QUVnQUVIY0d6WUNBQ0FBUWFUakFEWUNBQ0FBQ3pvQUlBQVFkQ0FBUVFFNkFEZ2dBRUwvLy8vL0R6Y0NNQ0FBUWVnUU5nSUFJQUJCOE5BQU5nSUFJQUJCUEdvUU9ob2dBRUlBTndKSUlBQUxDUUFnQUVFRWFoQStDeTRBSUFCQmtPQUFOZ0lBSUFCQjdBRnFFRDRnQUVHd0FXb1Fsd0lhSUFCQm9BRnFFTEVESUFBUWdBVWFJQUFMRHdBZ0FDQUFMUUFBSUFGeU9nQUFDM2tCQVg4Z0FFR3dBV3BCQ0VFQkVGNGFJd0JCRUdzaUFTUUFJQUVnQUVHa0FXb2lBQkFxTmdJSUlBRWdBQkFyTmdJQUEwQWdBVUVJYWlBQkVDd0VRQ0FCS0FJSUtBSUFJZ0FRa1FJRVFDQUFLQUpJSWdBRVFDQUFJQUFvQWdBb0FnUVJBUUFMQ3lBQlFRaHFFQzBhREFFTEN5QUJRUkJxSkFBTGlRRUFJQUFROFFFYUlBQkNBemNDZ0FFZ0FFR0E0UUEyQWdBZ0FFSHNHallDQUNBQVFZZ0JhaEE2R2lBQVFRQTJBcHdCSUFCQ0FEY0NsQUVnQUVIOEdUWUNBQ0FBUWFBQmFoQ0FCQ0FBUVpEZ0FEWUNBQ0FBUWJBQmFoQjBJQUJDQURjQzVBRWdBQ0FBTmdMZ0FTQUFRWXpiQURZQ3NBRWdBRUhzQVdvUU9ob2dBRUVBT2dENEFTQUFDemNBSUFCQitONEFOZ0lBSUFCQi9BSnFFRU1hSUFCQnZBSnFFRU1hSUFCQi9BRnFFRU1hSUFCQnZBRnFFRU1hSUFBUWl3RWFJQUFMZEFFRWZ5QUFFTm9CSUFCQ0FEY0NyQUVnQUVFQk9nQ29BU0FBUWVRWU5nSUFJQUJDQURjQ3RBRWdBRUg0M2dBMkFnQWdBRUc4QVdvUWJpRUJJQUJCL0FGcUVHNGhBaUFBUWJ3Q2FoQnVJUU1nQUVIOEFtb1FiaUVFSUFBZ0FSQmxJQUFnQWhCbElBQWdBeEJsSUFBZ0JCQmxJQUFMRGdBZ0FVRUFRY0FBRURNUWJob0xFQUFnQUNBQUtBSUFLQUlBRVFBQUdnc3VBUUYvSUFBb0FnUWhBZ05BSUFFZ0FrY0VRQ0FBRUNnYUlBSkJRR29pQWhDNUF3d0JDd3NnQUNBQk5nSUVDOEVLQVExL0l3QkJJR3NpQ0NRQUlBRkJDQkJRQkVBQ1FDQUFRYkFCYWlJRUVId2dBQ0FBS0FJQUtBS0VBUkVBQUVZTkFDQUFJQUFvQWdBb0FvUUJFUUFBSVFNQ1FDQURJQVFRZkNJQ1N3UkFJd0JCSUdzaUN5UUFBa0FnQXlBQ2F5SUpJQVFRS0NnQ0FDQUVLQUlFYTBFR2RVMEVRQ01BUVJCcklnTWtBQ0FESUFRMkFnQWdBeUFFS0FJRUlnSTJBZ1FnQXlBQ0lBbEJCblJxTmdJSUlBTW9BZ1FoQWdOQUlBTW9BZ2dnQWtjRVFDQUVFQ2dnQXlnQ0JCQzRBeUFESUFNb0FnUkJRR3NpQWpZQ0JBd0JDd3NnQXhCcElBTkJFR29rQUF3QkN5QUVFQ2doQ2lBTFFRaHFJUU1DZnlBRUVId2dDV29oQnlNQVFSQnJJZ1VrQUNBRklBYzJBZ3dDZnlNQVFSQnJJZ1lrQUNBRUVDZ2FJQVpCLy8vL0h6WUNEQ0FHUWYvLy8vOEhOZ0lJSUFaQkRHb2dCa0VJYWhDb0FTZ0NBQ0VDSUFaQkVHb2tBQ0FDSUFkUEN3UkFJQVFRaWdFaUJpQUNRUUYyU1FSQUlBVWdCa0VCZERZQ0NDQUZRUWhxSUFWQkRHb1FXQ2dDQUNFQ0N5QUZRUkJxSkFBZ0Fnd0JDeEJ3QUFzaEJTQUVFSHdoQjBFQUlRSWpBRUVRYXlJR0pBQWdCa0VBTmdJTUlBTkJER29nQmtFTWFpQUtFRWNnQlFSQUlBTW9BaEFhSUFWQi8vLy9IMHNFUUJCRkFBc2dCVUVHZEJBbklRSUxJQU1nQWpZQ0FDQURJQUlnQjBFR2RHb2lCellDQ0NBRElBYzJBZ1FnQXhBeElBSWdCVUVHZEdvMkFnQWdCa0VRYWlRQUl3QkJFR3NpQWlRQUlBSWdBeWdDQ0RZQ0FDQURLQUlJSVFVZ0FpQURRUWhxTmdJSUlBSWdCU0FKUVFaMGFqWUNCQ0FDS0FJQUlRVURRQ0FDS0FJRUlBVkhCRUFnQXlnQ0VDQUNLQUlBRUxnRElBSWdBaWdDQUVGQWF5SUZOZ0lBREFFTEN5QUNFTmdCSUFKQkVHb2tBQ0FFRUwwRElBUVFLQm9nQkNnQ0FDRUtJQVFvQWdRaENTQURRUVJxSWd3aEJ3TkFJQWtnQ2tjRVFDQUhLQUlBUVVCcUlnSVFZaUFDUWZBTE5nSUFJQUlnQ1VGQWFpSUpJZ1ZCQkdvaUJpa0NBRGNDQkNBQ0lBWW9BZ2cyQWd3Z0JoQ0pCQ0FDSUFVb0FoQTJBaEFnQWtHSTZBQTJBZ0FnQWlBRktBSVVOZ0lVSUFKQkdHb2dCVUVZYWlJR0VDZ1F3Z01oRFNBQ0lBWW9BZ0EyQWhnZ0FpQUdLQUlFTmdJY0lBWVFLQ2dDQUNFT0lBMFFLQ0FPTmdJQUlBWVFLRUVBTmdJQUlBWkNBRGNDQUNBQ0lBVXZBU3c3QVN3Z0FpQUZLUUlrTndJa0lBSkJzQXMyQWdBZ0FrSHdDallDQUNBQ1FlQVNOZ0lBSUFJZ0JTa0NNRGNDTUNBQ1FjemJBRFlDQUNBQ0lBVW9BamcyQWpnZ0FrSDBIRFlDQUNBQ0lBVXFBanc0QWp3Z0FrRzg1QUEyQWdBZ0J5QUhLQUlBUVVCcU5nSUFEQUVMQ3lBRUlBd1FOU0FFUVFScUlBTkJDR29RTlNBRUVDZ2dBeEF4RURVZ0F5QURLQUlFTmdJQUlBUVFmQm9nQkNnQ0FCb2dCQ2dDQUNBRUVJb0JRUVowYWhvZ0JDZ0NBQ0FFRUlvQlFRWjBhaG9nQkNnQ0FCb2dBeWdDQkNFQ0EwQWdBaUFES0FJSVJ3UkFJQU1vQWhBYUlBTWdBeWdDQ0VGQWFpSUZOZ0lJSUFVUXVRTU1BUXNMSUFNb0FnQUVRQ0FES0FJUUdpQURLQUlBSVFJZ0F4QXhLQUlBSUFNb0FnQnJHaUFDRUM0TEN5QUxRU0JxSkFBTUFRc2dBaUFEU3dSQUlBUW9BZ0FnQTBFR2RHb2hBeUFFRUh3YUlBUWdBeEM2QXlBRUtBSUFHaUFFS0FJQUlBUVFpZ0ZCQm5ScUdpQUVLQUlBR2lBRUtBSUFJQVFRZkVFR2RHb2FDd3NnQUVHTUFXb2lBeEM2QVNBSUlBUVFLallDR0NBSUlBUVFLellDRUFOQUlBaEJHR29nQ0VFUWFoQXNSUTBCSUFnZ0NDZ0NHRFlDRENBSVFReHFJUVFDUUNBREtBSUVJQU1RS0NnQ0FFa0VRQ0FESUFRUVNRd0JDeUFESUFRUXhnTUxJQWhCR0dvUXZBTU1BQXNBQ3lBQUlBQW9BZ0FvQW9nQkVRRUFDeUFBSUFFUW93RWdDRUVnYWlRQUN3OEFJQUFnQUNnQ0FFRkFhellDQUFzMEFDQUFLQUlBR2lBQUtBSUFJQUFRaWdGQkJuUnFHaUFBS0FJQUlBQVFmRUVHZEdvYUlBQW9BZ0FnQUJDS0FVRUdkR29hQ3lzQUlBQXFBakFnQUNvQ05DQUFLQUk0S0FJMElBQW9BamdvQWpBZ0FTQUNJQUFvQWpnUXZ3TVFzQUlMQndBZ0FFRTRhZ3RkQVFKL0l3QkJFR3NpQVNRQUlBQW9BakFnQUJCeElBRWdBQ2dDTUJDV0FpSUNFQ28yQWdnZ0FTQUNFQ3MyQWdBRFFDQUJRUWhxSUFFUUxBUkFJQUVvQWdnb0FnQWdBQkJ4SUFGQkNHb1FMUm9NQVFVZ0FVRVFhaVFBQ3dzTEtBQWdBaUFCYXlJQVFRRk9CRUFnQXlnQ0FDQUJJQUFRWmhvZ0F5QURLQUlBSUFCcU5nSUFDd3N2QUNNQVFSQnJJZ0VrQUNBQVFnQTNBZ0FnQVVFQU5nSU1JQUJCQ0dvZ0FVRU1haERBQWlBQlFSQnFKQUFnQUF1bkFRRUVmeU1BUVJCcklnUWtBQ0FCRUNnYUlBQWdCRUVJYWhEQ0F4b2dBUkF5SWdJRVFDQUFFTWdFSUFKSkJFQVFjQUFMSUFBZ0FCQW9JQUlRdHdFaUF6WUNBQ0FBSUFNMkFnUWdBQkFvSUFNZ0FrRUNkR28yQWdBZ0FFRUFFTWNDSUFFb0FnQWhBeUFCS0FJRUlRVWpBRUVRYXlJQkpBQWdBU0FBSUFJUTZ3RWhBaUFBRUNnZ0F5QUZJQUpCQkdvUXdRTWdBaEJwSUFGQkVHb2tBQXNnQkVFUWFpUUFJQUFMckFFQUlBQVFZaUFBUWZBTE5nSUFJQUJCQkdvZ0FVRUVhaENNQlNBQUlBRW9BaEEyQWhBZ0FFR0k2QUEyQWdBZ0FDQUJLQUlVTmdJVUlBQkJHR29nQVVFWWFoRERBeG9nQUNBQkx3RXNPd0VzSUFBZ0FTa0NKRGNDSkNBQVFiQUxOZ0lBSUFCQjhBbzJBZ0FnQUVIZ0VqWUNBQ0FBSUFFcEFqQTNBakFnQUVITTJ3QTJBZ0FnQUNBQktBSTROZ0k0SUFCQjlCdzJBZ0FnQUNBQktnSThPQUk4SUFCQnZPUUFOZ0lBSUFBTEd3QWdBRUVJUVFBUVhob2dBQ2dDaEFFaUFBUkFJQUFRdEFNTEMxTUJBbjhqQUVFZ2F5SURKQUFnQUJBb0lnSWdBMEVJYWlBQUlBQVFNa0VCYWhCTElBQVFNaUFDRUpnQ0lnSW9BZ2dnQVJCSUlBSWdBaWdDQ0VFRWFqWUNDQ0FBSUFJUVRDQUNFRW9nQTBFZ2FpUUFDeUFBSUFBb0FnUWdBQkFvS0FJQVJ3UkFJQUFnQVJCSkR3c2dBQ0FCRU1ZREN4d0FJQUFRaUFJZ0FDQUFLQUtFQVVHZ0FXcEJBQkMxQVRZQ2lBRUxEQUFnQVNBQ0tnSUFPQUlBQ3djQUlBQVFSQm9MRmdBZ0FTQUNMd0FBT3dBQUlBRWdBaTBBQWpvQUFndURBUUVGZnlBQUVKb0NJQUFRS0NFRUlBQW9BZ0FoQlNBQUtBSUVJUUlnQVVFRWFpSUdJUU1EUUNBQ0lBVkhCRUFnQkNBREtBSUFRUWhySUFKQkNHc2lBaENaQWlBRElBTW9BZ0JCQ0dzMkFnQU1BUXNMSUFBZ0JoQTFJQUJCQkdvZ0FVRUlhaEExSUFBUUtDQUJFREVRTlNBQklBRW9BZ1EyQWdBZ0FDQUFFRTRRMEFNTGVnRUNmeU1BUVJCcklnUWtBQ0FFUVFBMkFnd2dBRUVNYWlBRVFReHFJQU1RUnlBQkJFQWdBQ2dDRUJvZ0FVSC8vLy8vQTBzRVFCQkZBQXNnQVVFQ2RCQW5JUVVMSUFBZ0JUWUNBQ0FBSUFVZ0FrRUNkR29pQWpZQ0NDQUFJQUkyQWdRZ0FCQXhJQVVnQVVFQ2RHbzJBZ0FnQkVFUWFpUUFJQUFMS3dFQmZ5QUFLQUlFSVFJRFFDQUJJQUpIQkVBZ0FCQW9HaUFDUVFocklRSU1BUXNMSUFBZ0FUWUNCQXMxQUNBQUtBSUFHaUFBS0FJQUlBQVFqQUZCQTJ4cUdpQUFLQUlBSUFBUWpnRkJBMnhxR2lBQUtBSUFJQUFRakFGQkEyeHFHZ3NzQUNBQUtBSUFHaUFBS0FJQUlBQVFqUUZCQTNScUdpQUFLQUlBSUFBUWpRRkJBM1JxR2lBQUtBSUFHZ3RSQUNBQUVIUWdBRUlBTndKRUlBQkNnSUNBZ0lDQWdNQS9Od0k4SUFCQ2dJQ0EvQU0zQWpRZ0FFRi9OZ0l3SUFCQnhBODJBZ0FnQUVIc3lRQTJBZ0FnQUVITUFHb1FWQm9nQUVFQU5nSmtJQUFMREFBZ0FTQUNLUUlBTndJQUMySUNBWDhCZlNNQVFSQnJJZ0lrQUNBQ0lBQkJBQkFtS2dJQUlBRkJBQkFtS2dJQWs0czRBZ3dnQWlBQVFRRVFKaW9DQUNBQlFRRVFKaW9DQUpPTE9BSUlJQUpCREdvZ0FrRUlhaEMvQWlvQ0FDRURJQUpCRUdva0FDQURRd0FBZ0Q5ZUN5d0JBWDhnQUVIODFnQTJBZ0FnQUNnQ2FDSUJCRUFnQVNBQktBSUFLQUlFRVFFQUN5QUFFS0FDR2lBQUN3c0FJQUJCb05nQU5nSUFDMUFBSUFBUTFRTWdBRUdzMXdBMkFnQWdBRUVFYWhBNkdpQUFRUkJxRURvYUlBQkJIR29RT2hvZ0FFRW9haEE2R2lBQVFUUnFFRG9hSUFCQlFHc1FPaG9nQUVFQU5nSk1JQUJCMEFCcUVGUWFDdzBBSUFFZ0FKTWdBcFFnQUpJTERRQWdBQ2dDQUNBQlFRTnNhZ3RqQVFGL0l3QkJFR3NpQnlRQUlBQkJLR29nQjBFSWFrRUJJQUJCQkdvaUFCQk9RZjhCY1JEYkF4RGFBeUFBSUFkQkNHb2dBU0FDRUVBUXVRRWdBQ0FIUVFocUlBTWdCQkJBRUxrQklBQWdCMEVJYWlBRklBWVFRQkM1QVNBSFFSQnFKQUFMb2dVQkIzOGdBQ2dDQkNBQUVDZ29BZ0JKQkVBakFFRVFheUlDSkFBZ0FpQUFOZ0lBSUFJZ0FDZ0NCQ0lETmdJRUlBSWdBMEVEYWpZQ0NDQUFFQ2dnQWlnQ0JDQUJFTXNESUFJZ0FpZ0NCRUVEYWpZQ0JDQUNFR2tnQWtFUWFpUUFEd3NqQUVFZ2F5SUhKQUFnQUJBb0lnZ0NmeUFIUVFocUlRSUNmeUFBRUk0QlFRRnFJUVlqQUVFUWF5SUZKQUFnQlNBR05nSU1BbjhqQUVFUWF5SUVKQUFnQUJBb0dpQUVRZFdxMWFvRk5nSU1JQVJCLy8vLy93YzJBZ2dnQkVFTWFpQUVRUWhxRUtnQktBSUFJUU1nQkVFUWFpUUFJQU1nQms4TEJFQWdBQkNNQVNJRUlBTkJBWFpKQkVBZ0JTQUVRUUYwTmdJSUlBVkJDR29nQlVFTWFoQllLQUlBSVFNTElBVkJFR29rQUNBRERBRUxFSEFBQ3lFRklBQVFqZ0VoQmtFQUlRTWpBRUVRYXlJRUpBQWdCRUVBTmdJTUlBSkJER29nQkVFTWFpQUlFRWNnQlFSQUlBSW9BaEFhSUFWQjFhclZxZ1ZMQkVBUVJRQUxJQVZCQTJ3UUp5RURDeUFDSUFNMkFnQWdBaUFESUFaQkEyeHFJZ1kyQWdnZ0FpQUdOZ0lFSUFJUU1TQURJQVZCQTJ4cU5nSUFJQVJCRUdva0FDQUNLQUlJQ3lBQkVNc0RJQUlnQWlnQ0NFRURhallDQ0NBQUVNOERJQUFRS0JvZ0FrRUVhaUlESWdFZ0FTZ0NBQ0FBS0FJRUlBQW9BZ0FpQldzaUFVRjliVUVEYkdvaUJEWUNBQ0FCUVFGT0JFQWdCQ0FGSUFFUVpob0xJQUFnQXhBMUlBQkJCR29nQWtFSWFoQTFJQUFRS0NBQ0VERVFOU0FDSUFJb0FnUTJBZ0FnQUJDT0FSb2dBQ2dDQUJvZ0FDZ0NBQ0FBRUl3QlFRTnNhaG9nQUNnQ0FDQUFFSXdCUVFOc2Fob2dBQ2dDQUJvZ0FpZ0NCQ0VBQTBBZ0FDQUNLQUlJUndSQUlBSW9BaEFhSUFJZ0FpZ0NDRUVEYXpZQ0NBd0JDd3NnQWlnQ0FBUkFJQUlvQWhBYUlBSW9BZ0FoQUNBQ0VERW9BZ0FnQWlnQ0FHc2FJQUFRTGdzZ0IwRWdhaVFBQ3hrQUlBQkJBRG9BQWlBQUlBSTZBQUVnQUNBQk9nQUFJQUFMUUFFQmZ5TUFRUkJySWdNa0FDQUFRU2hxSUFOQkNHcEJBQ0FBUVFScUlnQVFUa0gvQVhFUTJ3TVEyZ01nQUNBRElBRWdBaEJBRUxrQklBTkJFR29rQUFzbkFRRi9Jd0JCRUdzaUF5UUFJQUJCQkdvZ0EwRUlhaUFCSUFJUVFCQzVBU0FEUVJCcUpBQUxud0VCQW44Z0FDZ0NCQ0FBRUNnb0FnQkhCRUFqQUVFUWF5SURKQUFnQXlBQVFRRVE2d0VoQWlBQUVDZ2dBaWdDQkNBQkVNa0RJQUlnQWlnQ0JFRUVhallDQkNBQ0VHa2dBMEVRYWlRQUR3c2pBRUVnYXlJREpBQWdBQkFvSWdJZ0EwRUlhaUFBSUFBUU1rRUJhaEJMSUFBUU1pQUNFTTBESWdJb0FnZ2dBUkRKQXlBQ0lBSW9BZ2hCQkdvMkFnZ2dBQ0FDRUV3Z0FoQktJQU5CSUdva0FBdUpDQUlPZndKOUl3QkJFR3NpQ1NRQUlBa2dBVFlDRENNQVFTQnJJZ1VrQUFKQUFrQWdBVUUwYWlJS0VLUUNEUUFDUUNBQ1FRQVFKaW9DQUNBQlFkQUFhaUlFUVFBUUppb0NBRndOQUNBQ1FRRVFKaW9DQUNBRVFRRVFKaW9DQUZ3TkFDQUNRUUlRSmlvQ0FDQUVRUUlRSmlvQ0FGd05BQ0FDUVFNUUppb0NBQ0FFUVFNUUppb0NBRndOQUNBQ1FRUVFKaW9DQUNBRVFRUVFKaW9DQUZ3TkFDQUNRUVVRSmlvQ0FDQUVRUVVRSmlvQ0FGc2hBd3NnQTBVTkFDQUJLZ0pNSVJFTUFRc2dBU0FDS1FJQU53SlFJQUVnQWlrQ0VEY0NZQ0FCSUFJcEFnZzNBbGdnQ2hDNkFTQUJRUnhxSWdzUXBRSWdBVUVFYWlJTkVFNGhBd0pBSUFNZ0FVRVFhaUlNSWdRUVRpSUdTd1JBSXdCQklHc2lEaVFBQWtBZ0F5QUdheUlHSUFRUUtDZ0NBQ0FFS0FJRWEwRURkVTBFUUNNQVFSQnJJZ2drQUNBSUlBUWdCaENlQWlJREtBSUVJUVlEUUNBREtBSUlJQVpIQkVBZ0JCQW9HaUFES0FJRUVNb0RJQU1nQXlnQ0JFRUlhaUlHTmdJRURBRUxDeUFERUdrZ0NFRVFhaVFBREFFTElBUVFLQ0VESUE1QkNHb2dCQ0FFRUU0Z0Jtb1FuUUlnQkJCT0lBTVFuQUlpRHlFSUl3QkJFR3NpQXlRQUlBTWdDQ2dDQ0RZQ0FDQUlLQUlJSVJBZ0F5QUlRUWhxTmdJSUlBTWdFQ0FHUVFOMGFqWUNCQ0FES0FJQUlRWURRQ0FES0FJRUlBWkhCRUFnQ0NnQ0VCb2dBeWdDQUJES0F5QURJQU1vQWdCQkNHb2lCallDQUF3QkN3c2dBeERZQVNBRFFSQnFKQUFnQkNBUEVNd0RJQThRbXdJTElBNUJJR29rQUF3QkN5QURJQVpKQkVBZ0JDZ0NBQ0FEUVFOMGFpRURJQVFRVGlFR0lBUWdBeERPQXlBRUlBWVE0Z01MQ3lBTkVFNGhCQU5BSUFRZ0IwWUVRQ0FNUVFBUVRTRUhJQVVnQVVFb2FpSUNFQ28yQWhnZ0JTQUNFQ3MyQWhCQkFTRUNBMEFnQlVFWWFpQUZRUkJxRUN3RVFBSi9JQVVvQWhnaUJDMEFBRVVFUUNBRklBY2dEQ0FDRUUwaUJ4RDBBemdDRENBS0lBVkJER29RM2dNZ0JTb0NEQ0VTSUFKQkFXb01BUXNnQkNBTEVFNGlBMEVCYWpvQUFDQUZJQWNnQjBFSWFpQUhRUkJxSUFkQkdHb2lCME1BQUFBQVF3QUFBQUJEQUFDQVB5QUxFS01DT0FJTUlBb2dCVUVNYWhEZUF5QUZLZ0lNSVJJZ0JDQUxFRTRnQTJzNkFBSWdBa0VEYWdzaEFpQVJJQktTSVJFZ0JTQUZLQUlZUVFOcU5nSVlEQUVGSUFFZ0VUZ0NUQXNMQlNBTUlBY1FUU0FOSUFjUVRTQUNFSzBDSUFkQkFXb2hCd3dCQ3dzTElBVkJJR29rQUNBQUlCRWdBQ29DVEpJNEFrd2dDVUVNYWlFQ0FrQWdBRUZBYXlJQUtBSUVJQUFRS0NnQ0FFa0VRQ0FBSUFJUVNRd0JDeU1BUVNCcklnVWtBQ0FBRUNnaUFTQUZRUWhxSUFBZ0FCQXlRUUZxRUVzZ0FCQXlJQUVRelFNaUFTZ0NDQ0FDRUVnZ0FTQUJLQUlJUVFScU5nSUlJQUFnQVJCTUlBRVFTaUFGUVNCcUpBQUxJQWxCRUdva0FBc3JBQ0FBS0FJQUdpQUFLQUlBSUFBUWxRRkJBblJxR2lBQUtBSUFHaUFBS0FJQUlBQVFNa0VDZEdvYUN6SUJBbjhnQUNnQ0FDRUNJQUFvQWdRaEFRTkFJQUVnQWtjRVFDQUFFQ2dhSUFGQkEyc2hBUXdCQ3dzZ0FDQUNOZ0lFQ3lzQUlBQW9BZ0FhSUFBb0FnQWdBQkNOQVVFRGRHb2FJQUFvQWdBYUlBQW9BZ0FnQUJCT1FRTjBhaG9MREFBZ0FDQUFLQUlBRU00REMyVUJBWDhnQUVFQU5nSk1JQUJCSEdvUXBRSWdBRUVFYWhDbEFpQUFRU2hxSWdFUWpnRWFJQUVRNFFNZ0FTZ0NBQm9nQVNnQ0FDQUJFSXdCUVFOc2Fob2dBU2dDQUJvZ0FTZ0NBQ0FCRUk0QlFRTnNhaG9nQUVFMGFoQzZBU0FBUVVCckVMb0JDeU1CQVgwQ1FDQUFRd0FBQUFCZERRQkRBQUNBUHlJQklBQmREUUFnQUNFQkN5QUJDemNBSUFCQjlOUUFOZ0lBSUFCQnlBTnFFRU1hSUFCQjZBSnFFRU1hSUFCQmlBSnFFRU1hSUFCQnFBRnFFRU1hSUFBUWl3RWFJQUFMUkFBZ0FDQUJLZ0l3T0FJd0lBQWdBU29DTkRnQ05DQUFJQUVxQWpnNEFqZ2dBQ0FCS2dJOE9BSThJQUFnQVNvQ1FEZ0NRQ0FBSUFFcUFrUTRBa1FnQUNBQkVHZ0xZQUVFZnlBQUVOb0JJQUJCNkJRMkFnQWdBRUgwMUFBMkFnQWdBRUdvQVdvUXNBRWhBU0FBUVlnQ2FoQ3dBU0VDSUFCQjZBSnFFTEFCSVFNZ0FFSElBMm9Rc0FFaEJDQUFJQUVRWlNBQUlBSVFaU0FBSUFNUVpTQUFJQVFRWlNBQUN3NEFJQUFRdGdFZ0FFRUFPd0U4Q3lVQUlBQXRBRDFGQkVBZ0FDQUFLQUlBS0FKSUVRRUFJQUJCQVRvQVBRc2dBRUhJQUdvTEpBQWdBQzBBUEVVRVFDQUFJQUFvQWdBb0FrUVJBUUFnQUVFQk9nQThDeUFBUVVCckN3Z0FJQUJCMEFCcUMxUUFJQUFRbUFFZ0FFSUFOd0pBSUFCQ2dJQ0FnSUNBZ01BL053STRJQUJDZ0lDQS9BTTNBakFnQUVIc0RqWUNBQ0FBUWRESUFEWUNBQ0FBUWNnQWFoQlVHaUFBUWVBQWFoQTZHaUFBUVFBMkFtd2dBQXRQQVFGL0l3QkJFR3NpQVNRQUlBQkJRR3NnQVVFSWFpQUFLZ0l3SUFBcUFqUVFRQ0FCSUFBcUFsQVFyQUVnQUNvQ1ZJeVVJQUFxQWxBUXJRRWdBQ29DVkl5VUVFQVF2QUVnQVVFUWFpUUFDeklCQVg4Z0FFSHcwQUEyQWdBZ0FDZ0NUQ0lCQkVBZ0FTQUJLQUlBS0FJRUVRRUFDeUFBUVR4cUVENGdBQkJER2lBQUN3c0FJQUFvQW9RQlFRRnhDd2dBSUFCQnNBRnFDeEVBSUFCQkF5QUFLQUlBS0FJTUVRSUFDekFCQVgwZ0FVRUFFQ1lxQWdBaEFpQUFRUUFRSmlBQ09BSUFJQUZCQVJBbUtnSUFJUUlnQUVFQkVDWWdBamdDQUFzMkFRRjlJQUZCQUJBbUtnSUFJQUJCQUJBbUtnSUFreUlDSUFLVUlBRkJBUkFtS2dJQUlBQkJBUkFtS2dJQWt5SUNJQUtVa3BFTFRBQWdBRUVBRUNaQmdJQ0EvQU0yQWdBZ0FFRUJFQ1pCQURZQ0FDQUFRUUlRSmtFQU5nSUFJQUJCQXhBbVFZQ0FnUHdETmdJQUlBQkJCQkFtUVFBMkFnQWdBRUVGRUNaQkFEWUNBQXZZQVFFSWZTQUJRUUFRSmlvQ0FDRURJQUZCQVJBbUtnSUFJUVFnQVVFQ0VDWXFBZ0FoQlNBQlFRTVFKaW9DQUNFR0lBRkJCQkFtS2dJQUlRY2dBVUVGRUNZaEFTQURJQWFVSUFRZ0JaU1RJZ2hEQUFBQUFGd0VRQ0FCS2dJQUlRa2dBRUVBRUNZZ0JrTUFBSUEvSUFpVklnS1VPQUlBSUFCQkFSQW1JQUlnQkl5VU9BSUFJQUJCQWhBbUlBSWdCWXlVT0FJQUlBQkJBeEFtSUFNZ0FwUTRBZ0FnQUVFRUVDWWdBaUFGSUFtVUlBWWdCNVNUbERnQ0FDQUFRUVVRSmlBQ0lBUWdCNVFnQXlBSmxKT1VPQUlBQ3lBSVF3QUFBQUJjQzFnQUlBQWdBVUVBRUNZcUFnQTRBZ0FnQUNBQlFRRVFKaW9DQURnQ0JDQUFJQUZCQWhBbUtnSUFPQUlJSUFBZ0FVRURFQ1lxQWdBNEFnd2dBQ0FCUVFRUUppb0NBRGdDRUNBQUlBRkJCUkFtS2dJQU9BSVVJQUFMTWdBZ0FMeEIvLy8vL3dkeFFZQ0FnUHdIVFFSOUlBQWdBQ0FCbGlBQnZFSC8vLy8vQjNGQmdJQ0EvQWRMR3dVZ0FRc0xqZ0lCQ0g4Z0FDZ0NCQ0VBSXdCQkVHc2lCQ1FBSUFRZ0FUWUNEQ0FFUVF4cUlRY0NRQ0FBUVJCcUlnRW9BZ1FnQVJBb0tBSUFSd1JBSUFFZ0J4QkpEQUVMSXdCQklHc2lDQ1FBSUFFUUtDSUZBbjhnQVNBQkVESkJBV29RU3lFRElBRVFNaUVKSXdCQkVHc2lCaVFBSUFaQkFEWUNEQ0FJUVFocUlnQkJER29nQmtFTWFpQUZFRWNnQXdSQUlBQW9BaEFhSUFOQi8vLy8vd05MQkVBUVJRQUxJQU5CQW5RUUp5RUNDeUFBSUFJMkFnQWdBQ0FDSUFsQkFuUnFJZ1UyQWdnZ0FDQUZOZ0lFSUFBUU1TQUNJQU5CQW5ScU5nSUFJQVpCRUdva0FDQUFLQUlJQ3lBSEVFZ2dBQ0FBS0FJSVFRUnFOZ0lJSUFFZ0FCQk1JQUFRU2lBSVFTQnFKQUFMSUFSQkVHb2tBQXNTQUNBQVFjZ0FJQUFvQWdBb0Fnd1JBZ0FMTUFFQmZ5QUFLQUlFSVFJakFFRVFheUlBSkFBZ0FDQUJOZ0lNSUFKQjNBQnFJQUJCREdvUW9RRWdBRUVRYWlRQUN3UUFRUUlMS1FBZ0FCQ1lBU0FBUVg4MkFqQWdBRUdRelFBMkFnQWdBRUVBTmdJMElBQkJvT2tBTmdJQUlBQUxHZ0FnQUJCaUlBQkJ1TXdBTmdJQUlBQkI1TXdBTmdJQUlBQUxEQUFnQUJDdkFob2dBQkF1Q3hFQUlBQkJBRG9BQUNBQVFRUnFFRG9hQzZRQkFRRi9JQUFRbUFFZ0FFSUFOd0l3SUFCQjFNc0FOZ0lBSUFCQ0FEY0NPQ0FBUVVCclFnQTNBZ0FnQUVISUFHb2lBVUdzekFBMkFnQWdBRUhNQUdvUWdBUWdBRUdRNWdBMkFnQWdBVUhzNWdBMkFnQWdBRUhjQUdvUU9ob2dBRUhvQUdvUU9ob2dBRUgwQUdvUU9ob2dBRUdBQVdvUU9ob2dBRUdNQVdvUU9ob2dBRUdZQVdvUU9ob2dBRUVBT2dDMEFTQUFRZ0EzQXF3QklBQkNBRGNDcEFFZ0FBc3JBUUYvSUFBb0FnUWhBZ05BSUFFZ0FrY0VRQ0FBRUNnYUlBSkJBV3NoQWd3QkN3c2dBQ0FCTmdJRUN5WUFJQUFvQWdBYUlBQW9BZ0FnQUJDUkFXb2FJQUFvQWdBZ0FCQ1JBV29hSUFBb0FnQWFDejhCQVg4akFFRVFheUlCSkFBZ0FCQW9HaUFCUVg4MkFnd2dBVUgvLy8vL0J6WUNDQ0FCUVF4cUlBRkJDR29RcUFFb0FnQWhBQ0FCUVJCcUpBQWdBQXMwQVFKL0FrQWdBQ2dDQkNBQUtBSUFJZ0pyUVFCTUJFQWdBQkRBQVF3QkN5QUFJQUpCQVdvMkFnQWdBaTBBQUNFQkN5QUJDeDRCQVg4Z0FTQUFhMEVFVHdSL0lBSWdBQ2dBQURZQ0FFRUVCVUVBQ3dzc0FDQUFLQUlBR2lBQUtBSUFJQUFRa1FGcUdpQUFLQUlBSUFBUWdRRnFHaUFBS0FJQUlBQVFrUUZxR2d0cUFRSi9Jd0JCRUdzaUFpUUFJQUlnQURZQ0FDQUNJQUFvQWdRaUF6WUNCQ0FDSUFFZ0EybzJBZ2dnQWlJQktBSUVJUU1EUUNBQktBSUlJQU5IQkVBZ0FCQW9HaUFCS0FJRUVMNEJJQUVnQVNnQ0JFRUJhaUlETmdJRURBRUxDeUFCRUdrZ0FrRVFhaVFBQ3kwQkFYOGdBQ0VCUVFBaEFBTkFJQUJCQTBjRVFDQUJJQUJCQW5ScVFRQTJBZ0FnQUVFQmFpRUFEQUVMQ3dzeEFRRi9JQUFRaHdRZ0FDZ0NBQVJBSUFBZ0FDZ0NBQkNDQkNBQUVDZ2FJQUFvQWdBaEFTQUFFSkVCR2lBQkVDNExDeDBCQVg4akFFRVFheUlESkFBZ0FDQUJJQUlRNFFJZ0EwRVFhaVFBQ3hrQkFYOGpBRUVRYXlJQkpBQWdBQkNKQkNBQlFSQnFKQUFMSXdBZ0FCRFRBaG9nQUVJQU53S0lBU0FBUVlRT05nSUFJQUJCNk1jQU5nSUFJQUFMRGdBZ0FTQUFRUU4wZGtIL0FYRUxLZ0VCZnlBQVFkRElBRFlDQUNBQUtBSnNJZ0VFUUNBQkVDNExJQUJCNEFCcUVENGdBQkJER2lBQUN6WUFBa0FDUUFKQUlBRkI1Z0JyRGdJQUFRSUxJQUFnQWhBMk5nSXdRUUVQQ3lBQUlBSVFOallDTkVFQkR3c2dBQ0FCSUFJUVd3c1VBQ0FBSUFFUTRRRWdBRUc4eEFBMkFnQWdBQXNPQUNBQUVNRUJRUVFRWVVFRVJndGlBUUo5SUFBUXdRRkJDQkJoUVFoR0JFQUNmVU1BQUFBQUlBQWdBU0FBS0FJQUtBSTRFUUlBSWdGRkRRQWFJQUlFUUNBQkVLRUVJUU1MSUFFUXVRSUxJUVFnQXlBRUlBQW9BaEN5UXdBQXlFS1ZsSklQQ3lBQUtBSVFza01BQUhwRWxRdHpBUU4vSXdCQkVHc2lBU1FBSUFCQndNSUFOZ0lBSUFFZ0FFRVFhaUlDRUNvMkFnZ2dBU0FDRUNzMkFnQURRQ0FCUVFocUlBRVFMQVJBSUFFb0FnZ29BZ0FpQXdSQUlBTWdBeWdDQUNnQ0JCRUJBQXNnQVVFSWFoQXRHZ3dCQ3dzZ0FoQStJQUFRN1FFYUlBRkJFR29rQUNBQUN3NEFJQUFRd1FGQkVCQmhRUkJHQ3g4QkFYOGdBRUVFYWlJQUVESWdBVXNFZnlBQUlBRVFMeWdDQUFWQkFBc0xDUUFnQUVFRWFoQXlDNVVGQWdwL0JIMENRQ0FCUlEwQUlBQW9BZ2doQnlBQktBSUVJZ3NRbHdRaERBTkFJQW9nREVZTkFTQUxJQW9RbGdRaUNDRUVRUUFoQlNNQVFSQnJJZ1lrQUFKQUlBUVF3UUZCQVJCaFFRRkdEUUFnQmlBRVFSaHFJZ2tRS2pZQ0NDQUdJQWtRS3pZQ0FBTkFJQVpCQ0dvZ0JoQXNCRUFnQWlBR0tBSUlLQUlBSWdrb0FnUkJBblJxS0FJQUlRMGdBd1JBSUFsQnhBQWdDU2dDQUNnQ0RCRUNBQTBEQ3lBSklBMGdDU2dDQUNnQ0tCRUNBRVVOQWlBR1FRaHFFQzBhREFFTEMwRUNJUVVnQkJDU0JFVU5BQ0FFSUFFZ0JDZ0NBQ2dDTkJFQ0FDSUZCRUFnQlNvQ0RDRVFJQVVxQWdnaEVRSkFJQVFnQVNnQ0JFRUFFSk1FSWc0Z0JTZ0NBQ0lFRUxrQ0lnOWZSUTBBSUFRb0FoeEZEUUFnRGlBUElCQWdENVdPbEpJaERndEJBU0VGSUE0Z0VWNE5BUXRCQWlFRkN5QUdRUkJxSkFBQ1FBSkFBa0FnQlVFQmF3NENBUUFDQ3lBQUlBZ29BaFFRbWdSRkRRRWdBQ0FJTmdJUUlBQkJBVG9BSUFKQUlBQW9BZ3dpQVVVTkFDQUJJQUFvQWdSR0RRQWdBU0FCS0FJQUtBSUVFUUVBQ3lBQUlBYzJBZ3dDUUNBSFJRMEFRUUFoQVFKL0lBZEZJQWdRa2dSRmNrVUVRQ0FIS0FJRUVLVUJJUUVMSUFGRklBZ1FsUVJGY2tVTEJIOGdCeEFvSUFnZ0J5Z0NCRUVCRUpNRUVKNEVRUUVGSUFFTFJRMEFJQUFnQUNnQ0RCQW9JZ0VvQWdBMkFpUWdBQ0FCS2dJRU9BSW9DeUFBSUFBcUFoZ2lEamdDSENBT1F3QUFBQUJjQkVBZ0FDQUlFSlVFT2dBVUN3SkFJQUFvQWd3aUFVVU5BQ0FCS0FJRUVLVUJSUTBBSUFBb0FnaEZEUUFnQUNnQ0RCQW9LZ0lRSVE0Z0FDZ0NDQ0lCSUE0Z0FpQUJLQUlBS0FJSUVRd0FDeUFBUVFBMkFoZ2dBRU1BQUFBQUVKa0VJQUJCQURvQUlVRUJEd3NnQUVFQk9nQWhDeUFLUVFGcUlRb01BQXNBQzBFQUMrMEJBUU4vSXdCQkVHc2lBaVFBQWtBQ1FDQUFLQUlRSWdORkRRQWdBQ2dDREVVTkFDQURLQUlNUlEwQUlBSkJnSUNBL0FNMkFnd2dBa0VBTmdJSUlBSWdBQ29DR0NBQkFuMGdBQ2dDRENnQ0JDRUVRd0FBQUFBaEFVTUFBQUFBSUFBb0FoQWlBeWdDREVVTkFCb2dBeERCQVVFQ0VHRkJBa1lFUUFKQUlBUVFwUUZGRFFBZ0JDZ0NGQ0lFUlEwQUlBUVF1UUloQVFzZ0FTQURLQUlNc2tNQUFNaENsWlFNQVFzZ0F5Z0NETEpEQUFCNlJKVUxsWkk0QWdRZ0FDQUNRUXhxSUFKQkNHb2dBa0VFYWhDL0FoQ21BU29DQURnQ0dBd0JDeUFBUVlDQWdQd0ROZ0lZQ3lBQ1FSQnFKQUFMUUFFQmZ3Si9RUUFnQUNnQ0NDSUNSUTBBR2lBQ0tBSUVDeUlDSUFGSEJFQWdBQ0FCQkg4Z0FTQUJLQUlBS0FJa0VRQUFCVUVBQ3pZQ0NBc2dBU0FDUndzb0FRRi9Jd0JCRUdzaUFpUUFJQUlnQVRZQ0RDQUFRUnhxSUFKQkRHb1FuQVFnQWtFUWFpUUFDK0FCQVFkL0lBQW9BZ1FnQUJBb0tBSUFSd1JBSUFBZ0FSQkpEd3NqQUVFZ2F5SUhKQUFnQUJBb0lnUUNmeUFBSUFBUU1rRUJhaEJMSVFNZ0FCQXlJUWdqQUVFUWF5SUZKQUFnQlVFQU5nSU1JQWRCQ0dvaUFrRU1haUFGUVF4cUlBUVFSeUFEQkVBZ0FpZ0NFQm9nQTBILy8vLy9BMHNFUUJCRkFBc2dBMEVDZEJBbklRWUxJQUlnQmpZQ0FDQUNJQVlnQ0VFQ2RHb2lCRFlDQ0NBQ0lBUTJBZ1FnQWhBeElBWWdBMEVDZEdvMkFnQWdCVUVRYWlRQUlBSW9BZ2dMSUFFUVNDQUNJQUlvQWdoQkJHbzJBZ2dnQUNBQ0VFd2dBaEJLSUFkQklHb2tBQXZHQVFFRWZ5TUFRUkJySWdFa0FDQUFRYVRBQURZQ0FDQUJJQUJCSEdvaUF4QXFOZ0lJSUFFZ0F4QXJOZ0lBQTBBQ1FDQUJRUWhxSUFFUUxFVUVRQ0FCSUFCQkVHb2lBaEFxTmdJSUlBRWdBaEFyTmdJQUEwQWdBVUVJYWlBQkVDeEZEUUlnQVNnQ0NDZ0NBQ0lFQkVBZ0JDQUVLQUlBS0FJRUVRRUFDeUFCUVFocUVDMGFEQUFMQUFzZ0FTZ0NDQ2dDQUNJQ0JFQWdBaUFDS0FJQUtBSUVFUUVBQ3lBQlFRaHFFQzBhREFFTEN5QURFRDRnQWhBK0lBQVF3d0VhSUFGQkVHb2tBQ0FBQzJVQ0FuOEJmU0FCSUFBcUFnUmNCRUFnQUNBQk9BSUVJQUFxQWdnZ0FDb0NESk1oQkNBQUtBSUFMUUFvQkVBZ0FDZ0NBQ2dDSUNFQ0N5QUFLQUlBS0FJUUlRTWdBRUVCTmdJVUlBQWdBU0FDSUFOc3NwTWlBVGdDQ0NBQUlBRWdCSk00QWd3TEMwSUFJQUFRc2dJYUlBQkMvNEdBZ0JBM0FrZ2dBRUwvZ1lDQUVEY0NRQ0FBUWRRTU5nSUFJQUJCckEwMkFnQWdBRUhRQUdvUVJCb2dBRUhZQUdvUVJCb2dBQXVyQkFNQmZ3UitBbndDZkNBQXV5RUhBa0FnQWJjaUNMMGlCVUlCaGlJRVVDQUZRdi8vLy8vLy8vLy8vd0NEUW9DQWdJQ0FnSUQ0L3dCV2NrVUVRQ0FIdlNJR1FqU0lwMEgvRDNFaUFrSC9EMGNOQVFzZ0J5QUlvaUlJSUFpakRBRUxBbjRDUUNBRUlBWkNBWVlpQTFRRVFDQUZRalNJcDBIL0QzRWhBU0FDUlFSQUlBWkNESVlpQTBJQVV3UkFRUUFoQWd3REMwRi9JUUlEUUNBRFFnR0dJZ05DQUZNTkF5QUNRUUZySVFJTUFBc0FDeUFHUXYvLy8vLy8vLzhIZzBLQWdJQ0FnSUNBQ0lRTUFnc2dCMFFBQUFBQUFBQUFBS0lnQnlBRElBUlJHd3dDQ3lBR1FRRWdBbXV0aGdzaEF3SitBa0FnQVVVRVFDQUZRZ3lHSWdSQ0FGTUVRRUVBSVFFTUFndEJmeUVCQTBBZ0JFSUJoaUlFUWdCVERRSWdBVUVCYXlFQkRBQUxBQXNnQlVMLy8vLy8vLy8vQjROQ2dJQ0FnSUNBZ0FpRURBRUxJQVZCQVNBQmE2MkdDeUVGSUFFZ0FrZ0VRQU5BQWtBZ0F5QUZmU0lFUWdCVERRQWdCQ0lEUWdCU0RRQWdCMFFBQUFBQUFBQUFBS0lNQXdzZ0EwSUJoaUVESUFKQkFXc2lBaUFCU2cwQUN5QUJJUUlMQWtBZ0F5QUZmU0lFUWdCVERRQWdCQ0lEUWdCU0RRQWdCMFFBQUFBQUFBQUFBS0lNQVFzQ1FDQURRdi8vLy8vLy8vOEhWZ1JBSUFNaEJBd0JDd05BSUFKQkFXc2hBaUFEUW9DQWdJQ0FnSUFFVkNFQklBTkNBWVlpQkNFRElBRU5BQXNMSUFaQ2dJQ0FnSUNBZ0lDQWY0TWdCRUtBZ0lDQWdJQ0FDSDBnQXExQ05JYUVJQVJCQVNBQ2E2MklJQUpCQVU0YmhMOExDeDBBSUFBdEFDZ0VmU0FBS0FJZ3NnVkRBQUFBQUFzZ0FDZ0NFTEtWQzNJQkEzOGpBRUVRYXlJQkpBQWdBRUg0UGpZQ0FDQUJJQUJCTEdvaUFoQXFOZ0lJSUFFZ0FoQXJOZ0lBQTBBZ0FVRUlhaUFCRUN3RVFDQUJLQUlJS0FJQUlnTUVRQ0FESUFNb0FnQW9BZ1FSQVFBTElBRkJDR29RTFJvTUFRc0xJQUlRUGlBQUVNTUJHaUFCUVJCcUpBQWdBQXNhQUNBQlFUa1FVU0lCUlFSQVFRRVBDeUFCSUFBUStRTkJBQXN3QUNBQUlBRXFBakE0QWpBZ0FDQUJLZ0kwT0FJMElBQWdBU29DT0RnQ09DQUFJQUVxQWp3NEFqd2dBQ0FCRUdnTEl3QWdBU0FBS0FLQUFVY0VRQ0FBSUFFMkFvQUJJQUFnQUNnQ0FDZ0NYQkVCQUFzTElRQWdBU0FBS0FJa1J3UkFJQUFnQVRZQ0pDQUFJQUFvQWdBb0Fqd1JBUUFMQ3lFQUlBRWdBQ2dDREVjRVFDQUFJQUUyQWd3Z0FDQUFLQUlBS0FJc0VRRUFDd3NoQUNBQklBQW9BZ2hIQkVBZ0FDQUJOZ0lJSUFBZ0FDZ0NBQ2dDS0JFQkFBc0x3QWNBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJRZHdBYXc0bUdoc1lHaGdZR0JnWUdCb2JHQmdZR0JnWUZCVVdGeGdZR0E0WUdoc2FBUmdZRXhnWUVCSUFDd0pBQWtBQ1FDQUJRU2hyRGg0Ukdob2FHaG9hR2c0UEdoNGFIaG9hR3dnYUNRb0xHaG9hR2hvZUFRSUFDd0pBQWtBZ0FVR1ZBV3NPRnh3Ykh3WWJHeDhGR3djYkNCc2JHeHNmR3cwQkd4c09BQXNnQVVFWFJnMFRJQUZCQlVjTkdnd2JDeUFDSUFBb0FneEhCRUFnQUNBQ05nSU1JQUFnQUNnQ0FDZ0NLQkVCQUFzUEN5QUFJQUlRcUFRUEN5QUFJQUlRcHdRUEN5QUFJQUlRc2dRUEN5QUNJQUFvQWdoSEJFQWdBQ0FDTmdJSUlBQWdBQ2dDQUNnQ01CRUJBQXNQQ3lBQUlBSVFxQVFQQ3lBQUlBSVFwd1FQQ3lBQ0lBQW9BaEJIQkVBZ0FDQUNOZ0lRSUFBZ0FDZ0NBQ2dDTUJFQkFBc1BDeUFDSUFBb0FoUkhCRUFnQUNBQ05nSVVJQUFnQUNnQ0FDZ0NMQkVCQUFzUEN5QUNJQUFvQWh4SEJFQWdBQ0FDTmdJY0lBQWdBQ2dDQUNnQ05CRUJBQXNQQ3lBQ0lBQW9BaUJIQkVBZ0FDQUNOZ0lnSUFBZ0FDZ0NBQ2dDT0JFQkFBc1BDeUFBSUFJUXBnUVBDeUFDSUFBb0FoeEhCRUFnQUNBQ05nSWNJQUFnQUNnQ0FDZ0NLQkVCQUFzUEN5QUFJQUlRcGdRUEN5QUNJQUFvQWp4SEJFQWdBQ0FDTmdJOElBQWdBQ2dDQUNnQ1VCRUJBQXNQQ3lBQ0lBQW9Ba0JIQkVBZ0FDQUNOZ0pBSUFBZ0FDZ0NBQ2dDVkJFQkFBc1BDeUFDSUFBb0FqeEhCRUFnQUNBQ05nSThJQUFnQUNnQ0FDZ0NSQkVCQUFzUEN5QUNJQUFvQWpoSEJFQWdBQ0FDTmdJNElBQWdBQ2dDQUNnQ1RCRUJBQXNQQ3lBQUlBSVFwUVFQQ3lBQUlBSVFwUVFQQ3lBQ0lBQW9Bb1FCUndSQUlBQWdBallDaEFFZ0FDQUFLQUlBS0FKZ0VRRUFDdzhMSUFJZ0FDZ0NxQUZIQkVBZ0FDQUNOZ0tvQVNBQUlBQW9BZ0FvQW53UkFRQUxEd3NnQWlBQUtBSkFSd1JBSUFBZ0FqWUNRQ0FBSUFBb0FnQW9Ba0FSQVFBTER3c2dBaUFBS0FKRVJ3UkFJQUFnQWpZQ1JDQUFJQUFvQWdBb0FrUVJBUUFMRHdzZ0FpQUFLQUpJUndSQUlBQWdBallDU0NBQUlBQW9BZ0FvQWtnUkFRQUxEd3NnQWlBQUtBSk1Sd1JBSUFBZ0FqWUNUQ0FBSUFBb0FnQW9Ba3dSQVFBTEN3OExJQUlnQUNnQ0VFY0VRQ0FBSUFJMkFoQWdBQ0FBS0FJQUtBSW9FUUVBQ3c4TElBQWdBaEM3QWc4TElBSWdBQ2dDTkVjRVFDQUFJQUkyQWpRZ0FDQUFLQUlBS0FJOEVRRUFDdzhMSUFJZ0FDZ0NCRWNFUUNBQUlBSTJBZ1FnQUNBQUtBSUFLQUlrRVFFQUN3c2pBQ0FCSUFBcUFvd0JYQVJBSUFBZ0FUZ0NqQUVnQUNBQUtBSUFLQUpjRVFFQUN3c3JBUUYvSUFBb0FnUWhBZ05BSUFFZ0FrY0VRQ0FBRUNnYUlBSkJCR3NoQWd3QkN3c2dBQ0FCTmdJRUN5TUFJQUVnQUNvQ2lBRmNCRUFnQUNBQk9BS0lBU0FBSUFBb0FnQW9BbGdSQVFBTEN5UUFJQUVnQUNvQ3JBRmNCRUFnQUNBQk9BS3NBU0FBSUFBb0FnQW9Bb0FCRVFFQUN3c2hBQ0FCSUFBcUFsaGNCRUFnQUNBQk9BSllJQUFnQUNnQ0FDZ0NWQkVCQUFzTElRQWdBU0FBS2dKOFhBUkFJQUFnQVRnQ2ZDQUFJQUFvQWdBb0FsZ1JBUUFMQ3lFQUlBRWdBQ29DT0Z3RVFDQUFJQUU0QWpnZ0FDQUFLQUlBS0FKQUVRRUFDd3ZvRFFBQ1FDQUNRd0FBZ0Q5Y0JFQWdBaUFEbEVNQUFJQS9JQUtUQW4xREFBQUFBQ0VDQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBRkJCMnNPb0FFWEdCa2FHeUFjSFJjWUdSb1ZCd2dWRlJjWUdoVVZGUlVMRlJnWkdoVVZGUmdWRlJjVkZSVWJHUlVWRlJVVkZSVVZGUlVGRlJVVkZRRUNGZ01WRlJVRUZSVVZGUlVWRlJVZUh3WWVIeDRmRVJJVkV4d2RGUlVWRlJnWkdoc2dGQlVWRnhnWkdoc2dGUlVWRlJjWUdSVVZGUlVWRlFrS0ZROFFGUlVWRlJVVkZSVVZGUlVWQUJVVkZSVVZGUlVWRlJVVkZSVVZGUlVXRlJVVkRBME9GUlVXRlFzZ0FDb0NFQXdnQ3lBQUtnSUVEQjhMSUFBcUFnZ01IZ3NnQUNvQ0VBd2RDeUFBS2dJWURCd0xJQUFxQWhnTUd3c2dBQ29DV0F3YUN5QUFLZ0tZQVF3WkN5QUFLZ0tjQVF3WUN5QUFLZ0tnQVF3WEN5QUFLZ0trQVF3V0N5QUFLZ0tzQVF3VkN5QUFLZ0t3QVF3VUN5QUFLZ0swQVF3VEN5QUFLZ0s0QVF3U0N5QUFLZ0tzQVF3UkN5QUFLZ0s4QVF3UUN5QUFLZ0pZREE4TElBQXFBbHdNRGdzZ0FDb0NlQXdOQ3lBQUtnSklJUUlMSUFJTUN3c2dBQ29DREF3S0N5QUFLZ0l3REFrTElBQXFBalFNQ0FzZ0FDb0NPQXdIQ3lBQUtnSThEQVlMSUFBcUFrQU1CUXNnQUNBQUtBSUFLQUpNRVFZQURBUUxJQUFnQUNnQ0FDZ0NVQkVHQUF3REN5QUFLZ0pRREFJTElBQXFBbFFNQVFzZ0FDb0NSQXVVa2lFREN3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUZCQjJzT29BRWRIaDhnSVNRS0N4MGVIeUFsRFE0bEpSMGVJQ1VsSlNVUkpSNGZJQ1VsSlI0bEpSMGxKU1VoQ1NVbEpTVWxKU1VsSlNVSEpTVWxKUUlEQkFVbEpTVUdKU1VsSlNVbEpTVWlJd3dpSXlJakZ4Z2xHUm9iSlNVbEpSNGZJQ0VrSENVbEhSNGZJQ0VrSlNVbEpSMGVIeVVsSlNVbEpROFFKUlVXSlNVbEpTVWxKU1VsSlNVbEFDVWxKU1VsSlNVbEpTVWxKU1VsSlNVQkpTVWxFaE1VSlNVSUpRc2dBeUFBS2dJUVhBUkFJQUFnQXpnQ0VDQUFJQUFvQWdBb0FpZ1JBUUFMRENRTElBTWdBQ29DREZ3RVFDQUFJQU00QWd3Z0FDQUFLQUlBS0FJMEVRRUFDd3dqQ3lBRElBQXFBZ1JjQkVBZ0FDQURPQUlFSUFBZ0FDZ0NBQ2dDSkJFQkFBc01JZ3NnQXlBQUtnSUlYQVJBSUFBZ0F6Z0NDQ0FBSUFBb0FnQW9BaWdSQVFBTERDRUxJQU1nQUNvQ0RGd0VRQ0FBSUFNNEFnd2dBQ0FBS0FJQUtBSXNFUUVBQ3d3Z0N5QURJQUFxQWhCY0JFQWdBQ0FET0FJUUlBQWdBQ2dDQUNnQ01CRUJBQXNNSHdzZ0F5QUFLZ0lZWEFSQUlBQWdBemdDR0NBQUlBQW9BZ0FvQWpnUkFRQUxEQjRMSUFNZ0FDb0NHRndFUUNBQUlBTTRBaGdnQUNBQUtBSUFLQUl3RVFFQUN3d2RDeUFESUFBcUFneGNCRUFnQUNBRE9BSU1JQUFnQUNnQ0FDZ0NLQkVCQUFzTUhBc2dBeUFBS2dJNFhBUkFJQUFnQXpnQ09DQUFJQUFvQWdBb0Frd1JBUUFMREJzTElBQWdBeERqQVF3YUN5QUFJQU1RcndRTUdRc2dBQ0FERUs0RURCZ0xJQU1nQUNvQ21BRmNCRUFnQUNBRE9BS1lBU0FBSUFBb0FnQW9BbXdSQVFBTERCY0xJQU1nQUNvQ25BRmNCRUFnQUNBRE9BS2NBU0FBSUFBb0FnQW9BbkFSQVFBTERCWUxJQU1nQUNvQ29BRmNCRUFnQUNBRE9BS2dBU0FBSUFBb0FnQW9BblFSQVFBTERCVUxJQU1nQUNvQ3BBRmNCRUFnQUNBRE9BS2tBU0FBSUFBb0FnQW9BbmdSQVFBTERCUUxJQUFnQXhDdEJBd1RDeUFESUFBcUFyQUJYQVJBSUFBZ0F6Z0NzQUVnQUNBQUtBSUFLQUtFQVJFQkFBc01FZ3NnQXlBQUtnSzBBVndFUUNBQUlBTTRBclFCSUFBZ0FDZ0NBQ2dDaUFFUkFRQUxEQkVMSUFNZ0FDb0N1QUZjQkVBZ0FDQURPQUs0QVNBQUlBQW9BZ0FvQW93QkVRRUFDd3dRQ3lBQUlBTVFyUVFNRHdzZ0F5QUFLZ0s4QVZ3RVFDQUFJQU00QXJ3QklBQWdBQ2dDQUNnQ2pBRVJBUUFMREE0TElBQWdBeEN1QkF3TkN5QURJQUFxQWx4Y0JFQWdBQ0FET0FKY0lBQWdBQ2dDQUNnQ1dCRUJBQXNNREFzZ0FDQURFT01CREFzTElBQWdBeENzQkF3S0N5QUFJQU1RcWdRTUNRc2dBeUFBS2dKSVhBUkFJQUFnQXpnQ1NDQUFJQUFvQWdBb0FsQVJBUUFMREFnTElBQWdBeEJYREFjTElBQWdBeEJXREFZTElBQWdBeEN3QkF3RkN5QUFJQU1RZ3dFTUJBc2dBeUFBS2dKQVhBUkFJQUFnQXpnQ1FDQUFJQUFvQWdBb0FrZ1JBUUFMREFNTElBTWdBQ29DVUZ3RVFDQUFJQU00QWxBZ0FDQUFLQUlBS0FKTUVRRUFDd3dDQ3lBRElBQXFBbFJjQkVBZ0FDQURPQUpVSUFBZ0FDZ0NBQ2dDVUJFQkFBc01BUXNnQXlBQUtnSkVYQVJBSUFBZ0F6Z0NSQ0FBSUFBb0FnQW9Ba3dSQVFBTEN3c2hBQ0FCSUFBb0FoaEhCRUFnQUNBQk5nSVlJQUFnQUNnQ0FDZ0NPQkVCQUFzTGhBRUFBa0FnQWtNQUFJQS9YQVJBQW44Q1FBSkFBa0FnQVVFbGF3NENBUUlBQzBFQUlBRkIyQUJIRFFJYUlBQW9BaGdNQWdzZ0FDZ0NNQXdCQ3lBQUtBSXdDeUFESUFJUWdRTWhBd3NDUUFKQUFrQUNRQ0FCUVNWckRnSUJBZ0FMSUFGQjJBQkhEUUlnQUNBREVMSUVEQU1MSUFBZ0F4QzdBZ3dDQ3lBQUlBTVF1d0lMQ3d0c0FRTi9Jd0JCRUdzaUFTUUFJQUJCaERzMkFnQWdBU0FBUVFocUlnSVFLallDQ0NBQklBSVFLellDQUFOQUlBRkJDR29nQVJBc0JFQWdBU2dDQ0NnQ0FDSURCRUFnQXlBREtBSUFLQUlFRVFFQUN5QUJRUWhxRUMwYURBRUxDeUFDRUQ0Z0FVRVFhaVFBSUFBTERBQWdBQ0FBS0FJQUVLc0VDMndCQTM4akFFRVFheUlCSkFBZ0FFR1FPallDQUNBQklBQkJDR29pQWhBcU5nSUlJQUVnQWhBck5nSUFBMEFnQVVFSWFpQUJFQ3dFUUNBQktBSUlLQUlBSWdNRVFDQURJQU1vQWdBb0FnUVJBUUFMSUFGQkNHb1FMUm9NQVFzTElBSVFQaUFCUVJCcUpBQWdBQXNaQUNBQlFRRVFVU0lCQkg4Z0FTQUFFUHNEUVFBRlFRRUxDOFFDQWdKL0IzMENmVUVCSVFJRFFBSkFJQUpCQ2tZRVFDQUFLZ0k4SVFRTUFRc2dBQ0FDUVFKMGFpb0NGQ0lFSUFGZlJRMEFJQUpCQVdvaEFpQUZRODNNekQyU0lRVU1BUXNMQWtBZ0JTQUJJQUpCQW5RZ0FHb3FBaEFpQnBNZ0JDQUdrNVZEemN6TVBaU1NJZ1FnQUNvQ0JDSUdJQUFxQWd3aUNCQzVCQ0lIUTI4U2d6cGdCRUJCQUNFQ0EwQWdBa0VFUmcwQ0lBUWdCaUFJRUxrRUlnVkRBQUFBQUZzTkFpQUVJQVFnQmlBSUVPUUJJQUdUSUFXVmt5RUVJQUpCQVdvaEFnd0FDd0FMSUFkREFBQUFBRnNOQUNBRlE4M016RDJTSVFkQkFDRUNBMEFnQlNBSElBV1RRd0FBQUQrVWtpSUVJQVlnQ0JEa0FTQUJreUlKaXlFS0lBSkJDRXNOQVNBRklBUWdDVU1BQUFBQVhpSURHeUVGSUFRZ0J5QURHeUVISUFKQkFXb2hBaUFLUTVXLzFqTmVEUUFMQ3lBRUN5QUFLZ0lJSUFBcUFoQVE1QUVMUWdFQmZTQUJRd0FBUUVDVUlnTWdBa01BQUVCQWxDSUNJQUZEQUFEQXdKU1NJZ0VnQVpJZ0FKUWdBME1BQUlBL0lBS1Rra01BQUVCQWxDQUFsQ0FBbEpLU0N3d0FJQUFRc3dJYUlBQVFMZ3RtQVFGL0l3QkJFR3NpQWlRQUlBSWdBRUVJYWlJQUVDbzJBZ2dnQWlBQUVDczJBZ0FEUUFKQUFuOUJBQ0FDUVFocUlBSVFMRVVOQUJvZ0FpZ0NDQ0lBS0FJQUlBRkhEUUVnQUJBOUN5RUFJQUpCRUdva0FDQUFEd3NnQWtFSWFoRENBUXdBQ3dBTERRQWdBQ29DQUNBQktnSUFYUXRWQVFGL0lBQW9BZ1FoQVFOQUlBRWdBQ2dDQ0VjRVFDQUFLQUlRR2lBQUlBQW9BZ2hCS0dzMkFnZ01BUXNMSUFBb0FnQUVRQ0FBS0FJUUdpQUFLQUlBSVFFZ0FCQXhLQUlBSUFBb0FnQnJHaUFCRUM0TEM1NEJBUVIvSUFBUXdRUWdBQkFvR2lBQlFRUnFJZ01pQWlBQ0tBSUFJQUFvQWdRZ0FDZ0NBQ0lFYXlJQ1FWaHRRU2hzYWlJRk5nSUFJQUpCQVU0RVFDQUZJQVFnQWhCbUdnc2dBQ0FERURVZ0FFRUVhaUFCUVFocUVEVWdBQkFvSUFFUU1SQTFJQUVnQVNnQ0JEWUNBQ0FBRUlRQkdpQUFLQUlBR2lBQUtBSUFJQUFRcHdGQktHeHFHaUFBS0FJQUlBQVFwd0ZCS0d4cUdpQUFLQUlBR2d1VEFRRURmeU1BUVJCcklnSWtBQ0FDSUFFMkFnd0NmeU1BUVJCcklnTWtBQ0FBRUNnYUlBTkI1c3laTXpZQ0RDQURRZi8vLy84SE5nSUlJQU5CREdvZ0EwRUlhaENvQVNnQ0FDRUVJQU5CRUdva0FDQUJJQVJOQ3dSQUlBQVFwd0VpQUNBRVFRRjJTUVJBSUFJZ0FFRUJkRFlDQ0NBQ1FRaHFJQUpCREdvUVdDZ0NBQ0VFQ3lBQ1FSQnFKQUFnQkE4TEVIQUFDMVFCQW44akFFRVFheUlESkFBZ0F5QUFOZ0lBSUFNZ0FDZ0NCQ0lDTmdJRUlBTWdBa0VvYWpZQ0NDQURJUUlnQUJBb0lBSW9BZ1FnQVJEQkFpQUNJQUlvQWdSQktHbzJBZ1FnQWhCcElBTkJFR29rQUFzMUFDQUFLQUlBR2lBQUtBSUFJQUFRcHdGQktHeHFHaUFBS0FJQUlBQVFoQUZCS0d4cUdpQUFLQUlBSUFBUXB3RkJLR3hxR2d0VkFRSi9JQUFRd1FRZ0FDZ0NBQVJBSUFBb0FnQWhBaUFBS0FJRUlRRURRQ0FCSUFKSEJFQWdBQkFvR2lBQlFTaHJJUUVNQVFzTElBQWdBallDQkNBQUVDZ2FJQUFvQWdBaEFTQUFFS2NCR2lBQkVDNExDd2NBSUFBdEFCUUxYQUVCZnlNQVFSQnJJZ01rQUNBRElBQkJDR29pQUJBcU5nSUlJQU1nQUJBck5nSUFBMEFnQTBFSWFpQURFQ3dFUUNBREtBSUlJZ0JCQkdvZ0FTQUFLZ0lrSUFLVUVNd0NJQU5CQ0dvUXdnRU1BUVVnQTBFUWFpUUFDd3NMQ1FBZ0FDQUJPQUlrQ3djQUlBQXFBZ3dMSUFBZ0FDQUJOZ0lBSUFCQkJHb2dBU2dDQ0JDNEFob2dBRUVBTmdJa0lBQUxRd0VCZnlNQVFSQnJJZ0VrQUNBQUVDZ2FJQUZCLy8vLy93TTJBZ3dnQVVILy8vLy9CellDQ0NBQlFReHFJQUZCQ0dvUXFBRW9BZ0FoQUNBQlFSQnFKQUFnQUFzTkFDQUFMd0VBSUFFdkFRQkdDd2tBSUFFZ0FoREpCQXVnQVFFRmZ5TUFRUkJySWdNa0FDQUFFREVhSUFFdkFRQWhCQUpBQWtBZ0FCQlZJZ1ZGRFFBZ0FDQUVJQVVRT3lJR0VDOG9BZ0FpQWtVTkFBTkFJQUlvQWdBaUFrVU5BU0FFSUFJb0FnUkhCRUFnQWlnQ0JDQUZFRHNnQmtjTkFnc2dCQ0FDS0FJRVJ3MEFJQUFRUmlBQ1FRaHFJQUVReWdSRkRRQUxJQU5CQ0dvZ0FoQkJLQUlBSVFJTUFRc2dBeENXQVNJQ05nSUlDeUFEUVJCcUpBQWdBZ3NKQUNBQUlBRVF5Z0lMS1FFQmZ5TUFRUkJySWdJa0FDQUNRUWhxSUFBZ0FSRExCQkJCS0FJQUlRQWdBa0VRYWlRQUlBQUxDZ0FnQUVIb0FHb1FNZ3Y0QWdFTGZ5QUJRVHdRVVNJQ1JRUkFRUUVQQ3dKL0lBSW9BZ1FRK2dNaUN3UkFJQUlvQWdRaEFpTUFRUkJySWdVa0FDQUZJQUEyQWd3Z0JVRU1haUVKQWtBZ0FrRVFhaUlES0FJRUlBTVFLQ2dDQUVjRVFDQURJQWtRU1F3QkN5TUFRU0JySWdva0FDQURFQ2dpQmdKL0lBTWdBeEF5UVFGcUVFc2hCQ0FERURJaERDTUFRUkJySWdja0FDQUhRUUEyQWd3Z0NrRUlhaUlDUVF4cUlBZEJER29nQmhCSElBUUVRQ0FDS0FJUUdpQUVRZi8vLy84RFN3UkFFRVVBQ3lBRVFRSjBFQ2NoQ0FzZ0FpQUlOZ0lBSUFJZ0NDQU1RUUowYWlJR05nSUlJQUlnQmpZQ0JDQUNFREVnQ0NBRVFRSjBhallDQUNBSFFSQnFKQUFnQWlnQ0NBc2dDUkJJSUFJZ0FpZ0NDRUVFYWpZQ0NDQURJQUlRVENBQ0VFb2dDa0VnYWlRQUN5QUZRUkJxSkFBTFFRSWdDMFVOQUJwQkFTQUJRUUVRVVNJQlJRMEFHaUFCS0FJRUVNNEVJUUlDUUNBQUtBSUVRUUJJRFFBZ0FpQUFLQUlFVFEwQUlBQWdBU2dDQkNBQUtBSUVFSXdDTmdJSUMwRUFDd3NIQUNBQUxRQW9DeG9BSUFBUTB3UWdBRUdjTXpZQ0FDQUFRWXpHQURZQ0FDQUFDeUVBSUFBUTFBUWdBRUVBTmdJTUlBQkIzREkyQWdBZ0FFSE14UUEyQWdBZ0FBc2VBQ0FBRUdJZ0FFRi9OZ0lFSUFCQnJESTJBZ0FnQUVHVXhRQTJBZ0FMSGdBZ0FCRFRCQ0FBUVFBMkFnZ2dBRUh3TVRZQ0FDQUFRYlF4TmdJQUN3UUFRUUVMR2dBZ0FVR2JBVVlFUUNBQUlBSVFOallDQkFzZ0FVR2JBVVlMSUFBZ0FVR2NBVVlFUUNBQUlBSVFOallDQ0VFQkR3c2dBQ0FCSUFJUTFnUUxFd0FnQUNBQktBSUlOZ0lJSUFBZ0FSRHZBUXNhQUNBQUVOUUVJQUJCK0RBMkFnQWdBRUhZeEFBMkFnQWdBQXRXQUFKQUFrQUNRQUpBQWtBZ0FVR1hBV3NPQ2dBQkJBUUVCQVFDQkFNRUN5QUFJQUlRTmpZQ0JFRUJEd3NnQUNBQ0VEWTJBZ2hCQVE4TElBQWdBaEEyTmdJTVFRRVBDeUFBSUFJUU5qWUNFRUVCRHd0QkFBc1pBQ0FBRU04Q0lBQkIzQzgyQWdBZ0FFR01NRFlDQUNBQUN5QUFJQUFRendJZ0FFRUFOZ0lRSUFCQjlDNDJBZ0FnQUVHb0x6WUNBQ0FBQ3pBQUlBQVEzd1FnQUVIRUxqWUNBQ0FBUWNEQ0FEWUNBQ0FBUVJCcUVEb2FJQUJCQURZQ0pDQUFRZ0EzQWh3Z0FBc1RBQ0FBSUFFcUFuZzRBbmdnQUNBQkVLUUVDeUVBSUFBUVlpQUFRWkF1TmdJQUlBQkJCR3BCdUM0UWx3RWdBRUhnTFRZQ0FBc2dBQ0FBRU04Q0lBQkJBRG9BRUNBQVFjZ3NOZ0lBSUFCQi9DdzJBZ0FnQUFzckFDQUFFUEFCR2lBQVFaZ3NOZ0lBSUFCQnBNQUFOZ0lBSUFCQkVHb1FPaG9nQUVFY2FoQTZHaUFBQzBjQUlBQVE4QUVhSUFCQkFEb0FLQ0FBUW44M0FpQWdBRUtBZ0lEOEF6Y0NHQ0FBUXJ5QWdJREFCemNDRUNBQVFjd3JOZ0lBSUFCQitENDJBZ0FnQUVFc2FoQTZHaUFBQ3lBQUlBQVEwUUlnQUVGL05nSVlJQUJCaUNzMkFnQWdBRUhBUFRZQ0FDQUFDeUFBSUFBUTBRSWdBRUVBTmdJWUlBQkJ4Q28yQWdBZ0FFSDhQRFlDQUNBQUN5QUFJQUFnQVNnQ0JEWUNCQ0FBSUFFb0FnZzJBZ2dnQUNBQktBSU1OZ0lNQ3hNQUlBQWdBU2dDR0RZQ0dDQUFJQUVRNVFRTElBQWdBQkRSQWlBQVFRQTJBaGdnQUVISUtUWUNBQ0FBUWJnOE5nSUFJQUFMSndBZ0FCQmlJQUJCQURZQ0JDQUFRWmdwTmdJQUlBQkJoRHMyQWdBZ0FFRUlhaEE2R2lBQUN5Y0FJQUFRWWlBQVFRQTJBZ1FnQUVIb0tEWUNBQ0FBUVpBNk5nSUFJQUJCQ0dvUU9ob2dBQXNhQUNBQUVLb0JHaUFBUVlnb05nSUFJQUJCdUNnMkFnQWdBQXNhQUNBQUVLb0JHaUFBUWFnbk5nSUFJQUJCMkNjMkFnQWdBQXN5QUNBQUVHSWdBRUxoOWRINGc0Q0F3RDgzQWd3Z0FFSzlsTnoyQXpjQ0JDQUFRZXdtTmdJQUlBQkIxRGsyQWdBZ0FBc2FBQ0FBRUtvQkdpQUFRWXdtTmdJQUlBQkJ2Q1kyQWdBZ0FBc1dBQ0FBRUdJZ0FFSGdKVFlDQUNBQVFiUWxOZ0lBQ3dRQVFRQUxLQUFnQUJDcUFSb2dBRUYvTmdJUUlBQkIxQ1EyQWdBZ0FFRUFOZ0lVSUFCQjFETTJBZ0FnQUFzMkFRRi9Jd0JCRUdzaUF5UUFJQUZCTjBZRVFDQURJQUlRekFFZ0FFRUVhaUFERU00Q0lBTVFid3NnQTBFUWFpUUFJQUZCTjBZTE9nQWdBQkQ4QkNBQVFRRTZBRVFnQUVFQU5nSkFJQUJDZ0lDQS9BTTNBamdnQUVHOElqWUNBQ0FBUVFBMkFrZ2dBRUdnK3dBMkFnQWdBQXNTQUNBQUlBRW9BakEyQWpBZ0FDQUJFR2dMT0FFQmZ5QUFFSFFnQUVIMDZORjdOZ0l3SUFCQitDRTJBZ0FnQUVFMGFoRDNCQ0VCSUFCQnpQb0FOZ0lBSUFGQmxQc0FOZ0lBSUFBTERBQWdBQkRVQWhvZ0FCQXVDeXdBSUFBUTFRSWFJQUJCN0NFMkFrUWdBRUdRSVRZQ0FDQUFRZXo1QURZQ1JDQUFRWkQ1QURZQ0FDQUFDeDRBSUFCQkFEWUNEQ0FBUW9DQWdQd0ROd0lFSUFCQmhDRTJBZ0FnQUF0T0FDQUFFSmdCSUFCQ2dJQ0EvSU9BZ01BL053STRJQUJDZ0lDQWdJQ0FnTUEvTndJd0lBQkJvQW8yQWdBZ0FFSG85UUEyQWdBZ0FFRkFheEJVR2lBQVFkZ0FhaEJVR2lBQVFnQTNBbkFMT2dBZ0FDQUJLZ0l3T0FJd0lBQWdBU29DTkRnQ05DQUFJQUVxQWpnNEFqZ2dBQ0FCS2dJOE9BSThJQUFnQVNvQ1FEZ0NRQ0FBSUFFUWFBc2tBQ0FBRUhRZ0FFTC8vLy8vRHpjQ01DQUFRZWdmTmdJQUlBQkJuUGNBTmdJQUlBQUxMd0VCZnlNQVFSQnJJZ0VrQUNBQVFnQTNBZ0FnQVVFQU5nSU1JQUJCQ0dvZ0FVRU1haERBQWlBQlFSQnFKQUFMSmdBZ0FCQ1lBU0FBUVFFNkFDNGdBRUdnSHpZQ0FDQUFRZ0EzQWpBZ0FFSDQrUUEyQWdBTEVnQWdBQ0FCTFFBdU9nQXVJQUFnQVJCb0N5RUFJQUFRL0FRZ0FFRUFOZ0k0SUFCQnlCNDJBZ0FnQUVIRTlnQTJBZ0FnQUFzTUFDQUFFSklDR2lBQUVDNExHUUFnQUVIc0dqWUNBQ0FBUVlnQmFoQStJQUFRUXhvZ0FBczZBQUpBQWtBQ1FDQUJRZjBBYXc0Q0FBRUNDeUFBSUFJUU5qWUNxQUZCQVE4TElBQWdBaEF3dGpnQ3JBRkJBUThMSUFBZ0FTQUNFT2NDQ3lFQUlBQWdBU2dDcUFFMkFxZ0JJQUFnQVNvQ3JBRTRBcXdCSUFBZ0FSRDFBUXN5QUNBQUVQRUJHaUFBUVFBMkFvQUJJQUJCNUJZMkFnQWdBRUlBTndLRUFTQUFRZFRaQURZQ0FDQUFRWXdCYWhBNkdndENBUUYvSUFBUWd3VWdBRUVBT2dDWUFTQUFRZXdWTmdJQUlBQkJuQUZxSWdGQkFEWUNCQ0FCUWN3WE5nSUFJQUJCbU53QU5nSUFJQUZCbE4wQU5nSUFJQUFMZndFRGZ5QUFJUUVDUUNBQVFRTnhCRUFEUUNBQkxRQUFSUTBDSUFGQkFXb2lBVUVEY1EwQUN3c0RRQ0FCSWdKQkJHb2hBU0FDS0FJQUlnTkJmM01nQTBHQmdvUUlhM0ZCZ0lHQ2hIaHhSUTBBQ3lBRFFmOEJjVVVFUUNBQ0lBQnJEd3NEUUNBQ0xRQUJJUU1nQWtFQmFpSUJJUUlnQXcwQUN3c2dBU0FBYXd2bEFnRUZmd0pBSUFDOElnUkJGM1pCL3dGeElnRkIvd0ZIRFFBZ0FFTUFBSUEvbENJQUlBQ1ZEd3NnQkVFQmRDSUNRWUNBZ1BnSFN3UkFBbjhnQVVVRVFFRUFJUUVDUUNBRVFRbDBJZ0pCQUVnTkFFRi9JUUVEUUNBQ1FRRjBJZ0pCQUVnTkFTQUJRUUZySVFFTUFBc0FDeUFFUVFFZ0FXdDBEQUVMSUFSQi8vLy9BM0ZCZ0lDQUJISUxJUUlnQVVIL0FFb0VRQU5BQWtBZ0FrR0FnSUFFYXlJRFFRQklEUUFnQXlJQ0RRQWdBRU1BQUFBQWxBOExJQUpCQVhRaEFpQUJRUUZySWdGQi93QktEUUFMUWY4QUlRRUxBa0FnQWtHQWdJQUVheUlEUVFCSURRQWdBeUlDRFFBZ0FFTUFBQUFBbEE4TEFrQWdBa0gvLy84RFN3UkFJQUloQXd3QkN3TkFJQUZCQVdzaEFTQUNRWUNBZ0FKSklRVWdBa0VCZENJRElRSWdCUTBBQ3dzZ0JFR0FnSUNBZUhFZ0EwR0FnSUFFYXlBQlFSZDBjaUFEUVFFZ0FXdDJJQUZCQVU0YmNyNFBDeUFBUXdBQUFBQ1VJQUFnQWtHQWdJRDRCMFliQ3lFQUlBRkIyUUJHQkVBZ0FDQUNFREMyT0FKNFFRRVBDeUFBSUFFZ0FoRFlBZ3NqQUNBQVFRQTJBZ3dnQUNBQk5nSUVJQUFnQVRZQ0FDQUFJQUZCQVdvMkFnZ2dBQXZ4QWdFSmZ5QUFJQUZIQkg4Z0FSQnlJUVVnQVJDVEFTRUJJd0JCRUdzaUJpUUFBa0FnQVNBQUVJVUJCSDhnQUJERUFrRUJhd1ZCQ2dzaUEwMEVRQ0FBRUhJaUFpRURJQUVFUUNBRElBVWdBUkRkQWdzZ0JrRUFPZ0FQSUFFZ0Ftb2dCa0VQYWhEcEFRSkFJQUFRaFFFRVFDQUFJQUVRNEFJTUFRc2dBQ0FCRU1nQ0N3d0JDeUFBRUpNQklnY2hDU01BUVJCcklnSWtBQUpBSUFFZ0Eyc2lCQ0FEUVg5elFSRnJUUVJBSUFBUWNpRUlBbjhnQTBIbi8vLy9CMGtFUUNBQ0lBTkJBWFEyQWdnZ0FpQURJQVJxTmdJTUlBSkJER29nQWtFSWFoQllLQUlBRUlzRkRBRUxRVzRMUVFGcUlnb1FKeUVFSUFFRVFDQUVJQVVnQVJEZkFnc2dDU0FIYXlJRkJFQWdBU0FFYWlBSElBaHFJQVVRM3dJTElBTkJDa2NFUUNBSUVDNExJQUFnQkJEb0FTQUFJQW9RaWdVZ0FDQUJJQVZxSWdBUTRBSWdBa0VBT2dBSElBQWdCR29nQWtFSGFoRHBBU0FDUVJCcUpBQU1BUXNRY0FBTEN5QUdRUkJxSkFCQkFBVWdBQXNhQ3hBQUlBQWdBVUdBZ0lDQWVISTJBZ2dMSkFBZ0FFRUxUd1IvSUFCQkVHcEJjSEVpQUNBQVFRRnJJZ0FnQUVFTFJoc0ZRUW9MQzBVQkFYOGpBRUVRYXlJQ0pBQUNRQ0FCRUlVQlJRUkFJQUFnQVNnQ0NEWUNDQ0FBSUFFcEFnQTNBZ0FNQVFzZ0FDQUJLQUlBSUFFb0FnUVE0UUlMSUFKQkVHb2tBQXQrQVFOL0l3QkJFR3NpQlNRQUl3QkJFR3NpQXlRQUlBRWdBR3RCQW5VaEFRTkFJQUVFUUNBRElBQTJBZ3dnQXlBREtBSU1JQUZCQVhZaUJFRUNkR28yQWd3Z0FTQUVRWDl6YWlBRUlBTW9BZ3dnQWhER0FpSUVHeUVCSUFNb0FneEJCR29nQUNBRUd5RUFEQUVMQ3lBRFFSQnFKQUFnQlVFUWFpUUFJQUFMQndBZ0FDb0NlQXU3QWdBQ1FDQUJRUlJMRFFBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJRUWxyRGdvQUFRSURCQVVHQndnSkNnc2dBaUFDS0FJQUlnRkJCR28yQWdBZ0FDQUJLQUlBTmdJQUR3c2dBaUFDS0FJQUlnRkJCR28yQWdBZ0FDQUJOQUlBTndNQUR3c2dBaUFDS0FJQUlnRkJCR28yQWdBZ0FDQUJOUUlBTndNQUR3c2dBaUFDS0FJQVFRZHFRWGh4SWdGQkNHbzJBZ0FnQUNBQktRTUFOd01BRHdzZ0FpQUNLQUlBSWdGQkJHbzJBZ0FnQUNBQk1nRUFOd01BRHdzZ0FpQUNLQUlBSWdGQkJHbzJBZ0FnQUNBQk13RUFOd01BRHdzZ0FpQUNLQUlBSWdGQkJHbzJBZ0FnQUNBQk1BQUFOd01BRHdzZ0FpQUNLQUlBSWdGQkJHbzJBZ0FnQUNBQk1RQUFOd01BRHdzZ0FpQUNLQUlBUVFkcVFYaHhJZ0ZCQ0dvMkFnQWdBQ0FCS3dNQU9RTUFEd3NnQUNBQ0lBTVJBd0FMQzFJQkEzOENRQ0FBS0FJQUxBQUFFTVFCUlFSQURBRUxBMEFnQUNnQ0FDSUNMQUFBSVFNZ0FDQUNRUUZxTmdJQUlBRWdBMnBCTUdzaEFTQUNMQUFCRU1RQlJRMEJJQUZCQ213aEFRd0FDd0FMSUFFTDFnSUJBMzhqQUVIUUFXc2lCU1FBSUFVZ0FqWUN6QUZCQUNFQ0lBVkJvQUZxUVFCQktCQXpHaUFGSUFVb0Fzd0JOZ0xJQVFKQVFRQWdBU0FGUWNnQmFpQUZRZEFBYWlBRlFhQUJhaUFESUFRUTVRSkJBRWdOQUNBQUtBSk1RUUJPSVFJZ0FDZ0NBQ0VHSUFBc0FFcEJBRXdFUUNBQUlBWkJYM0UyQWdBTElBWkJJSEVoQndKL0lBQW9BakFFUUNBQUlBRWdCVUhJQVdvZ0JVSFFBR29nQlVHZ0FXb2dBeUFFRU9VQ0RBRUxJQUJCMEFBMkFqQWdBQ0FGUWRBQWFqWUNFQ0FBSUFVMkFod2dBQ0FGTmdJVUlBQW9BaXdoQmlBQUlBVTJBaXdnQUNBQklBVkJ5QUZxSUFWQjBBQnFJQVZCb0FGcUlBTWdCQkRsQWlBR1JRMEFHaUFBUVFCQkFDQUFLQUlrRVFRQUdpQUFRUUEyQWpBZ0FDQUdOZ0lzSUFCQkFEWUNIQ0FBUVFBMkFoQWdBQ2dDRkJvZ0FFRUFOZ0lVUVFBTEdpQUFJQUFvQWdBZ0IzSTJBZ0FnQWtVTkFBc2dCVUhRQVdva0FBdC9BZ0YvQVg0Z0FMMGlBMEkwaUtkQi93OXhJZ0pCL3c5SEJId2dBa1VFUUNBQklBQkVBQUFBQUFBQUFBQmhCSDlCQUFVZ0FFUUFBQUFBQUFEd1E2SWdBUkNTQlNFQUlBRW9BZ0JCUUdvTE5nSUFJQUFQQ3lBQklBSkIvZ2RyTmdJQUlBTkMvLy8vLy8vLy80ZUFmNE5DZ0lDQWdJQ0FnUEEvaEw4RklBQUxDNXNDQUNBQVJRUkFRUUFQQ3dKL0FrQWdBQVIvSUFGQi93Qk5EUUVDUUVIVXZRRW9BZ0FvQWdCRkJFQWdBVUdBZjNGQmdMOERSZzBEREFFTElBRkIvdzlOQkVBZ0FDQUJRVDl4UVlBQmNqb0FBU0FBSUFGQkJuWkJ3QUZ5T2dBQVFRSU1CQXNnQVVHQXNBTlBRUUFnQVVHQVFIRkJnTUFEUnh0RkJFQWdBQ0FCUVQ5eFFZQUJjam9BQWlBQUlBRkJESFpCNEFGeU9nQUFJQUFnQVVFR2RrRS9jVUdBQVhJNkFBRkJBd3dFQ3lBQlFZQ0FCR3RCLy84L1RRUkFJQUFnQVVFL2NVR0FBWEk2QUFNZ0FDQUJRUkoyUWZBQmNqb0FBQ0FBSUFGQkJuWkJQM0ZCZ0FGeU9nQUNJQUFnQVVFTWRrRS9jVUdBQVhJNkFBRkJCQXdFQ3d0QjRNQUJRUmsyQWdCQmZ3VkJBUXNNQVFzZ0FDQUJPZ0FBUVFFTEM0WUNBZ04vQVh3akFFRVFheUlESkFBQ1FDQUF2Q0lFUWYvLy8vOEhjU0lDUWRxZnBPNEVUUVJBSUFFZ0FMc2lCU0FGUklQSXlXMHdYK1Evb2tRQUFBQUFBQUE0UTZCRUFBQUFBQUFBT01PZ0lnVkVBQUFBVVBzaCtiK2lvQ0FGUkdOaUdtRzBFRkcrb3FBNUF3QWdCWmxFQUFBQUFBQUE0RUZqQkVBZ0Jhb2hBZ3dDQzBHQWdJQ0FlQ0VDREFFTElBSkJnSUNBL0FkUEJFQWdBU0FBSUFDVHV6a0RBRUVBSVFJTUFRc2dBeUFDSUFKQkYzWkJsZ0ZySWdKQkYzUnJ2cnM1QXdnZ0EwRUlhaUFESUFKQkFVRUFFSllGSVFJZ0F5c0RBQ0VGSUFSQmYwd0VRQ0FCSUFXYU9RTUFRUUFnQW1zaEFnd0JDeUFCSUFVNUF3QUxJQU5CRUdva0FDQUNDOHdKQXdSOEJYOEJmaU1BUVRCcklnZ2tBQUpBQWtBQ1FDQUF2U0lMUWlDSXB5SUdRZi8vLy84SGNTSUhRZnJVdllBRVRRUkFJQVpCLy84L2NVSDd3eVJHRFFFZ0IwSDhzb3VBQkUwRVFDQUxRZ0JaQkVBZ0FTQUFSQUFBUUZUN0lmbS9vQ0lBUkRGallocGh0TkM5b0NJQ09RTUFJQUVnQUNBQ29VUXhZMklhWWJUUXZhQTVBd2hCQVNFR0RBVUxJQUVnQUVRQUFFQlUreUg1UDZBaUFFUXhZMklhWWJUUVBhQWlBamtEQUNBQklBQWdBcUZFTVdOaUdtRzAwRDJnT1FNSVFYOGhCZ3dFQ3lBTFFnQlpCRUFnQVNBQVJBQUFRRlQ3SVFuQW9DSUFSREZqWWhwaHRPQzlvQ0lDT1FNQUlBRWdBQ0FDb1VReFkySWFZYlRndmFBNUF3aEJBaUVHREFRTElBRWdBRVFBQUVCVSt5RUpRS0FpQUVReFkySWFZYlRnUGFBaUFqa0RBQ0FCSUFBZ0FxRkVNV05pR21HMDREMmdPUU1JUVg0aEJnd0RDeUFIUWJ1TThZQUVUUVJBSUFkQnZQdlhnQVJOQkVBZ0IwSDhzc3VBQkVZTkFpQUxRZ0JaQkVBZ0FTQUFSQUFBTUg5ODJSTEFvQ0lBUk1xVWs2ZVJEdW05b0NJQ09RTUFJQUVnQUNBQ29VVEtsSk9ua1E3cHZhQTVBd2hCQXlFR0RBVUxJQUVnQUVRQUFEQi9mTmtTUUtBaUFFVEtsSk9ua1E3cFBhQWlBamtEQUNBQklBQWdBcUZFeXBTVHA1RU82VDJnT1FNSVFYMGhCZ3dFQ3lBSFFmdkQ1SUFFUmcwQklBdENBRmtFUUNBQklBQkVBQUJBVlBzaEdjQ2dJZ0JFTVdOaUdtRzA4TDJnSWdJNUF3QWdBU0FBSUFLaFJERmpZaHBodFBDOW9Ea0RDRUVFSVFZTUJBc2dBU0FBUkFBQVFGVDdJUmxBb0NJQVJERmpZaHBodFBBOW9DSUNPUU1BSUFFZ0FDQUNvVVF4WTJJYVliVHdQYUE1QXdoQmZDRUdEQU1MSUFkQitzUGtpUVJMRFFFTElBRWdBQ0FBUklQSXlXMHdYK1Evb2tRQUFBQUFBQUE0UTZCRUFBQUFBQUFBT01PZ0lnTkVBQUJBVlBzaCtiK2lvQ0lDSUFORU1XTmlHbUcwMEQyaUlnV2hJZ0E1QXdBZ0IwRVVkaUlKSUFDOVFqU0lwMEgvRDNGclFSRklJUWNDZnlBRG1VUUFBQUFBQUFEZ1FXTUVRQ0FEcWd3QkMwR0FnSUNBZUFzaEJnSkFJQWNOQUNBQklBSWdBMFFBQUdBYVliVFFQYUlpQUtFaUJDQURSSE53QXk2S0dhTTdvaUFDSUFTaElBQ2hvU0lGb1NJQU9RTUFJQWtnQUwxQ05JaW5RZjhQY1d0Qk1rZ0VRQ0FFSVFJTUFRc2dBU0FFSUFORUFBQUFMb29ab3p1aUlnQ2hJZ0lnQTBUQlNTQWxtb043T2FJZ0JDQUNvU0FBb2FFaUJhRWlBRGtEQUFzZ0FTQUNJQUNoSUFXaE9RTUlEQUVMSUFkQmdJREEvd2RQQkVBZ0FTQUFJQUNoSWdBNUF3QWdBU0FBT1FNSVFRQWhCZ3dCQ3lBTFF2Ly8vLy8vLy84SGcwS0FnSUNBZ0lDQXNNRUFoTDhoQUNBSVFSQnFJUVlnQ0VFUWFrRUljaUVKUVFFaENnTkFJQVlDZnlBQW1VUUFBQUFBQUFEZ1FXTUVRQ0FBcWd3QkMwR0FnSUNBZUF1M0lnSTVBd0FnQUNBQ29VUUFBQUFBQUFCd1FhSWhBQ0FLQkVCQkFDRUtJQWtoQmd3QkN3c2dDQ0FBT1FNZ0lBaEJFR29nQ0NBSFFSUjJRWllJYXdKL0lBQkVBQUFBQUFBQUFBQmhCRUJCQVNFR0EwQWdCaUlKUVFGcklRWWdDRUVRYWlBSlFRTjBhaXNEQUVRQUFBQUFBQUFBQUdFTkFBc2dDVUVCYWd3QkMwRURDMEVCRUpZRklRWWdDQ3NEQUNFQUlBdENmMWNFUUNBQklBQ2FPUU1BSUFFZ0NDc0RDSm81QXdoQkFDQUdheUVHREFFTElBRWdBRGtEQUNBQklBZ3JBd2c1QXdnTElBaEJNR29rQUNBR0M5NFJBZ044RDM4akFFR3dCR3NpQ1NRQUlBSWdBa0VEYTBFWWJTSUlRUUFnQ0VFQVNoc2lFVUZvYkdvaERDQUVRUUowUWJDYkFXb29BZ0FpRFNBRFFRRnJJZ3RxUVFCT0JFQWdBeUFOYWlFSUlCRWdDMnNoQWdOQUlBbEJ3QUpxSUFwQkEzUnFJQUpCQUVnRWZFUUFBQUFBQUFBQUFBVWdBa0VDZEVIQW13RnFLQUlBdHdzNUF3QWdBa0VCYWlFQ0lBcEJBV29pQ2lBSVJ3MEFDd3NnREVFWWF5RVBJQTFCQUNBTlFRQktHeUVLUVFBaENBTkFSQUFBQUFBQUFBQUFJUVVnQTBFQVNnUkFJQWdnQzJvaERrRUFJUUlEUUNBRklBQWdBa0VEZEdvckF3QWdDVUhBQW1vZ0RpQUNhMEVEZEdvckF3Q2lvQ0VGSUFKQkFXb2lBaUFEUncwQUN3c2dDU0FJUVFOMGFpQUZPUU1BSUFnZ0NrWWhBaUFJUVFGcUlRZ2dBa1VOQUF0Qkx5QU1heUVUUVRBZ0RHc2hFaUFNUVJscklSUWdEU0VJQWtBRFFDQUpJQWhCQTNScUt3TUFJUVZCQUNFQ0lBZ2hDaUFJUVFGSUloQkZCRUFEUUNBSlFlQURhaUFDUVFKMGFnSi9JQVVDZnlBRlJBQUFBQUFBQUhBK29pSUZtVVFBQUFBQUFBRGdRV01FUUNBRnFnd0JDMEdBZ0lDQWVBdTNJZ1ZFQUFBQUFBQUFjTUdpb0NJR21VUUFBQUFBQUFEZ1FXTUVRQ0FHcWd3QkMwR0FnSUNBZUFzMkFnQWdDU0FLUVFGcklncEJBM1JxS3dNQUlBV2dJUVVnQWtFQmFpSUNJQWhIRFFBTEN3Si9JQVVnRHhEeUFTSUZJQVZFQUFBQUFBQUF3RCtpbkVRQUFBQUFBQUFnd0tLZ0lnV1pSQUFBQUFBQUFPQkJZd1JBSUFXcURBRUxRWUNBZ0lCNEN5RU9JQVVnRHJlaElRVUNRQUpBQWtBQ2Z5QVBRUUZJSWhWRkJFQWdDRUVDZENBSmFpSUNJQUlvQXR3RElnSWdBaUFTZFNJQ0lCSjBheUlLTmdMY0F5QUNJQTVxSVE0Z0NpQVRkUXdCQ3lBUERRRWdDRUVDZENBSmFpZ0MzQU5CRjNVTElndEJBVWdOQWd3QkMwRUNJUXNnQlVRQUFBQUFBQURnUDJZTkFFRUFJUXNNQVFzQ1FDQVFCRUJCQUNFS0RBRUxRUUFoQWtFQklSQURRQ0FKUWVBRGFpQUNRUUowYWlJV0tBSUFJUW9DZnlBV0lCQUVmMEVBSUFwRkRRRWFRWUNBZ0FnZ0Ntc0ZRZi8vL3djZ0Ntc0xOZ0lBUVFFTElRb2dBa0VCYWlJQ0lBaEdEUUVnQ2tVaEVBd0FDd0FMQWtBZ0ZRMEFBa0FDUUNBVURnSUFBUUlMSUFoQkFuUWdDV29pQWlBQ0tBTGNBMEgvLy84RGNUWUMzQU1NQVFzZ0NFRUNkQ0FKYWlJQ0lBSW9BdHdEUWYvLy93RnhOZ0xjQXdzZ0RrRUJhaUVPSUF0QkFrY05BRVFBQUFBQUFBRHdQeUFGb1NFRlFRSWhDeUFLUlEwQUlBVkVBQUFBQUFBQThEOGdEeER5QWFFaEJRc2dCVVFBQUFBQUFBQUFBR0VFUUVFQUlRb0NRQ0FJSWdJZ0RVd05BQU5BSUFsQjRBTnFJQUpCQVdzaUFrRUNkR29vQWdBZ0NuSWhDaUFDSUExS0RRQUxJQXBGRFFBZ0R5RU1BMEFnREVFWWF5RU1JQWxCNEFOcUlBaEJBV3NpQ0VFQ2RHb29BZ0JGRFFBTERBTUxRUUVoQWdOQUlBSWlDa0VCYWlFQ0lBbEI0QU5xSUEwZ0NtdEJBblJxS0FJQVJRMEFDeUFJSUFwcUlRb0RRQ0FKUWNBQ2FpQURJQWhxSWd0QkEzUnFJQWhCQVdvaUNDQVJha0VDZEVIQW13RnFLQUlBdHprREFFRUFJUUpFQUFBQUFBQUFBQUFoQlNBRFFRRk9CRUFEUUNBRklBQWdBa0VEZEdvckF3QWdDVUhBQW1vZ0N5QUNhMEVEZEdvckF3Q2lvQ0VGSUFKQkFXb2lBaUFEUncwQUN3c2dDU0FJUVFOMGFpQUZPUU1BSUFnZ0NrZ05BQXNnQ2lFSURBRUxDd0pBSUFWQkdDQU1heER5QVNJRlJBQUFBQUFBQUhCQlpnUkFJQWxCNEFOcUlBaEJBblJxQW44Z0JRSi9JQVZFQUFBQUFBQUFjRDZpSWdXWlJBQUFBQUFBQU9CQll3UkFJQVdxREFFTFFZQ0FnSUI0Q3lJQ3QwUUFBQUFBQUFCd3dhS2dJZ1daUkFBQUFBQUFBT0JCWXdSQUlBV3FEQUVMUVlDQWdJQjRDellDQUNBSVFRRnFJUWdNQVFzQ2Z5QUZtVVFBQUFBQUFBRGdRV01FUUNBRnFnd0JDMEdBZ0lDQWVBc2hBaUFQSVF3TElBbEI0QU5xSUFoQkFuUnFJQUkyQWdBTFJBQUFBQUFBQVBBL0lBd1E4Z0VoQlFKQUlBaEJmMHdOQUNBSUlRSURRQ0FKSUFKQkEzUnFJQVVnQ1VIZ0Eyb2dBa0VDZEdvb0FnQzNvamtEQUNBRlJBQUFBQUFBQUhBK29pRUZJQUpCQUVvaEFDQUNRUUZySVFJZ0FBMEFDeUFJUVg5TURRQWdDQ0VDQTBBZ0NDQUNJZ0JySVFORUFBQUFBQUFBQUFBaEJVRUFJUUlEUUFKQUlBVWdBa0VEZEVHUXNRRnFLd01BSUFrZ0FDQUNha0VEZEdvckF3Q2lvQ0VGSUFJZ0RVNE5BQ0FDSUFOSklRd2dBa0VCYWlFQ0lBd05BUXNMSUFsQm9BRnFJQU5CQTNScUlBVTVBd0FnQUVFQmF5RUNJQUJCQUVvTkFBc0xBa0FDUUFKQUFrQUNRQ0FFRGdRQkFnSUFCQXRFQUFBQUFBQUFBQUFoQmdKQUlBaEJBVWdOQUNBSlFhQUJhaUFJUVFOMGFpc0RBQ0VGSUFnaEFnTkFJQWxCb0FGcUlBSkJBM1JxSUFVZ0NVR2dBV29nQWtFQmF5SUFRUU4wYWlJREt3TUFJZ2NnQnlBRm9DSUZvYUE1QXdBZ0F5QUZPUU1BSUFKQkFVb2hBeUFBSVFJZ0F3MEFDeUFJUVFKSURRQWdDVUdnQVdvZ0NFRURkR29yQXdBaEJTQUlJUUlEUUNBSlFhQUJhaUFDUVFOMGFpQUZJQWxCb0FGcUlBSkJBV3NpQUVFRGRHb2lBeXNEQUNJR0lBWWdCYUFpQmFHZ09RTUFJQU1nQlRrREFDQUNRUUpLSVFNZ0FDRUNJQU1OQUF0RUFBQUFBQUFBQUFBaEJpQUlRUUZNRFFBRFFDQUdJQWxCb0FGcUlBaEJBM1JxS3dNQW9DRUdJQWhCQWtvaEFDQUlRUUZySVFnZ0FBMEFDd3NnQ1NzRG9BRWhCU0FMRFFJZ0FTQUZPUU1BSUFrckE2Z0JJUVVnQVNBR09RTVFJQUVnQlRrRENBd0RDMFFBQUFBQUFBQUFBQ0VGSUFoQkFFNEVRQU5BSUFVZ0NVR2dBV29nQ0VFRGRHb3JBd0NnSVFVZ0NFRUFTaUVBSUFoQkFXc2hDQ0FBRFFBTEN5QUJJQVdhSUFVZ0N4czVBd0FNQWd0RUFBQUFBQUFBQUFBaEJTQUlRUUJPQkVBZ0NDRUNBMEFnQlNBSlFhQUJhaUFDUVFOMGFpc0RBS0FoQlNBQ1FRQktJUUFnQWtFQmF5RUNJQUFOQUFzTElBRWdCWm9nQlNBTEd6a0RBQ0FKS3dPZ0FTQUZvU0VGUVFFaEFpQUlRUUZPQkVBRFFDQUZJQWxCb0FGcUlBSkJBM1JxS3dNQW9DRUZJQUlnQ0VjaEFDQUNRUUZxSVFJZ0FBMEFDd3NnQVNBRm1pQUZJQXNiT1FNSURBRUxJQUVnQlpvNUF3QWdDU3NEcUFFaEJTQUJJQWFhT1FNUUlBRWdCWm81QXdnTElBbEJzQVJxSkFBZ0RrRUhjUXNvQVFGL0l3QkJFR3NpQVNRQUlBRWdBRFlDREVIWXdBRkJCU0FCS0FJTUVBWWdBVUVRYWlRQUN5Z0JBWDhqQUVFUWF5SUJKQUFnQVNBQU5nSU1RZGZBQVVFRUlBRW9BZ3dRQmlBQlFSQnFKQUFMS0FFQmZ5TUFRUkJySWdFa0FDQUJJQUEyQWd4QjFzQUJRUU1nQVNnQ0RCQUdJQUZCRUdva0FBc29BUUYvSXdCQkVHc2lBU1FBSUFFZ0FEWUNERUhWd0FGQkFpQUJLQUlNRUFZZ0FVRVFhaVFBQ3lnQkFYOGpBRUVRYXlJQkpBQWdBU0FBTmdJTVFlaStBVUVCSUFFb0Fnd1FCaUFCUVJCcUpBQUxLQUVCZnlNQVFSQnJJZ0VrQUNBQklBQTJBZ3hCMU1BQlFRQWdBU2dDREJBR0lBRkJFR29rQUF2VEJnRUJmMEgwdmdGQmxaVUJFQnRCbk1BQlFacVZBVUVCUVFGQkFCQWFJd0JCRUdzaUFDUUFJQUJCbjVVQk5nSU1RYzdBQVNBQUtBSU1RUUZCZ0g5Qi93QVFCeUFBUVJCcUpBQWpBRUVRYXlJQUpBQWdBRUdrbFFFMkFneEJ6OEFCSUFBb0FneEJBVUdBZjBIL0FCQUhJQUJCRUdva0FDTUFRUkJySWdBa0FDQUFRYkNWQVRZQ0RFSFF3QUVnQUNnQ0RFRUJRUUJCL3dFUUJ5QUFRUkJxSkFBakFFRVFheUlBSkFBZ0FFRytsUUUyQWd4QjBjQUJJQUFvQWd4QkFrR0FnSDVCLy84QkVBY2dBRUVRYWlRQUl3QkJFR3NpQUNRQUlBQkJ4SlVCTmdJTVFiM0FBU0FBS0FJTVFRSkJBRUgvL3dNUUJ5QUFRUkJxSkFBakFFRVFheUlBSkFBZ0FFSFRsUUUyQWd4QnNjQUJJQUFvQWd4QkJFR0FnSUNBZUVILy8vLy9CeEFISUFCQkVHb2tBQ01BUVJCcklnQWtBQ0FBUWRlVkFUWUNERUhudmdFZ0FDZ0NERUVFUVFCQmZ4QUhJQUJCRUdva0FDTUFRUkJySWdBa0FDQUFRZVNWQVRZQ0RFSFN3QUVnQUNnQ0RFRUVRWUNBZ0lCNFFmLy8vLzhIRUFjZ0FFRVFhaVFBSXdCQkVHc2lBQ1FBSUFCQjZaVUJOZ0lNUVpuQUFTQUFLQUlNUVFSQkFFRi9FQWNnQUVFUWFpUUFJd0JCRUdzaUFDUUFJQUJCOTVVQk5nSU1RYWEvQVNBQUtBSU1RUVFRRHlBQVFSQnFKQUFqQUVFUWF5SUFKQUFnQUVIOWxRRTJBZ3hCbmNBQklBQW9BZ3hCQ0JBUElBQkJFR29rQUVHZ3Z3RkJoSllCRUJCQnlzQUJRWkNXQVJBUVFjdkFBVUVFUWJHV0FSQU1RY3pBQVVFQ1FiNldBUkFNUWMzQUFVRUVRYzJXQVJBTVFlUytBVUhjbGdFUUdTTUFRUkJySWdBa0FDQUFRZXlXQVRZQ0RFSFR3QUZCQUNBQUtBSU1FQVlnQUVFUWFpUUFRWXFYQVJDY0JVR3Zsd0VRbXdWQjFwY0JFSm9GUWZXWEFSQ1pCVUdkbUFFUW1BVkJ1cGdCRUpjRkl3QkJFR3NpQUNRQUlBQkI0SmdCTmdJTVFkbkFBVUVFSUFBb0Fnd1FCaUFBUVJCcUpBQWpBRUVRYXlJQUpBQWdBRUgrbUFFMkFneEIyc0FCUVFVZ0FDZ0NEQkFHSUFCQkVHb2tBRUdsbVFFUW5BVkJ4WmtCRUpzRlFlYVpBUkNhQlVHSG1nRVFtUVZCcVpvQkVKZ0ZRY3FhQVJDWEJTTUFRUkJySWdBa0FDQUFRZXlhQVRZQ0RFSGJ3QUZCQmlBQUtBSU1FQVlnQUVFUWFpUUFJd0JCRUdzaUFDUUFJQUJCaTVzQk5nSU1RZHpBQVVFSElBQW9BZ3dRQmlBQVFSQnFKQUFMS1FFQmZ5TUFRUkJySWdJa0FDQUNJQUUyQWd3Z0FrRU1haUFBRVFBQUlRQWdBa0VRYWlRQUlBQUxMQUVCZnlBQUVKTUJRUVJxRVBNQklnRWdBQkNUQVRZQ0FDQUJRUVJxSUFBUWNpQUFFSk1CRUdZYUlBRUxNd0VCZnlBQUtBSUFJUUlnQUNnQ0JDSUFRUUYxSUFGcUlnRWdBRUVCY1FSL0lBRW9BZ0FnQW1vb0FnQUZJQUlMRVFBQUN5VUFJQUJCd0pBQk5nSUFJQUF0QUFRRVFDQUFRYlNMQVJDSUFRc2dBRUVJYWhCZElBQUx1QUVCQTM4Z0FDZ0NDQ0VBSXdCQklHc2lCaVFBQW44Q1FFR0l3QUV0QUFCQkFYRU5BRUdJd0FFUVUwVU5BQ01BUVJCcklnY2tBRUVGUWVDUkFSQURJUWdnQjBFUWFpUUFRWVRBQVNBSU5nSUFRWWpBQVJCU0MwR0V3QUVvQWdBTElBQWdBUUovSXdCQkVHc2lBQ1FBSUFBZ0JqWUNEQ0FBUVF4cUlBSXFBZ0FRWENBQVFReHFJQU1xQWdBUVhDQUFRUXhxSUFRcUFnQVFYQ0FBUVF4cUlBVXFBZ0FRWENBQVFSQnFKQUFnQmdzUUJDQUdRU0JxSkFBTEZRQWdBQ0FCS0FLQUFUWUNnQUVnQUNBQkVOb0NDemtCQVg4Z0FDZ0NCQ0lFUVFGMUlBRnFJUUVnQUNnQ0FDRUFJQUVnQWlBRElBUkJBWEVFZnlBQktBSUFJQUJxS0FJQUJTQUFDeEVLQUF1Z0FRRURmeUFBS0FJSUlRQWpBRUVRYXlJRUpBQUNmd0pBUWJTL0FTMEFBRUVCY1EwQVFiUy9BUkJUUlEwQUl3QkJFR3NpQlNRQVFRTkJvSTRCRUFNaEJpQUZRUkJxSkFCQnNMOEJJQVkyQWdCQnRMOEJFRklMUWJDL0FTZ0NBQXNnQUNBQkFuOGpBRUVRYXlJQUpBQWdBQ0FFTmdJTUlBQkJER29nQWlvQ0FCQmNJQUJCREdvZ0F5b0NBQkJjSUFCQkVHb2tBQ0FFQ3hBRUlBUkJFR29rQUFzbEFDQUFRYmlOQVRZQ0FDQUFMUUFFQkVBZ0FFRzBpd0VRaUFFTElBQkJDR29RWFNBQUN4RUFJQUFnQVVFRWFpQUJLQUlBRUlzRUN3c0FRUmdRSnlBQUVQY0RDeVVBSUFCQjlJb0JOZ0lBSUFBdEFBUUVRQ0FBUWJTTEFSQ0lBUXNnQUVFSWFoQmRJQUFMT1FFQmZ5QUFLQUlFSWdSQkFYVWdBV29oQVNBQUtBSUFJUUFnQVNBQ0lBTWdCRUVCY1FSL0lBRW9BZ0FnQUdvb0FnQUZJQUFMRVFVQUN3NEFJQUFvQWdBUUhDQUFLQUlBQ3gwQkFYOGpBRUVRYXlJQkpBQWdBU0FBTmdJTUlBRkJFR29rQUNBQUN5RUFJQUFRZ3dJZ0FFSUFOd0pRSUFCQmpCUTJBZ0FnQUVIRTB3QTJBZ0FnQUFzOEFRRi9Jd0JCRUdzaUFpUUFJQUlnQVNrQ0FEY0RDRUczd0FFZ0FFRUNRYmlVQVVHSWlRRkJzd2dnQWtFSWFoQTNRUUFRQUNBQ1FSQnFKQUFMUEFFQmZ5TUFRUkJySWdJa0FDQUNJQUVwQWdBM0F3aEJtc0FCSUFCQkFrR1Vrd0ZCaUlrQlFaOElJQUpCQ0dvUU4wRUFFQUFnQWtFUWFpUUFDd2NBSUFBcUFnQUxQQUVCZnlNQVFSQnJJZ0lrQUNBQ0lBRXBBZ0EzQXdoQnpyOEJJQUJCQmtHd2p3RkJ5SThCUVl3SUlBSkJDR29RTjBFQkVBQWdBa0VRYWlRQUN4UUFJQUFFUUNBQUlBQW9BZ0FvQWl3UkFRQUxDdzRBUWFXL0FTQUJJQUlRQ1NBQUN3NEFRY2kvQVNBQklBSVFDU0FBQ3p3QkFYOGpBRUVRYXlJQ0pBQWdBaUFCS1FJQU53TUlRYU8vQVNBQVFRUkJvSXdCUWJDTUFVR0FDQ0FDUVFocUVEZEJBUkFBSUFKQkVHb2tBQXM4QVFGL0l3QkJFR3NpQWlRQUlBSWdBU2tDQURjRENFR2p2d0VnQUVFQ1FmU0xBVUdjaVFGQi9RY2dBa0VJYWhBM1FRRVFBQ0FDUVJCcUpBQUxnZ1VDREgwQmZ5TUFRZUFBYXlJUkpBQWdCRUVDRUNZcUFnQWdCRUVBRUNZcUFnQ1RJUVlnQkVFREVDWXFBZ0FnQkVFQkVDWXFBZ0NUSVFjZ0JFRUFFQ1lxQWdBaERTQUNLZ0lBSVE0Z0JFRUJFQ1lxQWdBaEQwTUFBSUEvSVFVZ0Fpb0NCQ0VRUXdBQWdEOGhDQUpBQW4wQ1FBSkFBa0FDUUFKQUFrQWdBUTRIQUFFQ0JBTUhCUWNMSUFNUWtBRWdCcFVoQ0NBREVJOEJJQWVWSVFVTUJnc2dBeENRQVNBR2xTQURFSThCSUFlVkVQZ0REQVFMSUFNUWtBRWdCcFVpQlNBRklBTVFqd0VnQjVVaUNKY2dDTHhCLy8vLy93ZHhRWUNBZ1B3SFN4c2dDQ0FGdkVILy8vLy9CM0ZCZ0lDQS9BZE5Hd3dEQ3lBREVJOEJJQWVWREFJTElBTVFrQUVnQnBVTUFRc2dBeENRQVNBR2xTQURFSThCSUFlVkVQZ0RJZ1ZEQUFDQVB5QUZRd0FBZ0Q5ZEd3c2lCU0VJQ3lBUlFjZ0FhaEJVSVFFZ0EwRUFFQ1lxQWdBaENTQURFSkFCSVFvZ0Fpb0NBQ0VMSUFNUWtBRWhEQ0FCUVFRUUppQUt1MFFBQUFBQUFBRGdQNklnQ2J1Z0lBc2dESlM3UkFBQUFBQUFBT0Evb3FDMk9BSUFJQU5CQVJBbUtnSUFJUWtnQXhDUEFTRUtJQUlxQWdRaEN5QURFSThCSVF3Z0FVRUZFQ1lnQ3J0RUFBQUFBQUFBNEQraUlBbTdvQ0FMSUF5VXUwUUFBQUFBQUFEZ1A2S2d0amdDQUNBUlFUQnFFRlFpQTBFQUVDWWdDRGdDQUNBRFFRTVFKaUFGT0FJQUlCRkJHR29RVkNJRVFRUVFKaUFOakxzZ0JydEVBQUFBQUFBQTREK2lvU0FHSUE2VXUwUUFBQUFBQUFEZ1A2S2h0amdDQUNBRVFRVVFKaUFQakxzZ0I3dEVBQUFBQUFBQTREK2lvU0FISUJDVXUwUUFBQUFBQUFEZ1A2S2h0amdDQUNBUkVGUWlBaUFCSUFNUXZRRWdBaUFDSUFRUXZRRWdBQ0FDSUFBb0FnQW9BaEFSQXdBZ0VVSGdBR29rQUFzR0FFSDJ2Z0VMeGpVRUYzOEJmUUYrQVh3akFFRXdheUlOSkFBZ0RVRWdhaEE2SVFrakFFRVFheUlESkFBZ0RVRUlhaUFBS0FJQUFuOGdBMEVJYWlJQlFhSDlBQkFlTmdJQUlBRW9BZ0FMRUJRUVFSb2dBUkJkSUFOQkVHb2tBQ01BUVJCcklnTWtBQ0FOS0FJSVFiQ0lBU2dDQUNBRFFRUnFFQXNoR2lBRElBTW9BZ1FRUVNFQklCb1ErQUVoQWlBQkVNZ0JJQU5CRUdva0FDQU5RUWhxRUYwQ1FDQUNJQWtRZ1FFaUEwc0VRQ01BUVNCcklnWWtBQUpBSUFJZ0Eyc2lCU0FKRUNnb0FnQWdDU2dDQkd0TkJFQWdDU0FGRUlnRURBRUxJQWtRS0NFSUlBWkJDR29oQXdKL0lBa1FnUUVnQldvaENpTUFRUkJySWdFa0FDQUJJQW8yQWd3Z0NpQUpFSVFFSWdSTkJFQWdDUkNSQVNJS0lBUkJBWFpKQkVBZ0FTQUtRUUYwTmdJSUlBRkJDR29nQVVFTWFoQllLQUlBSVFRTElBRkJFR29rQUNBRURBRUxFSEFBQ3lFQklBa1FnUUVoQ2lNQVFSQnJJZ1FrQUNBRVFRQTJBZ3dnQTBFTWFpQUVRUXhxSUFnUVJ5QUJCRUFnQXlnQ0VCb2dBUkFuSVFjTElBTWdCellDQUNBRElBY2dDbW9pQ2pZQ0NDQURJQW8yQWdRZ0F4QXhJQUVnQjJvMkFnQWdCRUVRYWlRQUl3QkJFR3NpQVNRQUlBRWdBeWdDQ0RZQ0FDQURLQUlJSVFRZ0FTQURRUWhxTmdJSUlBRWdCQ0FGYWpZQ0JDQUJLQUlBSVFRRFFDQUJLQUlFSUFSSEJFQWdBeWdDRUJvZ0FTZ0NBQkMrQVNBQklBRW9BZ0JCQVdvaUJEWUNBQXdCQ3dzZ0FSRFlBU0FCUVJCcUpBQWdDUkNIQkNBSkVDZ2dDU2dDQUNBSktBSUVJQU5CQkdvaUFSRHFBU0FKSUFFUU5TQUpRUVJxSUFOQkNHb1FOU0FKRUNnZ0F4QXhFRFVnQXlBREtBSUVOZ0lBSUFrZ0NSQ0JBUkNEQkNBREtBSUVJUUVEUUNBQklBTW9BZ2hIQkVBZ0F5Z0NFQm9nQXlBREtBSUlRUUZyTmdJSURBRUxDeUFES0FJQUJFQWdBeWdDRUJvZ0F5Z0NBQ0VCSUFNUU1TZ0NBQ0FES0FJQWF4b2dBUkF1Q3dzZ0JrRWdhaVFBREFFTElBSWdBMGtFUUNBSktBSUFJQUpxSVFNZ0NSQ0JBUm9nQ1NBREVJSUVJQWtvQWdBYUlBa29BZ0FnQ1JDUkFXb2FJQWtvQWdBYUlBa29BZ0FnQ1JDQkFXb2FDd3NnRFNBSktBSUFOZ0lNSUEwZ0FqWUNDQ01BUVJCcklnRWtBQ01BUVJCcklnTWtBQ0FESUFGQkNHb2lCRFlDQkNBRFFRaHFJQTFCQ0dvUU9TQURLQUlFSUFNb0FnZzJBZ0FnQXlnQ0JDQURLQUlNTmdJRUlBTWdBeWdDQkVFSWFqWUNCQ0FEUVJCcUpBQWdEVUVZYWlJV1FlaStBU0FFRUJNMkFnQWdBVUVRYWlRQUlCWW9BZ0FoQXlNQVFSQnJJZ0VrQUFKL0FrQkI4TDRCTFFBQVFRRnhEUUJCOEw0QkVGTkZEUUFqQUVFUWF5SUVKQUJCQWtINGlBRVFBeUVDSUFSQkVHb2tBRUhzdmdFZ0FqWUNBRUh3dmdFUVVndEI3TDRCS0FJQUN5QURRYXo5QUFKL0l3QkJFR3NpQXlRQUlBTWdBVUVJYWlJRU5nSU1JQU5CREdvZ0FCQ3JCUkIzSUFOQkVHb2tBQ0FFQ3hBRUlBRkJFR29rQUNBSktBSUFJUUFnRFVFSWFpSURJQWtRZ1FFaUFUWUNEQ0FEUVFBNkFBZ2dBeUFBTmdJQUlBTWdBQ0FCYWpZQ0JDQU5RUUEyQWdSQkFDRUFRUUFoQlNNQVFUQnJJaElrQUFKQUFuOGdFa0VRYWlJS1FReHFFSkFDR2lNQVFUQnJJZ2NrQUFKQUFrQURRQ0FGUVFSR0RRRWdCVUdmNndCcUlRRWdCVUVCYWlFRklBRXNBQUFnQXhDRkJFWU5BQXRCQUNFRkRBRUxJQW9nQXhDQ0FUNENBRUVBSVFVZ0F5MEFDQTBBSUFvZ0F4Q0NBVDRDQkNBRExRQUlEUUFnQ2lBREVJSUJQZ0lJSUFNdEFBZ05BQ0FIUVNCcUVEb2hEQUovQWtBRFFDQUhJQU1RZ2dHbklnRTJBaGdnQVVVTkFTQU1JQWRCR0dvUWp3TWdBeTBBQ0VVTkFBdEJBQXdCQ3lBSElBd1FLallDR0NBSElBd1FLellDRUNBS1FReHFJUUZCQ0NFRkEwQUNRQ0FIUVJocUlBZEJFR29RTENJUVJRMEFJQWNnQnlnQ0dDZ0NBRFlDRENBRlFRaEdCRUJCQUNFRklBTVF2d0VoQUF0QkFDRUdJd0JCSUdzaUN5UUFJQXNnQjBFTWFpSU9FSTRDTmdJUUlBdEJHR29oRHlBTFFSQnFJUk1nQzBFSWFpRVVJd0JCSUdzaUJDUUFJQUVRTVJvZ0RpZ0NBQ0VSSUFFUVZTRUNJQVJCQURvQUh3SkFBa0FnQWtVTkFDQUJJQkVnQWhBN0lnWVFMeWdDQUNJSVJRMEFBMEFnQ0NnQ0FDSUlSUTBCSUJFZ0NDZ0NCRWNFUUNBSUtBSUVJQUlRT3lBR1J3MENDeUFCRUVZZ0NFRUlhaUFPRUtBQlJRMEFDd3dCQ3lNQVFSQnJJZzRrQUNBQkVDZ2lDQ0FFUVJCcVFSQVFKeUFPUVFocUlBaEJBQkN6QVJDeUFTSUlLQUlBUVFocVFlanJBQ0FUSUJRUW1nTWdDQkE5UVFFNkFBUWdDQ2dDQUNBUk5nSUVJQWdvQWdCQkFEWUNBQ0FPUVJCcUpBQUNRQ0FCQW44Z0FSQXhLQUlBUVFGcXN5QUJFRVlxQWdBZ0FyT1VYa1ZCQUNBQ0cwVUVRQ0FFSUFJUWUwRUJjeUFDUVFGMGNqWUNEQ0FFQW44Z0FSQXhLQUlBUVFGcXN5QUJFRVlxQWdDVmpTSVlRd0FBZ0U5ZElCaERBQUFBQUdCeEJFQWdHS2tNQVF0QkFBczJBZ2dnQkVFTWFpQUVRUWhxRUZnb0FnQWhBaU1BUVJCcklnWWtBQ0FHSUFJMkFnd0NRQ0FHSUFKQkFVWUVmMEVDQlNBQ0lBSkJBV3R4UlEwQklBSVFoZ0VMSWdJMkFnd0xBa0FnQVJCVklnZ2dBa2tFUUNBQklBSVFpd01NQVFzZ0FpQUlUdzBBSUFnUWV5RU9BbjhnQVJBeEtBSUFzeUFCRUVZcUFnQ1ZqU0lZUXdBQWdFOWRJQmhEQUFBQUFHQnhCRUFnR0trTUFRdEJBQXNoQWlBR0FuOGdEZ1JBSUFJUXp3RU1BUXNnQWhDR0FRczJBZ2dnQmlBR1FReHFJQVpCQ0dvUVdDZ0NBQ0lDTmdJTUlBSWdDRThOQUNBQklBSVFpd01MSUFaQkVHb2tBQ0FSSUFFUVZTSUNFRHNoQmdzZ0Jnc1FMeWdDQUNJSVJRUkFJQVFvQWhBZ0FVRUlhaUlJS0FJQU5nSUFJQUVnQkNnQ0VEWUNDQ0FCSUFZUUx5QUlOZ0lBSUFRb0FoQW9BZ0JGRFFFZ0JDZ0NFQ0VHSUFFZ0JDZ0NFQ2dDQUNnQ0JDQUNFRHNRTHlBR05nSUFEQUVMSUFRb0FoQWdDQ2dDQURZQ0FDQUlJQVFvQWhBMkFnQUxJQVJCRUdvUTB3RWhDQ0FCRURFaUFpQUNLQUlBUVFGcU5nSUFJQVJCQVRvQUh5QUVRUkJxRU00QkN5QVBJQVJCRUdvZ0NCQkJJQVJCSDJvUTBnRWdCRUVnYWlRQUlBdEJHR29RY3lFRUlBdEJJR29rQUNBRUlBQWdCWFZCQTNFMkFnUWdBeTBBQ0EwQUlBVkJBbW9oQlNBSFFSaHFFQzBhREFFTEN5QVFRUUZ6Q3lFRklBd1FQZ3NnQjBFd2FpUUFJQVZGQ3dSQVFlanFBRUVMUVlpM0FTZ0NBQkRiQWd3QkN5QUtLQUlBUVFkSEJFQWdDaWdDQUNFQUlBb29BZ1FoQXlBU1FnYzNBd2dnRWlBRE5nSUVJQklnQURZQ0FFR0l0d0VvQWdCQjlPb0FJQklRNHdJTUFRdEJFQkFuSWdoQ0FEY0RBQ0FJUWdBM0F3Z0NmeUFJUVFBMkFnQWdDRUVFYWhBNkdpTUFRVEJySWhFa0FDQUlRUVJxSVE0Z0VVRVFhaUlFRUpBQ0dpQUVRUlJxRURvYUFuOERRQUpBQWtBQ1FBSi9RUUVnQXlnQ0FDQURLQUlFUmcwQUdpQURMUUFJQzBVRVFBSi9RUUFoQUNNQVFTQnJJZ1VrQUFKL0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFNUWdnR25RUUZyRGs0d0lpTXFKQzRuS1RnNE9EZzRPRGdtSEI0ZklUZ2JNUjBDQmdzTU9BNFNPRGdsS0RnUE9EZ3pOQ3MxTmpJM0lBQXZCeXd0RURnNEJBb1RHVGdCQ1JFVkRUZzRCVGdJRnpnVU9Cb1dBeGc0QzBIRUFCQW5RUUJCeEFBUU14Q3VBZ3c0QzBFWUVDY2lBRUlBTndNQUlBQkNBRGNERUNBQVFnQTNBd2dnQUJEd0JBdzNDMEVVRUNjaUFFSUFOd01BSUFCQkFEWUNFQ0FBUWdBM0F3Z2dBQkRwQkF3MkMwRVFFQ2NpQUVJQU53TUFJQUJDQURjRENDQUFFSW9ESUFCQmZ6WUNEQ0FBUWFqc0FEWUNBQ0FBUVlnMU5nSUFJQUFNTlF0QkZCQW5JZ0JDQURjREFDQUFRUUEyQWhBZ0FFSUFOd01JSUFBUTNBUU1OQXRCQ0JBbklnQkNBRGNEQUNBQUVORUVERE1MUVJRUUp5SUFRZ0EzQXdBZ0FFRUFOZ0lRSUFCQ0FEY0RDQ0FBRU9nRURESUxRUndRSnlJQVFnQTNBd0FnQUVFQU5nSVlJQUJDQURjREVDQUFRZ0EzQXdnZ0FCRGpCQXd4QzBFUUVDY2lBRUlBTndNQUlBQkNBRGNEQ0NBQUVOSUVEREFMUVJBUUp5SUFRZ0EzQXdBZ0FFSUFOd01JSUFBUTdRUU1Md3RCS0JBblFRQkJLQkF6RU4wRURDNExRUkFRSnlJQVFnQTNBd0FnQUVJQU53TUlJQUFROEFFTUxRdEJ3QUFRSjBFQVFjQUFFRE1RN0FRTUxBdEJKQkFuUVFCQkpCQXpFTTBDRENzTFFSd1FKeUlBUWdBM0F3QWdBRUVBTmdJWUlBQkNBRGNERUNBQVFnQTNBd2dnQUJEa0JBd3FDMEVjRUNjaUFFSUFOd01BSUFCQkFEWUNHQ0FBUWdBM0F4QWdBRUlBTndNSUlBQVE1d1FNS1F0QktCQW5RUUJCS0JBekVPRUVEQ2dMUVJBUUp5SUFRZ0EzQXdBZ0FFSUFOd01JSUFBUTZ3UU1Kd3RCT0JBblFRQkJPQkF6RU9JRURDWUxRUkFRSnlJQVFnQTNBd0FnQUVJQU53TUlJQUFRMndRTUpRdEJIQkFuSWdCQ0FEY0RBQ0FBUVFBMkFoZ2dBRUlBTndNUUlBQkNBRGNEQ0NBQUVJa0RJQUJCak8wQU5nSUFJQUJCNERjMkFnQWdBQXdrQzBFUUVDY2lBRUlBTndNQUlBQkNBRGNEQ0NBQUVPb0VEQ01MUVNBUUp5SUFRZ0EzQXdBZ0FFSUFOd01ZSUFCQ0FEY0RFQ0FBUWdBM0F3Z2dBQkNKQXlBQVFYODJBaHdnQUVIczdRQTJBZ0FnQUVHQU5qWUNBQ0FBRENJTFFRd1FKeUlBUWdBM0F3QWdBRUVBTmdJSUlBQVEyUVFNSVF0QkxCQW5RUUJCTEJBeklnQVF6UUlhSUFCQmZ6WUNKQ0FBUWFEdUFEWUNBQ0FBUVFBMkFpZ2dBRUdNT1RZQ0FDQUFEQ0FMUVJRUUp5SUFRZ0EzQXdBZ0FFRUFOZ0lRSUFCQ0FEY0RDQ0FBRU9BRURCOExRUkFRSnlJQVFnQTNBd0FnQUVJQU53TUlJQUFRaWdNZ0FFRUFOZ0lNSUFCQjZPNEFOZ0lBSUFCQjFEUTJBZ0FnQUF3ZUMwSGtBQkFuUVFCQjVBQVFNeERWQWd3ZEMwSGtBQkFuUVFCQjVBQVFNeEQyQkF3Y0MwSE1BQkFuUVFCQnpBQVFNeER5QkF3YkMwSEVBQkFuUVFCQnhBQVFNeEQwQkF3YUMwRTRFQ2RCQUVFNEVETVErZ1FNR1F0QnpBQVFKeEQ1QWd3WUMwRThFQ2RCQUVFOEVETVEvZ1FNRnd0QmdBRVFKMEVBUVlBQkVETVE4UUVNRmd0Qi9BRVFKeEMxQXd3VkMwSEFBQkFuUVFCQndBQVFNeEJ1REJRTFFkd0FFQ2RCQUVIY0FCQXpFSndEREJNTFFhUUJFQ2RCQUVHa0FSQXpFSVFGREJJTFFid0RFQ2NRdHdNTUVRdEIyQUFRSjBFQVFkZ0FFRE1RclFVTUVBdEI2QUlRSnhDdEF3d1BDMEdvQkJBbkVPZ0REQTRMUWRBQUVDZEJBRUhRQUJBekVMQUREQTBMUWJ3QkVDY1Frd0lNREF0QndBRVFKeEN2QXd3TEMwSGdBQkFuUVFCQjRBQVFNeEN3QVF3S0MwRTRFQ2RCQUVFNEVETVEvUU1NQ1F0QnVBRVFKMEVBUWJnQkVETVFnUVFNQ0F0QkJCQW5JZ0JCQURZQ0FDQUFFUDREREFjTFFjQUFFQ2RCQUVIQUFCQXpFTElDREFZTFFZZ0JFQ2RCQUVHSUFSQXpFTk1DREFVTFFaQUJFQ2RCQUVHUUFSQXpFSTBFREFRTFFmUUFFQ2RCQUVIMEFCQXpFTzBEREFNTFFlZ0FFQ2RCQUVIb0FCQXpFTkVEREFJTFFlQUFFQ2RCQUVIZ0FCQXpFSjhFSVFBTElBQUxJUUVEUUFKQUFrQWdBeENDQVNJWlVBUkFJQUVoQUF3QkN5QURMUUFJQkVCQkFDRUFJQUZGRFFFZ0FTQUJLQUlBS0FJRUVRRUFEQUVMSUFFRVFDQUJJQm1uUWYvL0EzRWdBeUFCS0FJQUtBSVFFUVFBRFFNTEFuOGdHYWNpQjBFRWF5SUFRYWNCVFFSQUlBQkJBblJCbE84QWFpZ0NBQXdCQzBGL0N5SUFRWDlIRFFFakFFRVFheUlDSkFBZ0FpQUhOZ0lNSXdCQkVHc2lEQ1FBSUF4QkNHb0NmeU1BUVJCcklnY2tBQ0FLUVF4cUlnWVFNUm9nQWtFTWFpSVBLQUlBSVFzQ1FBSkFJQVlRVlNJUVJRMEFJQVlnQ3lBUUVEc2lFeEF2S0FJQUlnQkZEUUFEUUNBQUtBSUFJZ0JGRFFFZ0N5QUFLQUlFUndSQUlBQW9BZ1FnRUJBN0lCTkhEUUlMSUFzZ0FDZ0NCRWNOQUNBR0VFWWdBRUVJYWlBUEVLQUJSUTBBQ3lBSFFRaHFJQUFRUVNnQ0FDRUFEQUVMSUFjUWxnRWlBRFlDQ0FzZ0IwRVFhaVFBSUFBTEVFRW9BZ0FoQUNBTVFSQnFKQUFnQWlBQU5nSUlJQUlRcVFFMkFnQkJmeUVBSUFKQkNHb2dBaERNQkVVRVFDQUNRUWhxRUhNb0FnUWhBQXNnQWtFUWFpUUFJQUJCZjBjTkFTQUZJQmszQXdCQkFDRUFRWWkzQVNnQ0FFSHA2d0FnQlJEakFpQUJSUTBBSUFFZ0FTZ0NBQ2dDQkJFQkFBc2dCVUVnYWlRQUlBQU1BZ3NDUUFKQUFrQUNRQ0FBRGdRQUFRSURCQXNnQXhBMkdnd0RDeUFGUVJCcUlBTVF6QUVnQlVFUWFoQnZEQUlMSUFNUU1Cb01BUXNnQXhDL0FSb01BQXNBQ3lJSFJRUkFJd0JCRUdzaUFDUUFJQUJCQ0dvZ0JFRVVhaUlDRUNzUWlBTUNRQU5BSUFBZ0FoQXFFSWdESXdCQkVHc2lBU1FBSUFFZ0FDZ0NERFlDQ0NBQklBQW9BZ1EyQWdBZ0FVRUlhaUFCRUN3aEJTQUJRUkJxSkFBZ0JVVU5BUUovSXdCQkVHc2lBU1FBSUFFZ0FDZ0NERFlDQ0NBQlFRaHFFSWNES0FJQUlRVWdBVUVRYWlRQUlBVW9BZ0FpQVFzZ0FTZ0NBQ2dDREJFQUFFVUVRQ0FBSUFCQkNHb2lBU2tDQURjQ0FDQUJRUVJxRUljREdnd0JDd3NnQUVFUWFpUUFEQVlMSUFCQkVHb2tBQXdGQ3lBSElBY29BZ0FvQWdnUkFBQWlBa0U1YXlJQVFSVkxEUUVDUUVFQklBQjBJZ0ZCOElFa2NVVUVRQ0FCUVlDQ2dBRnhEUUVnQUEwRElBUkJBUkJSSWdGRkRRVkJPU0VDUVF3UUp5RUFJQUVvQWdRaEFTQUFFSUFCSUFBZ0FUWUNDQ0FBSUFjMkFnUWdBRUdvMEFBMkFnQU1CQXRCUENFQ1FRZ1FKeUlBRUlBQklBQWdCellDQkNBQVFlRFBBRFlDQUF3REMwSEJBQ0VDUVFnUUp5SUFFSUFCSUFBZ0J6WUNCQ0FBUWNEUUFEWUNBQXdDQ3lNQVFSQnJJZ0FrQUNBQUlBUVFqQU0yQWdnZ0FCQ3BBVFlDQUFOQUFrQWdBRUVJYWlBQUVOY0JSUVJBUVFBaEF3d0JDeUFBUVFocUVITW9BZ1FpQXlBREtBSUFLQUlJRVFBQUlnTU5BQ0FBUVFocUVJa0NEQUVMQ3lBQVFSQnFKQUFnQTBFQVIwRUJkQXdFQzBFQUlRQUNRQUpBQWtBQ1FBSkFJQUpCR1dzT0J3SURCUVVGQlFFQUN5QUNRVFZHRFFNZ0FrRUJSdzBFUVFFaEFrRUlFQ2NpQUJDQUFTQUFJQWMyQWdRZ0FFR0F6d0EyQWdBTUJBdEJIeUVDUVFnUUp5SUFFSUFCSUFBZ0J6WUNCQ0FBUWZqUEFEWUNBQXdEQzBFWklRSkJDQkFuSWdBUWdBRWdBQ0FITmdJRUlBQkJzTThBTmdJQURBSUxJQVJCSHhCUklnRkZEUUpCR2lFQ1FRd1FKeUVBSUFFb0FnUWhBU0FBRUlBQklBQWdCellDQ0NBQUlBRTJBZ1FnQUVISXp3QTJBZ0FNQVF0Qk5TRUNRUWdRSnlJQUVJQUJJQUFnQnpZQ0JDQUFRWkRRQURZQ0FBc2pBRUV3YXlJQkpBQWdBU0FBTmdJb0lBRWdBanNCTGlBQklBUWdBVUV1YWhETkJEWUNJQ0FCRUtrQk5nSVlBa0FDUUFKL0lBRkJJR29nQVVFWWFoRFhBUVJBSUFFZ0FVRWdhaEJ6S0FJRU5nSVlJQVJCRkdvaUFCQXFJUVVnQUJBcklRWWpBRUVRYXlJQ0pBQWdBaUFHTmdJQUlBSWdCVFlDQ0FOQUFrQWdBa0VJYWlBQ0VDeEZEUUFnQWlnQ0NDZ0NBQ0FCS0FJWVJnMEFJQUpCQ0dvUUxSb01BUXNMSUFJb0FnZ2hCU0FDUVJCcUpBQWdBU0FGTmdJUUlBRWdBQkFyTmdJSUlBRkJFR29nQVVFSWFoQXNCRUFnQVNBQlFSQnFFSjhCS0FJQUlRVWpBRUVRYXlJQ0pBQWdBaUFGTmdJSUlBSWdBQkFxTmdJQUlBSkJDR29nQWhDS0FpRUZJQUFvQWdBZ0JVRUNkR29pQlVFRWFpQUFLQUlFSUFVUWtRTWhCaUFBRURJaEN5QUFJQVlRcXdRZ0FDQUxFT0FESUFVUTVRRWFJQUpCRUdva0FBc2dBU2dDR0NJQUlBQW9BZ0FvQWdnUkFBQWhBQ0FCS0FJWUlnSUVRQ0FDSUFJb0FnQW9BZ1FSQVFBTElBQUVRQ0FFSUFGQkxtb1FqZ01NQkFzZ0FTZ0NLQ0VBQ3lBQVJRc0VRQ0FFSUFGQkxtb1FqZ01NQVFzakFFRWdheUlMSkFBZ0N5QUJRUzVxSWc4UWpnSTJBaEFnQzBFWWFpRVhRUUFoRENNQVFTQnJJZ1VrQUNBRUVERWFJQTh2QVFBaEVDQUVFRlVoQWlBRlFRQTZBQjhDUUFKQUlBSkZEUUFnQkNBUUlBSVFPeUlNRUM4b0FnQWlCa1VOQUFOQUlBWW9BZ0FpQmtVTkFTQVFJQVlvQWdSSEJFQWdCaWdDQkNBQ0VEc2dERWNOQWdzZ0JCQkdJQVpCQ0dvZ0R4REtCRVVOQUFzTUFRc2pBRUVRYXlJVEpBQWdCQkFvSVFZZ0JVRVFha0VRRUNjZ0UwRUlhaUFHUVFBUXN3RVFzZ0VpQmlnQ0FDRVVJQXNvQWhBaEZTTUFRUkJySWc4a0FDQVBJQlUyQWdnZ0R5Z0NDQzhCQUNFVklCUkJBRFlDRENBVUlCVTdBUWdnRDBFUWFpUUFJQVlRUFVFQk9nQUVJQVlvQWdBZ0VEWUNCQ0FHS0FJQVFRQTJBZ0FnRTBFUWFpUUFBa0FnQkFKL0lBUVFNU2dDQUVFQmFyTWdCQkJHS2dJQUlBS3psRjVGUVFBZ0FodEZCRUFnQlNBQ0VIdEJBWE1nQWtFQmRISTJBZ3dnQlFKL0lBUVFNU2dDQUVFQmFyTWdCQkJHS2dJQWxZMGlHRU1BQUlCUFhTQVlRd0FBQUFCZ2NRUkFJQmlwREFFTFFRQUxOZ0lJSUFWQkRHb2dCVUVJYWhCWUtBSUFJUUlqQUVFUWF5SUdKQUFnQmlBQ05nSU1Ba0FnQmlBQ1FRRkdCSDlCQWdVZ0FpQUNRUUZyY1VVTkFTQUNFSVlCQ3lJQ05nSU1Dd0pBSUFRUVZTSU1JQUpKQkVBZ0JDQUNFSVlEREFFTElBSWdERThOQUNBTUVIc2hEd0ovSUFRUU1TZ0NBTE1nQkJCR0tnSUFsWTBpR0VNQUFJQlBYU0FZUXdBQUFBQmdjUVJBSUJpcERBRUxRUUFMSVFJZ0JnSi9JQThFUUNBQ0VNOEJEQUVMSUFJUWhnRUxOZ0lJSUFZZ0JrRU1haUFHUVFocUVGZ29BZ0FpQWpZQ0RDQUNJQXhQRFFBZ0JDQUNFSVlEQ3lBR1FSQnFKQUFnRUNBRUVGVWlBaEE3SVF3TElBd0xFQzhvQWdBaUJrVUVRQ0FGS0FJUUlBUkJDR29pQmlnQ0FEWUNBQ0FFSUFVb0FoQTJBZ2dnQkNBTUVDOGdCallDQUNBRktBSVFLQUlBUlEwQklBVW9BaEFoQmlBRUlBVW9BaEFvQWdBb0FnUWdBaEE3RUM4Z0JqWUNBQXdCQ3lBRktBSVFJQVlvQWdBMkFnQWdCaUFGS0FJUU5nSUFDeUFGUVJCcUVOTUJJUVlnQkJBeElnSWdBaWdDQUVFQmFqWUNBQ0FGUVFFNkFCOGdCVUVRYWhET0FRc2dGeUFGUVJCcUlBWVFRU0FGUVI5cUVOSUJJQVZCSUdva0FDQUxRUmhxRUhNaEFpQUxRU0JxSkFBZ0FpQUFOZ0lFSUFSQkZHb2dBVUVvYWhDUEF3dEJBQ0VBQ3lBQlFUQnFKQUFnQUEwQUlBY2dCQ0FIS0FJQUtBSWdFUUlBRFFFZ0J5QUhLQUlBS0FJSUVRQUFJZ0JCQVVjRVFDQUFRUmRIRFFJZ0NDQUhOZ0lBQlNBUklBYzJBZ3dnRVVFTWFpRUFBa0FnRGlnQ0JDQU9FQ2dvQWdCSkJFQWdEaUFBRUVrTUFRc2dEaUFBRUkwREN3c01BUXNMUVFJTElRRWpBRUVRYXlJQUpBQWdBQ0FFRUl3RE5nSUlJQUFRcVFFMkFnQURRQ0FBUVFocUlBQVExd0VFUUNBQVFRaHFFSE1vQWdRaUF3UkFJQU1nQXlnQ0FDZ0NCQkVCQUFzZ0FFRUlhaENKQWd3QkN3c2dCRUVVYWhBK0lBUVF0QUVnQUVFUWFpUUFJQkZCTUdva0FDQUJDd1JBSUFnUWtBTWdDQkF1REFFTElBMGdDRFlDQkFzZ0NrRU1haEMwQVNBU1FUQnFKQUFnRFNnQ0JDRUFJQllRWFNBSkVJb0VJQTFCTUdva0FDQUFDeDhBSUFGQkNtc2lBRUgvL3dOeFFRUk5CRUJCRXlBQWRrRUJjUThMUVFBTENnQWdBRUZBYWhEMkFnc01BQ0FBUVVCcUlBRVE5d0lMSHdBZ0FDZ0NGQkNSQWdSL0lBQW9BaFFnQUVGQWF6WUNTRUVBQlVFQ0N3c0pBQ0FBRVBnQ0VDNExHd0VCZnlBQUtBSXdJZ0VnQUNnQ1FDQUJLQUlBS0FJTUVRTUFDd1FBUVE0TEd3RUJmeUFBS0FJd0lnRWdBQ2dDUENBQktBSUFLQUlRRVFNQUN4c0JBWDhnQUNnQ01DSUJJQUFxQWpnZ0FTZ0NBQ2dDQ0JFSUFBdFJBUUYvSUFBZ0FDZ0NBQ2dDT0JFQUFBUkFJQUVDZnlBQUtBSklJZ01FUUNBRElBSWdBeWdDQUNnQ0FCRUNBQ0VDQ3lBQ0N5QUNLQUlBS0FJa0VRQUFJQUFvQWpBZ0FTZ0NBQ2dDRkJFRkFBc0xHQUFnQUMwQUxnUi9JQUFxQWpoREFBQUFBRjRGUVFBTEMxQUFJQUFnQVJEOUFTSUJRUUFnQVNnQ0FDZ0NBQkVEQUNBQklBQXFBamdnQVNnQ0FDZ0NDQkVJQUNBQklBQW9BandnQVNnQ0FDZ0NFQkVEQUNBQklBQW9Ba0FnQVNnQ0FDZ0NEQkVEQUNBQkN3d0FRUUpCQkNBQUxRQkVHd3NQQUNBQUlBQW9BZ0FvQWp3UkFRQUxDZ0FnQUVFMGF4RDZBZ3N6QUFKQUlBQWdBUkJmSWdFTkFFRUJJUUVnQUVFMGFpQUFFUHNDUlEwQUlBQWdBQ2dDQUNnQ1BCRUJBRUVBSVFFTElBRUxJZ0FnQVVFS2EwSC8vd054SWdCQkdrMEVRRUdUZ0lBZ0lBQjJRUUZ4RHd0QkFBdlpBZ0VJZndKL0FrQUNRQUpBSUFBb0FoUWlBU0FCS0FJQUtBSUlFUUFBUVFGckRnTUFBZ0VDQ3lBQlFjd0Fha0VBSUFFYkRBSUxJQUZCb0FGcVFRQWdBUnNoQWdzZ0Fnc2lBVVVFUUVFQkR3dEJBQ0VDSXdCQkVHc2lCQ1FBSUFRZ0FEWUNEQ0FFUVF4cUlRY0NRQ0FCUVFScUlnRW9BZ1FnQVJBb0tBSUFSd1JBSUFFZ0J4QkpEQUVMSXdCQklHc2lDQ1FBSUFFUUtDSUZBbjhnQVNBQkVESkJBV29RU3lFRElBRVFNaUVKSXdCQkVHc2lCaVFBSUFaQkFEWUNEQ0FJUVFocUlnQkJER29nQmtFTWFpQUZFRWNnQXdSQUlBQW9BaEFhSUFOQi8vLy8vd05MQkVBUVJRQUxJQU5CQW5RUUp5RUNDeUFBSUFJMkFnQWdBQ0FDSUFsQkFuUnFJZ1UyQWdnZ0FDQUZOZ0lFSUFBUU1TQUNJQU5CQW5ScU5nSUFJQVpCRUdva0FDQUFLQUlJQ3lBSEVFZ2dBQ0FBS0FJSVFRUnFOZ0lJSUFFZ0FCQk1JQUFRU2lBSVFTQnFKQUFMSUFSQkVHb2tBRUVBQ3pnQUlBQW9Ba3dpQUNBQlFRQVFKaW9DQUNBQlFRRVFKaW9DQUNBQ1FRQVFKaW9DQUNBQ1FRRVFKaW9DQUNBQUtBSUFLQUljRVJFQUN3UUFRU1FMQ1FBZ0FCRFVBaEF1Q3dzQUlBQkJ4QUJyRUlFQ0N6Z0FJQUFvQWt3aUFDQUJRUUFRSmlvQ0FDQUJRUUVRSmlvQ0FDQUNRUUFRSmlvQ0FDQUNRUUVRSmlvQ0FDQUFLQUlBS0FJWUVSRUFDdzBBSUFBcUFqUWdBU29DTkYwTHFnTUNCWDhDZlNNQVFTQnJJZ01rQUNBQlFZQUVFRkFFUUNBQVFkUUFhaUlDRUNvaEJTQUNFQ3NoQkNNQVFTQnJJZ0lrQUNBQ0lBUTJBaEFnQWlBRk5nSVlJQUpCdWdZMkFnd2dBaWdDR0NBQ0tBSVFJQUpCREdvUWdBSWdBa0VnYWlRQUN5QUJRY0FBRUZBaEFrRUFJQUlnQUNnQ0ZDSUZJQVVvQWdBb0FrUVJBQUFpQkVFRVJuRkZJQUZCZ0FKQmdBRVFwQUZCSUJDa0FSQlFHMFVFUUNBQUtBSk1JUUVnQTBFWWFpQUFLZ0l3SUFBcUFqUVFRQ0VDSUFOQkVHb2dBQ29DT0NBQUtnSThFRUFoQlFKQUFrQWdCRUVFUncwQUlBQW9BbUFpQkVVTkFDQUVFSDRoQkNBRFFRaHFFRVFpQmlBQ0lBUVFyUUlnQXhCRUlnSWdCU0FFRUswQ0lBQWdCaUFDSUFBb0FnQW9BbEFSQlFBTUFRc2dBQ0FDSUFVZ0FDZ0NBQ2dDVUJFRkFBc2dBQ29DUUNFSElBQXFBa2doQ0NBRElBQkIxQUJxSWdBUUtqWUNDQ0FESUFBUUt6WUNBQ0FISUFpVUlRY0RRQ0FEUVFocUlBTVFMQVJBSUFFZ0F5Z0NDQ2dDQUNJQUtBSXdJQWNRZ2dNZ0FDb0NOQ0FCS0FJQUtBSWdFUW9BSUFOQkNHb1FMUm9NQVFVZ0FTQUJLQUlBS0FJa0VRRUFDd3NMSUFOQklHb2tBQXMyQVFGL0FrQWdBQ2dDRkNJQlJRMEFJQUVvQWhSRkRRQWdBQ0FCS0FJVUlnRVFxd0lFZnlBQkJVRUFDellDWUNBQklBQVFjUXNMSHdBZ0FDQUJFRjhpQVVVRVFDQUFRY1FBYWlBQUVQc0NRUUZ6RHdzZ0FRc1ZBQ0FBS0FJVVFZQUNRWUFFRUtRQlFRQVFYaG9MQ2dBZ0FDZ0NGQkNCQWd1OUFnRUlmd0pBSUFBZ0FSQmZJZ0VOQUVFQklRRWdBQ2dDRkNJQ1FSWWdBaWdDQUNnQ0RCRUNBRVVOQUNBQUtBSVVJUUVqQUVFUWF5SURKQUFnQXlBQU5nSU1JQU5CREdvaEJ3SkFJQUZCMUFCcUlnRW9BZ1FnQVJBb0tBSUFSd1JBSUFFZ0J4QkpEQUVMSXdCQklHc2lDQ1FBSUFFUUtDSUVBbjhnQVNBQkVESkJBV29RU3lFQ0lBRVFNaUVKSXdCQkVHc2lCU1FBSUFWQkFEWUNEQ0FJUVFocUlnQkJER29nQlVFTWFpQUVFRWNnQWdSQUlBQW9BaEFhSUFKQi8vLy8vd05MQkVBUVJRQUxJQUpCQW5RUUp5RUdDeUFBSUFZMkFnQWdBQ0FHSUFsQkFuUnFJZ1EyQWdnZ0FDQUVOZ0lFSUFBUU1TQUdJQUpCQW5ScU5nSUFJQVZCRUdva0FDQUFLQUlJQ3lBSEVFZ2dBQ0FBS0FJSVFRUnFOZ0lJSUFFZ0FCQk1JQUFRU2lBSVFTQnFKQUFMSUFOQkVHb2tBRUVBSVFFTElBRUxSUUFnQUNBQUtBSUFLQUk0RVFBQUJFQWdBaUFDS0FJQUtBSWtFUUFBSWdJZ0FDZ0NPQ0FDS0FJQUtBSU1FUU1BSUFFZ0FpQUFLQUl3SUFFb0FnQW9BaFFSQlFBTEN4b0FJQUFnQVJEOUFTSUFRUUVnQUNnQ0FDZ0NBQkVEQUNBQUN3d0FJQUJCZ0FGQkFSQmVHZ3RLQUFKQUFrQUNRQUpBSUFGQnp3QnJEZ01BQVFJREN5QUFJQUlRTUxZNEFsQkJBUThMSUFBZ0FoQXd0amdDVkVFQkR3c2dBQ0FDRURDMk9BSllRUUVQQ3lBQUlBRWdBaEN4QVFzZEFRRi9JQUJCQkdvaUFCQ2tBZ1IvUVFBRklBQkJBQkF2S0FJQUN3dGpBUUYvSXdCQkVHc2lBaVFBSUFJZ0FFRUVhaUlBRUNvMkFnZ2dBaUFBRUNzMkFnQURRQUpBSUFKQkNHb2dBaEFzUlFSQVFRQWhBQXdCQ3lBQ0tBSUlLQUlBSWdBUVBTQUJFSlFCRFFBZ0FrRUlhaEF0R2d3QkN3c2dBa0VRYWlRQUlBQUxEZ0FnQUNnQ0tFRUVRUUFRWGhvTFFRRUJmd0pBSUFBZ0FSQmZJZ0lOQUVFQklRSWdBU0FBS0FJd0lBRW9BZ0FvQWdBUkFnQWlBVVVOQUNBQkVLd0NSUTBBSUFBZ0FUWUNPRUVBSVFJTElBSUxJZ0FnQVVFS2EwSC8vd054SWdCQkdrMEVRRUdUZ0lBb0lBQjJRUUZ4RHd0QkFBdEpBUUYvQWtBQ1FDQUFLQUlvSWdFZ0FDZ0NNQ0FCS0FJQUtBSlFFUUlBSWdFRVFDQUJFTllCRFFFTElBQkJBRFlDTkF3QkN5QUFJQUUyQWpRTElBQW9BaWhCQkVFQUVGNGFDemtCQVg4Q1FDQUFJQUVRWHlJQ0RRQWdBU0FBS0FJd0lBRW9BZ0FvQWdBUkFnQWlBVVVOQUNBQkVOWUJSUTBBSUFBZ0FUWUNOQXNnQWdzRUFFRWlDd2dBSUFBUVF4QXVDeUFCQVg4Z0FDZ0NBQ0VCSUFCQkFEWUNBQ0FCQkVBZ0FCQTlJQUVRblFNTEMrUUNBUVYvSXdCQklHc2lBU1FBSUFFZ0FDQUFLQUlBS0FJVUVRQUFJZ0kyQWhnZ0FrSGNBR29pQkNBQlFSaHFFSThDSUFFZ0FFSGNBR29pQlJBcU5nSVlBMEFnQVVFWWFoQXRJUU1nQVNBRkVDczJBaEFnQXlBQlFSQnFFQ3dFUUNBQkFuOUJBQ0FCS0FJWUtBSUFJZ05GRFFBYUlBTWdBeWdDQUNnQ0ZCRUFBQXMyQWhBZ0JDQUJRUkJxRUk4Q0RBRUxDeUFCSUFCQjZBQnFJZ01RS2pZQ0VDQUJJQU1RS3pZQ0NDQUNRZWdBYWlFREEzOGdBVUVRYWlBQlFRaHFFQ3dFZnlBQklBRW9BaEFvQWdBMkFnUWdBeUFCUVFScUVLRUJJQUZCRUdvUUxSb01BUVVnQVNBQVFmUUFhaUlBRUNvMkFoQWdBU0FBRUNzMkFnZ2dBa0gwQUdvaEFBTi9JQUZCRUdvZ0FVRUlhaEFzQkg4Z0FTQUJLQUlRS0FJQU5nSUVJQUFnQVVFRWFoQ2hBU0FCUVJCcUVDMGFEQUVGSUFJUXFnTUVRQ0FDSUFJb0FnQW9BZ1FSQVFCQkFDRUNDeUFDUVFFNkFMUUJJQUZCSUdva0FDQUNDd3NMQ3dzZ0FRRi9JQUJCOUFCcUlnQVFNaUFCU3dSL0lBQWdBUkF2S0FJQUJVRUFDd3M4QVFKL1Fkd0FFQ2RCQUVIY0FCQXpFSndESWdJaUFTQUFLZ0pRT0FKUUlBRWdBQ29DVkRnQ1ZDQUJJQUFxQWxnNEFsZ2dBU0FBRU5BQklBSUxaQUVCZnlNQVFSQnJJZ0lrQUNBQ0lBQkI5QUJxSWdBUUtqWUNDQ0FDSUFBUUt6WUNBQU5BQWtBZ0FrRUlhaUFDRUN4RkJFQkJBQ0VBREFFTElBSW9BZ2dvQWdBaUFCQTlJQUVRbEFFTkFDQUNRUWhxRUMwYURBRUxDeUFDUVJCcUpBQWdBQXRrQVFGL0l3QkJFR3NpQWlRQUlBSWdBRUhvQUdvaUFCQXFOZ0lJSUFJZ0FCQXJOZ0lBQTBBQ1FDQUNRUWhxSUFJUUxFVUVRRUVBSVFBTUFRc2dBaWdDQ0NnQ0FDSUFFRDBnQVJDVUFRMEFJQUpCQ0dvUUxSb01BUXNMSUFKQkVHb2tBQ0FBQ3pBQkFYMGdBU29DTUNFQ0lBQWdBU29DTkRnQ0RDQUFJQUk0QWdnZ0FFTUFBQUFBT0FJRUlBQkRBQUFBQURnQ0FBdXRBZ0lDZndKOUl3QkJNR3NpQXlRQUlBRWdBU2dDQUNnQ0NCRUJBQ0FCSUFBb0Fxd0JJZ0lnQWlnQ0FDZ0NKQkVBQUNBQktBSUFLQUlZRVFNQUlBTkJHR29RVkNFQ0lBQXFBakFoQkNBQUtnSkFJUVVnQWtFRUVDWWdCQ0FGbERnQ0FDQUFLZ0kwSVFRZ0FDb0NSQ0VGSUFKQkJSQW1JQVFnQlpRNEFnQWdBU0FDSUFFb0FnQW9BaEFSQXdBZ0F5QUFRZEFBYWlJQ0VDbzJBaEFnQXlBQ0VDczJBZ2dEUUNBRFFSQnFJQU5CQ0dvUUxBUkFJQU1vQWhBb0FnQWlBaUFCSUFBb0FxZ0JJQUlvQWdBb0FrZ1JCUUFnQTBFUWFoQXRHZ3dCQlFKQUlBQkJzQUZxSVFBRFFDQUFLQUlBSWdCRkRRRWdBQkR3QTBVRVFDQUFJQUVnQUNnQ0FDZ0NaQkVEQUFzZ0FFR1lBV29oQUF3QUN3QUxDd3NnQVNBQktBSUFLQUlNRVFFQUlBTkJNR29rQUF1VUFRRUhmd0pBSUFBUW93TWlCVVVOQUNBQVFZQUJhaUlHRURJaEJ3TkFJQUFRb3dORkRRRkJBQ0VDSUFSQjR3QkxEUUVEUUFKQUlBSWdCMFlOQUNBR0lBSVFMeWdDQUNFRElBQWdBallDcEFFZ0F5OEJMQ0lJQkVBZ0EwRUFPd0VzSUFNZ0NDQURLQUlBS0FJMEVRTUFJQUFvQXFRQklBSkpEUUVMSUFKQkFXb2hBZ3dCQ3dzZ0JFRUJhaUVFREFBTEFBc2dCUXVKQlFFR2Z5QUJRUVFRVUFSQUl3QkJFR3NpQXlRQUlBTWdBRUdZQVdvaUJSQXFOZ0lJSUFNZ0JSQXJOZ0lBQTBBZ0EwRUlhaUFERUN3RVFDQURLQUlJS0FJQVFnQTNBandnQTBFSWFoQXRHZ3dCQlNBQVFRQTJBckFCSUFNZ0FFR01BV29pQWhBcU5nSUlJQU1nQWhBck5nSUFBMEFnQTBFSWFpQURFQ3dFUUFKQUFrQWdBeWdDQ0NnQ0FDSUNLQUtVQVNJRVJRMEFJQVFvQWpSRkRRQWdCQ2dDTkNJRUtBSThSUVJBSUFRZ0FqWUNQQ0FFSUFJMkFrQWdBa0lBTndLWUFRd0NDeUFFS0FKQUlnY2dBallDbkFFZ0FpQUhOZ0tZQVNBRUlBSTJBa0FnQWtFQU5nS2NBUXdCQ3lBQ1FRQTJBcHdCSUFJZ0JqWUNtQUVDUUNBR1JRUkFJQUFnQWpZQ3NBRU1BUXNnQmlBQ05nS2NBUXNnQWlFR0N5QURRUWhxRUMwYURBRUZJQU1nQlJBcU5nSUlJQU1nQlJBck5nSUFBMEFnQTBFSWFpQURFQ3dFUUFKQUlBTW9BZ2dvQWdBaUFpZ0NQRVVOQUNBQ0tBSTRJUVFDUUFKQUlBSW9BalJCL3dGeERnSUFBUUlMSUFRb0FwZ0JJZ1VFUUNBRklBSW9BandpQnpZQ25BRWdCeUFGTmdLWUFRc2dBQ2dDc0FFZ0JFWUVRQ0FBSUFJb0FqdzJBckFCQ3lBRUlBSW9Ba0FpQWpZQ21BRWdBaUFFTmdLY0FRd0JDeUFFS0FLY0FTSUZCRUFnQlNBQ0tBSkFJZ2MyQXBnQklBY2dCVFlDbkFFTElBUWdCa1lFUUNBQ0tBSkFJUVlMSUFRZ0FpZ0NQQ0lDTmdLY0FTQUNJQVEyQXBnQkN5QURRUWhxRUMwYURBRUxDeUFBSUFZMkFyQUJJQU5CRUdva0FBc0xDd3NMSUFGQkNCQlFCRUFnQUNnQ3JBRWlBU0FCS0FJQUtBSUlFUUVBSUFBb0Fxd0JRd0FBQUFCREFBQUFBQ0FBS2dJd0lBQXFBalFRcEFNZ0FDZ0NxQUVnQUNvQ1FDQUFLZ0l3akpRZ0FDb0NSQ0FBS2dJMGpKUWdBQ29DTUNBQUtnSTBFS1FEQ3dzTUFDQUFRU3hxUVFJUTFRRUxSd0FDUUFKQUFrQUNRQ0FCUWR3QWF3NERBQUVDQXdzZ0FDQUNFRFkyQWpCQkFROExJQUFnQWhBMk5nSTBRUUVQQ3lBQUlBSVFpUUU2QURoQkFROExJQUFnQVNBQ0VGc0xEUUFnQUVISUFHc2dBUkNsQXdzTUFDQUJRZC8vQTNGQkNrWUxDUUFnQUJDckF4QXVDd2tBSUFBUXJBTVFMZ3NFQUVFcUM1SUJBZ0YvQTMwZ0FVRUlFRkFFUUNBQUtnS2tBU0VESUFBcUFwd0JJUVVnQUVHb0FXb2lBaUFBS2dLWUFTQUFLZ0tnQVl5VUlnUWdBQ29DbUFGREFBQUFQNVNTRUZjZ0FpQUZJQU9NbENJREVGWWdBRUhvQVdvaUFpQUVJQUFxQXBnQmtoQlhJQUlnQXlBQUtnS2NBWklRVmlBQVFhZ0NhaUlDSUFRUVZ5QUNJQU1nQUNvQ25BR1NFRllMSUFBZ0FSQ2pBUXNKQUNBQUlBRVF1d01MeXdJRENYd0Vmd1o5SUFBcUFwZ0JJUTRnQUNvQ3ZBRWhEeUFBS2dLY0FTRVFJQUFxQXJ3QklSRWdBQ29DbUFGREFBQUFQNVFpRWlBQUtnS2dBU0FBS2dLWUFaU1R1eUVESUFBcUFwd0JRd0FBQUQrVUloTWdBQ29DcEFFZ0FDb0NuQUdVazdzaEJDQUFRYkFCYWlFTVJCZ3RSRlQ3SVJsQUlBQWdBQ2dDQUNnQ2hBRVJBQUFpRGJpaklRVWdFcnNoQmlBVHV5RUhJQTRnRDVSREFBQUFQNVM3SVFnZ0VDQVJsRU1BQUFBL2xMc2hDVVFZTFVSVSt5SDV2eUVCQTBBZ0N5QU5TUVJBSUFFUTZBSWhBaUFNSUFzUXJnTWlDaUFDSUFhaUlBT2d0aEJYSUFvZ0FSRG1BaUFIb2lBRW9MWVFWaUFLSUFBcUFxd0JFSU1CSUFVZ0FhQWlBUkRvQWlFQ0lBd2dDMEVCY2hDdUF5SUtJQUlnQ0tJZ0E2QzJFRmNnQ2lBQkVPWUNJQW1pSUFTZ3RoQldJQW9nQUNvQ3JBRVFnd0VnQzBFQ2FpRUxJQVVnQWFBaEFRd0JDd3NMQ3dBZ0FDZ0NxQUZCQVhRTERBQWdBQkNnQWhvZ0FCQXVDd2tBSUFBUXNnTVFMZ3NjQVFGL0lBQWdBUkJmSWdJRWZ5QUNCU0FBUWJBQmFpQUJFRjhMQzNJQkFuOGpBRUVRYXlJQkpBQWdBRUd3QVdvUXdBTWdBQkNJQWlBQklBQkJwQUZxSWdJUUtqWUNDQ0FCSUFJUUt6WUNBQU5BSUFGQkNHb2dBUkFzQkVBZ0FTZ0NDQ2dDQUNnQ01DSUNJQUFvQW9BQklBSW9BZ0FvQWhRUkF3QWdBVUVJYWhBdEdnd0JCU0FCUVJCcUpBQUxDd3ZZQWdFRWZ5TUFRUkJySWdNa0FDTUFRUkJySWdJa0FBSkFJQUJCaUFGcUlnUVFNaUlGUlEwQUlBRWdBU2dDQUNnQ0NCRUJBQ0FDSUFRUUtqWUNDQ0FDSUFRUUt6WUNBQU5BSUFKQkNHb2dBaEFzUlEwQklBSW9BZ2dvQWdBaUJDMEFPQVJBSUFFZ0JDZ0NUQ0FCS0FJQUtBSVlFUU1BQ3lBQ1FRaHFFQzBhREFBTEFBc2dBa0VRYWlRQUlBVkJBRWNoQkNBRElBQkJwQUZxSWdJUUtqWUNDQ0FESUFJUUt6WUNBQU5BSUFOQkNHb2dBeEFzUlFSQUlBUUVRQ0FCSUFFb0FnQW9BZ3dSQVFBTElBTkJFR29rQUE4TElBTW9BZ2dvQWdBaUFpQUNLQUlBS0FJNEVRQUFCRUFnQVNBQktBSUFLQUlJRVFFQUlBSWdBUUovSUFJZ0FpZ0NBQ2dDUkJFQUFFRUNFR0ZCQWtZRVFDQUJJQUFRZmlBQktBSUFLQUlRRVFNQUlBQW9BdVFCREFFTElBQW9BdWdCQ3lBQ0tBSUFLQUpJRVFVQUlBRWdBU2dDQUNnQ0RCRUJBQXNnQTBFSWFoQXRHZ3dBQ3dBTGl3RUNBWDhCZlNNQVFSQnJJZ0lrQUNBQUlBRVFod0lDUUNBQlFZQUJFRkJGRFFBZ0FpQUFRYVFCYWlJQkVDbzJBZ2dnQWlBQkVDczJBZ0FEUUNBQ1FRaHFJQUlRTEVVTkFTQUFLZ0p3SWdNZ0FpZ0NDQ2dDQUNnQ05DSUJLZ0lFWEFSQUlBRWdBemdDQkNBQklBRW9BZ0FvQWdBUkFRQUxJQUpCQ0dvUUxSb01BQXNBQ3lBQ1FSQnFKQUFMUFFFQ2YwSFFBQkFuUVFCQjBBQVFNeUlCRUxBRElRSWdBU0FBS0FJd05nSXdJQUVnQUNnQ05EWUNOQ0FCSUFBdEFEZzZBRGdnQVNBQUVHZ2dBZ3NKQUNBQUVMWURFQzRMN2dFQ0FuOEVmU0FCUVFnUVVBUkFJQUFxQXF3QklRVWdBQzBBcUFFaEF5QUFLZ0trQVNFSElBQXFBcHdCSVFRZ0FFRzhBV29pQWlBQUtnS1lBU0FBS2dLZ0FZeVVJZ1lRVnlBQ0lBUWdCNHlVSWdRUVZpQUNJQVVRZ3dFZ0FFSDhBV29pQWlBR0lBQXFBcGdCa2hCWElBSWdCQkJXSUFJZ0F3UjlJQVVGSUFBcUFyQUJDeENEQVNBQVFid0NhaUlDSUFZZ0FDb0NtQUdTRUZjZ0FpQUVJQUFxQXB3QmtoQldJQUlnQXdSOUlBVUZJQUFxQXJnQkN4Q0RBU0FBUWZ3Q2FpSUNJQVlRVnlBQ0lBUWdBQ29DbkFHU0VGWWdBaUFEQkgwZ0JRVWdBQ29DdEFFTEVJTUJDeUFBSUFFUW93RUxEUUFnQVVFdFJpQUJRUXBHY2d1SEFnTURmd2Q4Qm4wakFFRVFheUlCSkFBZ0FDb0NtQUVoQ3lBQUtnS2NBU0VNSUFBcUFxQUJJUTBnQUNvQ21BRWhEaUFBS2dLa0FTRVBJQUFxQXB3QklSQWdBQ2dDcUFFaEFpQUJJQUJCc0FGcUlnTVFLallDQ0NBQklBTVFLellDQUNBTFF3QUFBRCtVSWdzZ0RTQU9sSk83SVFVZ0RFTUFBQUEvbENJTUlBOGdFSlNUdXlFR1JCZ3RSRlQ3SVJsQUlBSzNveUVISUF1N0lRZ2dETHNoQ1VRWUxVUlUreUg1dnlFRUEwQWdBVUVJYWlBQkVDd0VRQ0FFRU9nQ0lRb2dBU2dDQ0NJQ0lBb2dDS0lnQmFDMkVGY2dBaUFFRU9ZQ0lBbWlJQWFndGhCV0lBSWdBQ29DckFFUWd3RWdCeUFFb0NFRUlBRkJDR29RdkFNTUFRVWdBVUVRYWlRQUN3c0xDQUFnQUNnQ3FBRUxDUUFnQUJDU0FoQXVDd2dBSUFBdEFKZ0JDd29BSUFCQm5BRnJFR0FMQkFCQkxRc2pBUUYvSUFCQm5BRnFJZ0VvQWdRRVFDQUJLQUlFUVFoQkFCQmVHZ3NnQUJERkF3dU9BUUVFZndKQUlBRkJDQkJRUlEwQUlBQW9BcUFCUlEwQUlBQW9BcUFCSVFRakFFRVFheUlDSkFBZ0FpQUFRWXdCYWlJREVDbzJBZ2dnQWlBREVDczJBZ0FnQkVISUFHb2hBd05BSUFKQkNHb2dBaEFzQkVBZ0FpZ0NDQ2dDQUNJRklBTWdCQ2dDYkNBRktBSUFLQUpBRVFVQUlBSkJDR29RTFJvTUFRVWdBa0VRYWlRQUN3c0xJQUFnQVJDakFRc1VBQ0FBS0FLZ0FRUi9RY0MrQVFVZ0FCQitDd3NnQVFGL0lBQVF5QU1nQUVHY0FXb2lBU2dDQkFSQUlBRW9BZ1FnQUJCeEN3czdBUUYvQWtBZ0FDQUJFRjhpQVEwQVFRRWhBU0FBS0FJVUlnSkJEQ0FDS0FJQUtBSU1FUUlBUlEwQUlBQW9BaFFnQUJCbFFRQWhBUXNnQVFzY0FRRi9RY0FBRUNkQkFFSEFBQkF6RUxJQ0lnRWdBQkMyQWlBQkM2TUVBUVYvSXdCQjRBQnJJZ0lrQUFKQUlBRkJDQkJRUlEwQUFrQUNmeUFBS0FJd1FhQUJhaUVESXdCQkVHc2lBU1FBSUFFZ0F5MEFBRG9BRHlBQklBTkJCR29pQXhBcU5nSUlJQUVnQXhBck5nSUFBMzhnQVVFSWFpQUJFQ3dFZnlBQlFROXFJQUVvQWdnb0FnQWlBeUFES0FJQUtBSkVFUUFBRUxNRElBRkJDR29RTFJvTUFRVWdBUzBBRHlFRElBRkJFR29rQUNBREN3c2lCQXRCQWhCaFFRSkhEUUFDUUNBQUtBSTBJZ0ZGQkVBZ0FDQUFLQUl3UWFBQmFrRUNFTFVCTmdJMERBRUxJQUVnQVNnQ0FDZ0NDQkVCQUFzZ0FrSElBR29nQUNnQ01CQitFUGNESVFFZ0FrRXdhaEJVSWdNZ0FSRDJBMFVFUUNBREVQVURDeUFDSUFBb0FqQVFsZ0lpQVJBcU5nSW9JQUlnQVJBck5nSWdBMEFnQWtFb2FpQUNRU0JxRUN4RkRRRWdBaWdDS0NnQ0FDRUJJQUpCQ0dvUVZDSUZJQU1nQVNBQktBSUFLQUpnRVFBQUVMMEJJQUFvQWpRaUJpQUJLQUtJQVNBRklBWW9BZ0FvQWhBUkJRQWdBa0VvYWhBdEdnd0FDd0FMSUFSQkJCQmhRUVJIRFFBQ1FDQUFLQUk0SWdGRkJFQWdBQ0FBS0FJd1FhQUJha0VFRUxVQk5nSTREQUVMSUFFZ0FTZ0NBQ2dDQ0JFQkFBc2dBaUFBS0FJd0VKWUNJZ0VRS2pZQ1NDQUNJQUVRS3pZQ01BTkFJQUpCeUFCcUlBSkJNR29RTEVVTkFTQUNLQUpJS0FJQUlnRWdBU2dDQUNnQ1lCRUFBQ0VESUFBb0FqZ2lCQ0FCS0FLSUFTQURJQVFvQWdBb0FoQVJCUUFnQWtISUFHb1FMUm9NQUFzQUN5QUNRZUFBYWlRQUN3a0FJQUFRbHdJUUxndUxBUUFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVVIZkFHc09Cd0FCQWdNRUJRWUhDeUFBSUFJUU5qWUNNQXdIQ3lBQUlBSVFNTFk0QWpRTUJnc2dBQ0FDRURDMk9BSTREQVVMSUFBZ0FoQXd0amdDUEF3RUN5QUFJQUlRTUxZNEFrQU1Bd3NnQUNBQ0VEQzJPQUpFREFJTElBQWdBaEF3dGpnQ1NBd0JDeUFBSUFFZ0FoQmJEd3RCQVFzZkFBSkFJQUZCd0FBUVVFVU5BQ0FBS0FLRUFTSUFSUTBBSUFBUXRBTUxDd1lBSUFBUWZnc05BQ0FCUVN4R0lBRkJDa1p5Qzc4Q0FRbC9JQUFnQVJETkFTSUJSUVJBSUFBaEFRSkFBMEFnQVNnQ0ZDSUJSUTBCSUFFUThnTkZEUUFMSUFBZ0FUWUNoQUVqQUVFUWF5SUVKQUFnQkNBQU5nSU1JQVJCREdvaENBSkFJQUZCN0FGcUlnSW9BZ1FnQWhBb0tBSUFSd1JBSUFJZ0NCQkpEQUVMSXdCQklHc2lDU1FBSUFJUUtDSUZBbjhnQWlBQ0VESkJBV29RU3lFRElBSVFNaUVLSXdCQkVHc2lCaVFBSUFaQkFEWUNEQ0FKUVFocUlnQkJER29nQmtFTWFpQUZFRWNnQXdSQUlBQW9BaEFhSUFOQi8vLy8vd05MQkVBUVJRQUxJQU5CQW5RUUp5RUhDeUFBSUFjMkFnQWdBQ0FISUFwQkFuUnFJZ1UyQWdnZ0FDQUZOZ0lFSUFBUU1TQUhJQU5CQW5ScU5nSUFJQVpCRUdva0FDQUFLQUlJQ3lBSUVFZ2dBQ0FBS0FJSVFRUnFOZ0lJSUFJZ0FCQk1JQUFRU2lBSlFTQnFKQUFMSUFSQkVHb2tBQXNnQVVVUEN5QUJDd2dBSUFBZ0FSQmZDd2tBSUFBUWl3RVFMZ3NFQUVFc0N3Y0FJQUFvQW1nTEZnQWdBQ2dDYUNJQUlBRWdBQ2dDQUNnQ0RCRURBQXNVQUNBQUtBSm9JZ0FnQUNnQ0FDZ0NJQkVCQUFzeEFDQUFJQUVnQWlBRElBUWdCU0FHRU5rRElBQW9BbWdpQUNBQklBSWdBeUFFSUFVZ0JpQUFLQUlBS0FJY0VRa0FDeUVBSUFBZ0FTQUNFTndESUFBb0FtZ2lBQ0FCSUFJZ0FDZ0NBQ2dDR0JFSEFBdGpBUUovUWVnQUVDZEJBRUhvQUJBekVORURJZ0lpQVNBQUtBSXdOZ0l3SUFFZ0FDb0NORGdDTkNBQklBQXFBamc0QWpnZ0FTQUFLZ0k4T0FJOElBRWdBQ29DUURnQ1FDQUJJQUFxQWtRNEFrUWdBU0FBS2dKSU9BSklJQUVnQUJCb0lBSUxJUUFnQUNBQklBSVEzUU1nQUNnQ2FDSUFJQUVnQWlBQUtBSUFLQUlVRVFjQUN4a0FJQUFRNUFNZ0FDZ0NhQ0lBSUFBb0FnQW9BZ2dSQVFBTExBQWdBQ0FCSUFJUTN3TWdBQ2dDYUNJQUlBRWdBU2dDQUNnQ0pCRUFBQ0FDSUFBb0FnQW9BaEFSQlFBTENRQWdBQkRVQXhBdUMzd0FBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJRZWdBYXc0R0FBRUNBd1FGQmdzZ0FDQUNFREMyT0FJd0RBWUxJQUFnQWhBd3RqZ0NOQXdGQ3lBQUlBSVFNTFk0QWpnTUJBc2dBQ0FDRURDMk9BSThEQU1MSUFBZ0FoQXd0amdDUUF3Q0N5QUFJQUlRTUxZNEFrUU1BUXNnQUNBQklBSVFXdzhMUVFFTEpRQWdBVUVLYXlJQVFmLy9BM0ZCSVUwRVFFS0RnSUNBSUNBQXJZaW5RUUZ4RHd0QkFBc0VBRUVyQ3lZQUlBRkJBbXNpQUVILy93TnhRU1JOQkVCQ2djNkFnSUFDSUFDdGlLZEJBWEVQQzBFQUN3UUFRUThMQ1FBZ0FCRG1BeEF1QytvQ0FnSi9DWDBqQUVFUWF5SURKQUFnQVVFSUVGQUVRQ0FBS2dLY0FTRUdJQUFxQXFRQklRUWdBQ29DbkFFaENDQUFRYWdCYWlJQ0lBQXFBcGdCUXdBQUFEK1VJZ2tnQUNvQ29BRWdBQ29DbUFHVWt5SUZFRmNnQWlBR1F3QUFBRCtVSWdjZ0JDQUlsSk1pQmlBSGt5SUVFRllnQWlBRFFRaHFJQVVnQ1VPSllnMC9sQ0lJa3lJS0lBUVFRQkRiQVNBQ0lBTkJDR29nQ0NBRmtpSUlJQVFRUUJEY0FTQUFRWWdDYWlJQ0lBa2dCWklpQkJCWElBSWdCaEJXSUFJZ0EwRUlhaUFFSUFZZ0IwT0pZZzAvbENJTGt5SU1FRUFRMndFZ0FpQURRUWhxSUFRZ0N5QUdraUlFRUVBUTNBRWdBRUhvQW1vaUFpQUZFRmNnQWlBSElBYVNJZ2NRVmlBQ0lBTkJDR29nQ0NBSEVFQVEyd0VnQWlBRFFRaHFJQW9nQnhCQUVOd0JJQUJCeUFOcUlnSWdCU0FKa3lJRkVGY2dBaUFHRUZZZ0FpQURRUWhxSUFVZ0JCQkFFTnNCSUFJZ0EwRUlhaUFGSUF3UVFCRGNBUXNnQUNBQkVLTUJJQU5CRUdva0FBdUlBUUVEZnlNQVFSQnJJZ1FrQUNBQUlBRWdBaEMrQXlBQUtBSTRJUU1nQkVFSWFpQUFFT3NERUdjaUJVRUFFQ1lxQWdBZ0JVRUJFQ1lxQWdBZ0F5Z0NSQ0FES0FKQUlBRWdBaUFERU93REVMQUNJQVFnQUJEcUF4Qm5JZ0JCQUJBbUtnSUFJQUJCQVJBbUtnSUFJQU1vQWt3Z0F5Z0NTQ0FCSUFJZ0F4QitFTEFDSUFSQkVHb2tBQXRPQVFGL0l3QkJFR3NpQVNRQUlBQkJ5QUJxSUFGQkNHb2dBQ29DTUNBQUtnSTBFRUFnQVNBQUtnSlFFS3dCSUFBcUFsU1VJQUFxQWxBUXJRRWdBQ29DVkpRUVFCQzhBU0FCUVJCcUpBQUxUZ0VCZnlNQVFSQnJJZ0VrQUNBQVFjZ0FhaUFCUVFocUlBQXFBakFnQUNvQ05CQkFJQUVnQUNvQ1dCQ3NBU0FBS2dKY2xDQUFLZ0pZRUswQklBQXFBbHlVRUVBUXZBRWdBVUVRYWlRQUMwMEJBWDhqQUVFUWF5SUJKQUFnQUVGQWF5QUJRUWhxSUFBcUFqQWdBQ29DTkJCQUlBRWdBQ29DVUJDc0FTQUFLZ0pVbENBQUtnSlFFSzBCSUFBcUFsU1VFRUFRdkFFZ0FVRVFhaVFBQzA0QkFYOGpBRUVRYXlJQkpBQWdBRUhJQUdvZ0FVRUlhaUFBS2dJd0lBQXFBalFRUUNBQklBQXFBbEFRckFFZ0FDb0NXSlFnQUNvQ1VCQ3RBU0FBS2dKWWxCQkFFTHdCSUFGQkVHb2tBQXNjQVFGL1FmUUFFQ2RCQUVIMEFCQXpFTzBESWdFZ0FCRG5BeUFCQ3drQUlBQVE3d01RTGd1dkFRRUNmeU1BUVJCcklnSWtBQUpBSUFGQkNFSEFBQkNrQVJCUVJRMEFJQUFvQWt3aUFTQUJLQUlBS0FJSUVRRUFJQUFvQWt3aUFTQUFLQUkwSUFFb0FnQW9BZ3dSQXdBZ0FpQUFRVHhxSWdFUUtqWUNDQ0FDSUFFUUt6WUNBQU5BSUFKQkNHb2dBaEFzUlEwQklBSW9BZ2dvQWdBaUFSRHdBMFVFUUNBQUtBSk1JZ01nQVJEeEF5Z0NPRUdRdmdFZ0F5Z0NBQ2dDRUJFRkFBc2dBa0VJYWhBdEdnd0FDd0FMSUFKQkVHb2tBQXRVQVFKL0l3QkJFR3NpQVNRQUlBRWdBRUU4YWlJQ0VDbzJBZ2dnQVNBQ0VDczJBZ0FEUUNBQlFRaHFJQUVRTEFSQUlBRW9BZ2dvQWdBUThRTWdBQkJ4SUFGQkNHb1FMUm9NQVFVZ0FVRVFhaVFBQ3dzTFFRRUJmd0pBSUFBZ0FSQmZJZ0lOQUVFQklRSWdBU0FBS0FJd0lBRW9BZ0FvQWdBUkFnQWlBVVVOQUNBQkVLc0NSUTBBSUFBZ0FUWUNTRUVBSVFJTElBSUxDQUFnQUNvQ2pBRUw0UVVCRFg4akFFRWdheUlFSkFBZ0FDZ0NGQ0VNSUFRZ0FVSElBR3RCQUNBQkcwSGNBR29pQVJBcU5nSVlJQVFnQVJBck5nSVFJQUJCUEdvaEJRTkFBa0FDUUNBRVFSaHFJQVJCRUdvUUxBUkFJQVFvQWhnb0FnQWlBa1VOQWlBQ0VLd0NSUTBCSUFJaEFRTkFJQUZGRFFJZ0FTQU1SZ1JBSXdCQkVHc2lDU1FBSUFrZ0FEWUNEQ0FKUVF4cUlRb0NRQ0FDUVlnQmFpSURLQUlFSUFNUUtDZ0NBRWNFUUNBRElBb1FTUXdCQ3lNQVFTQnJJZzBrQUNBREVDZ2lDd0ovSUFNZ0F4QXlRUUZxRUVzaEJpQURFREloRGtFQUlRY2pBRUVRYXlJSUpBQWdDRUVBTmdJTUlBMUJDR29pQVVFTWFpQUlRUXhxSUFzUVJ5QUdCRUFnQVNnQ0VCb2dCa0gvLy8vL0Ewc0VRQkJGQUFzZ0JrRUNkQkFuSVFjTElBRWdCellDQUNBQklBY2dEa0VDZEdvaUN6WUNDQ0FCSUFzMkFnUWdBUkF4SUFjZ0JrRUNkR28yQWdBZ0NFRVFhaVFBSUFFb0FnZ0xJQW9RU0NBQklBRW9BZ2hCQkdvMkFnZ2dBeUFCRUV3Z0FSQktJQTFCSUdva0FBc2dDVUVRYWlRQURBTUZJQUVvQWhRaEFRd0JDd0FMQUFzZ0FCREhBVFlDVENBRVFTQnFKQUJCQUE4TElBSVE4Z05GSUFJZ0RFWnlEUUFnQWlFQkEwQWdBVVVOQVNBQUtBSklJQUZHQkVBZ0JDQUNOZ0lNSUFKQm9BRnFRUVJCRUJDa0FSQ3pBeUFFUVF4cUlRY0NRQ0FGS0FJRUlBVVFLQ2dDQUVjRVFDQUZJQWNRU1F3QkMwRUFJUUlqQUVFZ2F5SUpKQUFnQlJBb0lnZ0NmeUFGSUFVUU1rRUJhaEJMSVFNZ0JSQXlJUW9qQUVFUWF5SUdKQUFnQmtFQU5nSU1JQWxCQ0dvaUFVRU1haUFHUVF4cUlBZ1FSeUFEQkVBZ0FTZ0NFQm9nQTBILy8vLy9BMHNFUUJCRkFBc2dBMEVDZEJBbklRSUxJQUVnQWpZQ0FDQUJJQUlnQ2tFQ2RHb2lDRFlDQ0NBQklBZzJBZ1FnQVJBeElBSWdBMEVDZEdvMkFnQWdCa0VRYWlRQUlBRW9BZ2dMSUFjUVNDQUJJQUVvQWdoQkJHbzJBZ2dnQlNBQkVFd2dBUkJLSUFsQklHb2tBQXNGSUFFb0FoUWhBUXdCQ3dzTElBUkJHR29RTFJvTUFBc0FDd2dBSUFBcUFvZ0JDenNBQWtBQ1FBSkFJQUZCMmdCckRnSUFBUUlMSUFBZ0FoQXd0amdDaUFGQkFROExJQUFnQWhBd3RqZ0NqQUZCQVE4TElBQWdBU0FDRUljRkN5SUJBWDlCRUJBbklnRkNBRGNEQUNBQlFnQTNBd2dnQUNBQkVLb0JFUGtEUVFFTG1RSUJBMzhqQUVFZ2F5SUNKQUFnQWlBQUtBSUVRUkJxSWdFUUtqWUNHQ0FDSUFFUUt6WUNFQU4vQW45QkFDQUNRUmhxSUFKQkVHb1FMRVVOQUJvQ1FDQUNLQUlZS0FJQUlnRVFwUUZGRFFBZ0FTZ0NFRUYvUmcwQUlBRWdBQ2dDQ0NBQktBSVFFSXdDSWdNMkFoUWdBdzBBUVFFTUFRc2dBaUFCUVFScUlnRVFLallDQ0NBQ0lBRVFLellDQUFKL0EwQWdBa0VJYWlBQ0VDeEZCRUJCQkNFQlFRQU1BZ3NDUUNBQ0tBSUlLQUlBSWdFb0FnUkJBRWdOQUNBQktBSUVJQUFvQWdSQkVHb1FNa3NOQUNBQklBQW9BZ1JCRUdvZ0FTZ0NCQkF2S0FJQU5nSVVJQUpCQ0dvUUxSb01BUXNMUVFFaEFVRUJDd1IvSUFGQkFrZEJBWFFGSUFKQkdHb1FMUm9NQWdzTEN5RUFJQUpCSUdva0FDQUFDdzRBSUFBb0FnUkJBQkNiQkVFQkM2UUJBUU4vSXdCQkVHc2lBU1FBQWtBZ0FDZ0NCQkQ2QTBVTkFDQUJJQUFvQWdRaUFFRUVhaUlDRUNvMkFnZ2dBU0FDRUNzMkFnQWdBRUVRYWlFQ0EwQWdBVUVJYWlBQkVDeEZEUUVDUUNBQktBSUlLQUlBSWdBaUEwSE9BQ0FES0FJQUtBSU1FUUlBUlEwQUlBQW9BaVFpQTBFQVNBMEFJQUlRTWlBRFRRMEFJQUFnQWlBREVDOG9BZ0EyQWlnTElBRkJDR29RTFJvTUFBc0FDeUFCUVJCcUpBQkJBQXNMQUNBQVFRQVErd05CQVFzS0FDQUFLQUlFRUtvREN5TUFJQUZCQ210Qi8vOERjU0lBUVI5TkJFQkJnNENBZ0g4Z0FIWkJBWEVQQzBFQUN5WUFJQUZCQW1zaUFFSC8vd054UVNSTkJFQkNnWWFBZ0lBQ0lBQ3RpS2RCQVhFUEMwRUFDeHdCQVg5QmdBRVFKMEVBUVlBQkVETVE4UUVpQVNBQUVOb0NJQUVMTmdBQ1FBSkFBa0FnQVVIM0FHc09BZ0FCQWdzZ0FDQUNFRFkyQWpCQkFROExJQUFnQWhBMk5nSTBRUUVQQ3lBQUlBRWdBaEJiQ3cwQUlBRkJNRVlnQVVFS1JuSUxCQUJCTUFzY0FRRi9RY1FBRUNkQkFFSEVBQkF6RUs0Q0lnRWdBQkMyQWlBQkN3UUFRU2tMSHdBZ0FVSDVBRVlFUUNBQUlBSVFOallDTUVFQkR3c2dBQ0FCSUFJUVd3c21BQ0FCUVFwcklnQkIvLzhEY1VFblRRUkFRb09BZ0lDQUVDQUFyWWluUVFGeER3dEJBQXNFQUVFeEN4b0JBWDlCT0JBblFRQkJPQkF6RVAwRElnRWdBQkR6QkNBQkN3Y0FJQUZCRjBZTEJBQkJGd3NTQUVFRUVDY2lBRUVBTmdJQUlBQVEvZ01MZXdBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFGQkIyc09CZ0FCQWdNRUJRWUxJQUFnQWhBd3RqZ0NNQXdHQ3lBQUlBSVFNTFk0QWpRTUJRc2dBQ0FDRURDMk9BSTREQVFMSUFBZ0FoQXd0amdDUEF3REN5QUFJQUlRTUxZNEFrQU1BZ3NnQUNBQ0VEQzJPQUpFREFFTElBQWdBU0FDRUZzUEMwRUJDeUFBSUFGQkFXc2lBRUgvL3dOeFFRcE5CRUJCZ1F3Z0FIWkJBWEVQQzBFQUN4d0JBWDlCdUFFUUowRUFRYmdCRURNUWdRUWlBU0FBRU9jRElBRUxQQUVCZndKQUlBQWdBUkJmSWdFTkFFRUJJUUVnQUNnQ0ZDSUNRUTRnQWlnQ0FDZ0NEQkVDQUVVTkFDQUFLQUlVSUFBMkFqaEJBQ0VCQ3lBQkM2c0NBUWgvSUFBb0FoUWlBVUVySUFFb0FnQW9BZ3dSQWdBRWZ5QUFLQUlVSVFFakFFRVFheUlFSkFBZ0JDQUFOZ0lNSUFSQkRHb2hCd0pBSUFGQjRBQnFJZ0VvQWdRZ0FSQW9LQUlBUndSQUlBRWdCeEJKREFFTEl3QkJJR3NpQ0NRQUlBRVFLQ0lGQW44Z0FTQUJFREpCQVdvUVN5RURJQUVRTWlFSkl3QkJFR3NpQmlRQUlBWkJBRFlDRENBSVFRaHFJZ0JCREdvZ0JrRU1haUFGRUVjZ0F3UkFJQUFvQWhBYUlBTkIvLy8vL3dOTEJFQVFSUUFMSUFOQkFuUVFKeUVDQ3lBQUlBSTJBZ0FnQUNBQ0lBbEJBblJxSWdVMkFnZ2dBQ0FGTmdJRUlBQVFNU0FDSUFOQkFuUnFOZ0lBSUFaQkVHb2tBQ0FBS0FJSUN5QUhFRWdnQUNBQUtBSUlRUVJxTmdJSUlBRWdBQkJNSUFBUVNpQUlRU0JxSkFBTElBUkJFR29rQUVFQUJVRUJDd3ZhQVFJQmZRTi9Jd0JCSUdzaUJTUUFJQVZCQ0dvUVZDRURJQUFxQWpRaEFpQURRUUFRSmlBQ09BSUFJQUFxQWp3aEFpQURRUUVRSmlBQ09BSUFJQUFxQWpnaEFpQURRUUlRSmlBQ09BSUFRUU1oQkNBQUtnSkFJUUlnQTBFREVDWWdBamdDQUNBQUtnSkVJUUlnQTBFRUVDWWdBamdDQUNBQUtnSklJUUlnQTBFRkVDWWdBamdDQUFKQUlBQkJ6QUJxSUFNUTlnTkZEUUFnQUNBQkVGOGlCQTBBUVFFaEJDQUJJQUFvQWpBZ0FTZ0NBQ2dDQUJFQ0FDSUJSUTBBSUFFUXNRSkZEUUFnQUNBQk5nSmtRUUFoQkFzZ0JVRWdhaVFBSUFRTEZBQWdBQ2dDY0NJQUlBQW9BZ0FvQWdBUkFRQUxuUUVCQW44akFFRVFheUlCSkFBZ0FTQUFRZUFBYWlJQ0VDbzJBZ2dnQVNBQ0VDczJBZ0FEUUNBQlFRaHFJQUVRTEFSQUlBRW9BZ2dvQWdBb0FtUWdBQkJ4SUFGQkNHb1FMUm9NQVFVZ0FFRi9JQUlRTWtFR2JFRUdhaUlBUVFKMElBQkIvdi8vL3dOeElBQkhHeEFuSWdBMkFtd2dBRUlBTndJUUlBQkNnSUNBZ0lDQWdNQS9Od0lJSUFCQ2dJQ0EvQU0zQWdBZ0FVRVFhaVFBQ3dzTGp3SUJCSDhqQUVFd2F5SUJKQUFnQVVFWWFoQlVJUVFnQVNBQVFlQUFhaUlERUNvMkFoQWdBU0FERUNzMkFnaEJCaUVGQTBBZ0FVRVFhaUFCUVFocUVDd0VRQ0FFSUFFb0FoQW9BZ0FpQXlnQ1pCQitJQU5CekFCcUVMMEJJQVJCQUJBbUlRSWdCVUVDZENJRElBQW9BbXhxSUFJcUFnQTRBZ0FnQkVFQkVDWWhBaUFBS0FKc0lBTkJCSEpxSUFJcUFnQTRBZ0FnQkVFQ0VDWWhBaUFESUFBb0FteHFJQUlxQWdBNEFnZ2dCRUVERUNZaEFpQURJQUFvQW14cUlBSXFBZ0E0QWd3Z0JFRUVFQ1loQWlBRElBQW9BbXhxSUFJcUFnQTRBaEFnQkVFRkVDWWhBaUFESUFBb0FteHFJQUlxQWdBNEFoUWdCVUVHYWlFRklBRkJFR29RTFJvTUFRVWdBVUV3YWlRQUN3c0xOZ0VDZjBHUUFSQW5RUUJCa0FFUU14Q05CQ0lDSWdFZ0FDb0NpQUU0QW9nQklBRWdBQ29DakFFNEFvd0JJQUVnQUJEZUJDQUNDN1FCQVFGOUlBQXFBakFoQWlBQVFjZ0FhaUlCUVFBUUppQUNPQUlBSUFBcUFqZ2hBaUFCUVFFUUppQUNPQUlBSUFBcUFqUWhBaUFCUVFJUUppQUNPQUlBSUFBcUFqd2hBaUFCUVFNUUppQUNPQUlBSUFBcUFrQWhBaUFCUVFRUUppQUNPQUlBSUFBcUFrUWhBaUFCUVFVUUppQUNPQUlBSUFBZ0FDZ0NGQ0lCSUFFb0FnQW9BZ2dSQUFCQkVFWUVmeUFCUVp3QmFrRUFJQUViQlVFQUN5SUJOZ0p3SUFFRWZ5QUJJQUEyQWdSQkFBVkJBUXNMQ1FBZ0FCQ1BCQkF1Q3drQUlBQWdBUkROQVFzSkFDQUFFSzhDRUM0TEJ3QkRBQUFBQUFzS0FDQUFLQUlVS2dKNEMxRUJBWDhqQUVFUWF5SUJKQUFnQVNBQVFmd0FhaUlBRUNvMkFnZ2dBU0FBRUNzMkFnQURRQ0FCUVFocUlBRVFMQVJBSUFFb0FnZ29BZ0FRaEFNZ0FVRUlhaEF0R2d3QkJTQUJRUkJxSkFBTEN3dW5BZ0VJZnlBQUlBRVF6UUVhSUFBb0FoUVFzUUlFZnlBQUtBSVVJUUVqQUVFUWF5SUVKQUFnQkNBQU5nSU1JQVJCREdvaEJ3SkFJQUZCL0FCcUlnRW9BZ1FnQVJBb0tBSUFSd1JBSUFFZ0J4QkpEQUVMSXdCQklHc2lDQ1FBSUFFUUtDSUZBbjhnQVNBQkVESkJBV29RU3lFRElBRVFNaUVKSXdCQkVHc2lCaVFBSUFaQkFEWUNEQ0FJUVFocUlnQkJER29nQmtFTWFpQUZFRWNnQXdSQUlBQW9BaEFhSUFOQi8vLy8vd05MQkVBUVJRQUxJQU5CQW5RUUp5RUNDeUFBSUFJMkFnQWdBQ0FDSUFsQkFuUnFJZ1UyQWdnZ0FDQUZOZ0lFSUFBUU1TQUNJQU5CQW5ScU5nSUFJQVpCRUdva0FDQUFLQUlJQ3lBSEVFZ2dBQ0FBS0FJSVFRUnFOZ0lJSUFFZ0FCQk1JQUFRU2lBSVFTQnFKQUFMSUFSQkVHb2tBRUVBQlVFQkN3c1RBQ0FCUlFSQVFRRVBDeUFCTFFBTVFRQkhDeG9BSUFGRkJFQkJBUThMSUFGQk9pQUJLQUlBS0FJTUVRSUFDM1FBSUFGRkJFQkJBUThMQWtBQ1FBSkFBa0FDUUFKQUlBQW9BZ2hCQVdzT0JRRUNCQU1GQUFzZ0FTb0NEQ0FBS2dJTVd3OExJQUVxQWd3Z0FDb0NERndQQ3lBQktnSU1JQUFxQWd4ZkR3c2dBU29DRENBQUtnSU1YUThMSUFFcUFnd2dBQ29DREdBUEN5QUJLZ0lNSUFBcUFneGVDeEFBSUFGRkJFQkJBUThMSUFFUXlRSUw5UUlCQ0g5QkFTRUNBa0FnQVVFMUVGRWlBMFVOQUVFQ0lRSWdBQ2dDQkVFQVNBMEFJQUFvQWdRZ0F5Z0NCQkRzQVU4TkFDQUFJQU1vQWdRZ0FDZ0NCQkRnQVNBQUtBSUFLQUlzRVFJQVJRMEFRUUVoQWlBQlFjRUFFRkVpQVVVTkFDQUJLQUlFSVFGQkFDRUNJd0JCRUdzaUJDUUFJQVFnQURZQ0RDQUVRUXhxSVFjQ1FDQUJRUmhxSWdFb0FnUWdBUkFvS0FJQVJ3UkFJQUVnQnhCSkRBRUxJd0JCSUdzaUNDUUFJQUVRS0NJRkFuOGdBU0FCRURKQkFXb1FTeUVESUFFUU1pRUpJd0JCRUdzaUJpUUFJQVpCQURZQ0RDQUlRUWhxSWdCQkRHb2dCa0VNYWlBRkVFY2dBd1JBSUFBb0FoQWFJQU5CLy8vLy93TkxCRUFRUlFBTElBTkJBblFRSnlFQ0N5QUFJQUkyQWdBZ0FDQUNJQWxCQW5ScUlnVTJBZ2dnQUNBRk5nSUVJQUFRTVNBQ0lBTkJBblJxTmdJQUlBWkJFR29rQUNBQUtBSUlDeUFIRUVnZ0FDQUFLQUlJUVFScU5nSUlJQUVnQUJCTUlBQVFTaUFJUVNCcUpBQUxJQVJCRUdva0FFRUFJUUlMSUFJTEJ3QWdBQzBBREFzM0FRRi9RUUVoQWdKQUlBRkZEUUFnQVMwQURBUkFJQUFvQWdoRkRRRUxRUUFoQWlBQkxRQU1EUUFnQUNnQ0NFRUJSaUVDQ3lBQ0N4b0FJQUZGQkVCQkFROExJQUZCT3lBQktBSUFLQUlNRVFJQUN3TUFBUXNEQUFFTEh3QkJBQ0VBQWtBZ0FVVU5BQ0FCRUtVQlJRMEFJQUVvQWhRaEFBc2dBQXNoQUVFQUlRQUNRQ0FCUlEwQUlBRW9BZ1FRcFFGRkRRQWdBUkFvSVFBTElBQUxud0lCQ0g4Z0FVRThFRkVpQVVVRVFFRUJEd3NnQVNnQ0JDRUJJd0JCRUdzaUJDUUFJQVFnQURZQ0RDQUVRUXhxSVFjQ1FDQUJRUVJxSWdFb0FnUWdBUkFvS0FJQVJ3UkFJQUVnQnhCSkRBRUxJd0JCSUdzaUNDUUFJQUVRS0NJRkFuOGdBU0FCRURKQkFXb1FTeUVESUFFUU1pRUpJd0JCRUdzaUJpUUFJQVpCQURZQ0RDQUlRUWhxSWdCQkRHb2dCa0VNYWlBRkVFY2dBd1JBSUFBb0FoQWFJQU5CLy8vLy93TkxCRUFRUlFBTElBTkJBblFRSnlFQ0N5QUFJQUkyQWdBZ0FDQUNJQWxCQW5ScUlnVTJBZ2dnQUNBRk5nSUVJQUFRTVNBQ0lBTkJBblJxTmdJQUlBWkJFR29rQUNBQUtBSUlDeUFIRUVnZ0FDQUFLQUlJUVFScU5nSUlJQUVnQUJCTUlBQVFTaUFJUVNCcUpBQUxJQVJCRUdva0FFRUFDMnNCQVg4akFFRVFheUlDSkFBZ0FpQUFRUmhxSWdBUUtqWUNDQ0FDSUFBUUt6WUNBQU5BQWtBZ0FrRUlhaUFDRUN4RkJFQkJBQ0VBREFFTElBSW9BZ2dvQWdBaUFDQUJJQUFvQWdBb0Fod1JBZ0FpQUEwQUlBSkJDR29RTFJvTUFRc0xJQUpCRUdva0FDQUFDMnNCQVg4akFFRVFheUlDSkFBZ0FpQUFRUmhxSWdBUUtqWUNDQ0FDSUFBUUt6WUNBQU5BQWtBZ0FrRUlhaUFDRUN4RkJFQkJBQ0VBREFFTElBSW9BZ2dvQWdBaUFDQUJJQUFvQWdBb0FoZ1JBZ0FpQUEwQUlBSkJDR29RTFJvTUFRc0xJQUpCRUdva0FDQUFDd2tBSUFBUXN3SVFMZ3RYQUFKQUFrQUNRQUpBQWtBZ0FVSHVBR3NPQkFBQkFnTUVDeUFBSUFJUU5qWUNRRUVCRHdzZ0FDQUNFRFkyQWtSQkFROExJQUFnQWhBMk5nSklRUUVQQ3lBQUlBSVFOallDVEVFQkR3c2dBQ0FCSUFJUWtBUUxRQUVCZnlBQlFUVVFVU0lCUlFSQVFRRVBDeUFCS0FJRUlRSWpBRUVRYXlJQkpBQWdBU0FBTmdJTUlBSkJFR29nQVVFTWFoQ2NCQ0FCUVJCcUpBQkJBQXRyQVFGL0l3QkJFR3NpQWlRQUlBSWdBRUVRYWlJQUVDbzJBZ2dnQWlBQUVDczJBZ0FEUUFKQUlBSkJDR29nQWhBc1JRUkFRUUFoQUF3QkN5QUNLQUlJS0FJQUlnQWdBU0FBS0FJQUtBSWNFUUlBSWdBTkFDQUNRUWhxRUMwYURBRUxDeUFDUVJCcUpBQWdBQXZWQVFFRWZ5TUFRUkJySWdJa0FDQUNJQUJCRUdvaUF4QXFOZ0lJSUFJZ0F4QXJOZ0lBQTBBQ1FDQUNRUWhxSUFJUUxDSUZSUTBBSUFJb0FnZ29BZ0FpQXlBQklBTW9BZ0FvQWhnUkFnQWlCQTBBQWtBQ1FBSkFBa0FnQXlBREtBSUFLQUlJRVFBQVFUNXJEZ01BQVFJREN5QUFJQU0yQWh3TUFnc2dBQ0FETmdJZ0RBRUxJQUFnQXpZQ0pBc2dBa0VJYWhBdEdnd0JDd3NDUUNBRkRRQkJBaUVFSUFBb0FoeEZEUUFnQUNnQ0lFVU5BQ0FBS0FJa0lRQWdBa0VRYWlRQUlBQkZRUUYwRHdzZ0FrRVFhaVFBSUFSQi93RnhDd2tBSUFBUWxBUVFMZ3NtQUNBQlFRcHJJZ0JCLy84RGNVRWtUUVJBUW9HQWdJQ0FBeUFBcllpblFRRnhEd3RCQUFzeEFRSi9BMzhnQUNnQ0VDQUJUUVIvSUFJRklBSWdBQ2dDRkNBQlFTeHNhaTBBSUdvaEFpQUJRUUZxSVFFTUFRc0xDeUFCQVg4Z0FTQUFLQUlJU1FSL0lBQW9BZ3dnQVVFQ2RHb29BZ0FGUVFBTEM2RUVBUWgvSUFCQkFEb0FCQU5BSUFnZ0FDZ0NFRWtFUUFKL0lBQW9BZ3doQmlBQUtBSUlHaUFBS0FJVUlBaEJMR3hxSWdOQkFEb0FJQ0FES0FJSUlnUUVRQ0FFSUFJZ0JpQUVLQUlBS0FJSUVRd0FDeUFESUFJUW1RUUNRQ0FES0FJTUlnUkZEUUFnQXlvQ0dFTUFBSUEvWFVVTkFDQURMUUFVRFFBZ0JDQUNJQVlnQkNnQ0FDZ0NDQkVNQUF0QkFDRUVBa0FEUUNBRVFRQkhJUVZCQUNFSEFuOENRQ0FES0FJUUlncEZEUUFnQXlnQ0RFVU5BQ0FLS0FJTVJRMEFJQU1xQWhoREFBQ0FQMTBoQnd0QkFDQUhEUUFhSUFOQkFEb0FJVUVCSUFNZ0F5Z0NCQ0FHSUFVUW1BUU5BQm9nQXlBREtBSUlJQVlnQlJDWUJBc2hCeUFES0FJa0lnVUVRQ0FGSUFFZ0F5b0NLQ0FES2dJY0VMb0NJQU5CQURZQ0pBc0NRQ0FES0FJTUlnVkZEUUFnQXlvQ0dFTUFBSUEvWFVVTkFDQUZJQUVnQXlvQ0hDQUZLQUlBS0FJTUVRb0FDeUFES0FJSUlnVUVRQ0FGSUFFZ0F5b0NHQ0FGS0FJQUtBSU1FUW9BQ3lBSFJRMEJJQVJCNUFCSElRVWdCRUVCYWlFRUlBVU5BQXRCa01JQVFTWkJpTGNCS0FJQUVOc0NRUUFNQVF0QkFTRUVBa0FnQXlvQ0dFTUFBSUEvWEEwQUlBTXRBQ0VOQUVFQUlBTW9BZ2dpQTBVTkFSb2dBeUFES0FJQUtBSVFFUUFBSVFRTElBUUxCRUFnQUVFQk9nQUVDeUFJUVFGcUlRZ01BUXNMQTBBZ0FDZ0NDQ0FKU3dSQUlBQW9BZ3dnQ1VFQ2RHb29BZ0FpQVNBQktBSUFLQUlBRVFFQUlBbEJBV29oQ1F3QkN3c2dBQzBBQkFzSkFDQUFRUUE2QUF3TEZ3QWdBQzBBREVVRVFDQUFRUUU2QUF3Z0FCQzBBZ3NMQkFCQkxnc1pBQ0FCSUFBcUFneGNCRUFnQUNBQk9BSU1JQUFRdEFJTEN4a0FJQUVnQUMwQURFY0VRQ0FBSUFFNkFBd2dBQkMwQWdzTENRQWdBQ2dDQ0JBOUN4MEFJQUZCTlJCUklnRkZCRUJCQVE4TElBRW9BZ1FnQUJDYkJFRUFDMEFCQVg4Z0FVRUJFRkVpQVFSL0lBRW9BZ1FoQWlNQVFSQnJJZ0VrQUNBQklBQTJBZ3dnQWtIMEFHb2dBVUVNYWhDaEFTQUJRUkJxSkFCQkFBVkJBUXNMMEFFQkEzOGpBRUVRYXlJQ0pBQWdBaUFBUVJ4cUlnTVFLallDQ0NBQ0lBTVFLellDQUFOQUFrQWdBa0VJYWlBQ0VDd2lCRVVOQUNBQ0tBSUlLQUlBSWdNZ0FTQURLQUlBS0FJY0VRSUFJZ01OQUNBQ1FRaHFFQzBhREFFTEN3SkFJQVJGQkVBZ0FpQUFRUkJxSWdBUUtqWUNDQ0FDSUFBUUt6WUNBQU5BSUFKQkNHb2dBaEFzUlFSQVFRQWhBd3dEQ3lBQ0tBSUlLQUlBSWdBZ0FTQUFLQUlBS0FJY0VRSUFJZ01OQWlBQ1FRaHFFQzBhREFBTEFBc2dBa0VRYWlRQUlBTkIvd0Z4RHdzZ0FrRVFhaVFBSUFNTDBBRUJBMzhqQUVFUWF5SUNKQUFnQWlBQVFSeHFJZ01RS2pZQ0NDQUNJQU1RS3pZQ0FBTkFBa0FnQWtFSWFpQUNFQ3dpQkVVTkFDQUNLQUlJS0FJQUlnTWdBU0FES0FJQUtBSVlFUUlBSWdNTkFDQUNRUWhxRUMwYURBRUxDd0pBSUFSRkJFQWdBaUFBUVJCcUlnQVFLallDQ0NBQ0lBQVFLellDQUFOQUlBSkJDR29nQWhBc1JRUkFRUUFoQXd3REN5QUNLQUlJS0FJQUlnQWdBU0FBS0FJQUtBSVlFUUlBSWdNTkFpQUNRUWhxRUMwYURBQUxBQXNnQWtFUWFpUUFJQU5CL3dGeER3c2dBa0VRYWlRQUlBTUxDUUFnQUJDZEJCQXVDd2NBSUFBb0FpUUxCd0FnQUNnQ0lBdEFBUUYvSUFGQkFSQlJJZ0VFZnlBQktBSUVJUUlqQUVFUWF5SUJKQUFnQVNBQU5nSU1JQUpCNkFCcUlBRkJER29Rb1FFZ0FVRVFhaVFBUVFBRlFRRUxDMnNCQVg4akFFRVFheUlDSkFBZ0FpQUFRU3hxSWdBUUtqWUNDQ0FDSUFBUUt6WUNBQU5BQWtBZ0FrRUlhaUFDRUN4RkJFQkJBQ0VBREFFTElBSW9BZ2dvQWdBaUFDQUJJQUFvQWdBb0Fod1JBZ0FpQUEwQUlBSkJDR29RTFJvTUFRc0xJQUpCRUdva0FDQUFDMFlCQW45QjRBQVFKMEVBUWVBQUVETVFud1FpQWlJQklBQW9Ba0EyQWtBZ0FTQUFLQUpFTmdKRUlBRWdBQ2dDU0RZQ1NDQUJJQUFvQWt3MkFrd2dBU0FBRUxZQ0lBSUxhd0VCZnlNQVFSQnJJZ0lrQUNBQ0lBQkJMR29pQUJBcU5nSUlJQUlnQUJBck5nSUFBMEFDUUNBQ1FRaHFJQUlRTEVVRVFFRUFJUUFNQVFzZ0FpZ0NDQ2dDQUNJQUlBRWdBQ2dDQUNnQ0dCRUNBQ0lBRFFBZ0FrRUlhaEF0R2d3QkN3c2dBa0VRYWlRQUlBQUxDUUFnQUJDaUJCQXVDd3NBUVFnUUp5QUFFSkVFQzJzQkFYOGpBRUVRYXlJQ0pBQWdBaUFBUVFScUlnQVFLallDQ0NBQ0lBQVFLellDQUFOQUFrQWdBa0VJYWlBQ0VDeEZCRUJCQUNFQURBRUxJQUlvQWdnb0FnQWlBQ0FCSUFBb0FnQW9BaHdSQWdBaUFBMEFJQUpCQ0dvUUxSb01BUXNMSUFKQkVHb2tBQ0FBQzJzQkFYOGpBRUVRYXlJQ0pBQWdBaUFBUVFScUlnQVFLallDQ0NBQ0lBQVFLellDQUFOQUFrQWdBa0VJYWlBQ0VDeEZCRUJCQUNFQURBRUxJQUlvQWdnb0FnQWlBQ0FCSUFBb0FnQW9BaGdSQWdBaUFBMEFJQUpCQ0dvUUxSb01BUXNMSUFKQkVHb2tBQ0FBQ3drQUlBQVE0Z0VRTGdzT0FDQUJJQUlnQUNnQ0dCQ3BCQXNPQUNBQklBSWdBQ2dDR0JDcEJBc0hBQ0FBS2dJNEN3Y0FJQUFxQWpRTEJ3QWdBQ29DTUF0S0FRRi9JQU1nQUNvQ0ZKTWdCQ29DRkNBQUtnSVVrNVVoQXlBQUtBSVFJZ1lFUUNBR0lBTVF1QVFoQXdzZ0FTQUNJQVVnQUNvQ0dDQURJQVFxQWhnZ0FDb0NHSk9Va2hDeEJBc0hBQ0FBS2dJWUN4QUFJQUVnQWlBRElBQXFBaGdRc1FRTEJ3QWdBQ2dDRUF0RkFRRi9JQU1nQUNvQ0ZKTWdCQ29DRkNBQUtnSVVrNVVoQXlBQUtBSVFJZ1lFUUNBR0lBTVF1QVFoQXdzZ0FTQUNJQVVnQUNnQ0dDQUVLQUlZSUFNUWdRTVFzd1FMRUFBZ0FTQUNJQU1nQUNnQ0dCQ3pCQXUwQWdFSWZ5QUJRUm9RVVNJQlJRUkFRUUVQQ3lBQUlBQW9BZ1N5SUFFb0FnUW9BaEN5bFRnQ0ZDQUJLQUlJSVFFakFFRVFheUlFSkFBZ0JDQUFOZ0lNSUFSQkRHb2hCd0pBSUFGQkNHb2lBU2dDQkNBQkVDZ29BZ0JIQkVBZ0FTQUhFRWtNQVFzakFFRWdheUlJSkFBZ0FSQW9JZ1VDZnlBQklBRVFNa0VCYWhCTElRTWdBUkF5SVFrakFFRVFheUlHSkFBZ0JrRUFOZ0lNSUFoQkNHb2lBRUVNYWlBR1FReHFJQVVRUnlBREJFQWdBQ2dDRUJvZ0EwSC8vLy8vQTBzRVFCQkZBQXNnQTBFQ2RCQW5JUUlMSUFBZ0FqWUNBQ0FBSUFJZ0NVRUNkR29pQlRZQ0NDQUFJQVUyQWdRZ0FCQXhJQUlnQTBFQ2RHbzJBZ0FnQmtFUWFpUUFJQUFvQWdnTElBY1FTQ0FBSUFBb0FnaEJCR28yQWdnZ0FTQUFFRXdnQUJCS0lBaEJJR29rQUFzZ0JFRVFhaVFBUVFBTFRBRUJmMEVCSVFJQ1FDQUFLQUlNUVFGT0JFQWdBU0FBS0FJTUlBRW9BZ0FvQWdBUkFnQWlBVVVOQVNBQlFSd2dBU2dDQUNnQ0RCRUNBRVVOQVNBQUlBRTJBaEFMUVFBaEFnc2dBZ3VmQWdFSWZ5QUJRUmtRVVNJQlJRUkFRUUVQQ3lBQktBSUVJUUVqQUVFUWF5SUVKQUFnQkNBQU5nSU1JQVJCREdvaEJ3SkFJQUZCQ0dvaUFTZ0NCQ0FCRUNnb0FnQkhCRUFnQVNBSEVFa01BUXNqQUVFZ2F5SUlKQUFnQVJBb0lnVUNmeUFCSUFFUU1rRUJhaEJMSVFNZ0FSQXlJUWtqQUVFUWF5SUdKQUFnQmtFQU5nSU1JQWhCQ0dvaUFFRU1haUFHUVF4cUlBVVFSeUFEQkVBZ0FDZ0NFQm9nQTBILy8vLy9BMHNFUUJCRkFBc2dBMEVDZEJBbklRSUxJQUFnQWpZQ0FDQUFJQUlnQ1VFQ2RHb2lCVFlDQ0NBQUlBVTJBZ1FnQUJBeElBSWdBMEVDZEdvMkFnQWdCa0VRYWlRQUlBQW9BZ2dMSUFjUVNDQUFJQUFvQWdoQkJHbzJBZ2dnQVNBQUVFd2dBQkJLSUFoQklHb2tBQXNnQkVFUWFpUUFRUUFMYXdFQmZ5TUFRUkJySWdJa0FDQUNJQUJCQ0dvaUFCQXFOZ0lJSUFJZ0FCQXJOZ0lBQTBBQ1FDQUNRUWhxSUFJUUxFVUVRRUVBSVFBTUFRc2dBaWdDQ0NnQ0FDSUFJQUVnQUNnQ0FDZ0NIQkVDQUNJQURRQWdBa0VJYWhBdEdnd0JDd3NnQWtFUWFpUUFJQUFMYXdFQmZ5TUFRUkJySWdJa0FDQUNJQUJCQ0dvaUFCQXFOZ0lJSUFJZ0FCQXJOZ0lBQTBBQ1FDQUNRUWhxSUFJUUxFVUVRRUVBSVFBTUFRc2dBaWdDQ0NnQ0FDSUFJQUVnQUNnQ0FDZ0NHQkVDQUNJQURRQWdBa0VJYWhBdEdnd0JDd3NnQWtFUWFpUUFJQUFMQndBZ0FDb0NGQXNKQUNBQUVMUUVFQzRMbndJQkNIOGdBVUVmRUZFaUFVVUVRRUVCRHdzZ0FTZ0NCQ0VCSXdCQkVHc2lBeVFBSUFNZ0FEWUNEQ0FEUVF4cUlRY0NRQ0FCUVN4cUlnRW9BZ1FnQVJBb0tBSUFSd1JBSUFFZ0J4QkpEQUVMSXdCQklHc2lDQ1FBSUFFUUtDSUVBbjhnQVNBQkVESkJBV29RU3lFQ0lBRVFNaUVKSXdCQkVHc2lCU1FBSUFWQkFEWUNEQ0FJUVFocUlnQkJER29nQlVFTWFpQUVFRWNnQWdSQUlBQW9BaEFhSUFKQi8vLy8vd05MQkVBUVJRQUxJQUpCQW5RUUp5RUdDeUFBSUFZMkFnQWdBQ0FHSUFsQkFuUnFJZ1EyQWdnZ0FDQUVOZ0lFSUFBUU1TQUdJQUpCQW5ScU5nSUFJQVZCRUdva0FDQUFLQUlJQ3lBSEVFZ2dBQ0FBS0FJSVFRUnFOZ0lJSUFFZ0FCQk1JQUFRU2lBSVFTQnFKQUFMSUFOQkVHb2tBRUVBQzE4QkFYOGpBRUVRYXlJQ0pBQWdBaUFBUVFocUlnQVFLallDQ0NBQ0lBQVFLellDQUFOL0lBSkJDR29nQWhBc0JIOGdBaWdDQ0NnQ0FDSUFJQUVnQUNnQ0FDZ0NIQkVDQUJvZ0FrRUlhaEF0R2d3QkJTQUNRUkJxSkFCQkFBc0xDNHNCQVFGL0l3QkJFR3NpQWlRQUFrQWdBU0FBS0FJRUlBRW9BZ0FvQWdBUkFnQUVRQ0FDSUFCQkNHb2lBQkFxTmdJSUlBSWdBQkFyTmdJQUEwQWdBa0VJYWlBQ0VDeEZCRUJCQUNFQURBTUxJQUlvQWdnb0FnQWlBQ0FCSUFBb0FnQW9BaGdSQWdBaUFBMENJQUpCQ0dvUUxSb01BQXNBQ3lBQ1FSQnFKQUJCQVE4TElBSkJFR29rQUNBQUN3a0FJQUFRdGdRUUxnc0hBQ0FBS2dJUUN3Y0FJQUFxQWdnTFBnQkJBQ0VCQTM4Z0FVRUxSZ1IvUVFBRklBQWdBVUVDZEdvZ0FiSkR6Y3pNUFpRZ0FDb0NCQ0FBS2dJTUVPUUJPQUlVSUFGQkFXb2hBUXdCQ3dzTElBQWdBVUdyQVVZRVFDQUFJQUlRTmpZQ0pFRUJEd3NnQUNBQklBSVEyZ1FMSWdBZ0FVSEJBR3NpQUVILy93TnhRUTFOQkVCQmc4QUFJQUIyUVFGeER3dEJBQXNGQUVIT0FBc1ZBQ0FBS0FJb0lnQkZCRUJCQUE4TElBQW9BZ2dMU0FFQ2Z3SkFJQUZGRFFBQ1FBSkFJQUVvQWdRaUFpQUNLQUlBS0FJSUVRQUFRY2tBYXc0RUFRSUNBQUlMSUFFZ0FDZ0NLQkM3QkE4TElBRWdBQ2dDS0JDN0JDRURDeUFEQ3drQUlBQVF2Z0lRTGdzTUFDQUFFTDRDR2lBQUVDNExxQUVCQVg4akFFRWdheUlESkFBZ0FDQUJJQUlRNWdFZ0F5QUFRUWhxSWdBUUtqWUNHQ0FESUFBUUt6WUNFQU5BSUFOQkdHb2dBMEVRYWhBc0JFQWdBaUFES0FJWUlnQW9BZ0FvQWd4QkFuUnFLQUlBS2dJTUlRRWdBMEdBZ0lEOEF6WUNEQ0FEUVFBMkFnZ2dBeUFCUXdBQXlFS1ZPQUlFSUFBZ0EwRU1haUFEUVFocUlBTkJCR29RdndJUXBnRXFBZ0FReFFRZ0EwRVlhaERDQVF3QkJTQURRU0JxSkFBTEN3c2hBQ0FCUVR4cklnQkIvLzhEY1VFTlRRUkFRY0hnQUNBQWRrRUJjUThMUVFBTEJRQkJ5UUFMOXdJQkMzOUJHQkFuSWdnaEF5TUFRVUJxSWdFa0FDQURJQUFRNFFFZ0EwR3NPRFlDQUNBRFFRaHFFRG9oQWlBRFFRRTZBQlFnQVNBQUVFWWlBQkFxTmdJNElBRWdBQkFyTmdJd0EzOGdBVUU0YWlBQlFUQnFFQ3dFZnlBQlFRaHFJQUVvQWpnb0FnQVF4d1FoQ1FKQUlBSW9BZ1FnQWhBb0tBSUFTUVJBSUFJZ0NSREFCQXdCQzBFQUlRUWpBRUVnYXlJS0pBQWdBaEFvSWdZQ2Z5QUNJQUlRaEFGQkFXb1F2d1FoQlNBQ0VJUUJJUXNqQUVFUWF5SUhKQUFnQjBFQU5nSU1JQXBCQ0dvaUFFRU1haUFIUVF4cUlBWVFSeUFGQkVBZ0FDZ0NFQm9nQlVIbXpKa3pTd1JBRUVVQUN5QUZRU2hzRUNjaEJBc2dBQ0FFTmdJQUlBQWdCQ0FMUVNoc2FpSUdOZ0lJSUFBZ0JqWUNCQ0FBRURFZ0JDQUZRU2hzYWpZQ0FDQUhRUkJxSkFBZ0FDZ0NDQXNnQ1JEQkFpQUFJQUFvQWdoQktHbzJBZ2dnQWlBQUVMNEVJQUFRdlFRZ0NrRWdhaVFBQ3lBQlFUaHFFQzBhREFFRklBRkJRR3NrQUNBREN3c2FJQWhCa0RnMkFnQWdDQXNIQUNBQUtBSUlDd2tBSUFBUXdnSVFMZ3NNQUNBQUVNSUNHaUFBRUM0TDB3TUNCWDhFZlNNQVFSQnJJZ1VrQUNBQUlBRWdBaERtQVFKL0lBSWdBQ2dDQkNnQ0hFRUNkR29vQWdBcUFnd2lDQ0VCUVFBaEFpQUFRUWhxSWdZUWhBRkJBV3NoQXdOQUFrQWdBaUFEVEFSL0lBRWdCaUFDSUFOcVFRRjFJZ1FRd3dJb0FnQXFBZ3dpQ1Y0RVFDQUVRUUZxSVFJTUF3c2dBU0FKWFEwQklBUUZJQUlMREFJTElBUkJBV3NoQXd3QUN3QUxJUUlnQUVFSWFpSURFSVFCSVFZZ0FBSi9RUUFnQWtFQVNBMEFHa0VBSUFJZ0JrNE5BQm9nQXlBQ0VNTUNDeUlFTmdJY0lBSkJBVWdnQWlBR1NuSkZCRUFnQXlBQ1FRRnJFTU1DSVFjZ0FDZ0NIQ0VFQ3lBQUlBYzJBaGhEQUFDQVB5RUpBa0FDZndKL0lBUUVRQ0FFS0FJQUtnSU1JUXNnQUNnQ0dDRUhDeUFIQ3dSQUlBY29BZ0FxQWd3aENnc2dBQ2dDSEVVZ0NpQUxXM0pGQ3dSQVF3QUFnRDhoQVNBQUtBSVlSUTBCUXdBQWdEOGdDQ0FLa3lBTElBcVRsU0lCa3lFSkRBRUxRd0FBZ0Q4aEFRc2dCU0FERUNvMkFnZ2dCU0FERUNzMkFnQURRQ0FGUVFocUlBVVFMQVJBSUFVb0FnZ2lBaWdDQUNvQ0RDRUlJQUlDZlNBQUtBSWNCRUFnQVNBSUlBdGJEUUVhQ3lBSlF3QUFBQUFnQ0NBS1d4dERBQUFBQUNBQUtBSVlHd3NReFFRZ0JVRUlhaERDQVF3QkN3c2dCVUVRYWlRQUN5QUFJQUZCUEdzaUFFSC8vd054UVF4TkJFQkJ3U0FnQUhaQkFYRVBDMEVBQ3dVQVFjZ0FDd2tBSUFBUXhRSVFMZ3NaQUNBQlFhY0JSZ1JBSUFBZ0FoQTJOZ0ljUVFFUEMwRUFDeDRBSUFGQlBHdEJIM2NpQUVFSVRRUkFRY2tDSUFCMlFRRnhEd3RCQUFzRkFFSE1BQXNIQUNBQUtBSWNDMWtCQW44Z0FVRTFFRkVpQWtVRVFFRUJEd3RCQWlFREFrQWdBQ2dDSEVFQVNBMEFJQUFvQWh3Z0FpZ0NCQkRzQVU4TkFDQUNLQUlFSUFBb0Fod1E0QUVpQWtVTkFDQUNFTWtDUlEwQUlBQWdBUkNqQkNFREN5QURDLzRDQVF0L1FTQVFKeUlHSVFNakFFRkFhaUlCSkFBZ0F5QUFFT0VCSUFOQmdEYzJBZ0FnQTBFSWFoQTZJUUlnQTBFQk9nQVVJQUVnQUJCR0lnQVFLallDT0NBQklBQVFLellDTUFOL0lBRkJPR29nQVVFd2FoQXNCSDhnQVVFSWFpQUJLQUk0S0FJQUVNY0VJUWtDUUNBQ0tBSUVJQUlRS0NnQ0FFa0VRQ0FDSUFrUXdBUU1BUXRCQUNFRUl3QkJJR3NpQ2lRQUlBSVFLQ0lIQW44Z0FpQUNFSVFCUVFGcUVMOEVJUVVnQWhDRUFTRUxJd0JCRUdzaUNDUUFJQWhCQURZQ0RDQUtRUWhxSWdCQkRHb2dDRUVNYWlBSEVFY2dCUVJBSUFBb0FoQWFJQVZCNXN5Wk0wc0VRQkJGQUFzZ0JVRW9iQkFuSVFRTElBQWdCRFlDQUNBQUlBUWdDMEVvYkdvaUJ6WUNDQ0FBSUFjMkFnUWdBQkF4SUFRZ0JVRW9iR28yQWdBZ0NFRVFhaVFBSUFBb0FnZ0xJQWtRd1FJZ0FDQUFLQUlJUVNocU5nSUlJQUlnQUJDK0JDQUFFTDBFSUFwQklHb2tBQXNnQVVFNGFoQXRHZ3dCQlNBQlFVQnJKQUFnQXdzTEdpQUdRZ0EzQWhnZ0JrSGtOallDQUNBR0N5QUFJQUZCcUFGR0JFQWdBQ0FDRURZMkFneEJBUThMSUFBZ0FTQUNFTXNDQ3c4QUlBRkJ6UUJHSUFGQnlnQkdjZ3NGQUVITkFBdFpBUUovSUFGQk5SQlJJZ0pGQkVCQkFROExRUUloQXdKQUlBQW9BZ3hCQUVnTkFDQUFLQUlNSUFJb0FnUVE3QUZQRFFBZ0FpZ0NCQ0FBS0FJTUVPQUJJZ0pGRFFBZ0FoREpBa1VOQUNBQUlBRVF6d1FoQXdzZ0F3c2hBQ0FCUWFZQlJnUkFJQUFnQWhBd3RqZ0NERUVCRHdzZ0FDQUJJQUlReXdJTERRQWdBVUgrL3dOeFFjb0FSZ3NIQUNBQlFRcEdDd1VBUWNzQUN3UUFRUW9MQ0FBZ0FVSEtBRVlMQlFCQnlnQUxDUUFnQUJDVUFoQXVDdzRBSUFCQkNHb2dBU0FDRU13Q0N4RUFJQUFnQUVFSWFpQUJFTGNDT2dBb0N3Y0FJQUFvQWhRTFFRRUJmeUFBS0FJVVJRUkFRUWdRSnlBQUVKRUVEd3RCTEJBbklnRWdBQkRoQVNBQlFZZzBOZ0lBSUFGQkNHb2dBQ2dDRkJDNEFob2dBVUVCT2dBb0lBRUxDd0FnQVVIREFHdEJBa2tMQlFCQnhBQUxIUUVCZjBFSUVDY2lBVUlBTndNQUlBRVEwUVFpQVNBQUVPOEJJQUVMSVFBZ0FVR2RBVVlFUUNBQUlBSVFNTFk0QWd4QkFROExJQUFnQVNBQ0VOY0VDeU1BSUFGQnd3QnJJZ0JCLy84RGNVRURUUVJBUVEwZ0FFRVBjWFpCQVhFUEMwRUFDd1VBUWNZQUN6QUJBbjlCRUJBbklnRkNBRGNEQUNBQlFnQTNBd2dnQVJEU0JDSUJJZ0lnQUNvQ0REZ0NEQ0FDSUFBUTJBUWdBUXNJQUNBQlFjTUFSZ3NGQUVIREFBc1BBQ0FCUWNVQVJpQUJRY01BUm5JTEJRQkJ4UUFMSGdBZ0FVSERBR3NpQUVILy93TnhRUVJOQkVBZ0FFRUJjVVVQQzBFQUN3VUFRY2NBQ3lRQkFYOUJEQkFuSWdGQ0FEY0RBQ0FCUVFBMkFnZ2dBUkRaQkNJQklBQVEyQVFnQVFzTEFDQUJRY0VBYTBFQ1NRc0ZBRUhCQUFzOUFRSi9RU1FRSjBFQVFTUVFNeEROQWlJQ0lnRWdBQ2dDQkRZQ0JDQUJJQUFvQWdnMkFnZ2dBU0FBS0FJTU5nSU1JQUVnQUNnQ0VEWUNFQ0FDQ3g4QUlBRkJObXNpQUVILy93TnhRUVJOQkVCQkV5QUFka0VCY1E4TFFRQUxCQUJCT2dza0FRRi9RUkFRSnlJQlFnQTNBd0FnQVVJQU53TUlJQUVRMndRaUFTQUFFSm9CSUFFTElRQWdBVUdNQVVZRVFDQUFJQUlRTUxZNEFoQkJBUThMSUFBZ0FTQUNFTkFDQ3dvQUlBRkJObXRCQTBrTEJBQkJPQXMzQVFKL1FSUVFKeUlCUWdBM0F3QWdBVUVBTmdJUUlBRkNBRGNEQ0NBQkVOd0VJZ0VpQWlBQUtnSVFPQUlRSUFJZ0FCQ2FBU0FCQ3cwQUlBRkJPVVlnQVVFMlJuSUxCQUJCT1FzYUFRRi9RU2dRSjBFQVFTZ1FNeERkQkNJQklBQVFtZ0VnQVFzTUFDQUJRZjcvQTNGQkNrWUxDUUFnQUJEdEFSQXVDd2NBSUFGQk5rWUxCQUJCTmdzTUFDQUJRZjcvQTNGQk5rWUxCQUJCTndzaEFDQUJRWTBCUmdSQUlBQWdBaENKQVRvQUVFRUJEd3NnQUNBQklBSVEwQUlMSHdBZ0FVRTJheUlBUWYvL0EzRkJCVTBFUUVFaklBQjJRUUZ4RHd0QkFBc0VBRUVMQ3dRQVFUc0xOd0VDZjBFVUVDY2lBVUlBTndNQUlBRkJBRFlDRUNBQlFnQTNBd2dnQVJEZ0JDRUNJQUVnQUMwQUVEb0FFQ0FCSUFBUW1nRWdBZ3NOQUNBQlFUVkdJQUZCRzBaeUN3UUFRVFVMR2dFQmYwRW9FQ2RCQUVFb0VETVE0UVFpQVNBQUVKb0JJQUVMaHdFQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBRkJPR3NPQndBQkFnTUVCUVlIQ3lBQUlBSVFOallDRUF3SEN5QUFJQUlRTmpZQ0ZBd0dDeUFBSUFJUU1MWTRBaGdNQlFzZ0FDQUNFRFkyQWh3TUJBc2dBQ0FDRURZMkFpQU1Bd3NnQUNBQ0VEWTJBaVFNQWdzZ0FDQUNFSWtCT2dBb0RBRUxJQUFnQVNBQ0VQRUVEd3RCQVFzTUFDQUJRZnYvQTNGQkcwWUxCQUJCSHd0a0FRSi9RVGdRSjBFQVFUZ1FNeUlCRU9JRUlRSWdBU0FBS0FJUU5nSVFJQUVnQUNnQ0ZEWUNGQ0FCSUFBcUFoZzRBaGdnQVNBQUtBSWNOZ0ljSUFFZ0FDZ0NJRFlDSUNBQklBQW9BaVEyQWlRZ0FTQUFMUUFvT2dBb0lBRWdBQkNhQVNBQ0N5QUFJQUZCK2dCR0JFQWdBQ0FDRURZMkFoaEJBUThMSUFBZ0FTQUNFTzRCQ3cwQUlBRkJNa1lnQVVFZFJuSUxCQUJCTWdzeUFRRi9RUndRSnlJQlFnQTNBd0FnQVVFQU5nSVlJQUZDQURjREVDQUJRZ0EzQXdnZ0FSRGpCQ0lCSUFBUTVnUWdBUXNoQUNBQlFjWUFSZ1JBSUFBZ0FoQXd0amdDR0VFQkR3c2dBQ0FCSUFJUTdnRUxDZ0FnQVVFZGEwRUNTUXNFQUVFZUN6NEJBbjlCSEJBbklnRkNBRGNEQUNBQlFRQTJBaGdnQVVJQU53TVFJQUZDQURjRENDQUJFT1FFSWdFaUFpQUFLZ0lZT0FJWUlBSWdBQkRsQkNBQkN3Y0FJQUZCSFVZTEJBQkJIUXNoQUNBQlFkZ0FSZ1JBSUFBZ0FoQy9BVFlDR0VFQkR3c2dBQ0FCSUFJUTdnRUxEUUFnQVVFbFJpQUJRUjFHY2dzakFDQUJRUXByUWYvL0EzRWlBRUVjVFFSQVFZT0FnSUFCSUFCMlFRRnhEd3RCQUFzRUFFRWxDeklCQVg5QkhCQW5JZ0ZDQURjREFDQUJRUUEyQWhnZ0FVSUFOd01RSUFGQ0FEY0RDQ0FCRU9jRUlnRWdBQkRtQkNBQkN4Z0FJQUZCTlVZRVFDQUFJQUlRTmpZQ0JBc2dBVUUxUmdzSEFDQUJRUnBHQ3dRQVFSb0xLd0VCZjBFVUVDY2lBVUlBTndNQUlBRkJBRFlDRUNBQlFnQTNBd2dnQVJEb0JDSUJJQUFRN3dFZ0FRc0VBRUVtQ3hnQUlBRkJNMFlFUUNBQUlBSVFOallDQkFzZ0FVRXpSZ3NIQUNBQlFSbEdDd1FBUVJrTEt3RUJmMEVVRUNjaUFVSUFOd01BSUFGQkFEWUNFQ0FCUWdBM0F3Z2dBUkRwQkNJQklBQVE3d0VnQVFzZ0FDQUJRVHhySWdCQi8vOERjVUVHVFFSQVFkRUFJQUIyUVFGeER3dEJBQXNGQUVIQUFBc1pBRUVRRUNjaUFFSUFOd01BSUFCQ0FEY0RDQ0FBRU9vRUN5QUFJQUZCUEdzaUFFSC8vd054UVFaTkJFQkJ5UUFnQUhaQkFYRVBDMEVBQ3dRQVFUOExHUUJCRUJBbklnQkNBRGNEQUNBQVFnQTNBd2dnQUJEckJBdFdBUUYvQWtBQ1FBSkFBa0FDUUFKQUlBRkJQMnNPQkFBQkFnTUZDeUFBSUFJUU1MWTRBZ1FNQXdzZ0FDQUNFREMyT0FJSURBSUxJQUFnQWhBd3RqZ0NEQXdCQ3lBQUlBSVFNTFk0QWhBTFFRRWhBd3NnQXdzSEFDQUJRUnhHQ3dRQVFSd0xQd0VDZjBIQUFCQW5RUUJCd0FBUU14RHNCQ0lDSWdFZ0FDb0NCRGdDQkNBQklBQXFBZ2c0QWdnZ0FTQUFLZ0lNT0FJTUlBRWdBQ29DRURnQ0VDQUNDeUFBSUFGQlBHc2lBRUgvL3dOeFFRWk5CRUJCeFFBZ0FIWkJBWEVQQzBFQUN3UUFRVDRMR1FCQkVCQW5JZ0JDQURjREFDQUFRZ0EzQXdnZ0FCRHRCQXNJQUNBQlFjSUFSZ3NGQUVIQ0FBc09BQ0FCUVR4R0lBRkJ3Z0JHY2dzRUFFRThDeGtBSUFGQmxRRkdCRUFnQUNBQ0VEWTJBaEJCQVE4TFFRQUxJQUFnQVVFOGF5SUFRZi8vQTNGQkJrMEVRRUhEQUNBQWRrRUJjUThMUVFBTEJBQkJQUXN1QVFGL1FSZ1FKeUlCUWdBM0F3QWdBVUlBTndNUUlBRkNBRGNEQ0NBQkVQQUVJZ0VnQUNnQ0VEWUNFQ0FCQ3djQUlBRkJHMFlMQkFCQkd3c0pBQ0FBRU1NQkVDNExKQUVCZjBFUUVDY2lBVUlBTndNQUlBRkNBRGNEQ0NBQkVQQUJJZ0VnQUJDYUFTQUJDMWtBQWtBQ1FBSkFBa0FDUUNBQlFmSUFhdzRFQUFFQ0F3UUxJQUFnQWhBd3RqZ0NNRUVCRHdzZ0FDQUNFREMyT0FJMFFRRVBDeUFBSUFJUU1MWTRBamhCQVE4TElBQWdBaEEyTmdJOFFRRVBDeUFBSUFFZ0FoQmJDdzBBSUFGQkwwWWdBVUVLUm5JTEJBQkJMd3MrQVFKL1Fjd0FFQ2NRK1FJaUFpSUJJQUFxQWpBNEFqQWdBU0FBS2dJME9BSTBJQUVnQUNvQ09EZ0NPQ0FCSUFBb0FqdzJBandnQVNBQUVHZ2dBZ3RZQUFKQUFrQUNRQUpBQWtBZ0FVRXZhdzRFQUFFQ0F3UUxJQUFnQWhBd3RqZ0NPRUVCRHdzZ0FDQUNFRFkyQWp4QkFROExJQUFnQWhBMk5nSkFRUUVQQ3lBQUlBSVFpUUU2QUVSQkFROExJQUFnQVNBQ0VOWUNDeU1BSUFGQkNtdEIvLzhEY1NJQVFSMU5CRUJCZzRDQWdBTWdBSFpCQVhFUEMwRUFDeUVBSUFGQkNtc2lBRUgvL3dOeFFRNU5CRUJCZzVBQklBQjJRUUZ4RHd0QkFBc0VBRUVZQzBnQkFuOUJ6QUFRSjBFQVFjd0FFRE1pQVJEeUJDRUNJQUVnQUNvQ09EZ0NPQ0FCSUFBb0FqdzJBandnQVNBQUtBSkFOZ0pBSUFFZ0FDMEFSRG9BUkNBQklBQVEvUVFnQWdzZkFDQUJRU1ZHQkVBZ0FDQUNFTDhCTmdJd1FRRVBDeUFBSUFFZ0FoQmJDdzBBSUFGQkVrWWdBVUVLUm5JTEJBQkJFZ3NjQVFGL1FjUUFFQ2RCQUVIRUFCQXpFUFFFSWdFZ0FCRHpCQ0FCQ3dRQVFTY0xJQUFnQVVFS2F5SUFRZi8vQTNGQkRFMEVRRUdESVNBQWRrRUJjUThMUVFBTEJBQkJFUXNjQVFGL1FlUUFFQ2RCQUVIa0FCQXpFUFlFSWdFZ0FCRDVCQ0FCQzNrQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVVFaGF3NEtBUUlEQlFVRkJRVUZBQVFMSUFBZ0FoQXd0amdDTUVFQkR3c2dBQ0FDRURDMk9BSTBRUUVQQ3lBQUlBSVFNTFk0QWpoQkFROExJQUFnQWhBd3RqZ0NQRUVCRHdzZ0FVRXVSZzBCQ3lBQUlBRWdBaEJiRHdzZ0FDQUNFREMyT0FKQVFRRUxJQUFnQVVFS2F5SUFRZi8vQTNGQkRFMEVRRUdESUNBQWRrRUJjUThMUVFBTEJBQkJGZ3NjQVFGL1FlUUFFQ2RCQUVIa0FCQXpFTlVDSWdFZ0FCRDVCQ0FCQ3pjQUFrQUNRQUpBSUFGQkptc09BZ0FCQWdzZ0FDQUNFTDhCTmdJd1FRRVBDeUFBSUFJUU1MWTRBalJCQVE4TElBQWdBU0FDRUZzTERRQWdBVUVUUmlBQlFRcEdjZ3NFQUVFVEN5OEJBbjlCT0JBblFRQkJPQkF6RVBvRUlnSWlBU0FBS0FJd05nSXdJQUVnQUNvQ05EZ0NOQ0FCSUFBUWFDQUNDeUFBSUFGQkNtc2lBRUgvL3dOeFFRdE5CRUJCZ3hBZ0FIWkJBWEVQQzBFQUN3UUFRUlVMQndBZ0FDMEFMZ3NmQUNBQlFTaEdCRUFnQUNBQ0VEWTJBamhCQVE4TElBQWdBU0FDRU5ZQ0N5QUFJQUZCQ21zaUFFSC8vd054UVF0TkJFQkJneGdnQUhaQkFYRVBDMEVBQ3dRQVFSUUxKZ0VDZjBFOEVDZEJBRUU4RURNUS9nUWlBU0lDSUFBb0FqZzJBamdnQWlBQUVQMEVJQUVMSmdBZ0FVRUNheUlBUWYvL0EzRkJKRTBFUUVMQnpvQ0FnQUlnQUsySXAwRUJjUThMUVFBTEJ3QWdBQ29DY0FzRUFFRUlDeFVCQVg5QjZBSVFKeEN0QXlJQklBQVE5UUVnQVFzZ0FDQUJRUnBHQkVBZ0FDQUNFREMyT0FJOFFRRVBDeUFBSUFFZ0FoQ3hBUXNnQUNBQlFRVnJJZ0JCLy84RGNVRUpUUVJBUWVFRUlBQjJRUUZ4RHd0QkFBc0VBRUVGQ3ljQkFuOUJ3QUFRSjBFQVFjQUFFRE1RYmlJQklnSWdBQ29DUERnQ1BDQUNJQUFRMEFFZ0FRc2lBQ0FCUWY4QVJnUkFJQUFnQWhBd3RqZ0N2QUZCQVE4TElBQWdBU0FDRUlFRkN5Z0FJQUZCQW1zaUFFSC8vd054UVRKTkJFQkNnYzZBZ0lDQ2dBTWdBSzJJcDBFQmNROExRUUFMQkFCQk5Bc2pBUUovUWNBQkVDY1Fyd01pQVNJQ0lBQXFBcndCT0FLOEFTQUNJQUFRZ2dVZ0FRc21BQ0FCUVFKcklnQkIvLzhEY1VFa1RRUkFRb0dXZ0lDQUFpQUFyWWluUVFGeER3dEJBQXNFQUVFTkN6Z0FBa0FnQVVHQkFVY0VRQ0FCUVJkSERRRWdBQ0FDRURZMkFvQUJRUUVQQ3lBQUlBSVFOallDaEFGQkFROExJQUFnQVNBQ0VOa0NDeVlBSUFGQkFtc2lBRUgvL3dOeFFTUk5CRUJDZzVhQWdJQUNJQUN0aUtkQkFYRVBDMEVBQ3dRQVFRTUxMd0VDZjBIOEFSQW5FTFVESWdJaUFTQUFLQUtBQVRZQ2dBRWdBU0FBS0FLRUFUWUNoQUVnQVNBQUVOb0NJQUlMZFFBQ1FBSkFBa0FDUUFKQUlBRkJvUUZyRGdRQkFnTUFCQXNnQUNBQ0VJa0JPZ0NvQVVFQkR3c2dBQ0FDRURDMk9BS3dBVUVCRHdzZ0FDQUNFREMyT0FLMEFVRUJEd3NnQUNBQ0VEQzJPQUs0QVVFQkR3c2dBVUVmUndSQUlBQWdBU0FDRU9jQ0R3c2dBQ0FDRURDMk9BS3NBVUVCQ3lZQUlBRkJBbXNpQUVILy93TnhRU1JOQkVCQ29jNkFnSUFDSUFDdGlLZEJBWEVQQzBFQUN3UUFRUWNMVXdFQ2YwRzhBeEFuRUxjRElnSWlBU0FBTFFDb0FUb0FxQUVnQVNBQUtnS3NBVGdDckFFZ0FTQUFLZ0t3QVRnQ3NBRWdBU0FBS2dLMEFUZ0N0QUVnQVNBQUtnSzRBVGdDdUFFZ0FTQUFFUFVCSUFJTEtBQWdBVUVDYXlJQVFmLy9BM0ZCTVUwRVFFS0J6b0NBZ0lLQUFTQUFyWWluUVFGeER3dEJBQXNFQUVFekN4VUJBWDlCdkFFUUp4Q1RBaUlCSUFBUWdnVWdBUXNtQUNBQlFRSnJJZ0JCLy84RGNVRWtUUVJBUW9HT2dJQ0FBaUFBcllpblFRRnhEd3RCQUFzRUFFRU1DeUVBSUFGQklFWUVRQ0FBSUFJUWlRRTZBSmdCUVFFUEN5QUFJQUVnQWhEa0Fnc21BQ0FCUVFKcklnQkIvLzhEY1VFa1RRUkFRb0dPZ1lDQUFpQUFyWWluUVFGeER3dEJBQXNFQUVFUUN5d0JBbjlCcEFFUUowRUFRYVFCRURNaUFSQ0VCU0VDSUFFZ0FDMEFtQUU2QUpnQklBRWdBQkNqQlNBQ0N5SUJBWDRnQVNBQ3JTQURyVUlnaG9RZ0JDQUFFU0FBSWdWQ0lJaW5FQllnQmFjTEF3QUFDd2NBSUFBcUFud0wxQUlCQjM4akFFRWdheUlESkFBZ0F5QUFLQUljSWdRMkFoQWdBQ2dDRkNFRklBTWdBallDSENBRElBRTJBaGdnQXlBRklBUnJJZ0UyQWhRZ0FTQUNhaUVFUVFJaEJ5QURRUkJxSVFFQ2Z3SkFBa0FnQUNnQ1BDQURRUkJxUVFJZ0EwRU1haEFPRU9JQ1JRUkFBMEFnQkNBREtBSU1JZ1ZHRFFJZ0JVRi9UQTBESUFFZ0JTQUJLQUlFSWdoTElnWkJBM1JxSWdrZ0JTQUlRUUFnQmh0cklnZ2dDU2dDQUdvMkFnQWdBVUVNUVFRZ0JodHFJZ2tnQ1NnQ0FDQUlhellDQUNBRUlBVnJJUVFnQUNnQ1BDQUJRUWhxSUFFZ0Joc2lBU0FISUFacklnY2dBMEVNYWhBT0VPSUNSUTBBQ3dzZ0JFRi9SdzBCQ3lBQUlBQW9BaXdpQVRZQ0hDQUFJQUUyQWhRZ0FDQUJJQUFvQWpCcU5nSVFJQUlNQVFzZ0FFRUFOZ0ljSUFCQ0FEY0RFQ0FBSUFBb0FnQkJJSEkyQWdCQkFDQUhRUUpHRFFBYUlBSWdBU2dDQkdzTElRUWdBMEVnYWlRQUlBUUxRZ0VCZnlNQVFSQnJJZ01rQUNBQUtBSThJQUduSUFGQ0lJaW5JQUpCL3dGeElBTkJDR29RRlJEaUFpRUFJQU1wQXdnaEFTQURRUkJxSkFCQ2Z5QUJJQUFiQ3drQUlBQW9BandRR0F1UEJRSUdmZ0YvSUFFZ0FTZ0NBRUVQYWtGd2NTSUJRUkJxTmdJQUlBQUNmQ0FCS1FNQUlRUWdBU2tEQ0NFRkl3QkJJR3NpQUNRQUFrQWdCVUwvLy8vLy8vLy8vLzhBZ3lJRFFvQ0FnSUNBZ01DQVBIMGdBMEtBZ0lDQWdJREEvOE1BZlZRRVFDQUZRZ1NHSUFSQ1BJaUVJUU1nQkVMLy8vLy8vLy8vL3crRElnUkNnWUNBZ0lDQWdJQUlXZ1JBSUFOQ2dZQ0FnSUNBZ0lEQUFId2hBZ3dDQ3lBRFFvQ0FnSUNBZ0lDQVFIMGhBaUFFUW9DQWdJQ0FnSUNBQ0lWQ0FGSU5BU0FDSUFOQ0FZTjhJUUlNQVFzZ0JGQWdBMEtBZ0lDQWdJREEvLzhBVkNBRFFvQ0FnSUNBZ01ELy93QlJHMFVFUUNBRlFnU0dJQVJDUElpRVF2Ly8vLy8vLy84RGcwS0FnSUNBZ0lDQS9QOEFoQ0VDREFFTFFvQ0FnSUNBZ0lENC93QWhBaUFEUXYvLy8vLy8vNy8vd3dCV0RRQkNBQ0VDSUFOQ01JaW5JZ0ZCa2ZjQVNRMEFJQVFoQWlBRlF2Ly8vLy8vL3orRFFvQ0FnSUNBZ01BQWhDSURJUVlDUUNBQlFZSDNBR3NpQ0VIQUFIRUVRQ0FDSUFoQlFHcXRoaUVHUWdBaEFnd0JDeUFJUlEwQUlBWWdDSzBpQjRZZ0FrSEFBQ0FJYTYySWhDRUdJQUlnQjRZaEFnc2dBQ0FDTndNUUlBQWdCamNER0FKQVFZSDRBQ0FCYXlJQlFjQUFjUVJBSUFNZ0FVRkFhcTJJSVFSQ0FDRUREQUVMSUFGRkRRQWdBMEhBQUNBQmE2MkdJQVFnQWEwaUFvaUVJUVFnQXlBQ2lDRURDeUFBSUFRM0F3QWdBQ0FETndNSUlBQXBBd2hDQklZZ0FDa0RBQ0lFUWp5SWhDRUNJQUFwQXhBZ0FDa0RHSVJDQUZLdElBUkMvLy8vLy8vLy8vOFBnNFFpQkVLQmdJQ0FnSUNBZ0FoYUJFQWdBa0lCZkNFQ0RBRUxJQVJDZ0lDQWdJQ0FnSUFJaFVJQVVnMEFJQUpDQVlNZ0Fud2hBZ3NnQUVFZ2FpUUFJQUlnQlVLQWdJQ0FnSUNBZ0lCL2c0Uy9DemtEQUF1b0Z3TVNmd0orQVh3akFFR3dCR3NpQ1NRQUlBbEJBRFlDTEFKL0lBRzlJaGhDZjFjRVFFRUJJUklnQVpvaUFiMGhHRUhndGdFTUFRdEJBU0VTUWVPMkFTQUVRWUFRY1EwQUdrSG10Z0VnQkVFQmNRMEFHa0VBSVJKQkFTRVRRZUcyQVFzaEZBSkFJQmhDZ0lDQWdJQ0FnUGovQUlOQ2dJQ0FnSUNBZ1BqL0FGRUVRQ0FBUVNBZ0FpQVNRUU5xSWcwZ0JFSC8vM3R4RUZrZ0FDQVVJQklRVHlBQVFmdTJBVUgvdGdFZ0JVRWdjU0lERzBIenRnRkI5N1lCSUFNYklBRWdBV0liUVFNUVR3d0JDeUFKUVJCcUlROENRQUovQWtBZ0FTQUpRU3hxRUpJRklnRWdBYUFpQVVRQUFBQUFBQUFBQUdJRVFDQUpJQWtvQWl3aUJrRUJhellDTENBRlFTQnlJaFZCNFFCSERRRU1Bd3NnQlVFZ2NpSVZRZUVBUmcwQ0lBa29BaXdoQzBFR0lBTWdBMEVBU0JzTUFRc2dDU0FHUVIxcklnczJBaXdnQVVRQUFBQUFBQUN3UWFJaEFVRUdJQU1nQTBFQVNCc0xJUW9nQ1VFd2FpQUpRZEFDYWlBTFFRQklHeUlPSVFnRFFDQUlBbjhnQVVRQUFBQUFBQUR3UVdNZ0FVUUFBQUFBQUFBQUFHWnhCRUFnQWFzTUFRdEJBQXNpQXpZQ0FDQUlRUVJxSVFnZ0FTQUR1S0ZFQUFBQUFHWE56VUdpSWdGRUFBQUFBQUFBQUFCaURRQUxBa0FnQzBFQlNBUkFJQXNoQXlBSUlRWWdEaUVIREFFTElBNGhCeUFMSVFNRFFDQURRUjBnQTBFZFNCc2hEQUpBSUFoQkJHc2lCaUFIU1EwQUlBeXRJUmxDQUNFWUEwQWdCaUFHTlFJQUlCbUdJQmg4SWhnZ0dFS0FsT3ZjQTRBaUdFS0FsT3ZjQTM1OVBnSUFJQWNnQmtFRWF5SUdUUVJBSUJoQy8vLy8vdytESVJnTUFRc0xJQmluSWdORkRRQWdCMEVFYXlJSElBTTJBZ0FMQTBBZ0J5QUlJZ1pKQkVBZ0JrRUVheUlJS0FJQVJRMEJDd3NnQ1NBSktBSXNJQXhySWdNMkFpd2dCaUVJSUFOQkFFb05BQXNMSUFwQkdXcEJDVzBoQ0NBRFFYOU1CRUFnQ0VFQmFpRVJJQlZCNWdCR0lRMERRRUVKUVFBZ0Eyc2dBMEYzU0JzaEZnSkFJQVlnQjBzRVFFR0FsT3ZjQXlBV2RpRVhRWDhnRm5SQmYzTWhFRUVBSVFNZ0J5RUlBMEFnQ0NBRElBZ29BZ0FpRENBV2RtbzJBZ0FnRENBUWNTQVhiQ0VESUFoQkJHb2lDQ0FHU1EwQUN5QUhJQWRCQkdvZ0J5Z0NBQnNoQnlBRFJRMEJJQVlnQXpZQ0FDQUdRUVJxSVFZTUFRc2dCeUFIUVFScUlBY29BZ0FiSVFjTElBa2dDU2dDTENBV2FpSUROZ0lzSUE0Z0J5QU5HeUlJSUJGQkFuUnFJQVlnQmlBSWEwRUNkU0FSU2hzaEJpQURRUUJJRFFBTEMwRUFJUWdDUUNBR0lBZE5EUUFnRGlBSGEwRUNkVUVKYkNFSUlBY29BZ0FpREVFS1NRMEFRZVFBSVFNRFFDQUlRUUZxSVFnZ0F5QU1TdzBCSUFOQkNtd2hBd3dBQ3dBTElBcEJBQ0FJSUJWQjVnQkdHMnNnRlVIbkFFWWdDa0VBUjNGcklnTWdCaUFPYTBFQ2RVRUpiRUVKYTBnRVFDQURRWURJQUdvaUVFRUpiU0lNUVFKMElBbEJNR3BCQkhJZ0NVSFVBbW9nQzBFQVNCdHFRWUFnYXlFTlFRb2hBd0pBSUJBZ0RFRUpiR3NpREVFSFNnMEFRZVFBSVFNRFFDQU1RUUZxSWd4QkNFWU5BU0FEUVFwc0lRTU1BQXNBQ3dKQUlBMG9BZ0FpRENBTUlBTnVJaEVnQTJ4ckloQkZRUUFnRFVFRWFpSUxJQVpHR3cwQVJBQUFBQUFBQU9BL1JBQUFBQUFBQVBBL1JBQUFBQUFBQVBnL0lBWWdDMFliUkFBQUFBQUFBUGcvSUJBZ0EwRUJkaUlMUmhzZ0N5QVFTeHNoR2tRQkFBQUFBQUJBUTBRQUFBQUFBQUJBUXlBUlFRRnhHeUVCQWtBZ0V3MEFJQlF0QUFCQkxVY05BQ0FhbWlFYUlBR2FJUUVMSUEwZ0RDQVFheUlMTmdJQUlBRWdHcUFnQVdFTkFDQU5JQU1nQzJvaUF6WUNBQ0FEUVlDVTY5d0RUd1JBQTBBZ0RVRUFOZ0lBSUFjZ0RVRUVheUlOU3dSQUlBZEJCR3NpQjBFQU5nSUFDeUFOSUEwb0FnQkJBV29pQXpZQ0FDQURRZitUNjl3RFN3MEFDd3NnRGlBSGEwRUNkVUVKYkNFSUlBY29BZ0FpQzBFS1NRMEFRZVFBSVFNRFFDQUlRUUZxSVFnZ0F5QUxTdzBCSUFOQkNtd2hBd3dBQ3dBTElBMUJCR29pQXlBR0lBTWdCa2tiSVFZTEEwQWdCaUlMSUFkTklneEZCRUFnQzBFRWF5SUdLQUlBUlEwQkN3c0NRQ0FWUWVjQVJ3UkFJQVJCQ0hFaEV3d0JDeUFJUVg5elFYOGdDa0VCSUFvYklnWWdDRW9nQ0VGN1NuRWlBeHNnQm1vaENrRi9RWDRnQXhzZ0JXb2hCU0FFUVFoeEloTU5BRUYzSVFZQ1FDQU1EUUFnQzBFRWF5Z0NBQ0lEUlEwQVFRQWhCaUFEUVFwd0RRQkJBQ0VNUWVRQUlRWURRQ0FESUFad1JRUkFJQXhCQVdvaERDQUdRUXBzSVFZTUFRc0xJQXhCZjNNaEJnc2dDeUFPYTBFQ2RVRUpiQ0VESUFWQlgzRkJ4Z0JHQkVCQkFDRVRJQW9nQXlBR2FrRUpheUlEUVFBZ0EwRUFTaHNpQXlBRElBcEtHeUVLREFFTFFRQWhFeUFLSUFNZ0NHb2dCbXBCQ1dzaUEwRUFJQU5CQUVvYklnTWdBeUFLU2hzaENnc2dDaUFUY2lJWFFRQkhJUkFnQUVFZ0lBSUNmeUFJUVFBZ0NFRUFTaHNnQlVGZmNTSU1RY1lBUmcwQUdpQVBJQWdnQ0VFZmRTSURhaUFEYzYwZ0R4Q3JBU0lHYTBFQlRBUkFBMEFnQmtFQmF5SUdRVEE2QUFBZ0R5QUdhMEVDU0EwQUN3c2dCa0VDYXlJUklBVTZBQUFnQmtFQmEwRXRRU3NnQ0VFQVNCczZBQUFnRHlBUmF3c2dDaUFTYWlBUWFtcEJBV29pRFNBRUVGa2dBQ0FVSUJJUVR5QUFRVEFnQWlBTklBUkJnSUFFY3hCWkFrQUNRQUpBSUF4QnhnQkdCRUFnQ1VFUWFrRUljaUVESUFsQkVHcEJDWEloQ0NBT0lBY2dCeUFPU3hzaUJTRUhBMEFnQnpVQ0FDQUlFS3NCSVFZQ1FDQUZJQWRIQkVBZ0JpQUpRUkJxVFEwQkEwQWdCa0VCYXlJR1FUQTZBQUFnQmlBSlFSQnFTdzBBQ3d3QkN5QUdJQWhIRFFBZ0NVRXdPZ0FZSUFNaEJnc2dBQ0FHSUFnZ0Jtc1FUeUFIUVFScUlnY2dEazBOQUFzZ0Z3UkFJQUJCZzdjQlFRRVFUd3NnQ2tFQlNDQUhJQXRQY2cwQkEwQWdCelVDQUNBSUVLc0JJZ1lnQ1VFUWFrc0VRQU5BSUFaQkFXc2lCa0V3T2dBQUlBWWdDVUVRYWtzTkFBc0xJQUFnQmlBS1FRa2dDa0VKU0JzUVR5QUtRUWxySVFZZ0IwRUVhaUlISUF0UERRTWdDa0VKU2lFRElBWWhDaUFERFFBTERBSUxBa0FnQ2tFQVNBMEFJQXNnQjBFRWFpQUhJQXRKR3lFRklBbEJFR3BCQ1hJaEN5QUpRUkJxUVFoeUlRTWdCeUVJQTBBZ0N5QUlOUUlBSUFzUXF3RWlCa1lFUUNBSlFUQTZBQmdnQXlFR0N3SkFJQWNnQ0VjRVFDQUdJQWxCRUdwTkRRRURRQ0FHUVFGcklnWkJNRG9BQUNBR0lBbEJFR3BMRFFBTERBRUxJQUFnQmtFQkVFOGdCa0VCYWlFR0lCTkZRUUFnQ2tFQlNCc05BQ0FBUVlPM0FVRUJFRThMSUFBZ0JpQUxJQVpySWdZZ0NpQUdJQXBJR3hCUElBb2dCbXNoQ2lBSVFRUnFJZ2dnQlU4TkFTQUtRWDlLRFFBTEN5QUFRVEFnQ2tFU2FrRVNRUUFRV1NBQUlCRWdEeUFSYXhCUERBSUxJQW9oQmdzZ0FFRXdJQVpCQ1dwQkNVRUFFRmtMREFFTElCUkJDV29nRkNBRlFTQnhJZ3NiSVFvQ1FDQURRUXRMRFFCQkRDQURheUlHUlEwQVJBQUFBQUFBQUNCQUlSb0RRQ0FhUkFBQUFBQUFBREJBb2lFYUlBWkJBV3NpQmcwQUN5QUtMUUFBUVMxR0JFQWdHaUFCbWlBYW9hQ2FJUUVNQVFzZ0FTQWFvQ0Fhb1NFQkN5QVBJQWtvQWl3aUJpQUdRUjkxSWdacUlBWnpyU0FQRUtzQklnWkdCRUFnQ1VFd09nQVBJQWxCRDJvaEJnc2dFa0VDY2lFT0lBa29BaXdoQ0NBR1FRSnJJZ3dnQlVFUGFqb0FBQ0FHUVFGclFTMUJLeUFJUVFCSUd6b0FBQ0FFUVFoeElRZ2dDVUVRYWlFSEEwQWdCeUlGQW44Z0FabEVBQUFBQUFBQTRFRmpCRUFnQWFvTUFRdEJnSUNBZ0hnTElnWkIwTFlCYWkwQUFDQUxjam9BQUNBRlFRRnFJZ2NnQ1VFUWFtdEJBVWNnQ0NBRFFRQktja1ZCQUNBQklBYTNvVVFBQUFBQUFBQXdRS0lpQVVRQUFBQUFBQUFBQUdFYmNrVUVRQ0FGUVM0NkFBRWdCVUVDYWlFSEN5QUJSQUFBQUFBQUFBQUFZZzBBQ3lBQVFTQWdBaUFPSUE4Z0NVRVFhaUFNYW1zZ0Iyb2dBeUFQYWlBTWEwRUNhaUFEUlNBSElBbHJRUkpySUFOT2Noc2lBMm9pRFNBRUVGa2dBQ0FLSUE0UVR5QUFRVEFnQWlBTklBUkJnSUFFY3hCWklBQWdDVUVRYWlBSElBbEJFR3BySWdVUVR5QUFRVEFnQXlBRklBOGdER3NpQTJwclFRQkJBQkJaSUFBZ0RDQURFRThMSUFCQklDQUNJQTBnQkVHQXdBQnpFRmtnQ1VHd0JHb2tBQ0FDSUEwZ0FpQU5TaHNMTXdFQmZ5QUFLQUlVSWdNZ0FTQUNJQUFvQWhBZ0Eyc2lBU0FCSUFKTEd5SUJFR1lhSUFBZ0FDZ0NGQ0FCYWpZQ0ZDQUNDeWNCQVg4akFFRVFheUlCSkFBZ0FTQUFOZ0lNSUFFb0Fnd2hBQkNkQlNBQlFSQnFKQUFnQUFzbUFDQUJRUUpySWdCQi8vOERjVUVrVFFSQVFvWE9nSUNBQWlBQXJZaW5RUUZ4RHd0QkFBdjZBUUVFZnlNQVFmQUFheUlDSkFBZ0FpQUFOZ0pzSUFJZ0FpZ0NiRFlDQUNNQVFSQnJJZ01rQUNBRElBSTJBZ3dqQUVHZ0FXc2lBQ1FBSUFCQkNHcEIwTEVCUVpBQkVHWWFJQUFnQWtFUWFpSUJOZ0kwSUFBZ0FUWUNIQ0FBUVg0Z0FXc2lCRUgvLy8vL0J5QUVRZi8vLy84SFNSc2lCRFlDT0NBQUlBRWdCR29pQVRZQ0pDQUFJQUUyQWhnZ0FFRUlha0dTbFFFZ0FrSHNDRUh0Q0JDUkJTQUVCRUFnQUNnQ0hDSUJJQUVnQUNnQ0dFWnJRUUE2QUFBTElBQkJvQUZxSkFBZ0EwRVFhaVFBQW45QkFDQUNRUkJxSWdBUWhRVkJBV29pQVJEekFTSURSUTBBR2lBRElBQWdBUkJtQ3lFQUlBSkI4QUJxSkFBZ0FBc3ZBUUYvSXdCQkVHc2lBeVFBSUFNZ0FTQUNJQUFvQWdBUkJRQWdBeENmQlNFQUlBTVFieUFEUVJCcUpBQWdBQXNFQUVFRUN6a0JBWDhnQUNnQ0JDSUVRUUYxSUFGcUlRRWdBQ2dDQUNFQUlBRWdBaUFESUFSQkFYRUVmeUFCS0FJQUlBQnFLQUlBQlNBQUN4RVVBQXMzQVFGL0lBQW9BZ1FpQTBFQmRTQUJhaUVCSUFBb0FnQWhBQ0FCSUFJZ0EwRUJjUVIvSUFFb0FnQWdBR29vQWdBRklBQUxFUmtBQ3pzQkFYOGdBQ2dDQkNJRlFRRjFJQUZxSVFFZ0FDZ0NBQ0VBSUFFZ0FpQURJQVFnQlVFQmNRUi9JQUVvQWdBZ0FHb29BZ0FGSUFBTEVSWUFDemNCQVg4Z0FDZ0NCQ0lEUVFGMUlBRnFJUUVnQUNnQ0FDRUFJQUVnQWlBRFFRRnhCSDhnQVNnQ0FDQUFhaWdDQUFVZ0FBc1JIZ0FMREFBZ0FCQ2hCUm9nQUJBdUN3c0FJQUJCb29FQkVJZ0JDOFlCQVFOL0l3QkJFR3NpQXlRQUlBTWdBamdDQ0NBRElBRTJBZ3dnQUNnQ0NDRUFJd0JCRUdzaUFTUUFBbjhDUUVHUXdBRXRBQUJCQVhFTkFFR1F3QUVRVTBVTkFDTUFRUkJySWdRa0FFRURRZlNSQVJBRElRVWdCRUVRYWlRQVFZekFBU0FGTmdJQVFaREFBUkJTQzBHTXdBRW9BZ0FMSUFCQm1vRUJBbjhqQUVFUWF5SUFKQUFnQUNBQk5nSU1JQUJCREdvZ0EwRU1haWdDQUJCM0lBQkJER29nQTBFSWFpb0NBQkJjSUFCQkVHb2tBQ0FCQ3hBRUlBRkJFR29rQUNBRFFSQnFKQUFMU2dFQmZ5TUFRUkJySWdVa0FDQUZJQUk0QWdnZ0JTQUJPQUlNSUFVZ0F6Z0NCQ0FGSUFRNEFnQWdBRUdMZ1FFZ0JVRU1haUFGUVFocUlBVkJCR29nQlJDaUJTQUZRUkJxSkFBTFNnRUJmeU1BUVJCcklnVWtBQ0FGSUFJNEFnZ2dCU0FCT0FJTUlBVWdBemdDQkNBRklBUTRBZ0FnQUVIOGdBRWdCVUVNYWlBRlFRaHFJQVZCQkdvZ0JSQ2lCU0FGUVJCcUpBQUxrZ0VCQTM4akFFRVFheUlDSkFBZ0FpQUJOZ0lNSUFBb0FnZ2hBU01BUVJCcklnQWtBQUovQWtCQmdNQUJMUUFBUVFGeERRQkJnTUFCRUZORkRRQWpBRUVRYXlJREpBQkJBa0hRa1FFUUF5RUVJQU5CRUdva0FFSDh2d0VnQkRZQ0FFR0F3QUVRVWd0Qi9MOEJLQUlBQ3lBQlFmS0FBU0FBUVFocUlBSkJER29RcmdFUUJDQUFRUkJxSkFBZ0FrRVFhaVFBQzVJQkFRTi9Jd0JCRUdzaUFpUUFJQUlnQVRZQ0RDQUFLQUlJSVFFakFFRVFheUlBSkFBQ2Z3SkFRZmkvQVMwQUFFRUJjUTBBUWZpL0FSQlRSUTBBSXdCQkVHc2lBeVFBUVFKQnlKRUJFQU1oQkNBRFFSQnFKQUJCOUw4QklBUTJBZ0JCK0w4QkVGSUxRZlMvQVNnQ0FBc2dBVUh1Z0FFZ0FFRUlhaUFDUVF4cUVLNEJFQVFnQUVFUWFpUUFJQUpCRUdva0FBdVNBUUVEZnlNQVFSQnJJZ0lrQUNBQ0lBRTJBZ3dnQUNnQ0NDRUJJd0JCRUdzaUFDUUFBbjhDUUVId3Z3RXRBQUJCQVhFTkFFSHd2d0VRVTBVTkFDTUFRUkJySWdNa0FFRUNRY0NSQVJBRElRUWdBMEVRYWlRQVFleS9BU0FFTmdJQVFmQy9BUkJTQzBIc3Z3RW9BZ0FMSUFGQjZZQUJJQUJCQ0dvZ0FrRU1haEN1QVJBRUlBQkJFR29rQUNBQ1FSQnFKQUFMdFFFQkJIOGpBRUVRYXlJQ0pBQWdBaUFCT0FJTUlBQW9BZ2doQUNNQVFSQnJJZ1FrQUFKL0FrQkI2TDhCTFFBQVFRRnhEUUJCNkw4QkVGTkZEUUFqQUVFUWF5SURKQUJCQWtHNGtRRVFBeUVGSUFOQkVHb2tBRUhrdndFZ0JUWUNBRUhvdndFUVVndEI1TDhCS0FJQUN5QUFRZCtBQVFKL0l3QkJFR3NpQUNRQUlBQWdCRUVJYWlJRE5nSU1JQUJCREdvZ0FrRU1haW9DQUJCY0lBQkJFR29rQUNBREN4QUVJQVJCRUdva0FDQUNRUkJxSkFBTHRRRUJBMzhqQUVFUWF5SUNKQUFnQWlBQk5nSU1JQUFvQWdnaEFDTUFRUkJySWdFa0FBSi9Ba0JCNEw4QkxRQUFRUUZ4RFFCQjRMOEJFRk5GRFFBakFFRVFheUlESkFCQkFrR3drUUVRQXlFRUlBTkJFR29rQUVIY3Z3RWdCRFlDQUVIZ3Z3RVFVZ3RCM0w4QktBSUFDeUFBUWJ5QUFRSi9Jd0JCRUdzaUFDUUFJQUFnQVVFSWFpSUROZ0lNSUFCQkRHb2dBa0VNYWlnQ0FCQjNJQUJCRUdva0FDQURDeEFFSUFGQkVHb2tBQ0FDUVJCcUpBQUxrZ0VCQTM4akFFRVFheUlDSkFBZ0FpQUJOZ0lNSUFBb0FnZ2hBU01BUVJCcklnQWtBQUovQWtCQjJMOEJMUUFBUVFGeERRQkIyTDhCRUZORkRRQWpBRUVRYXlJREpBQkJBa0dva1FFUUF5RUVJQU5CRUdva0FFSFV2d0VnQkRZQ0FFSFl2d0VRVWd0QjFMOEJLQUlBQ3lBQlFkbUFBU0FBUVFocUlBSkJER29RcmdFUUJDQUFRUkJxSkFBZ0FrRVFhaVFBQ3owQkFYOGdBQ2dDQkNJR1FRRjFJQUZxSVFFZ0FDZ0NBQ0VBSUFFZ0FpQURJQVFnQlNBR1FRRnhCSDhnQVNnQ0FDQUFhaWdDQUFVZ0FBc1JFUUFMTndFQmZ5QUFLQUlFSWdOQkFYVWdBV29oQVNBQUtBSUFJUUFnQVNBQ0lBTkJBWEVFZnlBQktBSUFJQUJxS0FJQUJTQUFDeEVJQUF1OEFRRURmeU1BUVJCcklnTWtBQ0FESUFFMkFnd2dBQ2dDQ0NFQUl3QkJFR3NpQVNRQUFuOENRRUhFdndFdEFBQkJBWEVOQUVIRXZ3RVFVMFVOQUNNQVFSQnJJZ1FrQUVFRFFjeU9BUkFESVFVZ0JFRVFhaVFBUWNDL0FTQUZOZ0lBUWNTL0FSQlNDMEhBdndFb0FnQUxJQUJCanY0QUFuOGpBRUVRYXlJQUpBQWdBQ0FCTmdJTUlBQkJER29nQTBFTWFpZ0NBQkIzSUFCQkRHb2dBaENvQlJCM0lBQkJFR29rQUNBQkN4QUVJQUZCRUdva0FDQURRUkJxSkFBTEN3QWdBRUcxL2dBUWlBRUxuZ0lCQkg4akFFRWdheUlISkFBZ0J5QUNPQUlZSUFjZ0FUZ0NIQ0FISUFNNEFoUWdCeUFFT0FJUUlBY2dCVGdDRENBSElBWTRBZ2dnQUNnQ0NDRUFJd0JCTUdzaUNDUUFBbjhDUUVHOHZ3RXRBQUJCQVhFTkFFRzh2d0VRVTBVTkFDTUFRUkJySWdra0FFRUhRYkNPQVJBRElRb2dDVUVRYWlRQVFiaS9BU0FLTmdJQVFieS9BUkJTQzBHNHZ3RW9BZ0FMSUFCQnJmNEFBbjhqQUVFUWF5SUFKQUFnQUNBSU5nSU1JQUJCREdvZ0IwRWNhaW9DQUJCY0lBQkJER29nQjBFWWFpb0NBQkJjSUFCQkRHb2dCMEVVYWlvQ0FCQmNJQUJCREdvZ0IwRVFhaW9DQUJCY0lBQkJER29nQjBFTWFpb0NBQkJjSUFCQkRHb2dCMEVJYWlvQ0FCQmNJQUJCRUdva0FDQUlDeEFFSUFoQk1Hb2tBQ0FIUVNCcUpBQUxOUUVCZnlNQVFSQnJJZ01rQUNBRElBSTRBZ2dnQXlBQk9BSU1JQUJCcHY0QUlBTkJER29nQTBFSWFoQ2xCU0FEUVJCcUpBQUxOUUVCZnlNQVFSQnJJZ01rQUNBRElBSTRBZ2dnQXlBQk9BSU1JQUJCbi80QUlBTkJER29nQTBFSWFoQ2xCU0FEUVJCcUpBQUxIZ0FnQUNBQklBRW9BZ0FvQWlRUkFBQWdBaUFBS0FJQUtBSW9FUVVBQzVJQkFRTi9Jd0JCRUdzaUFpUUFJQUlnQVRZQ0RDQUFLQUlJSVFFakFFRVFheUlBSkFBQ2Z3SkFRYXkvQVMwQUFFRUJjUTBBUWF5L0FSQlRSUTBBSXdCQkVHc2lBeVFBUVFKQm1JNEJFQU1oQkNBRFFSQnFKQUJCcUw4QklBUTJBZ0JCckw4QkVGSUxRYWkvQVNnQ0FBc2dBVUdXL2dBZ0FFRUlhaUFDUVF4cUVLNEJFQVFnQUVFUWFpUUFJQUpCRUdva0FBc0xBQ0FBUVlqK0FCQ0lBUXNNQUNBQUVLWUZHaUFBRUM0TFFRRUJmeUFBS0FJRUlnaEJBWFVnQVdvaEFTQUFLQUlBSVFBZ0FTQUNJQU1nQkNBRklBWWdCeUFJUVFGeEJIOGdBU2dDQUNBQWFpZ0NBQVVnQUFzUkNRQUxPUUVCZnlBQUtBSUVJZ1JCQVhVZ0FXb2hBU0FBS0FJQUlRQWdBU0FDSUFNZ0JFRUJjUVIvSUFFb0FnQWdBR29vQWdBRklBQUxFUWNBQ3hVQkFYOUJxQVFRSnhEb0F5SUJJQUFROVFFZ0FRc2pBQ0FCUVFwclFmLy9BM0VpQUVFZVRRUkFRWU9BZ0lBSElBQjJRUUZ4RHd0QkFBdVNBUUVEZnlNQVFSQnJJZ0lrQUNBQ0lBRTJBZ3dnQUNnQ0NDRUJJd0JCRUdzaUFDUUFBbjhDUUVHY3Z3RXRBQUJCQVhFTkFFR2N2d0VRVTBVTkFDTUFRUkJySWdNa0FFRUNRZGlMQVJBRElRUWdBMEVRYWlRQVFaaS9BU0FFTmdJQVFaeS9BUkJTQzBHWXZ3RW9BZ0FMSUFGQjN2MEFJQUJCQ0dvZ0FrRU1haEN1QVJBRUlBQkJFR29rQUNBQ1FSQnFKQUFMeGdFQkFuOGpBRUVRYXlJREpBQWdBeUFDTmdJSUlBTWdBVFlDRENBQUtBSUlJUUFqQUVFUWF5SUJKQUFDZndKQVFaUy9BUzBBQUVFQmNRMEFRWlMvQVJCVFJRMEFJd0JCRUdzaUFpUUFRUU5CeklzQkVBTWhCQ0FDUVJCcUpBQkJrTDhCSUFRMkFnQkJsTDhCRUZJTFFaQy9BU2dDQUFzZ0FFSFYvUUFDZnlNQVFSQnJJZ0FrQUNBQUlBRTJBZ3dnQUVFTWFpQURRUXhxS0FJQUVIY2dBRUVNYWlBRFFRaHFLQUlBRUhjZ0FFRVFhaVFBSUFFTEVBUWdBVUVRYWlRQUlBTkJFR29rQUF1YkFRRURmeUFBS0FJSUlRQWpBRUVRYXlJREpBQUNmd0pBUVl5L0FTMEFBRUVCY1EwQVFZeS9BUkJUUlEwQUl3QkJFR3NpQWlRQVFRSkJ4SXNCRUFNaEJDQUNRUkJxSkFCQmlMOEJJQVEyQWdCQmpMOEJFRklMUVlpL0FTZ0NBQXNnQUVITC9RQUNmeU1BUVJCcklnQWtBQ0FBSUFOQkNHb2lBallDRENBQVFReHFJQUVRcUFVUWR5QUFRUkJxSkFBZ0Fnc1FCQ0FEUVJCcUpBQUxDd0FnQUVIRC9RQVFpQUVMQ3dBZ0FFRysvUUFRaUFFTERBQWdBQkNwQlJvZ0FCQXVDemtBQWtBQ1FBSkFJQUZCMGdCckRnSUFBUUlMSUFBZ0FoQXd0amdDVUVFQkR3c2dBQ0FDRURDMk9BSlVRUUVQQ3lBQUlBRWdBaEN4QVFzOUFRRi9JQUFvQWdRaUJrRUJkU0FCYWlFQklBQW9BZ0FoQUNBQklBSWdBeUFFSUFVZ0JrRUJjUVIvSUFFb0FnQWdBR29vQWdBRklBQUxFUThBQ3lJQUlBRkJDbXRCLy84RGNTSUFRUnBOQkVCQms0Q0FNQ0FBZGtFQmNROExRUUFMRHdBZ0FTQUFLQUlBYWlBQ09BSUFDdzBBSUFFZ0FDZ0NBR29xQWdBTEdBRUJmMEVRRUNjaUFFSUFOd0lBSUFCQ0FEY0NDQ0FBQ3dRQVFTTUxCZ0FnQUJBM0N3WUFRZjIrQVFzR0FFSEZ3QUVMQmdCQnc4QUJDemNCQVg4Z0FTQUFLQUlFSWdOQkFYVnFJUUVnQUNnQ0FDRUFJQUVnQWlBRFFRRnhCSDhnQVNnQ0FDQUFhaWdDQUFVZ0FBc1JBd0FMQmdCQndjQUJDdzhBSUFCQkFDQUFFTjhCUVRwR0d3c1BBQ0FBUVFBZ0FCRGZBVUU0UmhzTER3QWdBRUVBSUFBUTN3RkJPMFliQ3djQUlBQXZBUUFMVVFFQ2Z5TUFRUkJySWdJa0FDQUFLQUlBSVFNZ0FpQUJJQUFvQWdRaUFFRUJkV29pQVNBQVFRRnhCSDhnQVNnQ0FDQURhaWdDQUFVZ0F3c1JBQUE3QVE0Z0FpOEJEaUVBSUFKQkVHb2tBQ0FBQ3dZQVFidkFBUXZOQVFFQ2Z3SkFBa0FDZndOQUFrQUNRQ0FCS0FJUUlBTkxCSDhnQVNnQ0ZDQURRU3hzYWkwQUlFVU5BaUFDSUFSSERRRUNmMEVBSUFFb0FoUWdBMEVzYkdvb0FnZ2lBVVVOQUJvZ0FTZ0NCQXNGUVFBTERBTUxJQVJCQVdvaEJBc2dBMEVCYWlFRERBQUxBQXNpQVVVTkFBSkFBa0FDUUFKQUlBRWdBU2dDQUNnQ0NCRUFBRUU5YXc0RUFBTUJBZ1FMSUFBZ0FTZ0NGQkE5RUl3RkRBUUxJQUJCekpRQkVKY0JEQU1MSUFCQjBwUUJFSmNCREFJTElBQkIxNVFCRUpjQkRBRUxJQUJCMjVRQkVKY0JDd3VZQkFJRmZ3RitRUmdRSnlFRElBQW9BZ0FoQkVFQUlRQWdBMEVBT2dBRUlBTWdCRFlDQUNBRElBUVE3QUVpQVRZQ0NDQURRWDhnQVVFQ2RDQUJJQUZCLy8vLy93TnhSeHNRSnpZQ0RBTi9JQUFnQVU4RWZ5QURJQVJCRUdvUU1pSUFOZ0lRUVg5QmZ5QUFyVUlzZmlJR3B5SUJRUVJxSWdJZ0FTQUNTeHNnQmtJZ2lLY2JFQ2NpQVNBQU5nSUFJQUZCQkdvaEFTQUFCRUFnQVNBQVFTeHNhaUVDSUFFaEFBTkFJQUJDQURjQ0FDQUFRZ0EzQWlRZ0FFRUFPd0VnSUFCQ2dJQ0EvSU9BZ01BL053SVlJQUJDQURjQURTQUFRZ0EzQWdnZ0FFRXNhaUlBSUFKSERRQUxDeUFESUFFMkFoUkJBQVZCQUNFQkFrQWdCQ0FBRU9BQklnSkZEUUFDUUFKQUFrQWdBaUFDS0FJQUtBSUlFUUFBUVRockRnUUJBd0lBQXd0QkVCQW5JZ0VnQWlBREVMVUNJQUZCM01FQU5nSUFJQUVnQWkwQUVEb0FEQXdDQzBFUUVDY2lBU0FDSUFNUXRRSWdBVUh3d1FBMkFnQWdBU0FDS2dJUU9BSU1EQUVMUVJBUUp5SUJJQUlnQXhDMUFpQUJRUUE2QUF3Z0FVR0V3Z0EyQWdBTElBTW9BZ3dnQUVFQ2RHb2dBVFlDQUNBQVFRRnFJUUFnQXlnQ0NDRUJEQUVMQ3lFQUEwQWdBeWdDRUNBQVN3UkFJQU1vQWhRZ0FFRXNiR29oQVNBRVFSQnFJZ0lRTWlBQVN3Ui9JQUlnQUJBdktBSUFCVUVBQ3lJQ0tBSWNJZ1VnQlNnQ0FDZ0NKQkVBQUNFRklBRWdBallDQUNBQklBVTJBZ1FnQVNBQ0tBSWdFSm9FR2lBQVFRRnFJUUFNQVFzTElBTUwwZ0VCQkg4Z0FBUkFBa0FEUUNBQUtBSU1JUUlnQUNnQ0NDQUJUUVJBSUFJRVFDQUNFQzRMSUFBb0FoUWlBZ1JBSUFKQkJHc2lCQ2dDQUNJQkJFQWdBaUFCUVN4c2FpRUJBMEFnQVVFc2F5SUJLQUlFSWdNRVFDQURJQU1vQWdBb0FnUVJBUUFMSUFFb0FnZ2lBd1JBSUFNZ0F5Z0NBQ2dDQkJFQkFBc2dBU2dDRENJREJFQWdBeUFES0FJQUtBSUVFUUVBQ3lBQklBSkhEUUFMQ3lBRUVDNExEQUlMSUFJZ0FVRUNkR29vQWdBaUFnUkFJQUlnQWlnQ0FDZ0NDQkVCQUFzZ0FVRUJhaUVCREFBTEFBc0xJQUFRTGdzR0FFRzN3QUVMQmdCQnRjQUJDeklCQW45QjJBQVFKMEVBUWRnQUVETVFyUVVpQWlJQklBQXFBbEE0QWxBZ0FTQUFLZ0pVT0FKVUlBRWdBQkRRQVNBQ0N3Y0FJQUF0QUJnTERnQkJJQkFuSUFBb0FnQVF1QUlMQmdCQnNzQUJDMUVCQW44akFFRVFheUlDSkFBZ0FDZ0NBQ0VESUFJZ0FTQUFLQUlFSWdCQkFYVnFJZ0VnQUVFQmNRUi9JQUVvQWdBZ0Eyb29BZ0FGSUFNTEVRQUFOZ0lNSUFJb0Fnd2hBQ0FDUVJCcUpBQWdBQXNHQUVHdndBRUxCZ0JCck1BQkN3WUFRYXJBQVFzR0FFR293QUVMQmdCQnBzQUJDMXNBQWtBQ1FBSkFBa0FDUUNBQlFkUUFhdzRFQUFFQ0F3UUxJQUFnQWhBd3RqZ0NVRUVCRHdzZ0FDQUNFREMyT0FKVVFRRVBDeUFBSUFJUU1MWTRBbGhCQVE4TElBQWdBaEF3dGpnQ1hFRUJEd3NnQUNBQklBSVFzUUVMQmdCQnBNQUJDM01CQW44akFFRVFheUlDSkFBZ0FDZ0NBQ0VESUFJZ0FTQUFLQUlFSWdCQkFYVnFJZ0VnQUVFQmNRUi9JQUVvQWdBZ0Eyb29BZ0FGSUFNTEVRTUFRUkFRSnlJQUlBSXFBZ0E0QWdBZ0FDQUNLZ0lFT0FJRUlBQWdBaW9DQ0RnQ0NDQUFJQUlxQWd3NEFnd2dBa0VRYWlRQUlBQUxDZ0FnQUVIMEFHb1FNZ3QrQVFGL0l3QkJFR3NpQWlRQUlBSWdBRUhjQUdvaUFCQXFOZ0lJSUFJZ0FCQXJOZ0lBQTBBQ1FDQUNRUWhxSUFJUUxFVUVRRUVBSVFBTUFRc0NRQ0FDS0FJSUtBSUFJZ0JGRFFBZ0FFRXBJQUFvQWdBb0Fnd1JBZ0JGRFFBZ0FCQTlJQUVRbEFFTkFRc2dBa0VJYWhBdEdnd0JDd3NnQWtFUWFpUUFJQUFMZEFFQmZ5TUFRUkJySWdJa0FDQUNJQUJCM0FCcUlnQVFLallDQ0NBQ0lBQVFLellDQUFOQUFrQWdBa0VJYWlBQ0VDeEZCRUJCQUNFQURBRUxBa0FnQWlnQ0NDZ0NBQ0lBUlEwQUlBQVFzUUpGRFFBZ0FCQTlJQUVRbEFFTkFRc2dBa0VJYWhBdEdnd0JDd3NnQWtFUWFpUUFJQUFMZEFFQmZ5TUFRUkJySWdJa0FDQUNJQUJCM0FCcUlnQVFLallDQ0NBQ0lBQVFLellDQUFOQUFrQWdBa0VJYWlBQ0VDeEZCRUJCQUNFQURBRUxBa0FnQWlnQ0NDZ0NBQ0lBUlEwQUlBQVFxd0pGRFFBZ0FCQTlJQUVRbEFFTkFRc2dBa0VJYWhBdEdnd0JDd3NnQWtFUWFpUUFJQUFMZEFFQmZ5TUFRUkJySWdJa0FDQUNJQUJCM0FCcUlnQVFLallDQ0NBQ0lBQVFLellDQUFOQUFrQWdBa0VJYWlBQ0VDeEZCRUJCQUNFQURBRUxBa0FnQWlnQ0NDZ0NBQ0lBUlEwQUlBQVFoUU5GRFFBZ0FCQTlJQUVRbEFFTkFRc2dBa0VJYWhBdEdnd0JDd3NnQWtFUWFpUUFJQUFMSXdBZ0FVRUdhMEgvL3dOeElnQkJIazBFUUVHeGdvQ0FCQ0FBZGtFQmNROExRUUFMQmdCQm1zQUJDeEFBSUFBRVFDQUFFSkFEQ3lBQUVDNExCZ0JCbHNBQkN3WUFRZnUrQVFzV0FDQUFJQUVRY2tIT3Z3RWdBaWdDQUJBTkVQY0JDMEFCQW45QkRCQW5JZ0lpQVVFQU5nSUFJQUZCK0pBQk5nSUFJQUZCQkdvUXZnRWdBVUhBa0FFMkFnQWdBVUVJYWlBQUVPc0NJQUpCaUpBQk5nSUFJQUlMQkFCQkJnc0dBRUhPdndFTEJnQkJ6TDhCQ3hZQUlBQWdBUkJ5UWFPL0FTQUNLQUlBRUEwUTl3RUxSUUVDZjBFTUVDY2lBaUlCUVFBMkFnQWdBUkRWQXlBQlFleU5BVFlDQUNBQlFRUnFFTDRCSUFGQnVJMEJOZ0lBSUFGQkNHb2dBQkRyQWlBQ1FZU05BVFlDQUNBQ0N3WUFRYU8vQVFzR0FFR2h2d0VMRmdBZ0FDQUJFSEpCK2I0QklBSW9BZ0FRRFJEM0FRdFVBUUYvSXdCQklHc2lBeVFBSUFOQkNHb2dBUkNuQlNBRElBSVE3Z0lnQTBFWWFpQURRUWhxSUFNZ0FCRUZBQ0FEUVJocUVLc0ZJUUFnQTBFWWFoQmRJQU1RWFNBRFFRaHFFRzhnQTBFZ2FpUUFJQUFMUUFFQ2YwRU1FQ2NpQWlJQlFRQTJBZ0FnQVVHWWl3RTJBZ0FnQVVFRWFoQytBU0FCUWZTS0FUWUNBQ0FCUVFocUlBQVE2d0lnQWtIUWlnRTJBZ0FnQWdzR0FFSDV2Z0VMUmdFQ2YwSGdBQkFuUVFCQjRBQVFNeEN3QVNJQ0lnRWdBQ29DVURnQ1VDQUJJQUFxQWxRNEFsUWdBU0FBS2dKWU9BSllJQUVnQUNvQ1hEZ0NYQ0FCSUFBUTBBRWdBZ3NFQUVFb0N4d0JBWDlCaUFFUUowRUFRWWdCRURNUTB3SWlBU0FBRU40RUlBRUxDNGlyQWVvQkFFR0lDQXRWQVFBQUFBSUFBQUFEQUFBQUJBQUFBQVVBQUFBR0FBQUFCd0FBQUFnQUFBQUpBQUFBQ2dBQUFBc0FBQUFNQUFBQURRQUFBQTRBQUFBUEFBQUFFQUFBQUJFQUFBQVNBQUFBRXdBQUFCUUFBQUFVQUFBQUZRQkI2QWdMVVFFQUFBQVdBQUFBRndBQUFCZ0FBQUFaQUFBQUdnQUFBQWNBQUFBSUFBQUFDUUFBQUFvQUFBQUxBQUFBREFBQUFBMEFBQUFPQUFBQUR3QUFBQkFBQUFBUkFBQUFFZ0FBQUJNQUFBQVVBQUFBRkFCQnhBa0xVUUVBQUFBYkFBQUFGd0FBQUJnQUFBQVpBQUFBR2dBQUFBY0FBQUFJQUFBQUNRQUFBQW9BQUFBTEFBQUFEQUFBQUEwQUFBQU9BQUFBRHdBQUFCQUFBQUFSQUFBQUVnQUFBQk1BQUFBVUFBQUFGQUJCb0FvTFJRRUFBQUFjQUFBQUhRQUFBQjRBQUFBWkFBQUFHZ0FBQUFjQUFBQWZBQUFBQ1FBQUFBb0FBQUFMQUFBQUlBQUFBQTBBQUFBaEFBQUFJZ0FBQUNNQUFBQWtBQUFBSlFCQjhBb0xOUUVBQUFBbUFBQUFKd0FBQUNnQUFBQXBBQUFBR2dBQUFBY0FBQUFmQUFBQUNRQUFBQW9BQUFBTEFBQUFJQUFBQUEwQUFBQWhBRUd3Q3dzMUFRQUFBQ29BQUFBbkFBQUFLQUFBQUNrQUFBQWFBQUFBQndBQUFCOEFBQUFKQUFBQUNnQUFBQXNBQUFBZ0FBQUFEUUFBQUNFQVFmQUxDeWtyQUFBQUxBQUFBQzBBQUFBdUFBQUFLUUFBQUJvQUFBQXZBQUFBSHdBQUFEQUFBQUFLQUFBQUN3QkJxQXdMSVRFQUFBQXlBQUFBRkFBQUFCUUFBQUFVQUFBQUdnQUFBQzhBQUFBZkFBQUFNQUJCMUF3TFRRRUFBQUF6QUFBQU5BQUFBRFVBQUFBMkFBQUFOd0FBQURnQUFBQWZBQUFBQ1FBQUFBb0FBQUFMQUFBQUlBQUFBQTBBQUFBaEFBQUFPUUFBQURvQUFBQTdBQUFBUEFBQUFEMEFBQUErQUVHc0RRdE5BUUFBQUQ4QUFBQTBBQUFBTlFBQUFEWUFBQUEzQUFBQU9BQUFBQjhBQUFBSkFBQUFDZ0FBQUFzQUFBQWdBQUFBRFFBQUFDRUFBQUE1QUFBQU9nQUFBRHNBQUFBOEFBQUFQUUFBQUQ0QVFZUU9DMTFBQUFBQVFRQUFBRUlBQUFCREFBQUFSQUFBQUVVQUFBQUhBQUFBUmdBQUFBa0FBQUFLQUFBQUN3QUFBQXdBQUFBTkFBQUFEZ0FBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQVJ3QUFBRWdBQUFCSkFBQUFTZ0FBQUVzQVFld09DMDBCQUFBQVRBQUFBRTBBQUFCT0FBQUFUd0FBQUZBQUFBQUhBQUFBSHdBQUFBa0FBQUFLQUFBQUN3QUFBQ0FBQUFBTkFBQUFJUUFBQUZFQUFBQlNBQUFBVXdBQUFGUUFBQUJWQUFBQVZnQkJ4QThMVVFFQUFBQlhBQUFBV0FBQUFGa0FBQUJhQUFBQVd3QUFBQWNBQUFBZkFBQUFDUUFBQUFvQUFBQUxBQUFBSUFBQUFBMEFBQUFoQUFBQVhBQUFBRjBBQUFCZUFBQUFYd0FBQUdBQUFBQmhBQUFBWWdCQm9CQUxQUUVBQUFCakFBQUFaQUFBQUdVQUFBQm1BQUFBWndBQUFBY0FBQUFmQUFBQUNRQUFBQW9BQUFBTEFBQUFJQUFBQUEwQUFBQWhBQUFBT1FBQUFEb0FRZWdRQzBFQkFBQUFhQUFBQUdrQUFBQnFBQUFBYXdBQUFHd0FBQUFIQUFBQUh3QUFBQWtBQUFBS0FBQUFDd0FBQUNBQUFBQU5BQUFBSVFBQUFHMEFBQUJ1QUFBQWJ3QkJ0QkVMVlFFQUFBQndBQUFBY1FBQUFISUFBQUJ6QUFBQWRBQUFBSFVBQUFBZkFBQUFDUUFBQUFvQUFBQUxBQUFBSUFBQUFBMEFBQUFoQUFBQWRnQUFBSGNBQUFCNEFBQUFGQUFBQUJRQUFBQjVBQUFBZWdBQUFIc0FRWlFTQzBFQkFBQUFmQUFBQUgwQUFBQitBQUFBZndBQUFCb0FBQUIxQUFBQUh3QUFBQWtBQUFBS0FBQUFDd0FBQUNBQUFBQU5BQUFBSVFBQUFJQUFBQUNCQUFBQWdnQkI0QklMUFFFQUFBQ0RBQUFBaEFBQUFJVUFBQUIvQUFBQUdnQUFBQWNBQUFBZkFBQUFDUUFBQUFvQUFBQUxBQUFBSUFBQUFBMEFBQUFoQUFBQWhnQUFBSWNBUWFnVEMxa0JBQUFBaUFBQUFJa0FBQUNLQUFBQWl3QUFBSXdBQUFCMUFBQUFId0FBQUFrQUFBQUtBQUFBQ3dBQUFDQUFBQUFOQUFBQUlRQUFBSFlBQUFCM0FBQUFlQUFBQUJRQUFBQVVBQUFBalFBQUFJNEFBQUNQQUFBQWtBQkJqQlFMVVFFQUFBQ1JBQUFBa2dBQUFKTUFBQUNVQUFBQWxRQUFBSFVBQUFBZkFBQUFDUUFBQUFvQUFBQUxBQUFBSUFBQUFBMEFBQUFoQUFBQWRnQUFBSGNBQUFCNEFBQUFGQUFBQUJRQUFBQ1dBQUFBbHdCQjZCUUxlWmdBQUFDWkFBQUFtZ0FBQUpzQUFBQ2NBQUFBblFBQUFKNEFBQUNmQUFBQUNRQUFBQW9BQUFBTEFBQUFvQUFBQUtFQUFBQ2lBQUFBRHdBQUFCQUFBQUFSQUFBQUVnQUFBQk1BQUFDakFBQUFwQUFBQUtVQUFBQ21BQUFBcHdBQUFLZ0FBQUNwQUFBQXFnQUFBS3NBQUFDc0FBQUFyUUFBQUs0QVFld1ZDMjJZQUFBQXJ3QUFBTEFBQUFDeEFBQUFzZ0FBQUxNQUFBQ2VBQUFBbndBQUFBa0FBQUFLQUFBQUN3QUFBS0FBQUFDaEFBQUFvZ0FBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQW93QUFBS1FBQUFDbEFBQUFwZ0FBQUtjQUFBQ29BQUFBcVFBQUFLb0FBQUMwQUVIa0ZndGRBUUFBQUxVQUFBQzJBQUFBdHdBQUFMZ0FBQUM1QUFBQUJ3QUFBQWdBQUFBSkFBQUFDZ0FBQUFzQUFBQU1BQUFBRFFBQUFBNEFBQUFQQUFBQUVBQUFBQkVBQUFBU0FBQUFFd0FBQUtNQUFBQ2tBQUFBcFFBQUFLWUFBQUNuQUVITUZ3c0JGQUJCMkJjTGdRR1lBQUFBdWdBQUFMc0FBQUM4QUFBQXZRQUFBTDRBQUFDZUFBQUFud0FBQUFrQUFBQUtBQUFBQ3dBQUFLQUFBQUNoQUFBQW9nQUFBQThBQUFBUUFBQUFFUUFBQUJJQUFBQVRBQUFBb3dBQUFLUUFBQUNsQUFBQXBnQUFBS2NBQUFDb0FBQUFxUUFBQUtvQUFBQ3JBQUFBckFBQUFLMEFBQUN1QUFBQXZ3QUFBTUFBUWVRWUM0MEJtQUFBQU1FQUFBRENBQUFBd3dBQUFNUUFBQURGQUFBQW5nQUFBSjhBQUFBSkFBQUFDZ0FBQUFzQUFBQ2dBQUFBb1FBQUFLSUFBQUFQQUFBQUVBQUFBQkVBQUFBU0FBQUFFd0FBQUtNQUFBQ2tBQUFBcFFBQUFLWUFBQUNuQUFBQXFBQUFBS2tBQUFDcUFBQUFxd0FBQUt3QUFBQ3RBQUFBcmdBQUFNWUFBQURIQUFBQXlBQUFBTWtBQUFES0FFSDhHUXRseXdBQUFNd0FBQUROQUFBQXpnQUFBTThBQUFEUUFBQUFCd0FBQUFnQUFBQUpBQUFBQ2dBQUFBc0FBQUFNQUFBQURRQUFBQTRBQUFBUEFBQUFFQUFBQUJFQUFBQVNBQUFBRXdBQUFLTUFBQUNrQUFBQXBRQUFBS1lBQUFEUkFBQUEwZ0FBQUJRQVFld2FDMlhMQUFBQTB3QUFBTlFBQUFEVkFBQUF6d0FBQUxrQUFBQUhBQUFBQ0FBQUFBa0FBQUFLQUFBQUN3QUFBQXdBQUFBTkFBQUFEZ0FBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQW93QUFBS1FBQUFDbEFBQUFwZ0FBQU5FQUFBRFNBQUFBRkFCQjNCc0xqUUhXQUFBQTF3QUFBTmdBQUFEWkFBQUEyZ0FBQU5zQUFBQ2VBQUFBbndBQUFBa0FBQUFLQUFBQUN3QUFBS0FBQUFDaEFBQUEzQUFBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQW93QUFBS1FBQUFDbEFBQUFwZ0FBQUtjQUFBQ29BQUFBcVFBQUFLb0FBQUNyQUFBQXJBQUFBSzBBQUFDdUFBQUEzUUFBQU40QUFBRGZBQUFBNEFBQUFPRUFRZlFjQzBVQkFBQUE0Z0FBQU9NQUFBRGtBQUFBNVFBQUFPWUFBQUIxQUFBQUh3QUFBQWtBQUFBS0FBQUFDd0FBQUNBQUFBQU5BQUFBSVFBQUFJQUFBQUNCQUFBQWdnQUFBT2NBUWNRZEMzbVlBQUFBNkFBQUFPa0FBQURxQUFBQW5BQUFBT3NBQUFDZUFBQUFud0FBQUFrQUFBQUtBQUFBQ3dBQUFLQUFBQUNoQUFBQW9nQUFBQThBQUFBUUFBQUFFUUFBQUJJQUFBQVRBQUFBb3dBQUFLUUFBQUNsQUFBQXBnQUFBS2NBQUFDb0FBQUFxUUFBQUtvQUFBQ3JBQUFBckFBQUFLMEFBQUN1QUVISUhndE43QUFBQU8wQUFBRHVBQUFBN3dBQUFQQUFBQUR4QUFBQUJ3QUFBUElBQUFBSkFBQUFDZ0FBQUFzQUFBQWdBQUFBRFFBQUFDRUFBQUR6QUFBQTlBQUFBUFVBQUFBVUFBQUFGQUFBQVBZQVFhQWZDejBCQUFBQTl3QUFBUGdBQUFENUFBQUErZ0FBQUJvQUFBQUhBQUFBSHdBQUFBa0FBQUFLQUFBQUN3QUFBQ0FBQUFBTkFBQUFJUUFBQVBNQUFBRDBBRUhvSHdzK0FRQUFBUHNBQUFEOEFBQUEvUUFBQVA0QUFBRC9BQUFBQndBQUFCOEFBQUFKQUFBQUNnQUFBQXNBQUFBZ0FBQUFEUUFBQUNFQUFBQUFBUUFBQVFFQVFiQWdDMG9CQUFBQUFnRUFBQU1CQUFBRUFRQUFCUUVBQUFZQkFBQUhBQUFBSHdBQUFBa0FBQUFLQUFBQUN3QUFBQ0FBQUFBTkFBQUFJUUFBQUFjQkFBQUlBUUFBQ1FFQUFBb0JBQUFMQVFCQmhDRUxBUlFBUVpBaEMxNE1BUUFBRFFFQUFBNEJBQUFQQVFBQUJRRUFBQkFCQUFBUkFRQUFId0FBQUFrQUFBQUtBQUFBQ3dBQUFCSUJBQUFOQUFBQUV3RUFBQlFCQUFBVkFRQUFGZ0VBQUJjQkFBQVlBUUFBR1FFQUFCb0JBQUM4Ly8vL0FBQUFBQnNCQUVINElRczZBUUFBQUJ3QkFBQWRBUUFBSGdFQUFCOEJBQUFnQVFBQUJ3QUFBQjhBQUFBSkFBQUFDZ0FBQUFzQUFBQWdBQUFBRFFBQUFDRUFBQUFoQVFCQnZDSUxXdXdBQUFBaUFRQUFJd0VBQUNRQkFBQWxBUUFBSmdFQUFBY0FBQUR5QUFBQUNRQUFBQW9BQUFBTEFBQUFJQUFBQUEwQUFBQWhBQUFBOHdBQUFQUUFBQUQxQUFBQUZBQUFBQlFBQUFBbkFRQUFLQUVBQUNrQkFBQXFBUUJCb0NNTFJnRUFBQUFyQVFBQUxBRUFBQzBCQUFBdUFRQUFMd0VBQUFjQUFBQWZBQUFBQ1FBQUFBb0FBQUFMQUFBQUlBQUFBQTBBQUFBaEFBQUFNQUVBQURFQkFBQXlBUUFBTXdFQVFmQWpDeVkwQVFBQU5RRUFBRFlCQUFBM0FRQUFPQUVBQURrQkFBQXZBQUFBSHdBQUFEQUFBQUE2QVFCQm9DUUxKalFCQUFBN0FRQUFOZ0VBQURjQkFBQTRBUUFBT1FFQUFDOEFBQUFmQUFBQU1BQUFBRG9CQUVIVUpBc3FQQUVBQUQwQkFBQStBUUFBUHdFQUFFQUJBQUJCQVFBQVFnRUFBRU1CQUFCRUFRQUFSUUVBQUVZQkFFR0lKUXNoTVFBQUFFY0JBQUJJQVFBQVNRRUFBRW9CQUFBYUFBQUFMd0FBQUI4QUFBQXdBRUcwSlFzaE1RQUFBRXNCQUFCTUFRQUFUUUVBQUVvQkFBQWFBQUFBTHdBQUFCOEFBQUF3QUVIZ0pRc2hNUUFBQUU0QkFBQk1BUUFBVFFFQUFFb0JBQUFhQUFBQUx3QUFBQjhBQUFBd0FFR01KZ3NtUEFFQUFFOEJBQUJRQVFBQVVRRUFBRW9CQUFCU0FRQUFRZ0VBQUVNQkFBQkVBUUFBUlFFQVFid21DeVk4QVFBQVV3RUFBRkFCQUFCUkFRQUFTZ0VBQUZJQkFBQkNBUUFBUXdFQUFFUUJBQUJGQVFCQjdDWUxNakVBQUFCVUFRQUFWUUVBQUZZQkFBQlhBUUFBV0FFQUFDOEFBQUFmQUFBQU1BQUFBRmtCQUFCYUFRQUFXd0VBQUZ3QkFFR29Kd3NtUEFFQUFGMEJBQUJlQVFBQVh3RUFBRW9CQUFCZ0FRQUFRZ0VBQUVNQkFBQkVBUUFBUlFFQVFkZ25DeVk4QVFBQVlRRUFBRjRCQUFCZkFRQUFTZ0VBQUdBQkFBQkNBUUFBUXdFQUFFUUJBQUJGQVFCQmlDZ0xKandCQUFCaUFRQUFZd0VBQUdRQkFBQktBUUFBWlFFQUFFSUJBQUJEQVFBQVJBRUFBRVVCQUVHNEtBc21QQUVBQUdZQkFBQmpBUUFBWkFFQUFFb0JBQUJsQVFBQVFnRUFBRU1CQUFCRUFRQUFSUUVBUWVnb0N5WXhBQUFBWndFQUFHZ0JBQUJwQVFBQWFnRUFBR3NCQUFBdkFBQUFId0FBQURBQUFBQnNBUUJCbUNrTEpqRUFBQUJ0QVFBQWJnRUFBRzhCQUFCd0FRQUFjUUVBQUM4QUFBQWZBQUFBTUFBQUFISUJBRUhJS1FzNk1RQUFBSE1CQUFCMEFRQUFkUUVBQUhZQkFBQjNBUUFBZUFFQUFCOEFBQUI1QVFBQWVnRUFBSHNCQUFCOEFRQUFGQUFBQUJRQUFBQjlBUUJCakNvTExqRUFBQUIrQVFBQWZ3RUFBSUFCQUFDQkFRQUFHZ0FBQUM4QUFBQWZBQUFBTUFBQUFIb0JBQUI3QVFBQWZBRUFRY1FxQ3pveEFBQUFnZ0VBQUlNQkFBQ0VBUUFBaFFFQUFJWUJBQUI0QVFBQUh3QUFBSGtCQUFCNkFRQUFld0VBQUh3QkFBQVVBQUFBRkFBQUFJY0JBRUdJS3dzNk1RQUFBSWdCQUFDSkFRQUFpZ0VBQUlzQkFBQ01BUUFBZUFFQUFCOEFBQUI1QVFBQWVnRUFBSHNCQUFCOEFRQUFGQUFBQUJRQUFBQ05BUUJCekNzTFFqUUJBQUNPQVFBQWp3RUFBSkFCQUFDUkFRQUFrZ0VBQUM4QUFBQWZBQUFBTUFBQUFEb0JBQUNUQVFBQWxBRUFBSlVCQUFDV0FRQUFsd0VBQUpnQkFBQ1pBUUJCbUN3TEpqUUJBQUNhQVFBQW13RUFBSndCQUFBNEFRQUFuUUVBQUM4QUFBQWZBQUFBTUFBQUFEb0JBRUhJTEFzcW5nRUFBSjhCQUFDZ0FRQUFvUUVBQUtJQkFBQ2pBUUFBcEFFQUFLVUJBQUNtQVFBQXB3RUFBS2dCQUVIOExBc3FuZ0VBQUtrQkFBQ2dBUUFBb1FFQUFLSUJBQUNqQVFBQXBBRUFBS1VCQUFDbUFRQUFwd0VBQUtnQkFFR3dMUXNtbmdFQUFLb0JBQUNyQVFBQXJBRUFBSzBCQUFBYUFBQUFMd0FBQUI4QUFBQXdBQUFBcHdFQVFlQXRDeWFlQVFBQXJnRUFBSzhCQUFDd0FRQUFyUUVBQUJvQUFBQXZBQUFBSHdBQUFEQUFBQUNuQVFCQmtDNExKcDRCQUFDeEFRQUFyd0VBQUxBQkFBQ3RBUUFBR2dBQUFDOEFBQUFmQUFBQU1BQUFBS2NCQUVIRUxnc21uZ0VBQUxJQkFBQ3pBUUFBdEFFQUFLMEJBQUMxQVFBQUx3QUFBQjhBQUFBd0FBQUFwd0VBUWZRdUN5cWVBUUFBdGdFQUFMY0JBQUM0QVFBQXVRRUFBTG9CQUFDa0FRQUFwUUVBQUtZQkFBQ25BUUFBdXdFQVFhZ3ZDeXFlQVFBQXZBRUFBTGNCQUFDNEFRQUF1UUVBQUxvQkFBQ2tBUUFBcFFFQUFLWUJBQUNuQVFBQXV3RUFRZHd2Q3lhZUFRQUF2UUVBQUw0QkFBQy9BUUFBclFFQUFNQUJBQUNrQVFBQXBRRUFBS1lCQUFDbkFRQkJqREFMSnA0QkFBREJBUUFBdmdFQUFMOEJBQUN0QVFBQXdBRUFBS1FCQUFDbEFRQUFwZ0VBQUtjQkFFRzhNQXN5TVFBQUFNSUJBQUREQVFBQXhBRUFBTVVCQUFER0FRQUFMd0FBQUI4QUFBQXdBQUFBeHdFQUFNZ0JBQURKQVFBQXlnRUFRZmd3Q3pJeEFBQUF5d0VBQU13QkFBRE5BUUFBemdFQUFNOEJBQURRQVFBQTBRRUFBTklCQUFEVEFRQUExQUVBQU5VQkFBRFdBUUJCdERFTE1qRUFBQURYQVFBQTJBRUFBTmtCQUFET0FRQUFHZ0FBQU5BQkFBRFJBUUFBMGdFQUFOTUJBQURVQVFBQTFRRUFBTllCQUVId01Rc3lNUUFBQU5vQkFBRFlBUUFBMlFFQUFNNEJBQUFhQUFBQTBBRUFBTkVCQUFEU0FRQUEwd0VBQU5RQkFBRFZBUUFBMWdFQVFhd3lDeVl4QUFBQTJ3RUFBTndCQUFEZEFRQUEzZ0VBQUJvQUFBQXZBQUFBSHdBQUFEQUFBQURUQVFCQjNESUxOakVBQUFEZkFRQUE0QUVBQU9FQkFBRGlBUUFBNHdFQUFOQUJBQURSQVFBQTBnRUFBTk1CQUFEVUFRQUExUUVBQU5ZQkFBRGtBUUJCbkRNTExqRUFBQURsQVFBQTVnRUFBT2NCQUFEZUFRQUE2QUVBQU5BQkFBRFJBUUFBMGdFQUFOTUJBQURVQVFBQTFRRUFRZFF6Q3lvOEFRQUE2UUVBQUQ0QkFBQS9BUUFBUUFFQUFFRUJBQUJDQVFBQVF3RUFBRVFCQUFEcUFRQUFSZ0VBUVlnMEN4THJBUUFBN0FFQUFPMEJBQUR1QVFBQTd3RUFRYVEwQ3lZeEFBQUE4QUVBQVBFQkFBRHlBUUFBOHdFQUFCb0FBQUF2QUFBQUh3QUFBUFFCQUFEMUFRQkIxRFFMS2pFQUFBRDJBUUFBOXdFQUFQZ0JBQUQ1QVFBQUdnQUFBUG9CQUFEN0FRQUE5QUVBQVBVQkFBRDhBUUJCaURVTGJ6RUFBQUQ5QVFBQS9nRUFBUDhCQUFBQUFnQUFHZ0FBQUFFQ0FBQUNBZ0FBQXdJQUFQVUJBQUFFQWdBQVlXeHNiMk5oZEc5eVBGUStPanBoYkd4dlkyRjBaU2h6YVhwbFgzUWdiaWtnSjI0bklHVjRZMlZsWkhNZ2JXRjRhVzExYlNCemRYQndiM0owWldRZ2MybDZaUUJCZ0RZTEtnVUNBQUFHQWdBQUJ3SUFBQWdDQUFBSkFnQUFHZ0FBQUVJQkFBQkRBUUFBQ2dJQUFBc0NBQUFNQWdCQnREWUxKZ1VDQUFBTkFnQUFEZ0lBQUE4Q0FBQktBUUFBR2dBQUFFSUJBQUJEQVFBQVJBRUFBRVVCQUVIa05nc1NFQUlBQUJFQ0FBQVNBZ0FBRXdJQUFCUUNBRUdBTnd0WEVBSUFBQlVDQUFBV0FnQUFFd0lBQUJRQ0FBQmhiR3h2WTJGMGIzSThWRDQ2T21Gc2JHOWpZWFJsS0hOcGVtVmZkQ0J1S1NBbmJpY2daWGhqWldWa2N5QnRZWGhwYlhWdElITjFjSEJ2Y25SbFpDQnphWHBsQUVIZ053c21CUUlBQUJjQ0FBQVlBZ0FBR1FJQUFFb0JBQUFhQUFBQVFnRUFBRU1CQUFCRUFRQUFHZ0lBUVpBNEN4SWJBZ0FBSEFJQUFCMENBQUFlQWdBQUh3SUFRYXc0QzFjYkFnQUFJQUlBQUNFQ0FBQWVBZ0FBSHdJQUFHRnNiRzlqWVhSdmNqeFVQam82WVd4c2IyTmhkR1VvYzJsNlpWOTBJRzRwSUNkdUp5QmxlR05sWldSeklHMWhlR2x0ZFcwZ2MzVndjRzl5ZEdWa0lITnBlbVVBUVl3NUN6NGlBZ0FBSXdJQUFDUUNBQUFsQWdBQUpnSUFBTVlCQUFBbkFnQUFLQUlBQUNrQ0FBREhBUUFBeUFFQUFNa0JBQURLQVFBQUtnSUFBQ3NDQUFBc0FnQkIxRGtMTWpFQUFBQXRBZ0FBVlFFQUFGWUJBQUJYQVFBQVdBRUFBQzRDQUFBZkFBQUFMd0lBQUZrQkFBQmFBUUFBV3dFQUFGd0JBRUdRT2d0ck1BSUFBREVDQUFCb0FRQUFhUUVBQUdvQkFBQnJBUUFBTWdJQUFETUNBQUEwQWdBQWJBRUFBR0ZzYkc5allYUnZjanhVUGpvNllXeHNiMk5oZEdVb2MybDZaVjkwSUc0cElDZHVKeUJsZUdObFpXUnpJRzFoZUdsdGRXMGdjM1Z3Y0c5eWRHVmtJSE5wZW1VQVFZUTdDMnMxQWdBQU5nSUFBRzRCQUFCdkFRQUFjQUVBQUhFQkFBQTNBZ0FBT0FJQUFEa0NBQUJ5QVFBQVlXeHNiMk5oZEc5eVBGUStPanBoYkd4dlkyRjBaU2h6YVhwbFgzUWdiaWtnSjI0bklHVjRZMlZsWkhNZ2JXRjRhVzExYlNCemRYQndiM0owWldRZ2MybDZaUUJCK0RzTE5URUFBQUE2QWdBQWZ3RUFBSUFCQUFDQkFRQUFHZ0FBQUhnQkFBQWZBQUFBZVFFQUFIb0JBQUI3QVFBQWZBRUFBQlFBQUFBVUFFRzRQQXM2TVFBQUFEc0NBQUIwQVFBQWRRRUFBSFlCQUFCM0FRQUFlQUVBQUI4QUFBQjVBUUFBZWdFQUFIc0JBQUI4QVFBQVBBSUFBRDBDQUFCOUFRQkIvRHdMT2pFQUFBQStBZ0FBZ3dFQUFJUUJBQUNGQVFBQWhnRUFBSGdCQUFBZkFBQUFlUUVBQUhvQkFBQjdBUUFBZkFFQUFEOENBQUJBQWdBQWh3RUFRY0E5Q3pveEFBQUFRUUlBQUlrQkFBQ0tBUUFBaXdFQUFJd0JBQUI0QVFBQUh3QUFBSGtCQUFCNkFRQUFld0VBQUh3QkFBQkNBZ0FBUXdJQUFJMEJBRUdFUGd0clBBRUFBRVFDQUFCSUFRQUFTUUVBQUVvQkFBQWFBQUFBUWdFQUFFTUJBQUJFQVFBQVJRRUFBR0ZzYkc5allYUnZjanhVUGpvNllXeHNiMk5oZEdVb2MybDZaVjkwSUc0cElDZHVKeUJsZUdObFpXUnpJRzFoZUdsdGRXMGdjM1Z3Y0c5eWRHVmtJSE5wZW1VQVFmZytDNGNCUlFJQUFFWUNBQUNQQVFBQWtBRUFBSkVCQUFDU0FRQUFSd0lBQUVnQ0FBQkpBZ0FBT2dFQUFKTUJBQUNVQVFBQWxRRUFBSllCQUFDWEFRQUFtQUVBQUprQkFBQmhiR3h2WTJGMGIzSThWRDQ2T21Gc2JHOWpZWFJsS0hOcGVtVmZkQ0J1S1NBbmJpY2daWGhqWldWa2N5QnRZWGhwYlhWdElITjFjSEJ2Y25SbFpDQnphWHBsQUVHSXdBQUxFZXNCQUFCS0FnQUFGQUFBQUJRQUFBQVVBRUdrd0FBTGEwc0NBQUJNQWdBQW13RUFBSndCQUFBNEFRQUFuUUVBQUUwQ0FBQk9BZ0FBVHdJQUFEb0JBQUJoYkd4dlkyRjBiM0k4VkQ0Nk9tRnNiRzlqWVhSbEtITnBlbVZmZENCdUtTQW5iaWNnWlhoalpXVmtjeUJ0WVhocGJYVnRJSE4xY0hCdmNuUmxaQ0J6YVhwbEFFR1l3UUFMSnA0QkFBQlFBZ0FBcXdFQUFLd0JBQUN0QVFBQUdnQUFBS1FCQUFDbEFRQUFwZ0VBQUtjQkFFSEl3UUFMQ2xFQ0FBQlNBZ0FBVXdJQVFkekJBQXNLVVFJQUFGSUNBQUJVQWdCQjhNRUFDd3BSQWdBQVVnSUFBRlVDQUVHRXdnQUxNbFlDQUFCU0FnQUFWd0lBQUZOMFlYUmxUV0ZqYUdsdVpTQmxlR05sWldSbFpDQnRZWGdnYVhSbGNtRjBhVzl1Y3k0S0FFSEF3Z0FMYTFnQ0FBQlpBZ0FBc3dFQUFMUUJBQUN0QVFBQXRRRUFBRm9DQUFCYkFnQUFYQUlBQUtjQkFBQmhiR3h2WTJGMGIzSThWRDQ2T21Gc2JHOWpZWFJsS0hOcGVtVmZkQ0J1S1NBbmJpY2daWGhqWldWa2N5QnRZWGhwYlhWdElITjFjSEJ2Y25SbFpDQnphWHBsQUVHMHd3QUxmeUlDQUFCZEFnQUF3d0VBQU1RQkFBREZBUUFBeGdFQUFDY0NBQUFvQWdBQUtRSUFBTWNCQUFESUFRQUF5UUVBQU1vQkFBQmVBZ0FBWHdJQUFHRnNiRzlqWVhSdmNqeFVQam82WVd4c2IyTmhkR1VvYzJsNlpWOTBJRzRwSUNkdUp5QmxlR05sWldSeklHMWhlR2x0ZFcwZ2MzVndjRzl5ZEdWa0lITnBlbVVBUWJ6RUFBc1M2d0VBQUdBQ0FBQmhBZ0FBWWdJQUFHTUNBRUhZeEFBTE1qRUFBQUJrQWdBQXpBRUFBTTBCQUFET0FRQUF6d0VBQU5BQkFBRFJBUUFBMGdFQUFOTUJBQUJsQWdBQVpnSUFBTllCQUVHVXhRQUxMakVBQUFCbkFnQUEzQUVBQU4wQkFBRGVBUUFBR2dBQUFOQUJBQURSQVFBQTBnRUFBTk1CQUFEVUFRQUExUUVBUWN6RkFBczJNUUFBQUdnQ0FBRGdBUUFBNFFFQUFPSUJBQURqQVFBQTBBRUFBTkVCQUFEU0FRQUEwd0VBQUdrQ0FBQnFBZ0FBMWdFQUFPUUJBRUdNeGdBTExqRUFBQUJyQWdBQTVnRUFBT2NCQUFEZUFRQUE2QUVBQU5BQkFBRFJBUUFBMGdFQUFOTUJBQUJzQWdBQWJRSUFRY1RHQUF1YkFVQUFBQUJ1QWdBQUF3QUFBQVFBQUFBRkFBQUFCZ0FBQUFjQUFBQkdBQUFBQ1FBQUFBb0FBQUFMQUFBQURBQUFBQTBBQUFBT0FBQUFEd0FBQUJBQUFBQVJBQUFBRWdBQUFCTUFBQUJ2QWdBQWNBSUFBRWtBQUFCaGJHeHZZMkYwYjNJOFZENDZPbUZzYkc5allYUmxLSE5wZW1WZmRDQnVLU0FuYmljZ1pYaGpaV1ZrY3lCdFlYaHBiWFZ0SUhOMWNIQnZjblJsWkNCemFYcGxBRUhveHdBTFhrQUFBQUJ4QWdBQVFnQUFBRU1BQUFCRUFBQUFSUUFBQUFjQUFBQnlBZ0FBQ1FBQUFBb0FBQUFMQUFBQURBQUFBQTBBQUFBT0FBQUFEd0FBQUJBQUFBQVJBQUFBRWdBQUFCTUFBQUJIQUFBQVNBQUFBRWtBQUFCekFnQUFkQUlBUWRESUFBdVRBWFVDQUFCMkFnQUFUUUFBQUU0QUFBQlBBQUFBVUFBQUFBY0FBQUIzQWdBQUNRQUFBQW9BQUFBTEFBQUFlQUlBQUhrQ0FBQjZBZ0FBVVFBQUFGSUFBQUJUQUFBQVZBQUFBRlVBQUFCV0FBQUFZV3hzYjJOaGRHOXlQRlErT2pwaGJHeHZZMkYwWlNoemFYcGxYM1FnYmlrZ0oyNG5JR1Y0WTJWbFpITWdiV0Y0YVcxMWJTQnpkWEJ3YjNKMFpXUWdjMmw2WlFCQjdNa0FDMUVCQUFBQWV3SUFBRmdBQUFCWkFBQUFXZ0FBQUZzQUFBQjhBZ0FBZlFJQUFBa0FBQUFLQUFBQUN3QUFBQ0FBQUFBTkFBQUFJUUFBQUZ3QUFBQmRBQUFBWGdBQUFGOEFBQUJnQUFBQVlRQUFBR0lBUWNqS0FBdURBUUVBQUFCK0FnQUFaQUFBQUdVQUFBQm1BQUFBWndBQUFEZ0FBQUFmQUFBQUNRQUFBQW9BQUFBTEFBQUFJQUFBQUEwQUFBQWhBQUFBT1FBQUFEb0FBQUJoYkd4dlkyRjBiM0k4VkQ0Nk9tRnNiRzlqWVhSbEtITnBlbVZmZENCdUtTQW5iaWNnWlhoalpXVmtjeUJ0WVhocGJYVnRJSE4xY0hCdmNuUmxaQ0J6YVhwbEFFSFV5d0FMVGdFQUFBQi9BZ0FBZ0FJQUFJRUNBQUNDQWdBQWd3SUFBQWNBQUFBZkFBQUFDUUFBQUFvQUFBQUxBQUFBSUFBQUFBMEFBQUFoQUFBQWhBSUFBSVVDQUFDR0FnQUFod0lBQUlnQ0FBQ0pBZ0JCck13QUN3RVVBRUc0ekFBTElURUFBQUNLQWdBQWl3SUFBSXdDQUFDTkFnQUFqZ0lBQUM4QUFBQWZBQUFBTUFCQjVNd0FDeUV4QUFBQWp3SUFBSXNDQUFDTUFnQUFqUUlBQUk0Q0FBQXZBQUFBSHdBQUFEQUFRWkROQUFzNkFRQUFBSkFDQUFDUkFnQUFrZ0lBQUpNQ0FBQ1VBZ0FBQndBQUFCOEFBQUFKQUFBQUNnQUFBQXNBQUFBZ0FBQUFEUUFBQUNFQUFBQ1ZBZ0JCMU0wQUN6NEJBQUFBbGdJQUFKY0NBQUNZQWdBQW1RSUFBSm9DQUFBSEFBQUFId0FBQUFrQUFBQUtBQUFBQ3dBQUFDQUFBQUFOQUFBQUlRQUFBSnNDQUFDY0FnQkJuTTRBQzFvQkFBQUFuUUlBQUo0Q0FBQ2ZBZ0FBb0FJQUFMa0FBQUFIQUFBQUNBQUFBQWtBQUFBS0FBQUFDd0FBQUF3QUFBQU5BQUFBRGdBQUFBOEFBQUFRQUFBQUVRQUFBQklBQUFBVEFBQUFvd0FBQUtRQUFBQ2hBZ0FBb2dJQVFZRFBBQXNPb3dJQUFLUUNBQUNsQWdBQXBnSUFRWmpQQUFzT293SUFBS2NDQUFDb0FnQUFxUUlBUWJEUEFBc09vd0lBQUtvQ0FBQ29BZ0FBcVFJQVFjalBBQXNPb3dJQUFLc0NBQUNvQWdBQXJBSUFRZURQQUFzT293SUFBSzBDQUFDdUFnQUFxUUlBUWZqUEFBc09vd0lBQUs4Q0FBQ29BZ0FBcVFJQVFaRFFBQXNPb3dJQUFMQUNBQUN4QWdBQXNnSUFRYWpRQUFzT293SUFBTE1DQUFDMEFnQUF0UUlBUWNEUUFBc1Vvd0lBQUxZQ0FBQzNBZ0FBcVFJQUFBQUFnRDhBUWQ3UUFBc0NnRDhBUWZEUUFBdUhBYmdDQUFDNUFnQUFhUUFBQUdvQUFBQnJBQUFBYkFBQUFMb0NBQUM3QWdBQUNRQUFBQW9BQUFBTEFBQUF2QUlBQUEwQUFBQzlBZ0FBYlFBQUFHNEFBQUJ2QUFBQVlXeHNiMk5oZEc5eVBGUStPanBoYkd4dlkyRjBaU2h6YVhwbFgzUWdiaWtnSjI0bklHVjRZMlZsWkhNZ2JXRjRhVzExYlNCemRYQndiM0owWldRZ2MybDZaUUJCZ05JQUMxWUJBQUFBdmdJQUFIRUFBQUJ5QUFBQWN3QUFBSFFBQUFCMUFBQUFId0FBQUFrQUFBQUtBQUFBQ3dBQUFDQUFBQUFOQUFBQUlRQUFBSFlBQUFCM0FBQUFlQUFBQUw4Q0FBREFBZ0FBd1FJQUFNSUNBQUREQWdCQjROSUFDMW9CQUFBQXhBSUFBSWtBQUFDS0FBQUFpd0FBQUl3QUFBQjFBQUFBSHdBQUFBa0FBQUFLQUFBQUN3QUFBQ0FBQUFBTkFBQUFJUUFBQUhZQUFBQjNBQUFBZUFBQUFNVUNBQURHQWdBQXh3SUFBTWdDQUFESkFnQUF5Z0lBUWNUVEFBdFNBUUFBQU1zQ0FBQ1NBQUFBa3dBQUFKUUFBQUNWQUFBQWRRQUFBQjhBQUFBSkFBQUFDZ0FBQUFzQUFBQWdBQUFBRFFBQUFDRUFBQUIyQUFBQWR3QUFBSGdBQUFETUFnQUF6UUlBQU00Q0FBRFBBZ0JCb05RQUMwa0JBQUFBMEFJQUFIMEFBQUIrQUFBQWZ3QUFBQm9BQUFCMUFBQUFId0FBQUFrQUFBQUtBQUFBQ3dBQUFDQUFBQUFOQUFBQUlRQUFBSFlBQUFCM0FBQUFlQUFBQUJRQUFBQVVBRUgwMUFBTGVkRUNBQURTQWdBQW1nQUFBSnNBQUFDY0FBQUFuUUFBQUo0QUFBQ2ZBQUFBQ1FBQUFBb0FBQUFMQUFBQW9BQUFBS0VBQUFEVEFnQUFEd0FBQUJBQUFBQVJBQUFBRWdBQUFCTUFBQUNqQUFBQXBBQUFBS1VBQUFDbUFBQUFwd0FBQUtnQUFBQ3BBQUFBcWdBQUFLc0FBQUNzQUFBQXJRQUFBSzRBUWZqVkFBdDZtQUFBQU5RQ0FBRFZBZ0FBMWdJQUFKd0FBQUM1QUFBQW5nQUFBSjhBQUFBSkFBQUFDZ0FBQUFzQUFBQ2dBQUFBb1FBQUFLSUFBQUFQQUFBQUVBQUFBQkVBQUFBU0FBQUFFd0FBQUtNQUFBQ2tBQUFBcFFBQUFLWUFBQUNuQUFBQXFBQUFBS2tBQUFDcUFBQUExd0lBQU5nQ0FBRFpBZ0FBMmdJQVFmeldBQXNtMndJQUFOd0NBQURkQWdBQTNnSUFBTjhDQUFEZ0FnQUE0UUlBQU9JQ0FBRGpBZ0FBNUFJQVFhelhBQXRyNVFJQUFPWUNBQURuQWdBQUZBQUFBT2dDQUFEcEFnQUE2Z0lBQU9zQ0FBRHNBZ0FBRkFBQUFHRnNiRzlqWVhSdmNqeFVQam82WVd4c2IyTmhkR1VvYzJsNlpWOTBJRzRwSUNkdUp5QmxlR05sWldSeklHMWhlR2x0ZFcwZ2MzVndjRzl5ZEdWa0lITnBlbVVBUWFEWUFBc2w3UUlBQU80Q0FBQVVBQUFBRkFBQUFCUUFBQUFVQUFBQUZBQUFBQlFBQUFBVUFBQUFGQUJCME5nQUMzbVlBQUFBN3dJQUFOVUNBQURXQWdBQW5BQUFBTGtBQUFDZUFBQUFud0FBQUFrQUFBQUtBQUFBQ3dBQUFLQUFBQUNoQUFBQW9nQUFBQThBQUFBUUFBQUFFUUFBQUJJQUFBQVRBQUFBb3dBQUFLUUFBQUNsQUFBQXBnQUFBS2NBQUFDb0FBQUFxUUFBQUtvQUFBQ3JBQUFBckFBQUFLMEFBQUN1QUVIVTJRQUxyd0dZQUFBQThBSUFBTFlBQUFDM0FBQUF1QUFBQUxrQUFBQ2VBQUFBbndBQUFBa0FBQUFLQUFBQUN3QUFBS0FBQUFDaEFBQUFvZ0FBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQW93QUFBS1FBQUFDbEFBQUFwZ0FBQUtjQUFBQ29BQUFBcVFBQUFLb0FBQUJoYkd4dlkyRjBiM0k4VkQ0Nk9tRnNiRzlqWVhSbEtITnBlbVZmZENCdUtTQW5iaWNnWlhoalpXVmtjeUJ0WVhocGJYVnRJSE4xY0hCdmNuUmxaQ0J6YVhwbEFFR00yd0FMTnZFQ0FBRHlBZ0FBTFFBQUFDNEFBQUFwQUFBQUdnQUFBQWNBQUFBZkFBQUFDUUFBQUFvQUFBQUxBQUFBOHdJQUFBMEFBQUQwQWdCQnpOc0FDMEVCQUFBQTlRSUFBSVFBQUFDRkFBQUFmd0FBQUJvQUFBQjFBQUFBSHdBQUFBa0FBQUFLQUFBQUN3QUFBQ0FBQUFBTkFBQUFJUUFBQUlBQUFBQ0JBQUFBZ2dCQm1Od0FDMzZZQUFBQTlnSUFBTEFBQUFDeEFBQUFzZ0FBQUxNQUFBQ2VBQUFBbndBQUFBa0FBQUFLQUFBQUN3QUFBUGNDQUFDaEFBQUErQUlBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQW93QUFBS1FBQUFDbEFBQUFwZ0FBQUtjQUFBRDVBZ0FBK2dJQUFQc0NBQUMwQUFBQS9BSUFBR1QvLy84QUFBQUEvUUlBUWFEZEFBdlBBZFlBQUFEK0FnQUF1d0FBQUx3QUFBQzlBQUFBdmdBQUFKNEFBQUNmQUFBQUNRQUFBQW9BQUFBTEFBQUFvQUFBQUtFQUFBRGNBQUFBRHdBQUFCQUFBQUFSQUFBQUVnQUFBQk1BQUFDakFBQUFwQUFBQUtVQUFBQ21BQUFBcHdBQUFLZ0FBQUNwQUFBQXFnQUFBS3NBQUFDc0FBQUFyUUFBQUs0QUFBRGRBQUFBM2dBQUFOOEFBQURnQUFBQVlXeHNiMk5oZEc5eVBGUStPanBoYkd4dlkyRjBaU2h6YVhwbFgzUWdiaWtnSjI0bklHVjRZMlZsWkhNZ2JXRjRhVzExYlNCemRYQndiM0owWldRZ2MybDZaUUJCK040QUM0NEIvd0lBQUFBREFBRENBQUFBd3dBQUFNUUFBQURGQUFBQW5nQUFBSjhBQUFBSkFBQUFDZ0FBQUFzQUFBQ2dBQUFBb1FBQUFBRURBQUFQQUFBQUVBQUFBQkVBQUFBU0FBQUFFd0FBQUtNQUFBQ2tBQUFBcFFBQUFLWUFBQUNuQUFBQXFBQUFBS2tBQUFDcUFBQUFxd0FBQUt3QUFBQ3RBQUFBcmdBQUFNWUFBQUFDQXdBQUF3TUFBQVFEQUFBRkF3QkJrT0FBQzJZR0F3QUFCd01BQU0wQUFBRE9BQUFBendBQUFOQUFBQUFJQXdBQUNBQUFBQWtBQUFBS0FBQUFDd0FBQUFrREFBQU5BQUFBQ2dNQUFBOEFBQUFRQUFBQUVRQUFBQklBQUFBVEFBQUFvd0FBQUtRQUFBQ2xBQUFBcGdBQUFORUFBQURTQUFBQUN3TUFRWURoQUF1bkFRRUFBQUFNQXdBQTFBQUFBTlVBQUFEUEFBQUF1UUFBQUFjQUFBQUlBQUFBQ1FBQUFBb0FBQUFMQUFBQURBQUFBQTBBQUFBT0FBQUFEd0FBQUJBQUFBQVJBQUFBRWdBQUFCTUFBQUNqQUFBQXBBQUFBS1VBQUFDbUFBQUEwUUFBQU5JQUFBQmhiR3h2WTJGMGIzSThWRDQ2T21Gc2JHOWpZWFJsS0hOcGVtVmZkQ0J1S1NBbmJpY2daWGhqWldWa2N5QnRZWGhwYlhWdElITjFjSEJ2Y25SbFpDQnphWHBsQUVHdzRnQUxhK1VDQUFBTkF3QUE1d0lBQUE0REFBRG9BZ0FBNlFJQUFPb0NBQURyQWdBQTdBSUFBQThEQUFCaGJHeHZZMkYwYjNJOFZENDZPbUZzYkc5allYUmxLSE5wZW1WZmRDQnVLU0FuYmljZ1pYaGpaV1ZrY3lCdFlYaHBiWFZ0SUhOMWNIQnZjblJsWkNCemFYcGxBRUdrNHdBTGpnSFdBQUFBRUFNQUFOZ0FBQURaQUFBQTJnQUFBTnNBQUFDZUFBQUFud0FBQUFrQUFBQUtBQUFBQ3dBQUFLQUFBQUNoQUFBQUVRTUFBQThBQUFBUUFBQUFFUUFBQUJJQUFBQVRBQUFBb3dBQUFLUUFBQUNsQUFBQXBnQUFBS2NBQUFDb0FBQUFxUUFBQUtvQUFBQ3JBQUFBckFBQUFLMEFBQUN1QUFBQTNRQUFBTjRBQUFBU0F3QUFFd01BQUJRREFFRzg1QUFMUmdFQUFBQVZBd0FBNHdBQUFPUUFBQURsQUFBQTVnQUFBSFVBQUFBZkFBQUFDUUFBQUFvQUFBQUxBQUFBSUFBQUFBMEFBQUFoQUFBQWdBQUFBSUVBQUFDQ0FBQUFGZ01BUVl6bEFBdDVGd01BQUJnREFBRHBBQUFBNmdBQUFKd0FBQURyQUFBQW5nQUFBSjhBQUFBSkFBQUFDZ0FBQUFzQUFBQ2dBQUFBb1FBQUFCa0RBQUFQQUFBQUVBQUFBQkVBQUFBU0FBQUFFd0FBQUtNQUFBQ2tBQUFBcFFBQUFLWUFBQUNuQUFBQXFBQUFBS2tBQUFDcUFBQUFxd0FBQUt3QUFBQ3RBQUFBcmdCQmtPWUFDK3NCR2dNQUFCc0RBQUNBQWdBQWdRSUFBSUlDQUFDREFnQUFCd0FBQUI4QUFBQUpBQUFBQ2dBQUFBc0FBQUFnQUFBQUhBTUFBQjBEQUFDRUFnQUFoUUlBQUlZQ0FBQ0hBZ0FBaUFJQUFJa0NBQUFlQXdBQXVQLy8vd0FBQUFBZkF3QUFRWEowWW05aGNtUTZPbWx1YVhScFlXeHBlbVVnTFNCRWNtRjNJSEoxYkdVZ2RHRnlaMlYwY3lCdGFYTnphVzVuSUdOdmJYQnZibVZ1ZENCM2FXUjBhQ0JwWkNBbFpBb0FZV3hzYjJOaGRHOXlQRlErT2pwaGJHeHZZMkYwWlNoemFYcGxYM1FnYmlrZ0oyNG5JR1Y0WTJWbFpITWdiV0Y0YVcxMWJTQnpkWEJ3YjNKMFpXUWdjMmw2WlFCQmlPZ0FDNDRCQVFBQUFDQURBQUF0QUFBQUxnQUFBQ2tBQUFBYUFBQUFCd0FBQUI4QUFBQUpBQUFBQ2dBQUFBc0FBQUFnQUFBQURRQUFBQ0VBQUFCRVpYQmxibVJsYm1ONUlHTjVZMnhsSVFvQVlXeHNiMk5oZEc5eVBGUStPanBoYkd4dlkyRjBaU2h6YVhwbFgzUWdiaWtnSjI0bklHVjRZMlZsWkhNZ2JXRjRhVzExYlNCemRYQndiM0owWldRZ2MybDZaUUJCb09rQUN6b0JBQUFBSVFNQUFKRUNBQUNTQWdBQWt3SUFBSlFDQUFBaUF3QUFJd01BQUFrQUFBQUtBQUFBQ3dBQUFDQUFBQUFOQUFBQUlRQUFBQ1FEQUVIazZRQUx1d0lCQUFBQUpRTUFBSmNDQUFDWUFnQUFtUUlBQUpvQ0FBQW1Bd0FBSndNQUFBa0FBQUFLQUFBQUN3QUFBQ0FBQUFBTkFBQUFJUUFBQUpzQ0FBQW9Bd0FBWVd4c2IyTmhkRzl5UEZRK09qcGhiR3h2WTJGMFpTaHphWHBsWDNRZ2Jpa2dKMjRuSUdWNFkyVmxaSE1nYldGNGFXMTFiU0J6ZFhCd2IzSjBaV1FnYzJsNlpRQkNZV1FnYUdWaFpHVnlDZ0JWYm5OMWNIQnZjblJsWkNCMlpYSnphVzl1SUNWMUxpVjFJR1Y0Y0dWamRHVmtJQ1YxTGlWMUxnb0FVa2xXUlFCaGJHeHZZMkYwYjNJOFZENDZPbUZzYkc5allYUmxLSE5wZW1WZmRDQnVLU0FuYmljZ1pYaGpaV1ZrY3lCdFlYaHBiWFZ0SUhOMWNIQnZjblJsWkNCemFYcGxBQUJWYm10dWIzZHVJSEJ5YjNCbGNuUjVJR3RsZVNBbGJHeDFMQ0J0YVhOemFXNW5JR1p5YjIwZ2NISnZjR1Z5ZEhrZ1ZHOURMZ29BUWFqc0FBc3FNUUFBQUNrREFBRCtBUUFBL3dFQUFBQUNBQUFhQUFBQUx3QUFBQjhBQUFEMEFRQUE5UUVBQUFRQ0FFSGM3QUFMSmpFQUFBQXFBd0FBOFFFQUFQSUJBQUR6QVFBQUdnQUFBQzhBQUFBZkFBQUFNQUFBQVBVQkFFR003UUFMSmdVQ0FBQXJBd0FBR0FJQUFCa0NBQUJLQVFBQUdnQUFBRUlCQUFCREFRQUFSQUVBQUVVQkFFRzg3UUFMSmp3QkFBQXNBd0FBRGdJQUFBOENBQUJLQVFBQUdnQUFBRUlCQUFCREFRQUFSQUVBQUVVQkFFSHM3UUFMS2dVQ0FBQXRBd0FBQndJQUFBZ0NBQUFKQWdBQUdnQUFBRUlCQUFCREFRQUFSQUVBQUVVQkFBQU1BZ0JCb080QUN6NGlBZ0FBTGdNQUFDUUNBQUFsQWdBQUpnSUFBTVlCQUFBbkFnQUFLQUlBQUNrQ0FBREhBUUFBeUFFQUFNa0JBQURLQVFBQVhnSUFBRjhDQUFBc0FnQkI2TzRBQzdrQk1RQUFBQzhEQUFEM0FRQUErQUVBQVBrQkFBQWFBQUFBTHdBQUFCOEFBQUQwQVFBQTlRRUFBUHdCQUFBQkFBQUFBQUFBQVAvLy8vOENBQUFBQWdBQUFBSUFBQUFDQUFBQUFnQUFBQUlBQUFBQ0FBQUFBZ0FBQUFJQUFBQUNBQUFBQWdBQUFBSUFBQUQvLy8vL0FnQUFBQUlBQUFELy8vLy9BQUFBQUFJQUFBQUNBQUFBQWdBQUFQLy8vLy8vLy8vLy8vLy8vLy8vLy84Q0FBQUFBQUFBQUFJQUFBQUNBQUFBQWdBQUFQLy8vLzhEQUFBQUF3QUFBQUlBUWF6d0FBc1ZBZ0FBQVAvLy8vLy8vLy8vLy8vLy93SUFBQUFDQUVIVThBQUxEZi8vLy84QUFBQUEvLy8vL3dFQVFlendBQXNCQWdCQmdQRUFDdzBDQUFBQUFnQUFBQUlBQUFBQ0FFR2M4UUFMVlFJQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL3dJQUFBQUNBQUFBQWdBQUFBSUFBQUFDQUFBQUFnQUFBQUlBQUFBQ0FBQUFBZ0FBQUFNQUFBQUNBQUFBQWdBQUFBSUFRWVR5QUFzVkFnQUFBQUlBQUFBQ0FBQUFBZ0FBQUFJQUFBQUNBRUdrOGdBTEZRSUFBQUFDQUFBQUFnQUFBQUlBQUFBQ0FBQUFBZ0JCelBJQUN4UUNBQUFBQWdBQUFBSUFBQUFBQUFBQS8vLy8vd0JCOFBJQUN4RUNBQUFBQWdBQUFBQUFBQUFDQUFBQUFnQkJqUE1BQzRVQi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzhCQUFBQS8vLy8vd0lBQUFBQUFBQUEvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vd0FBQUFELy8vLy9BQUFBQUFBQUFBRC8vLy8vLy8vLy93QUFBQUFBQUFBQUFnQUFBQUFBQUFELy8vLy9BQUFBQUFJQUFBQUNBQUFBQWdCQm5QUUFDd0VDQUVHbzlBQUxLUC8vLy8vLy8vLy9BQUFBQUFBQWdMOEFBSUMvQUFBQUFBQUFnTDhBQUlBL0FBQ0F2d0FBZ0w4QVFkNzBBQXQvZ0Q4QUFBQUFBQUNBdndBQWdEOEFBQUFBQUFDQVB3QUFnRDhBQUlBL0FBQUFBQUFBQUFBQkFBQUFNQU1BQUo0Q0FBQ2ZBZ0FBb0FJQUFMa0FBQUFIQUFBQUNBQUFBQWtBQUFBS0FBQUFDd0FBQUF3QUFBQU5BQUFBRGdBQUFBOEFBQUFRQUFBQUVRQUFBQklBQUFBVEFBQUFvd0FBQUtRQUFBQ2xBQUFBcGdCQjZQVUFDMUVCQUFBQU1RTUFBQjBBQUFBZUFBQUFHUUFBQUJvQUFBQUhBQUFBQ0FBQUFBa0FBQUFLQUFBQUN3QUFBQXdBQUFBTkFBQUFEZ0FBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQUZBQUFBQlFBUWNUMkFBdE43QUFBQURJREFBRHVBQUFBN3dBQUFQQUFBQUR4QUFBQUJ3QUFBUElBQUFBSkFBQUFDZ0FBQUFzQUFBQWdBQUFBRFFBQUFDRUFBQUR6QUFBQTlBQUFBRE1EQUFBMEF3QUFOUU1BQVBZQVFaejNBQXMrQVFBQUFEWURBQUQ4QUFBQS9RQUFBUDRBQUFEL0FBQUFOd01BQUI4QUFBQUpBQUFBQ2dBQUFBc0FBQUFnQUFBQURRQUFBQ0VBQUFBNEF3QUFPUU1BUWVUM0FBdWpBUXdCQUFBN0F3QUFBd0VBQUFRQkFBQUZBUUFBQmdFQUFCRUJBQUFmQUFBQUNRQUFBQW9BQUFBTEFBQUFFZ0VBQUEwQUFBQVRBUUFBRkFFQUFCVUJBQUFXQVFBQUZ3RUFBQmdCQUFBWkFRQUFHZ0VBQUx6Ly8vOEFBQUFBR3dFQUFHRnNiRzlqWVhSdmNqeFVQam82WVd4c2IyTmhkR1VvYzJsNlpWOTBJRzRwSUNkdUp5QmxlR05sWldSeklHMWhlR2x0ZFcwZ2MzVndjRzl5ZEdWa0lITnBlbVVBUVpENUFBdGVEQUVBQUR3REFBQU9BUUFBRHdFQUFBVUJBQUFRQVFBQUVRRUFBQjhBQUFBSkFBQUFDZ0FBQUFzQUFBQVNBUUFBRFFBQUFCTUJBQUFVQVFBQUZRRUFBQllCQUFBWEFRQUFHQUVBQUJrQkFBQTlBd0FBdlAvLy93QUFBQUFiQVFCQitQa0FDMG5zQUFBQVBnTUFBUGdBQUFENUFBQUErZ0FBQUJvQUFBQUhBQUFBOGdBQUFBa0FBQUFLQUFBQUN3QUFBQ0FBQUFBTkFBQUFJUUFBQVBNQUFBRDBBQUFBOVFBQUFCUUFBQUFVQUVITStnQUxTZ0VBQUFBL0F3QUFIUUVBQUI0QkFBQWZBUUFBSUFFQUFFQURBQUFmQUFBQUNRQUFBQW9BQUFBTEFBQUFJQUFBQUEwQUFBQWhBQUFBUVFNQUFFSURBQURNLy8vL0FBQUFBRU1EQUVHZyt3QUxXdXdBQUFCRUF3QUFJd0VBQUNRQkFBQWxBUUFBSmdFQUFBY0FBQUR5QUFBQUNRQUFBQW9BQUFBTEFBQUFJQUFBQUEwQUFBQWhBQUFBUlFNQUFQUUFBQUJHQXdBQVJ3TUFBRWdEQUFCSkF3QUFTZ01BQUVzREFBQXFBUUJCaFB3QUMxNU1Bd0FBVFFNQUFDd0JBQUF0QVFBQUxnRUFBQzhCQUFBSEFBQUFUZ01BQUFrQUFBQUtBQUFBQ3dBQUFDQUFBQUFOQUFBQUlRQUFBRThEQUFCUUF3QUFVUU1BQUZJREFBQlRBd0FBVkFNQUFNRC8vLzhBQUFBQVZRTUFBRllEQUVIcy9BQUx4QXdVQUFBQUZBQUFBSEpsYm1SbGNrWmhZM1J2Y25rQWJXRnJaVkpsYm1SbGNsQmhhVzUwQUcxaGEyVlNaVzVrWlhKUVlYUm9BR0o1ZEdWTVpXNW5kR2dBYzJWMEFHeHZZV1FBVW1WdVpHVnlaWElBYzJGMlpRQnlaWE4wYjNKbEFIUnlZVzV6Wm05eWJRQmtjbUYzVUdGMGFBQmpiR2x3VUdGMGFBQmhiR2xuYmdCU1pXNWtaWEpsY2xkeVlYQndaWElBVW1WdVpHVnlVR0YwYUFCeVpYTmxkQUJoWkdSUVlYUm9BR1pwYkd4U2RXeGxBRzF2ZG1WVWJ3QnNhVzVsVkc4QVkzVmlhV05VYndCamJHOXpaUUJTWlc1a1pYSlFZWFJvVjNKaGNIQmxjZ0JTWlc1a1pYSlFZV2x1ZEZOMGVXeGxBR1pwYkd3QWMzUnliMnRsQUVacGJHeFNkV3hsQUc1dmJscGxjbThBWlhabGJrOWtaQUJUZEhKdmEyVkRZWEFBWW5WMGRBQnliM1Z1WkFCemNYVmhjbVVBVTNSeWIydGxTbTlwYmdCdGFYUmxjZ0JpWlhabGJBQkNiR1Z1WkUxdlpHVUFjM0pqVDNabGNnQnpZM0psWlc0QWIzWmxjbXhoZVFCa1lYSnJaVzRBYkdsbmFIUmxiZ0JqYjJ4dmNrUnZaR2RsQUdOdmJHOXlRblZ5YmdCb1lYSmtUR2xuYUhRQWMyOW1kRXhwWjJoMEFHUnBabVpsY21WdVkyVUFaWGhqYkhWemFXOXVBRzExYkhScGNHeDVBR2gxWlFCellYUjFjbUYwYVc5dUFHTnZiRzl5QUd4MWJXbHViM05wZEhrQVVtVnVaR1Z5VUdGcGJuUUFjM1I1YkdVQWRHaHBZMnR1WlhOekFHcHZhVzRBWTJGd0FHSnNaVzVrVFc5a1pRQnNhVzVsWVhKSGNtRmthV1Z1ZEFCeVlXUnBZV3hIY21Ga2FXVnVkQUJoWkdSVGRHOXdBR052YlhCc1pYUmxSM0poWkdsbGJuUUFVbVZ1WkdWeVVHRnBiblJYY21Gd2NHVnlBRTFoZERKRUFIaDRBSGg1QUhsNEFIbDVBSFI0QUhSNUFFWnBiR1VBWkdWbVlYVnNkRUZ5ZEdKdllYSmtBR0Z5ZEdKdllYSmtRbmxPWVcxbEFHRnlkR0p2WVhKa1FubEpibVJsZUFCaGNuUmliMkZ5WkVOdmRXNTBBRUZ5ZEdKdllYSmtBRzVoYldVQVlXUjJZVzVqWlFCa2NtRjNBSFJ5WVc1elptOXliVU52YlhCdmJtVnVkQUJ1YjJSbEFHSnZibVVBY205dmRFSnZibVVBWVc1cGJXRjBhVzl1UW5sSmJtUmxlQUJoYm1sdFlYUnBiMjVDZVU1aGJXVUFZVzVwYldGMGFXOXVRMjkxYm5RQWMzUmhkR1ZOWVdOb2FXNWxRbmxKYm1SbGVBQnpkR0YwWlUxaFkyaHBibVZDZVU1aGJXVUFjM1JoZEdWTllXTm9hVzVsUTI5MWJuUUFZbTkxYm1SekFHbHVjM1JoYm1ObEFGUnlZVzV6Wm05eWJVTnZiWEJ2Ym1WdWRBQnpZMkZzWlZnQWMyTmhiR1ZaQUhKdmRHRjBhVzl1QUU1dlpHVUFlQUI1QUVKdmJtVUFiR1Z1WjNSb0FGSnZiM1JDYjI1bEFFRnVhVzFoZEdsdmJnQk1hVzVsWVhKQmJtbHRZWFJwYjI0QVpIVnlZWFJwYjI0QVpuQnpBSGR2Y210VGRHRnlkQUIzYjNKclJXNWtBR1Z1WVdKc1pWZHZjbXRCY21WaEFHeHZiM0JXWVd4MVpRQnpjR1ZsWkFCaGNIQnNlUUJNYVc1bFlYSkJibWx0WVhScGIyNUpibk4wWVc1alpRQjBhVzFsQUdScFpFeHZiM0FBVTNSaGRHVk5ZV05vYVc1bEFGTjBZWFJsVFdGamFHbHVaVWx1YzNSaGJtTmxBR2x1Y0hWMFEyOTFiblFBYVc1d2RYUUFjM1JoZEdWRGFHRnVaMlZrUTI5MWJuUUFjM1JoZEdWRGFHRnVaMlZrVG1GdFpVSjVTVzVrWlhnQVUwMUpTVzV3ZFhRQWRIbHdaUUJpYjI5c0FBQTdBRzUxYldKbGNnQUFPQUIwY21sbloyVnlBRG9BWVhOQ2IyOXNBR0Z6VG5WdFltVnlBR0Z6VkhKcFoyZGxjZ0JUVFVsQ2IyOXNBSFpoYkhWbEFGTk5TVTUxYldKbGNnQlRUVWxVY21sbloyVnlBR1pwY21VQVJtbDBBR052Ym5SaGFXNEFZMjkyWlhJQVptbDBWMmxrZEdnQVptbDBTR1ZwWjJoMEFHNXZibVVBYzJOaGJHVkViM2R1QUVGc2FXZHViV1Z1ZEFCMGIzQk1aV1owQUhSdmNFTmxiblJsY2dCMGIzQlNhV2RvZEFCalpXNTBaWEpNWldaMEFHTmxiblJsY2dCalpXNTBaWEpTYVdkb2RBQmliM1IwYjIxTVpXWjBBR0p2ZEhSdmJVTmxiblJsY2dCaWIzUjBiMjFTYVdkb2RBQkJRVUpDQUcxcGJsZ0FiV2x1V1FCdFlYaFlBRzFoZUZrQUFBQmtYd0FBWlY4QUFHWmZBQUJuWHdBQVlXeHNiMk5oZEc5eVBGUStPanBoYkd4dlkyRjBaU2h6YVhwbFgzUWdiaWtnSjI0bklHVjRZMlZsWkhNZ2JXRjRhVzExYlNCemRYQndiM0owWldRZ2MybDZaUUIwWHdBQVpGOEFBSFZmQUFCa1h3QUFhV2xwQUdscEFIWUFkbWtBZEY4QUFIcGZBQUIyYVdrQWRGOEFBSHBmQUFCN1h3QUFkbWxwYVFCQndJa0JDeUowWHdBQWVsOEFBR1pmQUFCbFh3QUFkbWxwYVdrQUFBQjBYd0FBZWw4QUFHWmZBRUh3aVFFTFZuUmZBQUIzWHdBQWZGOEFBSDFmQUFCK1h3QUFmbDhBQUhacGFXbHBhV2tBYm05MGFXWjVUMjVFWlhOMGNuVmpkR2x2YmdCcGJYQnNaVzFsYm5RQVpYaDBaVzVrQUFBQUFIUmZBQUI1WHdBQWVsOEFBR1JmQUVIUWlnRUxHa1FFQUFCRkJBQUFSZ1FBQUVjRUFBQklCQUFBU1FRQUFFb0VBRUgwaWdFTEdVUUVBQUJMQkFBQUZBQUFBQlFBQUFBVUFBQUFGQUFBQUJRQVFaaUxBUXVkQVV3RUFBQk5CQUFBRkFBQUFCUUFBQUFVQUFBQUZBQUFBQlFBQUFCZlgyUmxjM1J5ZFdOMEFBQjBYd0FBZEY4QUFIdGZBQUIwWHdBQVpsOEFBR1ZmQUFCMFh3QUFabDhBQUdSZkFBQ2dYd0FBWkY4QUFHbHBhV2tBQUFBQWRGOEFBS1JmQUFBQUFBQUFkRjhBQUtSZkFBQm1Yd0FBZTE4QUFIUmZBQUNrWHdBQXBWOEFBQUFBQUFCMFh3QUFwRjhBQUtaZkFBQ21Yd0FBZG1scFptWUFRY0NNQVFzNmRGOEFBS1JmQUFDbVh3QUFwbDhBQUtaZkFBQ21Yd0FBcGw4QUFLWmZBQUIyYVdsbVptWm1abVlBQUFCMFh3QUFvMThBQUtSZkFBQmtYd0JCaEkwQkN5cE9CQUFBVHdRQUFGQUVBQUJSQkFBQVVnUUFBRk1FQUFCVUJBQUFWUVFBQUZZRUFBQlhCQUFBV0FRQVFiaU5BUXNwVGdRQUFGa0VBQUFVQUFBQUZBQUFBRklFQUFBVUFBQUFGQUFBQUJRQUFBQVVBQUFBVndRQUFCUUFRZXlOQVF1NkFlMENBQUJhQkFBQUZBQUFBQlFBQUFCU0JBQUFGQUFBQUJRQUFBQVVBQUFBRkFBQUFGY0VBQUFVQUFBQWRGOEFBS1ZmQUFCMFh3QUFwbDhBQUtaZkFBQUFBQUFBZEY4QUFLWmZBQUNtWHdBQXBsOEFBS1pmQUFDbVh3QUFwbDhBQUhSZkFBQm1Yd0FBZTE4QUFIUmZBQURQWHdBQVoxOEFBSFJmQUFEUFh3QUF5RjhBQUhSZkFBRFBYd0FBcGw4QUFIWnBhV1lBQUFBQWRGOEFBTTlmQUFES1h3QUFkRjhBQU05ZkFBREpYd0FBZEY4QUFNOWZBQURMWHdCQnNJOEJDMDUwWHdBQXoxOEFBS1pmQUFDbVh3QUFwbDhBQUtaZkFBQjJhV2xtWm1abUFIUmZBQURQWHdBQVoxOEFBS1pmQUFCMmFXbHBaZ0FBQUhSZkFBRFBYd0FBZEY4QUFNNWZBQURQWHdBQVpGOEFRWWlRQVFzdVd3UUFBRndFQUFCZEJBQUFYZ1FBQUY4RUFBQmdCQUFBWVFRQUFHSUVBQUJqQkFBQVpBUUFBR1VFQUFCbUJBQkJ3SkFCQ3k0VUFBQUFGQUFBQUJRQUFBQVVBQUFBRkFBQUFCUUFBQUFVQUFBQUZBQUFBQlFBQUFBVUFBQUFaUVFBQUdjRUFFSDRrQUVMWGhRQUFBQVVBQUFBRkFBQUFCUUFBQUFVQUFBQUZBQUFBQlFBQUFBVUFBQUFGQUFBQUJRQUFBQm9CQUFBYVFRQUFIUmZBQURJWHdBQWRGOEFBR2RmQUFCMFh3QUFwbDhBQUhSZkFBREtYd0FBZEY4QUFNbGZBQUIwWHdBQXkxOEFRZUNSQVF1VUFuUmZBQUNtWHdBQXBsOEFBS1pmQUFDbVh3QUFkRjhBQUdkZkFBQ21Yd0FBWm1scEFCaGdBQUFYWUFBQUdHQUFBQmRnQUFDZ1h3QUFHR0FBQUJkZ0FBQVpZQUFBR1dBQUFCZGdBQUFjWUFBQUdHQUFBQjFnQUFCcGFXbGtBQUFBQUhSZkFBQVlZQUFBZDE4QUFCNWdBQUFZWUFBQW9GOEFBQjlnQUFBWVlBQUFvRjhBQUNCZ0FBQVlZQUFBb0Y4QUFDRmdBQUFZWUFBQW9GOEFBQ0pnQUFBYllBQUFHV0FBQUNKZ0FBQWJZQUFBb0Y4QUFCbGdBQUFiWUFBQUkyQUFBQnRnQUFBWllBQUFJMkFBQUJ0Z0FBQ2dYd0FBR0dBQUFCdGdBQUFBQUFBQWRGOEFBREJnQUFBWVlBQUFwbDhBQUtaZkFBQjJhV2xwWm1ZQUFETmdBQUFpWUFBQUhHQUFBRE5nQUFDbVh3QUFhV2xwWmdCQmdKUUJDeFowWHdBQU5HQUFBQmhnQUFDbVh3QUFPR0FBQUNOZ0FFR2dsQUVMNXh3Y1lBQUFPR0FBQUJoZ0FBQ21Yd0FBYVdscGFXWUFBQUFaWUFBQU9XQUFBRHBnQUFBNVlBQUFHV0FBQUdWdWRISjVBR1Y0YVhRQVlXNTVBSFZ1YTI1dmQyNEFBS0JmQUFBM1lBQUFHV0FBQUQ1Z0FBQTdZQUFBUDJBQUFEdGdBQUJBWUFBQU8yQUFBSFJmQUFCQVlBQUFhUUFsY0FCMmIybGtBR0p2YjJ3QVkyaGhjZ0J6YVdkdVpXUWdZMmhoY2dCMWJuTnBaMjVsWkNCamFHRnlBSE5vYjNKMEFIVnVjMmxuYm1Wa0lITm9iM0owQUdsdWRBQjFibk5wWjI1bFpDQnBiblFBYkc5dVp3QjFibk5wWjI1bFpDQnNiMjVuQUdac2IyRjBBR1J2ZFdKc1pRQnpkR1E2T25OMGNtbHVad0J6ZEdRNk9tSmhjMmxqWDNOMGNtbHVaengxYm5OcFoyNWxaQ0JqYUdGeVBnQnpkR1E2T25kemRISnBibWNBYzNSa09qcDFNVFp6ZEhKcGJtY0FjM1JrT2pwMU16SnpkSEpwYm1jQVpXMXpZM0pwY0hSbGJqbzZkbUZzQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR05vWVhJK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhOcFoyNWxaQ0JqYUdGeVBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWJuTnBaMjVsWkNCamFHRnlQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHphRzl5ZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4ZFc1emFXZHVaV1FnYzJodmNuUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BHbHVkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkVzV6YVdkdVpXUWdhVzUwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhzYjI1blBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWJuTnBaMjVsWkNCc2IyNW5QZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHBiblE0WDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhWcGJuUTRYM1ErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR2x1ZERFMlgzUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnBiblF4Tmw5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4cGJuUXpNbDkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYVc1ME16SmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhabXh2WVhRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdSdmRXSnNaVDRBQUFBQUFBQURBQUFBQkFBQUFBUUFBQUFHQUFBQWcvbWlBRVJPYmdEOEtSVUEwVmNuQU4wMDlRQmkyOEFBUEptVkFFR1FRd0JqVWY0QXU5NnJBTGRoeFFBNmJpUUEwazFDQUVrRzRBQUo2aTRBSEpMUkFPc2QvZ0Fwc1J3QTZENm5BUFUxZ2dCRXV5NEFuT21FQUxRbWNBQkJmbDhBMXBFNUFGT0RPUUNjOURrQWkxK0VBQ2o1dlFENEh6c0EzditYQUErWUJRQVJMKzhBQ2xxTEFHMGZiUURQZmpZQUNjc25BRVpQdHdDZVpqOEFMZXBmQUxvbmRRRGw2OGNBUFh2eEFQYzVCd0NTVW9vQSsydnFBQit4WHdBSVhZMEFNQU5XQUh2OFJnRHdxMnNBSUx6UEFEYjBtZ0RqcVIwQVhtR1JBQWdiNWdDRm1XVUFvQlJmQUkxQWFBQ0EyUDhBSjNOTkFBWUdNUURLVmhVQXlhaHpBSHZpWUFCcmpNQUFHY1JIQU0xbnd3QUo2TndBV1lNcUFJdDJ4QUNtSEpZQVJLL2RBQmxYMFFDbFBnVUFCUWYvQUROK1B3RENNdWdBbUUvZUFMdDlNZ0FtUGNNQUhtdnZBSi80WGdBMUh6b0FmL0xLQVBHSEhRQjhrQ0VBYWlSOEFOVnUrZ0F3TFhjQUZUdERBTFVVeGdEREdaMEFyY1RDQUN4TlFRQU1BRjBBaG4xR0FPTnhMUUNieHBvQU0ySUFBTFRTZkFDMHA1Y0FOMVhWQU5jKzlnQ2pFQmdBVFhiOEFHU2RLZ0J3MTZzQVkzejRBSHF3VndBWEZlY0F3RWxXQUR2VzJRQ25oRGdBSkNQTEFOYUtkd0JhVkNNQUFCKzVBUEVLR3dBWnp0OEFuekgvQUdZZWFnQ1pWMkVBclB0SEFINS8yQUFpWmJjQU11aUpBT2EvWUFEdnhNMEFiRFlKQUYwLzFBQVczdGNBV0R2ZUFONmJrZ0RTSWlnQUtJYm9BT0pZVFFER3lqSUFDT01XQU9COXl3QVh3RkFBOHgybkFCamdXd0F1RXpRQWd4SmlBSU5JQVFEMWpsc0FyYkIvQUI3cDhnQklTa01BRUdmVEFLcmQyQUN1WDBJQWFtSE9BQW9vcEFEVG1iUUFCcWJ5QUZ4M2Z3Q2p3b01BWVR5SUFJcHplQUN2akZvQWI5ZTlBQzJtWXdEMHY4c0FqWUh2QUNiQlp3QlZ5a1VBeXRrMkFDaW8wZ0RDWVkwQUVzbDNBQVFtRkFBU1Jwc0F4Rm5FQU1qRlJBQk5zcEVBQUJmekFOUkRyUUFwU2VVQS9kVVFBQUMrL0FBZWxNd0FjTTd1QUJNKzlRRHM4WUFBcytmREFNZjRLQUNUQlpRQXdYRStBQzRKc3dBTFJmTUFpQktjQUtzZ2V3QXV0WjhBUjVMQ0FIc3lMd0FNVlcwQWNxZVFBR3ZuSHdBeHk1WUFlUlpLQUVGNTRnRDAzNGtBNkpTWEFPTG1oQUNaTVpjQWlPMXJBRjlmTmdDNy9RNEFTSnEwQUdla2JBQnhja0lBalYweUFKOFZ1QUM4NVFrQWpURWxBUGQwT1FBd0JSd0FEUXdCQUVzSWFBQXM3bGdBUjZxUUFIVG5BZ0M5MWlRQTkzMm1BRzVJY2dDZkZ1OEFqcFNtQUxTUjlnRFJVMUVBendyeUFDQ1lNd0QxUzM0QXNtTm9BTjArWHdCQVhRTUFoWWwvQUZWU0tRQTNaTUFBYmRnUUFESklNZ0JiVEhVQVRuSFVBRVZVYmdBTENjRUFLdlZwQUJSbTFRQW5CNTBBWFFSUUFMUTcyd0RxZHNVQWgva1hBRWxyZlFBZEo3b0FsbWtwQU1iTXJBQ3RGRlFBa09KcUFJalppUUFzY2xBQUJLUytBSGNIbEFEek1IQUFBUHduQU9weHFBQm13a2tBWk9BOUFKZmRnd0NqUDVjQVE1VDlBQTJHakFBeFFkNEFram1kQU4xd2pBQVh0K2NBQ044N0FCVTNLd0JjZ0tBQVdvQ1RBQkFSa2dBUDZOZ0FiSUN2QU52L1N3QTRrQThBV1JoMkFHS2xGUUJoeTdzQXg0bTVBQkJBdlFEUzhnUUFTWFVuQU91MjlnRGJJcnNBQ2hTcUFJa21Md0JrZzNZQUNUc3pBQTZVR2dCUk9xb0FIYVBDQUsvdHJnQmNKaElBYmNKTkFDMTZuQURBVnBjQUF6K0RBQW53OWdBclFJd0FiVEdaQURtMEJ3QU1JQlVBMk1OYkFQV1N4QURHclVzQVRzcWxBS2MzelFEbXFUWUFxNUtVQU4xQ2FBQVpZOTRBZG96dkFHaUxVZ0Q4MnpjQXJxR3JBTjhWTVFBQXJxRUFEUHZhQUdSTlpnRHRCYmNBS1dVd0FGZFd2d0JIL3pvQWF2bTVBSFcrOHdBb2s5OEFxNEF3QUdhTTlnQUV5eFVBK2lJR0FObmtIUUE5czZRQVZ4dVBBRGJOQ1FCT1F1a0FFNzZrQURNanRRRHdxaG9BVDJXb0FOTEJwUUFMUHc4QVczak5BQ1A1ZGdCN2l3UUFpUmR5QU1hbVV3QnZidUlBNytzQUFKdEtXQURFMnJjQXFtYTZBSGJQendEUkFoMEFzZkV0QUl5WndRRERyWGNBaGtqYUFQZGRvQURHZ1BRQXJQQXZBTjNzbWdBL1hMd0EwTjV0QUpESEh3QXEyN1lBb3lVNkFBQ3ZtZ0N0VTVNQXRsY0VBQ2t0dEFCTGdINEEyZ2VuQUhhcURnQjdXYUVBRmhJcUFOeTNMUUQ2NWYwQWlkditBSW0rL1FEa2Rtd0FCcW44QUQ2QWNBQ0ZiaFVBL1lmL0FDZytCd0JoWnpNQUtoaUdBRTI5NmdDejU2OEFqMjF1QUpWbk9RQXh2MXNBaE5kSUFERGZGZ0RITFVNQUpXRTFBTWx3emdBd3k3Z0F2Mno5QUtRQW9nQUZiT1FBV3QyZ0FDRnZSd0JpRXRJQXVWeUVBSEJoU1FCclZ1QUFtVklCQUZCVk53QWUxYmNBTS9IRUFCTnVYd0JkTU9RQWhTNnBBQjJ5d3dDaE1qWUFDTGVrQU9xeDFBQVc5eUVBajJua0FDZi9kd0FNQTRBQWpVQXRBRS9Ob0FBZ3Baa0FzNkxUQUM5ZENnQzArVUlBRWRyTEFIMiswQUNiMjhFQXF4ZTlBTXFpZ1FBSWFsd0FMbFVYQUNjQVZRQi9GUEFBNFFlR0FCUUxaQUNXUVkwQWg3N2VBTnI5S2dCckpiWUFlNGswQUFYei9nQzV2NTRBYUdwUEFFb3FxQUJQeEZvQUxmaThBTmRhbUFEMHg1VUFEVTJOQUNBNnBnQ2tWMThBRkQreEFJQTRsUURNSUFFQWNkMkdBTW5ldGdDL1lQVUFUV1VSQUFFSGF3Q01zS3dBc3NEUUFGRlZTQUFlK3c0QWxYTERBS01HT3dEQVFEVUFCdHg3QU9CRnpBQk9LZm9BMXNySUFPanpRUUI4Wk40QW0yVFlBTm0rTVFDa2w4TUFkMWpVQUduanhRRHcyaE1BdWpvOEFFWVlSZ0JWZFY4QTByMzFBRzZTeGdDc0xsMEFEa1R0QUJ3K1FnQmh4SWNBS2YzcEFPZlc4d0FpZk1vQWI1RTFBQWpneFFELzE0MEFibXJpQUxEOXhnQ1RDTUVBZkYxMEFHdXRzZ0ROYnAwQVBuSjdBTVlSYWdEM3o2a0FLWFBmQUxYSnVnQzNBRkVBNHJJTkFIUzZKQURsZldBQWROaUtBQTBWTEFDQkdBd0FmbWFVQUFFcEZnQ2ZlbllBL2YyK0FGWkY3d0RaZmpZQTdOa1RBSXU2dVFERWwvd0FNYWduQVBGdXd3Q1V4VFlBMktoV0FMU290UURQekE0QUVva3RBRzlYTkFBc1Zva0FtYzdqQU5ZZ3VRQnJYcW9BUGlxY0FCRmZ6QUQ5QzBvQTRmVDdBSTQ3YlFEaWhpd0E2ZFNFQVB5MHFRRHY3dEVBTGpYSkFDODVZUUE0SVVRQUc5bklBSUg4Q2dEN1Ntb0FMeHpZQUZPMGhBQk9tWXdBVkNMTUFDcFYzQURBeHRZQUN4bVdBQnB3dUFCcGxXUUFKbHBnQUQ5UzdnQi9FUThBOUxVUkFQekw5UUEwdkMwQU5MenVBT2hkekFEZFhtQUFaNDZiQUpJejd3REpGN2dBWVZpYkFPRlh2QUJSZzhZQTJENFFBTjF4U0FBdEhOMEFyeGloQUNFc1JnQlo4OWNBMlhxWUFKNVV3QUJQaHZvQVZnYjhBT1Y1cmdDSklqWUFPSzBpQUdlVDNBQlY2S29BZ2lZNEFNcm5td0JSRGFRQW1UT3hBS25YRGdCcEJVZ0FaYkx3QUgrSXB3Q0lUSmNBK2RFMkFDR1Nzd0I3Z2tvQW1NOGhBRUNmM0FEY1IxVUE0WFE2QUdmclFnRCtuZDhBWHRSZkFIdG5wQUM2ckhvQVZmYWlBQ3VJSXdCQnVsVUFXVzRJQUNFcWhnQTVSNE1BaWVQbUFPV2UxQUJKKzBBQS8xYnBBQndQeWdERldZb0FsUG9yQU5QQnhRQVB4YzhBMjFxdUFFZkZoZ0NGUTJJQUlZWTdBQ3g1bEFBUVlZY0FLa3g3QUlBc0dnQkR2eElBaUNhUUFIZzhpUUNveE9RQTVkdDdBTVE2d2dBbTlPb0E5MmVLQUEyU3Z3QmxveXNBUFpPeEFMMThDd0NrVWR3QUo5MWpBR25oM1FDYWxCa0FxQ21WQUdqT0tBQUo3YlFBUko4Z0FFNll5Z0J3Z21NQWZud2pBQSs1TWdDbjlZNEFGRmJuQUNIeENBQzFuU29BYjM1TkFLVVpVUUMxK2FzQWd0L1dBSmJkWVFBV05nSUF4RHFmQUlPaW9RQnk3VzBBT1kxNkFJSzRxUUJyTWx3QVJpZGJBQUEwN1FEU0FIY0EvUFJWQUFGWlRRRGdjWUFBUVpPeEFRczlRUHNoK1Q4QUFBQUFMVVIwUGdBQUFJQ1lSdmc4QUFBQVlGSE1lRHNBQUFDQWd4dndPUUFBQUVBZ0pYbzRBQUFBZ0NLQzR6WUFBQUFBSGZOcE5RQkI5TEVCQ3dKckJBQkJtN0lCQ3dYLy8vLy8vd0JCNExJQkN4QXRLeUFnSURCWU1IZ0FLRzUxYkd3cEFFR0Fzd0VMUVJFQUNnQVJFUkVBQUFBQUJRQUFBQUFBQUFrQUFBQUFDd0FBQUFBQUFBQUFFUUFQQ2hFUkVRTUtCd0FCQUFrTEN3QUFDUVlMQUFBTEFBWVJBQUFBRVJFUkFFSFJzd0VMSVFzQUFBQUFBQUFBQUJFQUNnb1JFUkVBQ2dBQUFnQUpDd0FBQUFrQUN3QUFDd0JCaTdRQkN3RU1BRUdYdEFFTEZRd0FBQUFBREFBQUFBQUpEQUFBQUFBQURBQUFEQUJCeGJRQkN3RU9BRUhSdEFFTEZRMEFBQUFFRFFBQUFBQUpEZ0FBQUFBQURnQUFEZ0JCLzdRQkN3RVFBRUdMdFFFTEhnOEFBQUFBRHdBQUFBQUpFQUFBQUFBQUVBQUFFQUFBRWdBQUFCSVNFZ0JCd3JVQkN3NFNBQUFBRWhJU0FBQUFBQUFBQ1FCQjg3VUJDd0VMQUVIL3RRRUxGUW9BQUFBQUNnQUFBQUFKQ3dBQUFBQUFDd0FBQ3dCQnJiWUJDd0VNQUVHNXRnRUxXUXdBQUFBQURBQUFBQUFKREFBQUFBQUFEQUFBREFBQU1ERXlNelExTmpjNE9VRkNRMFJGUmkwd1dDc3dXQ0F3V0Mwd2VDc3dlQ0F3ZUFCcGJtWUFTVTVHQUc1aGJnQk9RVTRBTGdBQUFBQ1lYUUFBZG1WamRHOXlBRUdrdHdFTDhnTUNBQUFBQXdBQUFBVUFBQUFIQUFBQUN3QUFBQTBBQUFBUkFBQUFFd0FBQUJjQUFBQWRBQUFBSHdBQUFDVUFBQUFwQUFBQUt3QUFBQzhBQUFBMUFBQUFPd0FBQUQwQUFBQkRBQUFBUndBQUFFa0FBQUJQQUFBQVV3QUFBRmtBQUFCaEFBQUFaUUFBQUdjQUFBQnJBQUFBYlFBQUFIRUFBQUIvQUFBQWd3QUFBSWtBQUFDTEFBQUFsUUFBQUpjQUFBQ2RBQUFBb3dBQUFLY0FBQUN0QUFBQXN3QUFBTFVBQUFDL0FBQUF3UUFBQU1VQUFBREhBQUFBMHdBQUFBRUFBQUFMQUFBQURRQUFBQkVBQUFBVEFBQUFGd0FBQUIwQUFBQWZBQUFBSlFBQUFDa0FBQUFyQUFBQUx3QUFBRFVBQUFBN0FBQUFQUUFBQUVNQUFBQkhBQUFBU1FBQUFFOEFBQUJUQUFBQVdRQUFBR0VBQUFCbEFBQUFad0FBQUdzQUFBQnRBQUFBY1FBQUFIa0FBQUIvQUFBQWd3QUFBSWtBQUFDTEFBQUFqd0FBQUpVQUFBQ1hBQUFBblFBQUFLTUFBQUNuQUFBQXFRQUFBSzBBQUFDekFBQUF0UUFBQUxzQUFBQy9BQUFBd1FBQUFNVUFBQURIQUFBQTBRQUFBRjlmYm1WNGRGOXdjbWx0WlNCdmRtVnlabXh2ZHdCaVlYTnBZMTl6ZEhKcGJtY0FYMTlqZUdGZlozVmhjbVJmWVdOeGRXbHlaU0JrWlhSbFkzUmxaQ0J5WldOMWNuTnBkbVVnYVc1cGRHbGhiR2w2WVhScGIyNEFVSFZ5WlNCMmFYSjBkV0ZzSUdaMWJtTjBhVzl1SUdOaGJHeGxaQ0VBUVppN0FRc0JCUUJCcExzQkN3SnVCQUJCdkxzQkN3cHZCQUFBY0FRQUFHeGdBRUhVdXdFTEFRSUFRZU83QVFzRi8vLy8vLzhBUWRTOUFRc0NsR0FBUVl5K0FRc0RvR0pRXCI7XG5cbmlmICghaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSkge1xuIHdhc21CaW5hcnlGaWxlID0gbG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSk7XG59XG5cbmZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKSB7XG4gdHJ5IHtcbiAgaWYgKGZpbGUgPT0gd2FzbUJpbmFyeUZpbGUgJiYgd2FzbUJpbmFyeSkge1xuICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICB9XG4gIHZhciBiaW5hcnkgPSB0cnlQYXJzZUFzRGF0YVVSSShmaWxlKTtcbiAgaWYgKGJpbmFyeSkge1xuICAgcmV0dXJuIGJpbmFyeTtcbiAgfVxuICBpZiAocmVhZEJpbmFyeSkge1xuICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gIH0gZWxzZSB7XG4gICB0aHJvdyBcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCI7XG4gIH1cbiB9IGNhdGNoIChlcnIpIHtcbiAgYWJvcnQoZXJyKTtcbiB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoKSB7XG4gaWYgKCF3YXNtQmluYXJ5ICYmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSkge1xuICBpZiAodHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCIgJiYgIWlzRmlsZVVSSSh3YXNtQmluYXJ5RmlsZSkpIHtcbiAgIHJldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSwge1xuICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCJcbiAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICBpZiAoIXJlc3BvbnNlW1wib2tcIl0pIHtcbiAgICAgdGhyb3cgXCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIiArIHdhc21CaW5hcnlGaWxlICsgXCInXCI7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZVtcImFycmF5QnVmZmVyXCJdKCk7XG4gICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2V0QmluYXJ5KHdhc21CaW5hcnlGaWxlKTtcbiAgIH0pO1xuICB9IGVsc2Uge1xuICAgaWYgKHJlYWRBc3luYykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgcmVhZEFzeW5jKHdhc21CaW5hcnlGaWxlLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShyZXNwb25zZSkpO1xuICAgICB9LCByZWplY3QpO1xuICAgIH0pO1xuICAgfVxuICB9XG4gfVxuIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ2V0QmluYXJ5KHdhc21CaW5hcnlGaWxlKTtcbiB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiB2YXIgaW5mbyA9IHtcbiAgXCJhXCI6IGFzbUxpYnJhcnlBcmdcbiB9O1xuIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XG4gIHZhciBleHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgTW9kdWxlW1wiYXNtXCJdID0gZXhwb3J0cztcbiAgd2FzbU1lbW9yeSA9IE1vZHVsZVtcImFzbVwiXVtcIk1cIl07XG4gIHVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKTtcbiAgd2FzbVRhYmxlID0gTW9kdWxlW1wiYXNtXCJdW1wiT1wiXTtcbiAgYWRkT25Jbml0KE1vZHVsZVtcImFzbVwiXVtcIk5cIl0pO1xuICByZW1vdmVSdW5EZXBlbmRlbmN5KFwid2FzbS1pbnN0YW50aWF0ZVwiKTtcbiB9XG4gYWRkUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIik7XG4gZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZShvdXRwdXQpIHtcbiAgcmVjZWl2ZUluc3RhbmNlKG91dHB1dFtcImluc3RhbmNlXCJdKTtcbiB9XG4gZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlcikge1xuICByZXR1cm4gZ2V0QmluYXJ5UHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24oYmluYXJ5KSB7XG4gICB2YXIgcmVzdWx0ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbmZvKTtcbiAgIHJldHVybiByZXN1bHQ7XG4gIH0pLnRoZW4ocmVjZWl2ZXIsIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgZXJyKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIgKyByZWFzb24pO1xuICAgYWJvcnQocmVhc29uKTtcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoKSB7XG4gIGlmICghd2FzbUJpbmFyeSAmJiB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT09IFwiZnVuY3Rpb25cIiAmJiAhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSAmJiAhaXNGaWxlVVJJKHdhc21CaW5hcnlGaWxlKSAmJiB0eXBlb2YgZmV0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7XG4gICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIlxuICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciByZXN1bHQgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSwgaW5mbyk7XG4gICAgcmV0dXJuIHJlc3VsdC50aGVuKHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UsIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICBlcnIoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIgKyByZWFzb24pO1xuICAgICBlcnIoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKTtcbiAgICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSk7XG4gICAgfSk7XG4gICB9KTtcbiAgfSBlbHNlIHtcbiAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UpO1xuICB9XG4gfVxuIGlmIChNb2R1bGVbXCJpbnN0YW50aWF0ZVdhc21cIl0pIHtcbiAgdHJ5IHtcbiAgIHZhciBleHBvcnRzID0gTW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKGluZm8sIHJlY2VpdmVJbnN0YW5jZSk7XG4gICByZXR1cm4gZXhwb3J0cztcbiAgfSBjYXRjaCAoZSkge1xuICAgZXJyKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIgKyBlKTtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuIH1cbiBpbnN0YW50aWF0ZUFzeW5jKCkuY2F0Y2gocmVhZHlQcm9taXNlUmVqZWN0KTtcbiByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3Muc2hpZnQoKTtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgIGNhbGxiYWNrKE1vZHVsZSk7XG4gICBjb250aW51ZTtcbiAgfVxuICB2YXIgZnVuYyA9IGNhbGxiYWNrLmZ1bmM7XG4gIGlmICh0eXBlb2YgZnVuYyA9PT0gXCJudW1iZXJcIikge1xuICAgaWYgKGNhbGxiYWNrLmFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgd2FzbVRhYmxlLmdldChmdW5jKSgpO1xuICAgfSBlbHNlIHtcbiAgICB3YXNtVGFibGUuZ2V0KGZ1bmMpKGNhbGxiYWNrLmFyZyk7XG4gICB9XG4gIH0gZWxzZSB7XG4gICBmdW5jKGNhbGxiYWNrLmFyZyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrLmFyZyk7XG4gIH1cbiB9XG59XG5cbnZhciBjaGFyXzAgPSA0ODtcblxudmFyIGNoYXJfOSA9IDU3O1xuXG5mdW5jdGlvbiBtYWtlTGVnYWxGdW5jdGlvbk5hbWUobmFtZSkge1xuIGlmICh1bmRlZmluZWQgPT09IG5hbWUpIHtcbiAgcmV0dXJuIFwiX3Vua25vd25cIjtcbiB9XG4gbmFtZSA9IG5hbWUucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLCBcIiRcIik7XG4gdmFyIGYgPSBuYW1lLmNoYXJDb2RlQXQoMCk7XG4gaWYgKGYgPj0gY2hhcl8wICYmIGYgPD0gY2hhcl85KSB7XG4gIHJldHVybiBcIl9cIiArIG5hbWU7XG4gfSBlbHNlIHtcbiAgcmV0dXJuIG5hbWU7XG4gfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOYW1lZEZ1bmN0aW9uKG5hbWUsIGJvZHkpIHtcbiBuYW1lID0gbWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpO1xuIHJldHVybiBuZXcgRnVuY3Rpb24oXCJib2R5XCIsIFwicmV0dXJuIGZ1bmN0aW9uIFwiICsgbmFtZSArIFwiKCkge1xcblwiICsgJyAgICBcInVzZSBzdHJpY3RcIjsnICsgXCIgICAgcmV0dXJuIGJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cIiArIFwifTtcXG5cIikoYm9keSk7XG59XG5cbnZhciBlbXZhbF9mcmVlX2xpc3QgPSBbXTtcblxudmFyIGVtdmFsX2hhbmRsZV9hcnJheSA9IFsge30sIHtcbiB2YWx1ZTogdW5kZWZpbmVkXG59LCB7XG4gdmFsdWU6IG51bGxcbn0sIHtcbiB2YWx1ZTogdHJ1ZVxufSwge1xuIHZhbHVlOiBmYWxzZVxufSBdO1xuXG5mdW5jdGlvbiBjb3VudF9lbXZhbF9oYW5kbGVzKCkge1xuIHZhciBjb3VudCA9IDA7XG4gZm9yICh2YXIgaSA9IDU7IGkgPCBlbXZhbF9oYW5kbGVfYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgaWYgKGVtdmFsX2hhbmRsZV9hcnJheVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICArK2NvdW50O1xuICB9XG4gfVxuIHJldHVybiBjb3VudDtcbn1cblxuZnVuY3Rpb24gZ2V0X2ZpcnN0X2VtdmFsKCkge1xuIGZvciAodmFyIGkgPSA1OyBpIDwgZW12YWxfaGFuZGxlX2FycmF5Lmxlbmd0aDsgKytpKSB7XG4gIGlmIChlbXZhbF9oYW5kbGVfYXJyYXlbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIGVtdmFsX2hhbmRsZV9hcnJheVtpXTtcbiAgfVxuIH1cbiByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdF9lbXZhbCgpIHtcbiBNb2R1bGVbXCJjb3VudF9lbXZhbF9oYW5kbGVzXCJdID0gY291bnRfZW12YWxfaGFuZGxlcztcbiBNb2R1bGVbXCJnZXRfZmlyc3RfZW12YWxcIl0gPSBnZXRfZmlyc3RfZW12YWw7XG59XG5cbmZ1bmN0aW9uIF9fZW12YWxfcmVnaXN0ZXIodmFsdWUpIHtcbiBzd2l0Y2ggKHZhbHVlKSB7XG4gY2FzZSB1bmRlZmluZWQ6XG4gIHtcbiAgIHJldHVybiAxO1xuICB9XG5cbiBjYXNlIG51bGw6XG4gIHtcbiAgIHJldHVybiAyO1xuICB9XG5cbiBjYXNlIHRydWU6XG4gIHtcbiAgIHJldHVybiAzO1xuICB9XG5cbiBjYXNlIGZhbHNlOlxuICB7XG4gICByZXR1cm4gNDtcbiAgfVxuXG4gZGVmYXVsdDpcbiAge1xuICAgdmFyIGhhbmRsZSA9IGVtdmFsX2ZyZWVfbGlzdC5sZW5ndGggPyBlbXZhbF9mcmVlX2xpc3QucG9wKCkgOiBlbXZhbF9oYW5kbGVfYXJyYXkubGVuZ3RoO1xuICAgZW12YWxfaGFuZGxlX2FycmF5W2hhbmRsZV0gPSB7XG4gICAgcmVmY291bnQ6IDEsXG4gICAgdmFsdWU6IHZhbHVlXG4gICB9O1xuICAgcmV0dXJuIGhhbmRsZTtcbiAgfVxuIH1cbn1cblxuZnVuY3Rpb24gZXh0ZW5kRXJyb3IoYmFzZUVycm9yVHlwZSwgZXJyb3JOYW1lKSB7XG4gdmFyIGVycm9yQ2xhc3MgPSBjcmVhdGVOYW1lZEZ1bmN0aW9uKGVycm9yTmFtZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBlcnJvck5hbWU7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHZhciBzdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbiAgaWYgKHN0YWNrICE9PSB1bmRlZmluZWQpIHtcbiAgIHRoaXMuc3RhY2sgPSB0aGlzLnRvU3RyaW5nKCkgKyBcIlxcblwiICsgc3RhY2sucmVwbGFjZSgvXkVycm9yKDpbXlxcbl0qKT9cXG4vLCBcIlwiKTtcbiAgfVxuIH0pO1xuIGVycm9yQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlRXJyb3JUeXBlLnByb3RvdHlwZSk7XG4gZXJyb3JDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBlcnJvckNsYXNzO1xuIGVycm9yQ2xhc3MucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfSBlbHNlIHtcbiAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gIH1cbiB9O1xuIHJldHVybiBlcnJvckNsYXNzO1xufVxuXG52YXIgUHVyZVZpcnR1YWxFcnJvciA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZW1iaW5kX2luaXRfY2hhckNvZGVzKCkge1xuIHZhciBjb2RlcyA9IG5ldyBBcnJheSgyNTYpO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgY29kZXNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuIH1cbiBlbWJpbmRfY2hhckNvZGVzID0gY29kZXM7XG59XG5cbnZhciBlbWJpbmRfY2hhckNvZGVzID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiByZWFkTGF0aW4xU3RyaW5nKHB0cikge1xuIHZhciByZXQgPSBcIlwiO1xuIHZhciBjID0gcHRyO1xuIHdoaWxlIChIRUFQVThbY10pIHtcbiAgcmV0ICs9IGVtYmluZF9jaGFyQ29kZXNbSEVBUFU4W2MrK11dO1xuIH1cbiByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50KCkge1xuIHJldHVybiBPYmplY3Qua2V5cyhyZWdpc3RlcmVkSW5zdGFuY2VzKS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdldExpdmVJbmhlcml0ZWRJbnN0YW5jZXMoKSB7XG4gdmFyIHJ2ID0gW107XG4gZm9yICh2YXIgayBpbiByZWdpc3RlcmVkSW5zdGFuY2VzKSB7XG4gIGlmIChyZWdpc3RlcmVkSW5zdGFuY2VzLmhhc093blByb3BlcnR5KGspKSB7XG4gICBydi5wdXNoKHJlZ2lzdGVyZWRJbnN0YW5jZXNba10pO1xuICB9XG4gfVxuIHJldHVybiBydjtcbn1cblxudmFyIGRlbGV0aW9uUXVldWUgPSBbXTtcblxuZnVuY3Rpb24gZmx1c2hQZW5kaW5nRGVsZXRlcygpIHtcbiB3aGlsZSAoZGVsZXRpb25RdWV1ZS5sZW5ndGgpIHtcbiAgdmFyIG9iaiA9IGRlbGV0aW9uUXVldWUucG9wKCk7XG4gIG9iai4kJC5kZWxldGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgb2JqW1wiZGVsZXRlXCJdKCk7XG4gfVxufVxuXG52YXIgZGVsYXlGdW5jdGlvbiA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gc2V0RGVsYXlGdW5jdGlvbihmbikge1xuIGRlbGF5RnVuY3Rpb24gPSBmbjtcbiBpZiAoZGVsZXRpb25RdWV1ZS5sZW5ndGggJiYgZGVsYXlGdW5jdGlvbikge1xuICBkZWxheUZ1bmN0aW9uKGZsdXNoUGVuZGluZ0RlbGV0ZXMpO1xuIH1cbn1cblxuZnVuY3Rpb24gaW5pdF9lbWJpbmQoKSB7XG4gTW9kdWxlW1wiZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudFwiXSA9IGdldEluaGVyaXRlZEluc3RhbmNlQ291bnQ7XG4gTW9kdWxlW1wiZ2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlc1wiXSA9IGdldExpdmVJbmhlcml0ZWRJbnN0YW5jZXM7XG4gTW9kdWxlW1wiZmx1c2hQZW5kaW5nRGVsZXRlc1wiXSA9IGZsdXNoUGVuZGluZ0RlbGV0ZXM7XG4gTW9kdWxlW1wic2V0RGVsYXlGdW5jdGlvblwiXSA9IHNldERlbGF5RnVuY3Rpb247XG59XG5cbnZhciByZWdpc3RlcmVkSW5zdGFuY2VzID0ge307XG5cbnZhciBCaW5kaW5nRXJyb3IgPSB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIHRocm93QmluZGluZ0Vycm9yKG1lc3NhZ2UpIHtcbiB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiBnZXRCYXNlc3RQb2ludGVyKGNsYXNzXywgcHRyKSB7XG4gaWYgKHB0ciA9PT0gdW5kZWZpbmVkKSB7XG4gIHRocm93QmluZGluZ0Vycm9yKFwicHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkXCIpO1xuIH1cbiB3aGlsZSAoY2xhc3NfLmJhc2VDbGFzcykge1xuICBwdHIgPSBjbGFzc18udXBjYXN0KHB0cik7XG4gIGNsYXNzXyA9IGNsYXNzXy5iYXNlQ2xhc3M7XG4gfVxuIHJldHVybiBwdHI7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVySW5oZXJpdGVkSW5zdGFuY2UoY2xhc3NfLCBwdHIsIGluc3RhbmNlKSB7XG4gcHRyID0gZ2V0QmFzZXN0UG9pbnRlcihjbGFzc18sIHB0cik7XG4gaWYgKHJlZ2lzdGVyZWRJbnN0YW5jZXMuaGFzT3duUHJvcGVydHkocHRyKSkge1xuICB0aHJvd0JpbmRpbmdFcnJvcihcIlRyaWVkIHRvIHJlZ2lzdGVyIHJlZ2lzdGVyZWQgaW5zdGFuY2U6IFwiICsgcHRyKTtcbiB9IGVsc2Uge1xuICByZWdpc3RlcmVkSW5zdGFuY2VzW3B0cl0gPSBpbnN0YW5jZTtcbiB9XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVIYW5kbGUoaGFuZGxlKSB7XG4gaWYgKCFoYW5kbGUpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgdXNlIGRlbGV0ZWQgdmFsLiBoYW5kbGUgPSBcIiArIGhhbmRsZSk7XG4gfVxuIHJldHVybiBlbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXS52YWx1ZTtcbn1cblxudmFyIHJlZ2lzdGVyZWRUeXBlcyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRUeXBlTmFtZSh0eXBlKSB7XG4gdmFyIHB0ciA9IF9fX2dldFR5cGVOYW1lKHR5cGUpO1xuIHZhciBydiA9IHJlYWRMYXRpbjFTdHJpbmcocHRyKTtcbiBfZnJlZShwdHIpO1xuIHJldHVybiBydjtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZVJlZ2lzdGVyZWRUeXBlKHJhd1R5cGUsIGh1bWFuTmFtZSkge1xuIHZhciBpbXBsID0gcmVnaXN0ZXJlZFR5cGVzW3Jhd1R5cGVdO1xuIGlmICh1bmRlZmluZWQgPT09IGltcGwpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoaHVtYW5OYW1lICsgXCIgaGFzIHVua25vd24gdHlwZSBcIiArIGdldFR5cGVOYW1lKHJhd1R5cGUpKTtcbiB9XG4gcmV0dXJuIGltcGw7XG59XG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXJJbmhlcml0ZWRJbnN0YW5jZShjbGFzc18sIHB0cikge1xuIHB0ciA9IGdldEJhc2VzdFBvaW50ZXIoY2xhc3NfLCBwdHIpO1xuIGlmIChyZWdpc3RlcmVkSW5zdGFuY2VzLmhhc093blByb3BlcnR5KHB0cikpIHtcbiAgZGVsZXRlIHJlZ2lzdGVyZWRJbnN0YW5jZXNbcHRyXTtcbiB9IGVsc2Uge1xuICB0aHJvd0JpbmRpbmdFcnJvcihcIlRyaWVkIHRvIHVucmVnaXN0ZXIgdW5yZWdpc3RlcmVkIGluc3RhbmNlOiBcIiArIHB0cik7XG4gfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hGaW5hbGl6ZXIoaGFuZGxlKSB7fVxuXG52YXIgZmluYWxpemF0aW9uR3JvdXAgPSBmYWxzZTtcblxuZnVuY3Rpb24gcnVuRGVzdHJ1Y3RvcigkJCkge1xuIGlmICgkJC5zbWFydFB0cikge1xuICAkJC5zbWFydFB0clR5cGUucmF3RGVzdHJ1Y3RvcigkJC5zbWFydFB0cik7XG4gfSBlbHNlIHtcbiAgJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MucmF3RGVzdHJ1Y3RvcigkJC5wdHIpO1xuIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZUNsYXNzSGFuZGxlKCQkKSB7XG4gJCQuY291bnQudmFsdWUgLT0gMTtcbiB2YXIgdG9EZWxldGUgPSAwID09PSAkJC5jb3VudC52YWx1ZTtcbiBpZiAodG9EZWxldGUpIHtcbiAgcnVuRGVzdHJ1Y3RvcigkJCk7XG4gfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hGaW5hbGl6ZXIoaGFuZGxlKSB7XG4gaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBGaW5hbGl6YXRpb25Hcm91cCkge1xuICBhdHRhY2hGaW5hbGl6ZXIgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgIHJldHVybiBoYW5kbGU7XG4gIH07XG4gIHJldHVybiBoYW5kbGU7XG4gfVxuIGZpbmFsaXphdGlvbkdyb3VwID0gbmV3IEZpbmFsaXphdGlvbkdyb3VwKGZ1bmN0aW9uKGl0ZXIpIHtcbiAgZm9yICh2YXIgcmVzdWx0ID0gaXRlci5uZXh0KCk7ICFyZXN1bHQuZG9uZTsgcmVzdWx0ID0gaXRlci5uZXh0KCkpIHtcbiAgIHZhciAkJCA9IHJlc3VsdC52YWx1ZTtcbiAgIGlmICghJCQucHRyKSB7XG4gICAgY29uc29sZS53YXJuKFwib2JqZWN0IGFscmVhZHkgZGVsZXRlZDogXCIgKyAkJC5wdHIpO1xuICAgfSBlbHNlIHtcbiAgICByZWxlYXNlQ2xhc3NIYW5kbGUoJCQpO1xuICAgfVxuICB9XG4gfSk7XG4gYXR0YWNoRmluYWxpemVyID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gIGZpbmFsaXphdGlvbkdyb3VwLnJlZ2lzdGVyKGhhbmRsZSwgaGFuZGxlLiQkLCBoYW5kbGUuJCQpO1xuICByZXR1cm4gaGFuZGxlO1xuIH07XG4gZGV0YWNoRmluYWxpemVyID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gIGZpbmFsaXphdGlvbkdyb3VwLnVucmVnaXN0ZXIoaGFuZGxlLiQkKTtcbiB9O1xuIHJldHVybiBhdHRhY2hGaW5hbGl6ZXIoaGFuZGxlKTtcbn1cblxuZnVuY3Rpb24gX19lbWJpbmRfY3JlYXRlX2luaGVyaXRpbmdfY29uc3RydWN0b3IoY29uc3RydWN0b3JOYW1lLCB3cmFwcGVyVHlwZSwgcHJvcGVydGllcykge1xuIGNvbnN0cnVjdG9yTmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcoY29uc3RydWN0b3JOYW1lKTtcbiB3cmFwcGVyVHlwZSA9IHJlcXVpcmVSZWdpc3RlcmVkVHlwZSh3cmFwcGVyVHlwZSwgXCJ3cmFwcGVyXCIpO1xuIHByb3BlcnRpZXMgPSByZXF1aXJlSGFuZGxlKHByb3BlcnRpZXMpO1xuIHZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG4gdmFyIHJlZ2lzdGVyZWRDbGFzcyA9IHdyYXBwZXJUeXBlLnJlZ2lzdGVyZWRDbGFzcztcbiB2YXIgd3JhcHBlclByb3RvdHlwZSA9IHJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZTtcbiB2YXIgYmFzZUNsYXNzID0gcmVnaXN0ZXJlZENsYXNzLmJhc2VDbGFzcztcbiB2YXIgYmFzZUNsYXNzUHJvdG90eXBlID0gYmFzZUNsYXNzLmluc3RhbmNlUHJvdG90eXBlO1xuIHZhciBiYXNlQ29uc3RydWN0b3IgPSByZWdpc3RlcmVkQ2xhc3MuYmFzZUNsYXNzLmNvbnN0cnVjdG9yO1xuIHZhciBjdG9yID0gY3JlYXRlTmFtZWRGdW5jdGlvbihjb25zdHJ1Y3Rvck5hbWUsIGZ1bmN0aW9uKCkge1xuICByZWdpc3RlcmVkQ2xhc3MuYmFzZUNsYXNzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgaWYgKHRoaXNbbmFtZV0gPT09IGJhc2VDbGFzc1Byb3RvdHlwZVtuYW1lXSkge1xuICAgIHRocm93IG5ldyBQdXJlVmlydHVhbEVycm9yKFwiUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIFwiICsgbmFtZSArIFwiIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gSmF2YVNjcmlwdFwiKTtcbiAgIH1cbiAgfS5iaW5kKHRoaXMpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX19wYXJlbnRcIiwge1xuICAgdmFsdWU6IHdyYXBwZXJQcm90b3R5cGVcbiAgfSk7XG4gIHRoaXNbXCJfX2NvbnN0cnVjdFwiXS5hcHBseSh0aGlzLCBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gfSk7XG4gd3JhcHBlclByb3RvdHlwZVtcIl9fY29uc3RydWN0XCJdID0gZnVuY3Rpb24gX19jb25zdHJ1Y3QoKSB7XG4gIGlmICh0aGlzID09PSB3cmFwcGVyUHJvdG90eXBlKSB7XG4gICB0aHJvd0JpbmRpbmdFcnJvcihcIlBhc3MgY29ycmVjdCAndGhpcycgdG8gX19jb25zdHJ1Y3RcIik7XG4gIH1cbiAgdmFyIGlubmVyID0gYmFzZUNvbnN0cnVjdG9yW1wiaW1wbGVtZW50XCJdLmFwcGx5KHVuZGVmaW5lZCwgWyB0aGlzIF0uY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIGRldGFjaEZpbmFsaXplcihpbm5lcik7XG4gIHZhciAkJCA9IGlubmVyLiQkO1xuICBpbm5lcltcIm5vdGlmeU9uRGVzdHJ1Y3Rpb25cIl0oKTtcbiAgJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAkJDoge1xuICAgIHZhbHVlOiAkJFxuICAgfVxuICB9KTtcbiAgYXR0YWNoRmluYWxpemVyKHRoaXMpO1xuICByZWdpc3RlckluaGVyaXRlZEluc3RhbmNlKHJlZ2lzdGVyZWRDbGFzcywgJCQucHRyLCB0aGlzKTtcbiB9O1xuIHdyYXBwZXJQcm90b3R5cGVbXCJfX2Rlc3RydWN0XCJdID0gZnVuY3Rpb24gX19kZXN0cnVjdCgpIHtcbiAgaWYgKHRoaXMgPT09IHdyYXBwZXJQcm90b3R5cGUpIHtcbiAgIHRocm93QmluZGluZ0Vycm9yKFwiUGFzcyBjb3JyZWN0ICd0aGlzJyB0byBfX2Rlc3RydWN0XCIpO1xuICB9XG4gIGRldGFjaEZpbmFsaXplcih0aGlzKTtcbiAgdW5yZWdpc3RlckluaGVyaXRlZEluc3RhbmNlKHJlZ2lzdGVyZWRDbGFzcywgdGhpcy4kJC5wdHIpO1xuIH07XG4gY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHdyYXBwZXJQcm90b3R5cGUpO1xuIGZvciAodmFyIHAgaW4gcHJvcGVydGllcykge1xuICBjdG9yLnByb3RvdHlwZVtwXSA9IHByb3BlcnRpZXNbcF07XG4gfVxuIHJldHVybiBfX2VtdmFsX3JlZ2lzdGVyKGN0b3IpO1xufVxuXG52YXIgc3RydWN0UmVnaXN0cmF0aW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycykge1xuIHdoaWxlIChkZXN0cnVjdG9ycy5sZW5ndGgpIHtcbiAgdmFyIHB0ciA9IGRlc3RydWN0b3JzLnBvcCgpO1xuICB2YXIgZGVsID0gZGVzdHJ1Y3RvcnMucG9wKCk7XG4gIGRlbChwdHIpO1xuIH1cbn1cblxuZnVuY3Rpb24gc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIocG9pbnRlcikge1xuIHJldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKEhFQVBVMzJbcG9pbnRlciA+PiAyXSk7XG59XG5cbnZhciBhd2FpdGluZ0RlcGVuZGVuY2llcyA9IHt9O1xuXG52YXIgdHlwZURlcGVuZGVuY2llcyA9IHt9O1xuXG52YXIgSW50ZXJuYWxFcnJvciA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gdGhyb3dJbnRlcm5hbEVycm9yKG1lc3NhZ2UpIHtcbiB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQobXlUeXBlcywgZGVwZW5kZW50VHlwZXMsIGdldFR5cGVDb252ZXJ0ZXJzKSB7XG4gbXlUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgdHlwZURlcGVuZGVuY2llc1t0eXBlXSA9IGRlcGVuZGVudFR5cGVzO1xuIH0pO1xuIGZ1bmN0aW9uIG9uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpIHtcbiAgdmFyIG15VHlwZUNvbnZlcnRlcnMgPSBnZXRUeXBlQ29udmVydGVycyh0eXBlQ29udmVydGVycyk7XG4gIGlmIChteVR5cGVDb252ZXJ0ZXJzLmxlbmd0aCAhPT0gbXlUeXBlcy5sZW5ndGgpIHtcbiAgIHRocm93SW50ZXJuYWxFcnJvcihcIk1pc21hdGNoZWQgdHlwZSBjb252ZXJ0ZXIgY291bnRcIik7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBteVR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICByZWdpc3RlclR5cGUobXlUeXBlc1tpXSwgbXlUeXBlQ29udmVydGVyc1tpXSk7XG4gIH1cbiB9XG4gdmFyIHR5cGVDb252ZXJ0ZXJzID0gbmV3IEFycmF5KGRlcGVuZGVudFR5cGVzLmxlbmd0aCk7XG4gdmFyIHVucmVnaXN0ZXJlZFR5cGVzID0gW107XG4gdmFyIHJlZ2lzdGVyZWQgPSAwO1xuIGRlcGVuZGVudFR5cGVzLmZvckVhY2goZnVuY3Rpb24oZHQsIGkpIHtcbiAgaWYgKHJlZ2lzdGVyZWRUeXBlcy5oYXNPd25Qcm9wZXJ0eShkdCkpIHtcbiAgIHR5cGVDb252ZXJ0ZXJzW2ldID0gcmVnaXN0ZXJlZFR5cGVzW2R0XTtcbiAgfSBlbHNlIHtcbiAgIHVucmVnaXN0ZXJlZFR5cGVzLnB1c2goZHQpO1xuICAgaWYgKCFhd2FpdGluZ0RlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShkdCkpIHtcbiAgICBhd2FpdGluZ0RlcGVuZGVuY2llc1tkdF0gPSBbXTtcbiAgIH1cbiAgIGF3YWl0aW5nRGVwZW5kZW5jaWVzW2R0XS5wdXNoKGZ1bmN0aW9uKCkge1xuICAgIHR5cGVDb252ZXJ0ZXJzW2ldID0gcmVnaXN0ZXJlZFR5cGVzW2R0XTtcbiAgICArK3JlZ2lzdGVyZWQ7XG4gICAgaWYgKHJlZ2lzdGVyZWQgPT09IHVucmVnaXN0ZXJlZFR5cGVzLmxlbmd0aCkge1xuICAgICBvbkNvbXBsZXRlKHR5cGVDb252ZXJ0ZXJzKTtcbiAgICB9XG4gICB9KTtcbiAgfVxuIH0pO1xuIGlmICgwID09PSB1bnJlZ2lzdGVyZWRUeXBlcy5sZW5ndGgpIHtcbiAgb25Db21wbGV0ZSh0eXBlQ29udmVydGVycyk7XG4gfVxufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9maW5hbGl6ZV92YWx1ZV9vYmplY3Qoc3RydWN0VHlwZSkge1xuIHZhciByZWcgPSBzdHJ1Y3RSZWdpc3RyYXRpb25zW3N0cnVjdFR5cGVdO1xuIGRlbGV0ZSBzdHJ1Y3RSZWdpc3RyYXRpb25zW3N0cnVjdFR5cGVdO1xuIHZhciByYXdDb25zdHJ1Y3RvciA9IHJlZy5yYXdDb25zdHJ1Y3RvcjtcbiB2YXIgcmF3RGVzdHJ1Y3RvciA9IHJlZy5yYXdEZXN0cnVjdG9yO1xuIHZhciBmaWVsZFJlY29yZHMgPSByZWcuZmllbGRzO1xuIHZhciBmaWVsZFR5cGVzID0gZmllbGRSZWNvcmRzLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQuZ2V0dGVyUmV0dXJuVHlwZTtcbiB9KS5jb25jYXQoZmllbGRSZWNvcmRzLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQuc2V0dGVyQXJndW1lbnRUeXBlO1xuIH0pKTtcbiB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbIHN0cnVjdFR5cGUgXSwgZmllbGRUeXBlcywgZnVuY3Rpb24oZmllbGRUeXBlcykge1xuICB2YXIgZmllbGRzID0ge307XG4gIGZpZWxkUmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBpKSB7XG4gICB2YXIgZmllbGROYW1lID0gZmllbGQuZmllbGROYW1lO1xuICAgdmFyIGdldHRlclJldHVyblR5cGUgPSBmaWVsZFR5cGVzW2ldO1xuICAgdmFyIGdldHRlciA9IGZpZWxkLmdldHRlcjtcbiAgIHZhciBnZXR0ZXJDb250ZXh0ID0gZmllbGQuZ2V0dGVyQ29udGV4dDtcbiAgIHZhciBzZXR0ZXJBcmd1bWVudFR5cGUgPSBmaWVsZFR5cGVzW2kgKyBmaWVsZFJlY29yZHMubGVuZ3RoXTtcbiAgIHZhciBzZXR0ZXIgPSBmaWVsZC5zZXR0ZXI7XG4gICB2YXIgc2V0dGVyQ29udGV4dCA9IGZpZWxkLnNldHRlckNvbnRleHQ7XG4gICBmaWVsZHNbZmllbGROYW1lXSA9IHtcbiAgICByZWFkOiBmdW5jdGlvbihwdHIpIHtcbiAgICAgcmV0dXJuIGdldHRlclJldHVyblR5cGVbXCJmcm9tV2lyZVR5cGVcIl0oZ2V0dGVyKGdldHRlckNvbnRleHQsIHB0cikpO1xuICAgIH0sXG4gICAgd3JpdGU6IGZ1bmN0aW9uKHB0ciwgbykge1xuICAgICB2YXIgZGVzdHJ1Y3RvcnMgPSBbXTtcbiAgICAgc2V0dGVyKHNldHRlckNvbnRleHQsIHB0ciwgc2V0dGVyQXJndW1lbnRUeXBlW1widG9XaXJlVHlwZVwiXShkZXN0cnVjdG9ycywgbykpO1xuICAgICBydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4gICAgfVxuICAgfTtcbiAgfSk7XG4gIHJldHVybiBbIHtcbiAgIG5hbWU6IHJlZy5uYW1lLFxuICAgXCJmcm9tV2lyZVR5cGVcIjogZnVuY3Rpb24ocHRyKSB7XG4gICAgdmFyIHJ2ID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBmaWVsZHMpIHtcbiAgICAgcnZbaV0gPSBmaWVsZHNbaV0ucmVhZChwdHIpO1xuICAgIH1cbiAgICByYXdEZXN0cnVjdG9yKHB0cik7XG4gICAgcmV0dXJuIHJ2O1xuICAgfSxcbiAgIFwidG9XaXJlVHlwZVwiOiBmdW5jdGlvbihkZXN0cnVjdG9ycywgbykge1xuICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiBmaWVsZHMpIHtcbiAgICAgaWYgKCEoZmllbGROYW1lIGluIG8pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGZpZWxkOiAgXCInICsgZmllbGROYW1lICsgJ1wiJyk7XG4gICAgIH1cbiAgICB9XG4gICAgdmFyIHB0ciA9IHJhd0NvbnN0cnVjdG9yKCk7XG4gICAgZm9yIChmaWVsZE5hbWUgaW4gZmllbGRzKSB7XG4gICAgIGZpZWxkc1tmaWVsZE5hbWVdLndyaXRlKHB0ciwgb1tmaWVsZE5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGRlc3RydWN0b3JzICE9PSBudWxsKSB7XG4gICAgIGRlc3RydWN0b3JzLnB1c2gocmF3RGVzdHJ1Y3RvciwgcHRyKTtcbiAgICB9XG4gICAgcmV0dXJuIHB0cjtcbiAgIH0sXG4gICBcImFyZ1BhY2tBZHZhbmNlXCI6IDgsXG4gICBcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6IHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLFxuICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiByYXdEZXN0cnVjdG9yXG4gIH0gXTtcbiB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2hpZnRGcm9tU2l6ZShzaXplKSB7XG4gc3dpdGNoIChzaXplKSB7XG4gY2FzZSAxOlxuICByZXR1cm4gMDtcblxuIGNhc2UgMjpcbiAgcmV0dXJuIDE7XG5cbiBjYXNlIDQ6XG4gIHJldHVybiAyO1xuXG4gY2FzZSA4OlxuICByZXR1cm4gMztcblxuIGRlZmF1bHQ6XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIHR5cGUgc2l6ZTogXCIgKyBzaXplKTtcbiB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCByZWdpc3RlcmVkSW5zdGFuY2UsIG9wdGlvbnMpIHtcbiBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiBpZiAoIShcImFyZ1BhY2tBZHZhbmNlXCIgaW4gcmVnaXN0ZXJlZEluc3RhbmNlKSkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKTtcbiB9XG4gdmFyIG5hbWUgPSByZWdpc3RlcmVkSW5zdGFuY2UubmFtZTtcbiBpZiAoIXJhd1R5cGUpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoJ3R5cGUgXCInICsgbmFtZSArICdcIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyJyk7XG4gfVxuIGlmIChyZWdpc3RlcmVkVHlwZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpIHtcbiAgaWYgKG9wdGlvbnMuaWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9ucykge1xuICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgdGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnXCIgKyBuYW1lICsgXCInIHR3aWNlXCIpO1xuICB9XG4gfVxuIHJlZ2lzdGVyZWRUeXBlc1tyYXdUeXBlXSA9IHJlZ2lzdGVyZWRJbnN0YW5jZTtcbiBkZWxldGUgdHlwZURlcGVuZGVuY2llc1tyYXdUeXBlXTtcbiBpZiAoYXdhaXRpbmdEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IGF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO1xuICBkZWxldGUgYXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07XG4gIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7XG4gICBjYigpO1xuICB9KTtcbiB9XG59XG5cbmZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wocmF3VHlwZSwgbmFtZSwgc2l6ZSwgdHJ1ZVZhbHVlLCBmYWxzZVZhbHVlKSB7XG4gdmFyIHNoaWZ0ID0gZ2V0U2hpZnRGcm9tU2l6ZShzaXplKTtcbiBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTtcbiByZWdpc3RlclR5cGUocmF3VHlwZSwge1xuICBuYW1lOiBuYW1lLFxuICBcImZyb21XaXJlVHlwZVwiOiBmdW5jdGlvbih3dCkge1xuICAgcmV0dXJuICEhd3Q7XG4gIH0sXG4gIFwidG9XaXJlVHlwZVwiOiBmdW5jdGlvbihkZXN0cnVjdG9ycywgbykge1xuICAgcmV0dXJuIG8gPyB0cnVlVmFsdWUgOiBmYWxzZVZhbHVlO1xuICB9LFxuICBcImFyZ1BhY2tBZHZhbmNlXCI6IDgsXG4gIFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgdmFyIGhlYXA7XG4gICBpZiAoc2l6ZSA9PT0gMSkge1xuICAgIGhlYXAgPSBIRUFQODtcbiAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gMikge1xuICAgIGhlYXAgPSBIRUFQMTY7XG4gICB9IGVsc2UgaWYgKHNpemUgPT09IDQpIHtcbiAgICBoZWFwID0gSEVBUDMyO1xuICAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBib29sZWFuIHR5cGUgc2l6ZTogXCIgKyBuYW1lKTtcbiAgIH1cbiAgIHJldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKGhlYXBbcG9pbnRlciA+PiBzaGlmdF0pO1xuICB9LFxuICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGxcbiB9KTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NIYW5kbGVfaXNBbGlhc09mKG90aGVyKSB7XG4gaWYgKCEodGhpcyBpbnN0YW5jZW9mIENsYXNzSGFuZGxlKSkge1xuICByZXR1cm4gZmFsc2U7XG4gfVxuIGlmICghKG90aGVyIGluc3RhbmNlb2YgQ2xhc3NIYW5kbGUpKSB7XG4gIHJldHVybiBmYWxzZTtcbiB9XG4gdmFyIGxlZnRDbGFzcyA9IHRoaXMuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3M7XG4gdmFyIGxlZnQgPSB0aGlzLiQkLnB0cjtcbiB2YXIgcmlnaHRDbGFzcyA9IG90aGVyLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO1xuIHZhciByaWdodCA9IG90aGVyLiQkLnB0cjtcbiB3aGlsZSAobGVmdENsYXNzLmJhc2VDbGFzcykge1xuICBsZWZ0ID0gbGVmdENsYXNzLnVwY2FzdChsZWZ0KTtcbiAgbGVmdENsYXNzID0gbGVmdENsYXNzLmJhc2VDbGFzcztcbiB9XG4gd2hpbGUgKHJpZ2h0Q2xhc3MuYmFzZUNsYXNzKSB7XG4gIHJpZ2h0ID0gcmlnaHRDbGFzcy51cGNhc3QocmlnaHQpO1xuICByaWdodENsYXNzID0gcmlnaHRDbGFzcy5iYXNlQ2xhc3M7XG4gfVxuIHJldHVybiBsZWZ0Q2xhc3MgPT09IHJpZ2h0Q2xhc3MgJiYgbGVmdCA9PT0gcmlnaHQ7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5SW50ZXJuYWxQb2ludGVyKG8pIHtcbiByZXR1cm4ge1xuICBjb3VudDogby5jb3VudCxcbiAgZGVsZXRlU2NoZWR1bGVkOiBvLmRlbGV0ZVNjaGVkdWxlZCxcbiAgcHJlc2VydmVQb2ludGVyT25EZWxldGU6IG8ucHJlc2VydmVQb2ludGVyT25EZWxldGUsXG4gIHB0cjogby5wdHIsXG4gIHB0clR5cGU6IG8ucHRyVHlwZSxcbiAgc21hcnRQdHI6IG8uc21hcnRQdHIsXG4gIHNtYXJ0UHRyVHlwZTogby5zbWFydFB0clR5cGVcbiB9O1xufVxuXG5mdW5jdGlvbiB0aHJvd0luc3RhbmNlQWxyZWFkeURlbGV0ZWQob2JqKSB7XG4gZnVuY3Rpb24gZ2V0SW5zdGFuY2VUeXBlTmFtZShoYW5kbGUpIHtcbiAgcmV0dXJuIGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcy5uYW1lO1xuIH1cbiB0aHJvd0JpbmRpbmdFcnJvcihnZXRJbnN0YW5jZVR5cGVOYW1lKG9iaikgKyBcIiBpbnN0YW5jZSBhbHJlYWR5IGRlbGV0ZWRcIik7XG59XG5cbmZ1bmN0aW9uIENsYXNzSGFuZGxlX2Nsb25lKCkge1xuIGlmICghdGhpcy4kJC5wdHIpIHtcbiAgdGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKHRoaXMpO1xuIH1cbiBpZiAodGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSkge1xuICB0aGlzLiQkLmNvdW50LnZhbHVlICs9IDE7XG4gIHJldHVybiB0aGlzO1xuIH0gZWxzZSB7XG4gIHZhciBjbG9uZSA9IGF0dGFjaEZpbmFsaXplcihPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge1xuICAgJCQ6IHtcbiAgICB2YWx1ZTogc2hhbGxvd0NvcHlJbnRlcm5hbFBvaW50ZXIodGhpcy4kJClcbiAgIH1cbiAgfSkpO1xuICBjbG9uZS4kJC5jb3VudC52YWx1ZSArPSAxO1xuICBjbG9uZS4kJC5kZWxldGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGNsb25lO1xuIH1cbn1cblxuZnVuY3Rpb24gQ2xhc3NIYW5kbGVfZGVsZXRlKCkge1xuIGlmICghdGhpcy4kJC5wdHIpIHtcbiAgdGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKHRoaXMpO1xuIH1cbiBpZiAodGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgJiYgIXRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoXCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uXCIpO1xuIH1cbiBkZXRhY2hGaW5hbGl6ZXIodGhpcyk7XG4gcmVsZWFzZUNsYXNzSGFuZGxlKHRoaXMuJCQpO1xuIGlmICghdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSkge1xuICB0aGlzLiQkLnNtYXJ0UHRyID0gdW5kZWZpbmVkO1xuICB0aGlzLiQkLnB0ciA9IHVuZGVmaW5lZDtcbiB9XG59XG5cbmZ1bmN0aW9uIENsYXNzSGFuZGxlX2lzRGVsZXRlZCgpIHtcbiByZXR1cm4gIXRoaXMuJCQucHRyO1xufVxuXG5mdW5jdGlvbiBDbGFzc0hhbmRsZV9kZWxldGVMYXRlcigpIHtcbiBpZiAoIXRoaXMuJCQucHRyKSB7XG4gIHRocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCh0aGlzKTtcbiB9XG4gaWYgKHRoaXMuJCQuZGVsZXRlU2NoZWR1bGVkICYmICF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKSB7XG4gIHRocm93QmluZGluZ0Vycm9yKFwiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvblwiKTtcbiB9XG4gZGVsZXRpb25RdWV1ZS5wdXNoKHRoaXMpO1xuIGlmIChkZWxldGlvblF1ZXVlLmxlbmd0aCA9PT0gMSAmJiBkZWxheUZ1bmN0aW9uKSB7XG4gIGRlbGF5RnVuY3Rpb24oZmx1c2hQZW5kaW5nRGVsZXRlcyk7XG4gfVxuIHRoaXMuJCQuZGVsZXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gaW5pdF9DbGFzc0hhbmRsZSgpIHtcbiBDbGFzc0hhbmRsZS5wcm90b3R5cGVbXCJpc0FsaWFzT2ZcIl0gPSBDbGFzc0hhbmRsZV9pc0FsaWFzT2Y7XG4gQ2xhc3NIYW5kbGUucHJvdG90eXBlW1wiY2xvbmVcIl0gPSBDbGFzc0hhbmRsZV9jbG9uZTtcbiBDbGFzc0hhbmRsZS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBDbGFzc0hhbmRsZV9kZWxldGU7XG4gQ2xhc3NIYW5kbGUucHJvdG90eXBlW1wiaXNEZWxldGVkXCJdID0gQ2xhc3NIYW5kbGVfaXNEZWxldGVkO1xuIENsYXNzSGFuZGxlLnByb3RvdHlwZVtcImRlbGV0ZUxhdGVyXCJdID0gQ2xhc3NIYW5kbGVfZGVsZXRlTGF0ZXI7XG59XG5cbmZ1bmN0aW9uIENsYXNzSGFuZGxlKCkge31cblxudmFyIHJlZ2lzdGVyZWRQb2ludGVycyA9IHt9O1xuXG5mdW5jdGlvbiBlbnN1cmVPdmVybG9hZFRhYmxlKHByb3RvLCBtZXRob2ROYW1lLCBodW1hbk5hbWUpIHtcbiBpZiAodW5kZWZpbmVkID09PSBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlKSB7XG4gIHZhciBwcmV2RnVuYyA9IHByb3RvW21ldGhvZE5hbWVdO1xuICBwcm90b1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgaWYgKCFwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KGFyZ3VtZW50cy5sZW5ndGgpKSB7XG4gICAgdGhyb3dCaW5kaW5nRXJyb3IoXCJGdW5jdGlvbiAnXCIgKyBodW1hbk5hbWUgKyBcIicgY2FsbGVkIHdpdGggYW4gaW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIChcIiArIGFyZ3VtZW50cy5sZW5ndGggKyBcIikgLSBleHBlY3RzIG9uZSBvZiAoXCIgKyBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlICsgXCIpIVwiKTtcbiAgIH1cbiAgIHJldHVybiBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ3VtZW50cy5sZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUgPSBbXTtcbiAgcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVtwcmV2RnVuYy5hcmdDb3VudF0gPSBwcmV2RnVuYztcbiB9XG59XG5cbmZ1bmN0aW9uIGV4cG9zZVB1YmxpY1N5bWJvbChuYW1lLCB2YWx1ZSwgbnVtQXJndW1lbnRzKSB7XG4gaWYgKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICBpZiAodW5kZWZpbmVkID09PSBudW1Bcmd1bWVudHMgfHwgdW5kZWZpbmVkICE9PSBNb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZSAmJiB1bmRlZmluZWQgIT09IE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlW251bUFyZ3VtZW50c10pIHtcbiAgIHRocm93QmluZGluZ0Vycm9yKFwiQ2Fubm90IHJlZ2lzdGVyIHB1YmxpYyBuYW1lICdcIiArIG5hbWUgKyBcIicgdHdpY2VcIik7XG4gIH1cbiAgZW5zdXJlT3ZlcmxvYWRUYWJsZShNb2R1bGUsIG5hbWUsIG5hbWUpO1xuICBpZiAoTW9kdWxlLmhhc093blByb3BlcnR5KG51bUFyZ3VtZW50cykpIHtcbiAgIHRocm93QmluZGluZ0Vycm9yKFwiQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAoXCIgKyBudW1Bcmd1bWVudHMgKyBcIikhXCIpO1xuICB9XG4gIE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlW251bUFyZ3VtZW50c10gPSB2YWx1ZTtcbiB9IGVsc2Uge1xuICBNb2R1bGVbbmFtZV0gPSB2YWx1ZTtcbiAgaWYgKHVuZGVmaW5lZCAhPT0gbnVtQXJndW1lbnRzKSB7XG4gICBNb2R1bGVbbmFtZV0ubnVtQXJndW1lbnRzID0gbnVtQXJndW1lbnRzO1xuICB9XG4gfVxufVxuXG5mdW5jdGlvbiBSZWdpc3RlcmVkQ2xhc3MobmFtZSwgY29uc3RydWN0b3IsIGluc3RhbmNlUHJvdG90eXBlLCByYXdEZXN0cnVjdG9yLCBiYXNlQ2xhc3MsIGdldEFjdHVhbFR5cGUsIHVwY2FzdCwgZG93bmNhc3QpIHtcbiB0aGlzLm5hbWUgPSBuYW1lO1xuIHRoaXMuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiB0aGlzLmluc3RhbmNlUHJvdG90eXBlID0gaW5zdGFuY2VQcm90b3R5cGU7XG4gdGhpcy5yYXdEZXN0cnVjdG9yID0gcmF3RGVzdHJ1Y3RvcjtcbiB0aGlzLmJhc2VDbGFzcyA9IGJhc2VDbGFzcztcbiB0aGlzLmdldEFjdHVhbFR5cGUgPSBnZXRBY3R1YWxUeXBlO1xuIHRoaXMudXBjYXN0ID0gdXBjYXN0O1xuIHRoaXMuZG93bmNhc3QgPSBkb3duY2FzdDtcbiB0aGlzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zID0gW107XG59XG5cbmZ1bmN0aW9uIHVwY2FzdFBvaW50ZXIocHRyLCBwdHJDbGFzcywgZGVzaXJlZENsYXNzKSB7XG4gd2hpbGUgKHB0ckNsYXNzICE9PSBkZXNpcmVkQ2xhc3MpIHtcbiAgaWYgKCFwdHJDbGFzcy51cGNhc3QpIHtcbiAgIHRocm93QmluZGluZ0Vycm9yKFwiRXhwZWN0ZWQgbnVsbCBvciBpbnN0YW5jZSBvZiBcIiArIGRlc2lyZWRDbGFzcy5uYW1lICsgXCIsIGdvdCBhbiBpbnN0YW5jZSBvZiBcIiArIHB0ckNsYXNzLm5hbWUpO1xuICB9XG4gIHB0ciA9IHB0ckNsYXNzLnVwY2FzdChwdHIpO1xuICBwdHJDbGFzcyA9IHB0ckNsYXNzLmJhc2VDbGFzcztcbiB9XG4gcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gY29uc3ROb1NtYXJ0UHRyUmF3UG9pbnRlclRvV2lyZVR5cGUoZGVzdHJ1Y3RvcnMsIGhhbmRsZSkge1xuIGlmIChoYW5kbGUgPT09IG51bGwpIHtcbiAgaWYgKHRoaXMuaXNSZWZlcmVuY2UpIHtcbiAgIHRocm93QmluZGluZ0Vycm9yKFwibnVsbCBpcyBub3QgYSB2YWxpZCBcIiArIHRoaXMubmFtZSk7XG4gIH1cbiAgcmV0dXJuIDA7XG4gfVxuIGlmICghaGFuZGxlLiQkKSB7XG4gIHRocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyBcIicgKyBfZW1iaW5kX3JlcHIoaGFuZGxlKSArICdcIiBhcyBhICcgKyB0aGlzLm5hbWUpO1xuIH1cbiBpZiAoIWhhbmRsZS4kJC5wdHIpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSBcIiArIHRoaXMubmFtZSk7XG4gfVxuIHZhciBoYW5kbGVDbGFzcyA9IGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcztcbiB2YXIgcHRyID0gdXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLCBoYW5kbGVDbGFzcywgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpO1xuIHJldHVybiBwdHI7XG59XG5cbmZ1bmN0aW9uIGdlbmVyaWNQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycywgaGFuZGxlKSB7XG4gdmFyIHB0cjtcbiBpZiAoaGFuZGxlID09PSBudWxsKSB7XG4gIGlmICh0aGlzLmlzUmVmZXJlbmNlKSB7XG4gICB0aHJvd0JpbmRpbmdFcnJvcihcIm51bGwgaXMgbm90IGEgdmFsaWQgXCIgKyB0aGlzLm5hbWUpO1xuICB9XG4gIGlmICh0aGlzLmlzU21hcnRQb2ludGVyKSB7XG4gICBwdHIgPSB0aGlzLnJhd0NvbnN0cnVjdG9yKCk7XG4gICBpZiAoZGVzdHJ1Y3RvcnMgIT09IG51bGwpIHtcbiAgICBkZXN0cnVjdG9ycy5wdXNoKHRoaXMucmF3RGVzdHJ1Y3RvciwgcHRyKTtcbiAgIH1cbiAgIHJldHVybiBwdHI7XG4gIH0gZWxzZSB7XG4gICByZXR1cm4gMDtcbiAgfVxuIH1cbiBpZiAoIWhhbmRsZS4kJCkge1xuICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3MgXCInICsgX2VtYmluZF9yZXByKGhhbmRsZSkgKyAnXCIgYXMgYSAnICsgdGhpcy5uYW1lKTtcbiB9XG4gaWYgKCFoYW5kbGUuJCQucHRyKSB7XG4gIHRocm93QmluZGluZ0Vycm9yKFwiQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgXCIgKyB0aGlzLm5hbWUpO1xuIH1cbiBpZiAoIXRoaXMuaXNDb25zdCAmJiBoYW5kbGUuJCQucHRyVHlwZS5pc0NvbnN0KSB7XG4gIHRocm93QmluZGluZ0Vycm9yKFwiQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSBcIiArIChoYW5kbGUuJCQuc21hcnRQdHJUeXBlID8gaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZS5uYW1lIDogaGFuZGxlLiQkLnB0clR5cGUubmFtZSkgKyBcIiB0byBwYXJhbWV0ZXIgdHlwZSBcIiArIHRoaXMubmFtZSk7XG4gfVxuIHZhciBoYW5kbGVDbGFzcyA9IGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcztcbiBwdHIgPSB1cGNhc3RQb2ludGVyKGhhbmRsZS4kJC5wdHIsIGhhbmRsZUNsYXNzLCB0aGlzLnJlZ2lzdGVyZWRDbGFzcyk7XG4gaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gaGFuZGxlLiQkLnNtYXJ0UHRyKSB7XG4gICB0aHJvd0JpbmRpbmdFcnJvcihcIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsXCIpO1xuICB9XG4gIHN3aXRjaCAodGhpcy5zaGFyaW5nUG9saWN5KSB7XG4gIGNhc2UgMDpcbiAgIGlmIChoYW5kbGUuJCQuc21hcnRQdHJUeXBlID09PSB0aGlzKSB7XG4gICAgcHRyID0gaGFuZGxlLiQkLnNtYXJ0UHRyO1xuICAgfSBlbHNlIHtcbiAgICB0aHJvd0JpbmRpbmdFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgXCIgKyAoaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZSA/IGhhbmRsZS4kJC5zbWFydFB0clR5cGUubmFtZSA6IGhhbmRsZS4kJC5wdHJUeXBlLm5hbWUpICsgXCIgdG8gcGFyYW1ldGVyIHR5cGUgXCIgKyB0aGlzLm5hbWUpO1xuICAgfVxuICAgYnJlYWs7XG5cbiAgY2FzZSAxOlxuICAgcHRyID0gaGFuZGxlLiQkLnNtYXJ0UHRyO1xuICAgYnJlYWs7XG5cbiAgY2FzZSAyOlxuICAgaWYgKGhhbmRsZS4kJC5zbWFydFB0clR5cGUgPT09IHRoaXMpIHtcbiAgICBwdHIgPSBoYW5kbGUuJCQuc21hcnRQdHI7XG4gICB9IGVsc2Uge1xuICAgIHZhciBjbG9uZWRIYW5kbGUgPSBoYW5kbGVbXCJjbG9uZVwiXSgpO1xuICAgIHB0ciA9IHRoaXMucmF3U2hhcmUocHRyLCBfX2VtdmFsX3JlZ2lzdGVyKGZ1bmN0aW9uKCkge1xuICAgICBjbG9uZWRIYW5kbGVbXCJkZWxldGVcIl0oKTtcbiAgICB9KSk7XG4gICAgaWYgKGRlc3RydWN0b3JzICE9PSBudWxsKSB7XG4gICAgIGRlc3RydWN0b3JzLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLCBwdHIpO1xuICAgIH1cbiAgIH1cbiAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICB0aHJvd0JpbmRpbmdFcnJvcihcIlVuc3VwcG9ydGluZyBzaGFyaW5nIHBvbGljeVwiKTtcbiAgfVxuIH1cbiByZXR1cm4gcHRyO1xufVxuXG5mdW5jdGlvbiBub25Db25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycywgaGFuZGxlKSB7XG4gaWYgKGhhbmRsZSA9PT0gbnVsbCkge1xuICBpZiAodGhpcy5pc1JlZmVyZW5jZSkge1xuICAgdGhyb3dCaW5kaW5nRXJyb3IoXCJudWxsIGlzIG5vdCBhIHZhbGlkIFwiICsgdGhpcy5uYW1lKTtcbiAgfVxuICByZXR1cm4gMDtcbiB9XG4gaWYgKCFoYW5kbGUuJCQpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoJ0Nhbm5vdCBwYXNzIFwiJyArIF9lbWJpbmRfcmVwcihoYW5kbGUpICsgJ1wiIGFzIGEgJyArIHRoaXMubmFtZSk7XG4gfVxuIGlmICghaGFuZGxlLiQkLnB0cikge1xuICB0aHJvd0JpbmRpbmdFcnJvcihcIkNhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlIFwiICsgdGhpcy5uYW1lKTtcbiB9XG4gaWYgKGhhbmRsZS4kJC5wdHJUeXBlLmlzQ29uc3QpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlIFwiICsgaGFuZGxlLiQkLnB0clR5cGUubmFtZSArIFwiIHRvIHBhcmFtZXRlciB0eXBlIFwiICsgdGhpcy5uYW1lKTtcbiB9XG4gdmFyIGhhbmRsZUNsYXNzID0gaGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO1xuIHZhciBwdHIgPSB1cGNhc3RQb2ludGVyKGhhbmRsZS4kJC5wdHIsIGhhbmRsZUNsYXNzLCB0aGlzLnJlZ2lzdGVyZWRDbGFzcyk7XG4gcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZ2V0UG9pbnRlZShwdHIpIHtcbiBpZiAodGhpcy5yYXdHZXRQb2ludGVlKSB7XG4gIHB0ciA9IHRoaXMucmF3R2V0UG9pbnRlZShwdHIpO1xuIH1cbiByZXR1cm4gcHRyO1xufVxuXG5mdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9kZXN0cnVjdG9yKHB0cikge1xuIGlmICh0aGlzLnJhd0Rlc3RydWN0b3IpIHtcbiAgdGhpcy5yYXdEZXN0cnVjdG9yKHB0cik7XG4gfVxufVxuXG5mdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9kZWxldGVPYmplY3QoaGFuZGxlKSB7XG4gaWYgKGhhbmRsZSAhPT0gbnVsbCkge1xuICBoYW5kbGVbXCJkZWxldGVcIl0oKTtcbiB9XG59XG5cbmZ1bmN0aW9uIGRvd25jYXN0UG9pbnRlcihwdHIsIHB0ckNsYXNzLCBkZXNpcmVkQ2xhc3MpIHtcbiBpZiAocHRyQ2xhc3MgPT09IGRlc2lyZWRDbGFzcykge1xuICByZXR1cm4gcHRyO1xuIH1cbiBpZiAodW5kZWZpbmVkID09PSBkZXNpcmVkQ2xhc3MuYmFzZUNsYXNzKSB7XG4gIHJldHVybiBudWxsO1xuIH1cbiB2YXIgcnYgPSBkb3duY2FzdFBvaW50ZXIocHRyLCBwdHJDbGFzcywgZGVzaXJlZENsYXNzLmJhc2VDbGFzcyk7XG4gaWYgKHJ2ID09PSBudWxsKSB7XG4gIHJldHVybiBudWxsO1xuIH1cbiByZXR1cm4gZGVzaXJlZENsYXNzLmRvd25jYXN0KHJ2KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5oZXJpdGVkSW5zdGFuY2UoY2xhc3NfLCBwdHIpIHtcbiBwdHIgPSBnZXRCYXNlc3RQb2ludGVyKGNsYXNzXywgcHRyKTtcbiByZXR1cm4gcmVnaXN0ZXJlZEluc3RhbmNlc1twdHJdO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2xhc3NIYW5kbGUocHJvdG90eXBlLCByZWNvcmQpIHtcbiBpZiAoIXJlY29yZC5wdHJUeXBlIHx8ICFyZWNvcmQucHRyKSB7XG4gIHRocm93SW50ZXJuYWxFcnJvcihcIm1ha2VDbGFzc0hhbmRsZSByZXF1aXJlcyBwdHIgYW5kIHB0clR5cGVcIik7XG4gfVxuIHZhciBoYXNTbWFydFB0clR5cGUgPSAhIXJlY29yZC5zbWFydFB0clR5cGU7XG4gdmFyIGhhc1NtYXJ0UHRyID0gISFyZWNvcmQuc21hcnRQdHI7XG4gaWYgKGhhc1NtYXJ0UHRyVHlwZSAhPT0gaGFzU21hcnRQdHIpIHtcbiAgdGhyb3dJbnRlcm5hbEVycm9yKFwiQm90aCBzbWFydFB0clR5cGUgYW5kIHNtYXJ0UHRyIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuIH1cbiByZWNvcmQuY291bnQgPSB7XG4gIHZhbHVlOiAxXG4gfTtcbiByZXR1cm4gYXR0YWNoRmluYWxpemVyKE9iamVjdC5jcmVhdGUocHJvdG90eXBlLCB7XG4gICQkOiB7XG4gICB2YWx1ZTogcmVjb3JkXG4gIH1cbiB9KSk7XG59XG5cbmZ1bmN0aW9uIFJlZ2lzdGVyZWRQb2ludGVyX2Zyb21XaXJlVHlwZShwdHIpIHtcbiB2YXIgcmF3UG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlZShwdHIpO1xuIGlmICghcmF3UG9pbnRlcikge1xuICB0aGlzLmRlc3RydWN0b3IocHRyKTtcbiAgcmV0dXJuIG51bGw7XG4gfVxuIHZhciByZWdpc3RlcmVkSW5zdGFuY2UgPSBnZXRJbmhlcml0ZWRJbnN0YW5jZSh0aGlzLnJlZ2lzdGVyZWRDbGFzcywgcmF3UG9pbnRlcik7XG4gaWYgKHVuZGVmaW5lZCAhPT0gcmVnaXN0ZXJlZEluc3RhbmNlKSB7XG4gIGlmICgwID09PSByZWdpc3RlcmVkSW5zdGFuY2UuJCQuY291bnQudmFsdWUpIHtcbiAgIHJlZ2lzdGVyZWRJbnN0YW5jZS4kJC5wdHIgPSByYXdQb2ludGVyO1xuICAgcmVnaXN0ZXJlZEluc3RhbmNlLiQkLnNtYXJ0UHRyID0gcHRyO1xuICAgcmV0dXJuIHJlZ2lzdGVyZWRJbnN0YW5jZVtcImNsb25lXCJdKCk7XG4gIH0gZWxzZSB7XG4gICB2YXIgcnYgPSByZWdpc3RlcmVkSW5zdGFuY2VbXCJjbG9uZVwiXSgpO1xuICAgdGhpcy5kZXN0cnVjdG9yKHB0cik7XG4gICByZXR1cm4gcnY7XG4gIH1cbiB9XG4gZnVuY3Rpb24gbWFrZURlZmF1bHRIYW5kbGUoKSB7XG4gIGlmICh0aGlzLmlzU21hcnRQb2ludGVyKSB7XG4gICByZXR1cm4gbWFrZUNsYXNzSGFuZGxlKHRoaXMucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCB7XG4gICAgcHRyVHlwZTogdGhpcy5wb2ludGVlVHlwZSxcbiAgICBwdHI6IHJhd1BvaW50ZXIsXG4gICAgc21hcnRQdHJUeXBlOiB0aGlzLFxuICAgIHNtYXJ0UHRyOiBwdHJcbiAgIH0pO1xuICB9IGVsc2Uge1xuICAgcmV0dXJuIG1ha2VDbGFzc0hhbmRsZSh0aGlzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgIHB0clR5cGU6IHRoaXMsXG4gICAgcHRyOiBwdHJcbiAgIH0pO1xuICB9XG4gfVxuIHZhciBhY3R1YWxUeXBlID0gdGhpcy5yZWdpc3RlcmVkQ2xhc3MuZ2V0QWN0dWFsVHlwZShyYXdQb2ludGVyKTtcbiB2YXIgcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQgPSByZWdpc3RlcmVkUG9pbnRlcnNbYWN0dWFsVHlwZV07XG4gaWYgKCFyZWdpc3RlcmVkUG9pbnRlclJlY29yZCkge1xuICByZXR1cm4gbWFrZURlZmF1bHRIYW5kbGUuY2FsbCh0aGlzKTtcbiB9XG4gdmFyIHRvVHlwZTtcbiBpZiAodGhpcy5pc0NvbnN0KSB7XG4gIHRvVHlwZSA9IHJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkLmNvbnN0UG9pbnRlclR5cGU7XG4gfSBlbHNlIHtcbiAgdG9UeXBlID0gcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQucG9pbnRlclR5cGU7XG4gfVxuIHZhciBkcCA9IGRvd25jYXN0UG9pbnRlcihyYXdQb2ludGVyLCB0aGlzLnJlZ2lzdGVyZWRDbGFzcywgdG9UeXBlLnJlZ2lzdGVyZWRDbGFzcyk7XG4gaWYgKGRwID09PSBudWxsKSB7XG4gIHJldHVybiBtYWtlRGVmYXVsdEhhbmRsZS5jYWxsKHRoaXMpO1xuIH1cbiBpZiAodGhpcy5pc1NtYXJ0UG9pbnRlcikge1xuICByZXR1cm4gbWFrZUNsYXNzSGFuZGxlKHRvVHlwZS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHtcbiAgIHB0clR5cGU6IHRvVHlwZSxcbiAgIHB0cjogZHAsXG4gICBzbWFydFB0clR5cGU6IHRoaXMsXG4gICBzbWFydFB0cjogcHRyXG4gIH0pO1xuIH0gZWxzZSB7XG4gIHJldHVybiBtYWtlQ2xhc3NIYW5kbGUodG9UeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgcHRyVHlwZTogdG9UeXBlLFxuICAgcHRyOiBkcFxuICB9KTtcbiB9XG59XG5cbmZ1bmN0aW9uIGluaXRfUmVnaXN0ZXJlZFBvaW50ZXIoKSB7XG4gUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlLmdldFBvaW50ZWUgPSBSZWdpc3RlcmVkUG9pbnRlcl9nZXRQb2ludGVlO1xuIFJlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gUmVnaXN0ZXJlZFBvaW50ZXJfZGVzdHJ1Y3RvcjtcbiBSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGVbXCJhcmdQYWNrQWR2YW5jZVwiXSA9IDg7XG4gUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlW1wicmVhZFZhbHVlRnJvbVBvaW50ZXJcIl0gPSBzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcjtcbiBSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGVbXCJkZWxldGVPYmplY3RcIl0gPSBSZWdpc3RlcmVkUG9pbnRlcl9kZWxldGVPYmplY3Q7XG4gUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlW1wiZnJvbVdpcmVUeXBlXCJdID0gUmVnaXN0ZXJlZFBvaW50ZXJfZnJvbVdpcmVUeXBlO1xufVxuXG5mdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcihuYW1lLCByZWdpc3RlcmVkQ2xhc3MsIGlzUmVmZXJlbmNlLCBpc0NvbnN0LCBpc1NtYXJ0UG9pbnRlciwgcG9pbnRlZVR5cGUsIHNoYXJpbmdQb2xpY3ksIHJhd0dldFBvaW50ZWUsIHJhd0NvbnN0cnVjdG9yLCByYXdTaGFyZSwgcmF3RGVzdHJ1Y3Rvcikge1xuIHRoaXMubmFtZSA9IG5hbWU7XG4gdGhpcy5yZWdpc3RlcmVkQ2xhc3MgPSByZWdpc3RlcmVkQ2xhc3M7XG4gdGhpcy5pc1JlZmVyZW5jZSA9IGlzUmVmZXJlbmNlO1xuIHRoaXMuaXNDb25zdCA9IGlzQ29uc3Q7XG4gdGhpcy5pc1NtYXJ0UG9pbnRlciA9IGlzU21hcnRQb2ludGVyO1xuIHRoaXMucG9pbnRlZVR5cGUgPSBwb2ludGVlVHlwZTtcbiB0aGlzLnNoYXJpbmdQb2xpY3kgPSBzaGFyaW5nUG9saWN5O1xuIHRoaXMucmF3R2V0UG9pbnRlZSA9IHJhd0dldFBvaW50ZWU7XG4gdGhpcy5yYXdDb25zdHJ1Y3RvciA9IHJhd0NvbnN0cnVjdG9yO1xuIHRoaXMucmF3U2hhcmUgPSByYXdTaGFyZTtcbiB0aGlzLnJhd0Rlc3RydWN0b3IgPSByYXdEZXN0cnVjdG9yO1xuIGlmICghaXNTbWFydFBvaW50ZXIgJiYgcmVnaXN0ZXJlZENsYXNzLmJhc2VDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG4gIGlmIChpc0NvbnN0KSB7XG4gICB0aGlzW1widG9XaXJlVHlwZVwiXSA9IGNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlO1xuICAgdGhpcy5kZXN0cnVjdG9yRnVuY3Rpb24gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgdGhpc1tcInRvV2lyZVR5cGVcIl0gPSBub25Db25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZTtcbiAgIHRoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uID0gbnVsbDtcbiAgfVxuIH0gZWxzZSB7XG4gIHRoaXNbXCJ0b1dpcmVUeXBlXCJdID0gZ2VuZXJpY1BvaW50ZXJUb1dpcmVUeXBlO1xuIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVB1YmxpY1N5bWJvbChuYW1lLCB2YWx1ZSwgbnVtQXJndW1lbnRzKSB7XG4gaWYgKCFNb2R1bGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgdGhyb3dJbnRlcm5hbEVycm9yKFwiUmVwbGFjaW5nIG5vbmV4aXN0YW50IHB1YmxpYyBzeW1ib2xcIik7XG4gfVxuIGlmICh1bmRlZmluZWQgIT09IE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlICYmIHVuZGVmaW5lZCAhPT0gbnVtQXJndW1lbnRzKSB7XG4gIE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlW251bUFyZ3VtZW50c10gPSB2YWx1ZTtcbiB9IGVsc2Uge1xuICBNb2R1bGVbbmFtZV0gPSB2YWx1ZTtcbiAgTW9kdWxlW25hbWVdLmFyZ0NvdW50ID0gbnVtQXJndW1lbnRzO1xuIH1cbn1cblxuZnVuY3Rpb24gZHluQ2FsbExlZ2FjeShzaWcsIHB0ciwgYXJncykge1xuIHZhciBmID0gTW9kdWxlW1wiZHluQ2FsbF9cIiArIHNpZ107XG4gcmV0dXJuIGFyZ3MgJiYgYXJncy5sZW5ndGggPyBmLmFwcGx5KG51bGwsIFsgcHRyIF0uY29uY2F0KGFyZ3MpKSA6IGYuY2FsbChudWxsLCBwdHIpO1xufVxuXG5mdW5jdGlvbiBkeW5DYWxsKHNpZywgcHRyLCBhcmdzKSB7XG4gaWYgKHNpZy5pbmRleE9mKFwialwiKSAhPSAtMSkge1xuICByZXR1cm4gZHluQ2FsbExlZ2FjeShzaWcsIHB0ciwgYXJncyk7XG4gfVxuIHJldHVybiB3YXNtVGFibGUuZ2V0KHB0cikuYXBwbHkobnVsbCwgYXJncyk7XG59XG5cbmZ1bmN0aW9uIGdldER5bkNhbGxlcihzaWcsIHB0cikge1xuIHZhciBhcmdDYWNoZSA9IFtdO1xuIHJldHVybiBmdW5jdGlvbigpIHtcbiAgYXJnQ2FjaGUubGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgIGFyZ0NhY2hlW2ldID0gYXJndW1lbnRzW2ldO1xuICB9XG4gIHJldHVybiBkeW5DYWxsKHNpZywgcHRyLCBhcmdDYWNoZSk7XG4gfTtcbn1cblxuZnVuY3Rpb24gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oc2lnbmF0dXJlLCByYXdGdW5jdGlvbikge1xuIHNpZ25hdHVyZSA9IHJlYWRMYXRpbjFTdHJpbmcoc2lnbmF0dXJlKTtcbiBmdW5jdGlvbiBtYWtlRHluQ2FsbGVyKCkge1xuICBpZiAoc2lnbmF0dXJlLmluZGV4T2YoXCJqXCIpICE9IC0xKSB7XG4gICByZXR1cm4gZ2V0RHluQ2FsbGVyKHNpZ25hdHVyZSwgcmF3RnVuY3Rpb24pO1xuICB9XG4gIHJldHVybiB3YXNtVGFibGUuZ2V0KHJhd0Z1bmN0aW9uKTtcbiB9XG4gdmFyIGZwID0gbWFrZUR5bkNhbGxlcigpO1xuIGlmICh0eXBlb2YgZnAgIT09IFwiZnVuY3Rpb25cIikge1xuICB0aHJvd0JpbmRpbmdFcnJvcihcInVua25vd24gZnVuY3Rpb24gcG9pbnRlciB3aXRoIHNpZ25hdHVyZSBcIiArIHNpZ25hdHVyZSArIFwiOiBcIiArIHJhd0Z1bmN0aW9uKTtcbiB9XG4gcmV0dXJuIGZwO1xufVxuXG52YXIgVW5ib3VuZFR5cGVFcnJvciA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gdGhyb3dVbmJvdW5kVHlwZUVycm9yKG1lc3NhZ2UsIHR5cGVzKSB7XG4gdmFyIHVuYm91bmRUeXBlcyA9IFtdO1xuIHZhciBzZWVuID0ge307XG4gZnVuY3Rpb24gdmlzaXQodHlwZSkge1xuICBpZiAoc2Vlblt0eXBlXSkge1xuICAgcmV0dXJuO1xuICB9XG4gIGlmIChyZWdpc3RlcmVkVHlwZXNbdHlwZV0pIHtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZURlcGVuZGVuY2llc1t0eXBlXSkge1xuICAgdHlwZURlcGVuZGVuY2llc1t0eXBlXS5mb3JFYWNoKHZpc2l0KTtcbiAgIHJldHVybjtcbiAgfVxuICB1bmJvdW5kVHlwZXMucHVzaCh0eXBlKTtcbiAgc2Vlblt0eXBlXSA9IHRydWU7XG4gfVxuIHR5cGVzLmZvckVhY2godmlzaXQpO1xuIHRocm93IG5ldyBVbmJvdW5kVHlwZUVycm9yKG1lc3NhZ2UgKyBcIjogXCIgKyB1bmJvdW5kVHlwZXMubWFwKGdldFR5cGVOYW1lKS5qb2luKFsgXCIsIFwiIF0pKTtcbn1cblxuZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MocmF3VHlwZSwgcmF3UG9pbnRlclR5cGUsIHJhd0NvbnN0UG9pbnRlclR5cGUsIGJhc2VDbGFzc1Jhd1R5cGUsIGdldEFjdHVhbFR5cGVTaWduYXR1cmUsIGdldEFjdHVhbFR5cGUsIHVwY2FzdFNpZ25hdHVyZSwgdXBjYXN0LCBkb3duY2FzdFNpZ25hdHVyZSwgZG93bmNhc3QsIG5hbWUsIGRlc3RydWN0b3JTaWduYXR1cmUsIHJhd0Rlc3RydWN0b3IpIHtcbiBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTtcbiBnZXRBY3R1YWxUeXBlID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZ2V0QWN0dWFsVHlwZVNpZ25hdHVyZSwgZ2V0QWN0dWFsVHlwZSk7XG4gaWYgKHVwY2FzdCkge1xuICB1cGNhc3QgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbih1cGNhc3RTaWduYXR1cmUsIHVwY2FzdCk7XG4gfVxuIGlmIChkb3duY2FzdCkge1xuICBkb3duY2FzdCA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGRvd25jYXN0U2lnbmF0dXJlLCBkb3duY2FzdCk7XG4gfVxuIHJhd0Rlc3RydWN0b3IgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkZXN0cnVjdG9yU2lnbmF0dXJlLCByYXdEZXN0cnVjdG9yKTtcbiB2YXIgbGVnYWxGdW5jdGlvbk5hbWUgPSBtYWtlTGVnYWxGdW5jdGlvbk5hbWUobmFtZSk7XG4gZXhwb3NlUHVibGljU3ltYm9sKGxlZ2FsRnVuY3Rpb25OYW1lLCBmdW5jdGlvbigpIHtcbiAgdGhyb3dVbmJvdW5kVHlwZUVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBcIiArIG5hbWUgKyBcIiBkdWUgdG8gdW5ib3VuZCB0eXBlc1wiLCBbIGJhc2VDbGFzc1Jhd1R5cGUgXSk7XG4gfSk7XG4gd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoWyByYXdUeXBlLCByYXdQb2ludGVyVHlwZSwgcmF3Q29uc3RQb2ludGVyVHlwZSBdLCBiYXNlQ2xhc3NSYXdUeXBlID8gWyBiYXNlQ2xhc3NSYXdUeXBlIF0gOiBbXSwgZnVuY3Rpb24oYmFzZSkge1xuICBiYXNlID0gYmFzZVswXTtcbiAgdmFyIGJhc2VDbGFzcztcbiAgdmFyIGJhc2VQcm90b3R5cGU7XG4gIGlmIChiYXNlQ2xhc3NSYXdUeXBlKSB7XG4gICBiYXNlQ2xhc3MgPSBiYXNlLnJlZ2lzdGVyZWRDbGFzcztcbiAgIGJhc2VQcm90b3R5cGUgPSBiYXNlQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICBiYXNlUHJvdG90eXBlID0gQ2xhc3NIYW5kbGUucHJvdG90eXBlO1xuICB9XG4gIHZhciBjb25zdHJ1Y3RvciA9IGNyZWF0ZU5hbWVkRnVuY3Rpb24obGVnYWxGdW5jdGlvbk5hbWUsIGZ1bmN0aW9uKCkge1xuICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gaW5zdGFuY2VQcm90b3R5cGUpIHtcbiAgICB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKFwiVXNlICduZXcnIHRvIGNvbnN0cnVjdCBcIiArIG5hbWUpO1xuICAgfVxuICAgaWYgKHVuZGVmaW5lZCA9PT0gcmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpIHtcbiAgICB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKG5hbWUgKyBcIiBoYXMgbm8gYWNjZXNzaWJsZSBjb25zdHJ1Y3RvclwiKTtcbiAgIH1cbiAgIHZhciBib2R5ID0gcmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJndW1lbnRzLmxlbmd0aF07XG4gICBpZiAodW5kZWZpbmVkID09PSBib2R5KSB7XG4gICAgdGhyb3cgbmV3IEJpbmRpbmdFcnJvcihcIlRyaWVkIHRvIGludm9rZSBjdG9yIG9mIFwiICsgbmFtZSArIFwiIHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoXCIgKyBhcmd1bWVudHMubGVuZ3RoICsgXCIpIC0gZXhwZWN0ZWQgKFwiICsgT2JqZWN0LmtleXMocmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpLnRvU3RyaW5nKCkgKyBcIikgcGFyYW1ldGVycyBpbnN0ZWFkIVwiKTtcbiAgIH1cbiAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICB2YXIgaW5zdGFuY2VQcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm90b3R5cGUsIHtcbiAgIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IGNvbnN0cnVjdG9yXG4gICB9XG4gIH0pO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBpbnN0YW5jZVByb3RvdHlwZTtcbiAgdmFyIHJlZ2lzdGVyZWRDbGFzcyA9IG5ldyBSZWdpc3RlcmVkQ2xhc3MobmFtZSwgY29uc3RydWN0b3IsIGluc3RhbmNlUHJvdG90eXBlLCByYXdEZXN0cnVjdG9yLCBiYXNlQ2xhc3MsIGdldEFjdHVhbFR5cGUsIHVwY2FzdCwgZG93bmNhc3QpO1xuICB2YXIgcmVmZXJlbmNlQ29udmVydGVyID0gbmV3IFJlZ2lzdGVyZWRQb2ludGVyKG5hbWUsIHJlZ2lzdGVyZWRDbGFzcywgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgdmFyIHBvaW50ZXJDb252ZXJ0ZXIgPSBuZXcgUmVnaXN0ZXJlZFBvaW50ZXIobmFtZSArIFwiKlwiLCByZWdpc3RlcmVkQ2xhc3MsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICB2YXIgY29uc3RQb2ludGVyQ29udmVydGVyID0gbmV3IFJlZ2lzdGVyZWRQb2ludGVyKG5hbWUgKyBcIiBjb25zdCpcIiwgcmVnaXN0ZXJlZENsYXNzLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuICByZWdpc3RlcmVkUG9pbnRlcnNbcmF3VHlwZV0gPSB7XG4gICBwb2ludGVyVHlwZTogcG9pbnRlckNvbnZlcnRlcixcbiAgIGNvbnN0UG9pbnRlclR5cGU6IGNvbnN0UG9pbnRlckNvbnZlcnRlclxuICB9O1xuICByZXBsYWNlUHVibGljU3ltYm9sKGxlZ2FsRnVuY3Rpb25OYW1lLCBjb25zdHJ1Y3Rvcik7XG4gIHJldHVybiBbIHJlZmVyZW5jZUNvbnZlcnRlciwgcG9pbnRlckNvbnZlcnRlciwgY29uc3RQb2ludGVyQ29udmVydGVyIF07XG4gfSk7XG59XG5cbmZ1bmN0aW9uIG5ld18oY29uc3RydWN0b3IsIGFyZ3VtZW50TGlzdCkge1xuIGlmICghKGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZXdfIGNhbGxlZCB3aXRoIGNvbnN0cnVjdG9yIHR5cGUgXCIgKyB0eXBlb2YgY29uc3RydWN0b3IgKyBcIiB3aGljaCBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiB9XG4gdmFyIGR1bW15ID0gY3JlYXRlTmFtZWRGdW5jdGlvbihjb25zdHJ1Y3Rvci5uYW1lIHx8IFwidW5rbm93bkZ1bmN0aW9uTmFtZVwiLCBmdW5jdGlvbigpIHt9KTtcbiBkdW1teS5wcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gdmFyIG9iaiA9IG5ldyBkdW1teSgpO1xuIHZhciByID0gY29uc3RydWN0b3IuYXBwbHkob2JqLCBhcmd1bWVudExpc3QpO1xuIHJldHVybiByIGluc3RhbmNlb2YgT2JqZWN0ID8gciA6IG9iajtcbn1cblxuZnVuY3Rpb24gY3JhZnRJbnZva2VyRnVuY3Rpb24oaHVtYW5OYW1lLCBhcmdUeXBlcywgY2xhc3NUeXBlLCBjcHBJbnZva2VyRnVuYywgY3BwVGFyZ2V0RnVuYykge1xuIHZhciBhcmdDb3VudCA9IGFyZ1R5cGVzLmxlbmd0aDtcbiBpZiAoYXJnQ291bnQgPCAyKSB7XG4gIHRocm93QmluZGluZ0Vycm9yKFwiYXJnVHlwZXMgYXJyYXkgc2l6ZSBtaXNtYXRjaCEgTXVzdCBhdCBsZWFzdCBnZXQgcmV0dXJuIHZhbHVlIGFuZCAndGhpcycgdHlwZXMhXCIpO1xuIH1cbiB2YXIgaXNDbGFzc01ldGhvZEZ1bmMgPSBhcmdUeXBlc1sxXSAhPT0gbnVsbCAmJiBjbGFzc1R5cGUgIT09IG51bGw7XG4gdmFyIG5lZWRzRGVzdHJ1Y3RvclN0YWNrID0gZmFsc2U7XG4gZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdUeXBlcy5sZW5ndGg7ICsraSkge1xuICBpZiAoYXJnVHlwZXNbaV0gIT09IG51bGwgJiYgYXJnVHlwZXNbaV0uZGVzdHJ1Y3RvckZ1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgIG5lZWRzRGVzdHJ1Y3RvclN0YWNrID0gdHJ1ZTtcbiAgIGJyZWFrO1xuICB9XG4gfVxuIHZhciByZXR1cm5zID0gYXJnVHlwZXNbMF0ubmFtZSAhPT0gXCJ2b2lkXCI7XG4gdmFyIGFyZ3NMaXN0ID0gXCJcIjtcbiB2YXIgYXJnc0xpc3RXaXJlZCA9IFwiXCI7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdDb3VudCAtIDI7ICsraSkge1xuICBhcmdzTGlzdCArPSAoaSAhPT0gMCA/IFwiLCBcIiA6IFwiXCIpICsgXCJhcmdcIiArIGk7XG4gIGFyZ3NMaXN0V2lyZWQgKz0gKGkgIT09IDAgPyBcIiwgXCIgOiBcIlwiKSArIFwiYXJnXCIgKyBpICsgXCJXaXJlZFwiO1xuIH1cbiB2YXIgaW52b2tlckZuQm9keSA9IFwicmV0dXJuIGZ1bmN0aW9uIFwiICsgbWFrZUxlZ2FsRnVuY3Rpb25OYW1lKGh1bWFuTmFtZSkgKyBcIihcIiArIGFyZ3NMaXN0ICsgXCIpIHtcXG5cIiArIFwiaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IFwiICsgKGFyZ0NvdW50IC0gMikgKyBcIikge1xcblwiICsgXCJ0aHJvd0JpbmRpbmdFcnJvcignZnVuY3Rpb24gXCIgKyBodW1hbk5hbWUgKyBcIiBjYWxsZWQgd2l0aCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLCBleHBlY3RlZCBcIiArIChhcmdDb3VudCAtIDIpICsgXCIgYXJncyEnKTtcXG5cIiArIFwifVxcblwiO1xuIGlmIChuZWVkc0Rlc3RydWN0b3JTdGFjaykge1xuICBpbnZva2VyRm5Cb2R5ICs9IFwidmFyIGRlc3RydWN0b3JzID0gW107XFxuXCI7XG4gfVxuIHZhciBkdG9yU3RhY2sgPSBuZWVkc0Rlc3RydWN0b3JTdGFjayA/IFwiZGVzdHJ1Y3RvcnNcIiA6IFwibnVsbFwiO1xuIHZhciBhcmdzMSA9IFsgXCJ0aHJvd0JpbmRpbmdFcnJvclwiLCBcImludm9rZXJcIiwgXCJmblwiLCBcInJ1bkRlc3RydWN0b3JzXCIsIFwicmV0VHlwZVwiLCBcImNsYXNzUGFyYW1cIiBdO1xuIHZhciBhcmdzMiA9IFsgdGhyb3dCaW5kaW5nRXJyb3IsIGNwcEludm9rZXJGdW5jLCBjcHBUYXJnZXRGdW5jLCBydW5EZXN0cnVjdG9ycywgYXJnVHlwZXNbMF0sIGFyZ1R5cGVzWzFdIF07XG4gaWYgKGlzQ2xhc3NNZXRob2RGdW5jKSB7XG4gIGludm9rZXJGbkJvZHkgKz0gXCJ2YXIgdGhpc1dpcmVkID0gY2xhc3NQYXJhbS50b1dpcmVUeXBlKFwiICsgZHRvclN0YWNrICsgXCIsIHRoaXMpO1xcblwiO1xuIH1cbiBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0NvdW50IC0gMjsgKytpKSB7XG4gIGludm9rZXJGbkJvZHkgKz0gXCJ2YXIgYXJnXCIgKyBpICsgXCJXaXJlZCA9IGFyZ1R5cGVcIiArIGkgKyBcIi50b1dpcmVUeXBlKFwiICsgZHRvclN0YWNrICsgXCIsIGFyZ1wiICsgaSArIFwiKTsgLy8gXCIgKyBhcmdUeXBlc1tpICsgMl0ubmFtZSArIFwiXFxuXCI7XG4gIGFyZ3MxLnB1c2goXCJhcmdUeXBlXCIgKyBpKTtcbiAgYXJnczIucHVzaChhcmdUeXBlc1tpICsgMl0pO1xuIH1cbiBpZiAoaXNDbGFzc01ldGhvZEZ1bmMpIHtcbiAgYXJnc0xpc3RXaXJlZCA9IFwidGhpc1dpcmVkXCIgKyAoYXJnc0xpc3RXaXJlZC5sZW5ndGggPiAwID8gXCIsIFwiIDogXCJcIikgKyBhcmdzTGlzdFdpcmVkO1xuIH1cbiBpbnZva2VyRm5Cb2R5ICs9IChyZXR1cm5zID8gXCJ2YXIgcnYgPSBcIiA6IFwiXCIpICsgXCJpbnZva2VyKGZuXCIgKyAoYXJnc0xpc3RXaXJlZC5sZW5ndGggPiAwID8gXCIsIFwiIDogXCJcIikgKyBhcmdzTGlzdFdpcmVkICsgXCIpO1xcblwiO1xuIGlmIChuZWVkc0Rlc3RydWN0b3JTdGFjaykge1xuICBpbnZva2VyRm5Cb2R5ICs9IFwicnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpO1xcblwiO1xuIH0gZWxzZSB7XG4gIGZvciAodmFyIGkgPSBpc0NsYXNzTWV0aG9kRnVuYyA/IDEgOiAyOyBpIDwgYXJnVHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgIHZhciBwYXJhbU5hbWUgPSBpID09PSAxID8gXCJ0aGlzV2lyZWRcIiA6IFwiYXJnXCIgKyAoaSAtIDIpICsgXCJXaXJlZFwiO1xuICAgaWYgKGFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbiAhPT0gbnVsbCkge1xuICAgIGludm9rZXJGbkJvZHkgKz0gcGFyYW1OYW1lICsgXCJfZHRvcihcIiArIHBhcmFtTmFtZSArIFwiKTsgLy8gXCIgKyBhcmdUeXBlc1tpXS5uYW1lICsgXCJcXG5cIjtcbiAgICBhcmdzMS5wdXNoKHBhcmFtTmFtZSArIFwiX2R0b3JcIik7XG4gICAgYXJnczIucHVzaChhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb24pO1xuICAgfVxuICB9XG4gfVxuIGlmIChyZXR1cm5zKSB7XG4gIGludm9rZXJGbkJvZHkgKz0gXCJ2YXIgcmV0ID0gcmV0VHlwZS5mcm9tV2lyZVR5cGUocnYpO1xcblwiICsgXCJyZXR1cm4gcmV0O1xcblwiO1xuIH0gZWxzZSB7fVxuIGludm9rZXJGbkJvZHkgKz0gXCJ9XFxuXCI7XG4gYXJnczEucHVzaChpbnZva2VyRm5Cb2R5KTtcbiB2YXIgaW52b2tlckZ1bmN0aW9uID0gbmV3XyhGdW5jdGlvbiwgYXJnczEpLmFwcGx5KG51bGwsIGFyZ3MyKTtcbiByZXR1cm4gaW52b2tlckZ1bmN0aW9uO1xufVxuXG5mdW5jdGlvbiBoZWFwMzJWZWN0b3JUb0FycmF5KGNvdW50LCBmaXJzdEVsZW1lbnQpIHtcbiB2YXIgYXJyYXkgPSBbXTtcbiBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgYXJyYXkucHVzaChIRUFQMzJbKGZpcnN0RWxlbWVudCA+PiAyKSArIGldKTtcbiB9XG4gcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jbGFzc19mdW5jdGlvbihyYXdDbGFzc1R5cGUsIG1ldGhvZE5hbWUsIGFyZ0NvdW50LCByYXdBcmdUeXBlc0FkZHIsIGludm9rZXJTaWduYXR1cmUsIHJhd0ludm9rZXIsIGZuKSB7XG4gdmFyIHJhd0FyZ1R5cGVzID0gaGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCwgcmF3QXJnVHlwZXNBZGRyKTtcbiBtZXRob2ROYW1lID0gcmVhZExhdGluMVN0cmluZyhtZXRob2ROYW1lKTtcbiByYXdJbnZva2VyID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oaW52b2tlclNpZ25hdHVyZSwgcmF3SW52b2tlcik7XG4gd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIFsgcmF3Q2xhc3NUeXBlIF0sIGZ1bmN0aW9uKGNsYXNzVHlwZSkge1xuICBjbGFzc1R5cGUgPSBjbGFzc1R5cGVbMF07XG4gIHZhciBodW1hbk5hbWUgPSBjbGFzc1R5cGUubmFtZSArIFwiLlwiICsgbWV0aG9kTmFtZTtcbiAgZnVuY3Rpb24gdW5ib3VuZFR5cGVzSGFuZGxlcigpIHtcbiAgIHRocm93VW5ib3VuZFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIFwiICsgaHVtYW5OYW1lICsgXCIgZHVlIHRvIHVuYm91bmQgdHlwZXNcIiwgcmF3QXJnVHlwZXMpO1xuICB9XG4gIHZhciBwcm90byA9IGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3I7XG4gIGlmICh1bmRlZmluZWQgPT09IHByb3RvW21ldGhvZE5hbWVdKSB7XG4gICB1bmJvdW5kVHlwZXNIYW5kbGVyLmFyZ0NvdW50ID0gYXJnQ291bnQgLSAxO1xuICAgcHJvdG9bbWV0aG9kTmFtZV0gPSB1bmJvdW5kVHlwZXNIYW5kbGVyO1xuICB9IGVsc2Uge1xuICAgZW5zdXJlT3ZlcmxvYWRUYWJsZShwcm90bywgbWV0aG9kTmFtZSwgaHVtYW5OYW1lKTtcbiAgIHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGVbYXJnQ291bnQgLSAxXSA9IHVuYm91bmRUeXBlc0hhbmRsZXI7XG4gIH1cbiAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIHJhd0FyZ1R5cGVzLCBmdW5jdGlvbihhcmdUeXBlcykge1xuICAgdmFyIGludm9rZXJBcmdzQXJyYXkgPSBbIGFyZ1R5cGVzWzBdLCBudWxsIF0uY29uY2F0KGFyZ1R5cGVzLnNsaWNlKDEpKTtcbiAgIHZhciBmdW5jID0gY3JhZnRJbnZva2VyRnVuY3Rpb24oaHVtYW5OYW1lLCBpbnZva2VyQXJnc0FycmF5LCBudWxsLCByYXdJbnZva2VyLCBmbik7XG4gICBpZiAodW5kZWZpbmVkID09PSBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlKSB7XG4gICAgZnVuYy5hcmdDb3VudCA9IGFyZ0NvdW50IC0gMTtcbiAgICBwcm90b1ttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICB9IGVsc2Uge1xuICAgIHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGVbYXJnQ291bnQgLSAxXSA9IGZ1bmM7XG4gICB9XG4gICByZXR1cm4gW107XG4gIH0pO1xuICByZXR1cm4gW107XG4gfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGhpcyh0aGlzXywgY2xhc3NUeXBlLCBodW1hbk5hbWUpIHtcbiBpZiAoISh0aGlzXyBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoaHVtYW5OYW1lICsgJyB3aXRoIGludmFsaWQgXCJ0aGlzXCI6ICcgKyB0aGlzXyk7XG4gfVxuIGlmICghKHRoaXNfIGluc3RhbmNlb2YgY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3RvcikpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoaHVtYW5OYW1lICsgJyBpbmNvbXBhdGlibGUgd2l0aCBcInRoaXNcIiBvZiB0eXBlICcgKyB0aGlzXy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiB9XG4gaWYgKCF0aGlzXy4kJC5wdHIpIHtcbiAgdGhyb3dCaW5kaW5nRXJyb3IoXCJjYW5ub3QgY2FsbCBlbXNjcmlwdGVuIGJpbmRpbmcgbWV0aG9kIFwiICsgaHVtYW5OYW1lICsgXCIgb24gZGVsZXRlZCBvYmplY3RcIik7XG4gfVxuIHJldHVybiB1cGNhc3RQb2ludGVyKHRoaXNfLiQkLnB0ciwgdGhpc18uJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MsIGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jbGFzc19wcm9wZXJ0eShyYXdDbGFzc1R5cGUsIGZpZWxkTmFtZSwgcmF3RmllbGRUeXBlLCByYXdGaWVsZFB0ciwgZ2V0dGVyU2lnbmF0dXJlLCBnZXR0ZXIsIHNldHRlclNpZ25hdHVyZSwgc2V0dGVyKSB7XG4gZmllbGROYW1lID0gcmVhZExhdGluMVN0cmluZyhmaWVsZE5hbWUpO1xuIGdldHRlciA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGdldHRlclNpZ25hdHVyZSwgZ2V0dGVyKTtcbiB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgWyByYXdDbGFzc1R5cGUgXSwgZnVuY3Rpb24oY2xhc3NUeXBlKSB7XG4gIGNsYXNzVHlwZSA9IGNsYXNzVHlwZVswXTtcbiAgdmFyIGh1bWFuTmFtZSA9IGNsYXNzVHlwZS5uYW1lICsgXCIuXCIgKyBmaWVsZE5hbWU7XG4gIHZhciBkZXNjID0ge1xuICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aHJvd1VuYm91bmRUeXBlRXJyb3IoXCJDYW5ub3QgYWNjZXNzIFwiICsgaHVtYW5OYW1lICsgXCIgZHVlIHRvIHVuYm91bmQgdHlwZXNcIiwgWyByYXdGaWVsZFR5cGUgXSk7XG4gICB9LFxuICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9O1xuICBpZiAoc2V0dGVyKSB7XG4gICBkZXNjLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93VW5ib3VuZFR5cGVFcnJvcihcIkNhbm5vdCBhY2Nlc3MgXCIgKyBodW1hbk5hbWUgKyBcIiBkdWUgdG8gdW5ib3VuZCB0eXBlc1wiLCBbIHJhd0ZpZWxkVHlwZSBdKTtcbiAgIH07XG4gIH0gZWxzZSB7XG4gICBkZXNjLnNldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB0aHJvd0JpbmRpbmdFcnJvcihodW1hbk5hbWUgKyBcIiBpcyBhIHJlYWQtb25seSBwcm9wZXJ0eVwiKTtcbiAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3IsIGZpZWxkTmFtZSwgZGVzYyk7XG4gIHdoZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtdLCBbIHJhd0ZpZWxkVHlwZSBdLCBmdW5jdGlvbihmaWVsZFR5cGUpIHtcbiAgIGZpZWxkVHlwZSA9IGZpZWxkVHlwZVswXTtcbiAgIHZhciBkZXNjID0ge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiBmaWVsZFR5cGVbXCJmcm9tV2lyZVR5cGVcIl0oZ2V0dGVyKHJhd0ZpZWxkUHRyKSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICB9O1xuICAgaWYgKHNldHRlcikge1xuICAgIHNldHRlciA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNldHRlclNpZ25hdHVyZSwgc2V0dGVyKTtcbiAgICBkZXNjLnNldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgdmFyIGRlc3RydWN0b3JzID0gW107XG4gICAgIHNldHRlcihyYXdGaWVsZFB0ciwgZmllbGRUeXBlW1widG9XaXJlVHlwZVwiXShkZXN0cnVjdG9ycywgdikpO1xuICAgICBydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4gICAgfTtcbiAgIH1cbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yLCBmaWVsZE5hbWUsIGRlc2MpO1xuICAgcmV0dXJuIFtdO1xuICB9KTtcbiAgcmV0dXJuIFtdO1xuIH0pO1xufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcihyYXdDbGFzc1R5cGUsIGFyZ0NvdW50LCByYXdBcmdUeXBlc0FkZHIsIGludm9rZXJTaWduYXR1cmUsIGludm9rZXIsIHJhd0NvbnN0cnVjdG9yKSB7XG4gYXNzZXJ0KGFyZ0NvdW50ID4gMCk7XG4gdmFyIHJhd0FyZ1R5cGVzID0gaGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCwgcmF3QXJnVHlwZXNBZGRyKTtcbiBpbnZva2VyID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oaW52b2tlclNpZ25hdHVyZSwgaW52b2tlcik7XG4gdmFyIGFyZ3MgPSBbIHJhd0NvbnN0cnVjdG9yIF07XG4gdmFyIGRlc3RydWN0b3JzID0gW107XG4gd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIFsgcmF3Q2xhc3NUeXBlIF0sIGZ1bmN0aW9uKGNsYXNzVHlwZSkge1xuICBjbGFzc1R5cGUgPSBjbGFzc1R5cGVbMF07XG4gIHZhciBodW1hbk5hbWUgPSBcImNvbnN0cnVjdG9yIFwiICsgY2xhc3NUeXBlLm5hbWU7XG4gIGlmICh1bmRlZmluZWQgPT09IGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keSkge1xuICAgY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5ID0gW107XG4gIH1cbiAgaWYgKHVuZGVmaW5lZCAhPT0gY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ0NvdW50IC0gMV0pIHtcbiAgIHRocm93IG5ldyBCaW5kaW5nRXJyb3IoXCJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggaWRlbnRpY2FsIG51bWJlciBvZiBwYXJhbWV0ZXJzIChcIiArIChhcmdDb3VudCAtIDEpICsgXCIpIGZvciBjbGFzcyAnXCIgKyBjbGFzc1R5cGUubmFtZSArIFwiJyEgT3ZlcmxvYWQgcmVzb2x1dGlvbiBpcyBjdXJyZW50bHkgb25seSBwZXJmb3JtZWQgdXNpbmcgdGhlIHBhcmFtZXRlciBjb3VudCwgbm90IGFjdHVhbCB0eXBlIGluZm8hXCIpO1xuICB9XG4gIGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVthcmdDb3VudCAtIDFdID0gZnVuY3Rpb24gdW5ib3VuZFR5cGVIYW5kbGVyKCkge1xuICAgdGhyb3dVbmJvdW5kVHlwZUVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBcIiArIGNsYXNzVHlwZS5uYW1lICsgXCIgZHVlIHRvIHVuYm91bmQgdHlwZXNcIiwgcmF3QXJnVHlwZXMpO1xuICB9O1xuICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgcmF3QXJnVHlwZXMsIGZ1bmN0aW9uKGFyZ1R5cGVzKSB7XG4gICBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQgLSAxXSA9IGZ1bmN0aW9uIGNvbnN0cnVjdG9yX2JvZHkoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IGFyZ0NvdW50IC0gMSkge1xuICAgICB0aHJvd0JpbmRpbmdFcnJvcihodW1hbk5hbWUgKyBcIiBjYWxsZWQgd2l0aCBcIiArIGFyZ3VtZW50cy5sZW5ndGggKyBcIiBhcmd1bWVudHMsIGV4cGVjdGVkIFwiICsgKGFyZ0NvdW50IC0gMSkpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9ycy5sZW5ndGggPSAwO1xuICAgIGFyZ3MubGVuZ3RoID0gYXJnQ291bnQ7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdDb3VudDsgKytpKSB7XG4gICAgIGFyZ3NbaV0gPSBhcmdUeXBlc1tpXVtcInRvV2lyZVR5cGVcIl0oZGVzdHJ1Y3RvcnMsIGFyZ3VtZW50c1tpIC0gMV0pO1xuICAgIH1cbiAgICB2YXIgcHRyID0gaW52b2tlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICBydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4gICAgcmV0dXJuIGFyZ1R5cGVzWzBdW1wiZnJvbVdpcmVUeXBlXCJdKHB0cik7XG4gICB9O1xuICAgcmV0dXJuIFtdO1xuICB9KTtcbiAgcmV0dXJuIFtdO1xuIH0pO1xufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbihyYXdDbGFzc1R5cGUsIG1ldGhvZE5hbWUsIGFyZ0NvdW50LCByYXdBcmdUeXBlc0FkZHIsIGludm9rZXJTaWduYXR1cmUsIHJhd0ludm9rZXIsIGNvbnRleHQsIGlzUHVyZVZpcnR1YWwpIHtcbiB2YXIgcmF3QXJnVHlwZXMgPSBoZWFwMzJWZWN0b3JUb0FycmF5KGFyZ0NvdW50LCByYXdBcmdUeXBlc0FkZHIpO1xuIG1ldGhvZE5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG1ldGhvZE5hbWUpO1xuIHJhd0ludm9rZXIgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihpbnZva2VyU2lnbmF0dXJlLCByYXdJbnZva2VyKTtcbiB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgWyByYXdDbGFzc1R5cGUgXSwgZnVuY3Rpb24oY2xhc3NUeXBlKSB7XG4gIGNsYXNzVHlwZSA9IGNsYXNzVHlwZVswXTtcbiAgdmFyIGh1bWFuTmFtZSA9IGNsYXNzVHlwZS5uYW1lICsgXCIuXCIgKyBtZXRob2ROYW1lO1xuICBpZiAoaXNQdXJlVmlydHVhbCkge1xuICAgY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5wdXJlVmlydHVhbEZ1bmN0aW9ucy5wdXNoKG1ldGhvZE5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHVuYm91bmRUeXBlc0hhbmRsZXIoKSB7XG4gICB0aHJvd1VuYm91bmRUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBcIiArIGh1bWFuTmFtZSArIFwiIGR1ZSB0byB1bmJvdW5kIHR5cGVzXCIsIHJhd0FyZ1R5cGVzKTtcbiAgfVxuICB2YXIgcHJvdG8gPSBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlO1xuICB2YXIgbWV0aG9kID0gcHJvdG9bbWV0aG9kTmFtZV07XG4gIGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCB8fCB1bmRlZmluZWQgPT09IG1ldGhvZC5vdmVybG9hZFRhYmxlICYmIG1ldGhvZC5jbGFzc05hbWUgIT09IGNsYXNzVHlwZS5uYW1lICYmIG1ldGhvZC5hcmdDb3VudCA9PT0gYXJnQ291bnQgLSAyKSB7XG4gICB1bmJvdW5kVHlwZXNIYW5kbGVyLmFyZ0NvdW50ID0gYXJnQ291bnQgLSAyO1xuICAgdW5ib3VuZFR5cGVzSGFuZGxlci5jbGFzc05hbWUgPSBjbGFzc1R5cGUubmFtZTtcbiAgIHByb3RvW21ldGhvZE5hbWVdID0gdW5ib3VuZFR5cGVzSGFuZGxlcjtcbiAgfSBlbHNlIHtcbiAgIGVuc3VyZU92ZXJsb2FkVGFibGUocHJvdG8sIG1ldGhvZE5hbWUsIGh1bWFuTmFtZSk7XG4gICBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ0NvdW50IC0gMl0gPSB1bmJvdW5kVHlwZXNIYW5kbGVyO1xuICB9XG4gIHdoZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtdLCByYXdBcmdUeXBlcywgZnVuY3Rpb24oYXJnVHlwZXMpIHtcbiAgIHZhciBtZW1iZXJGdW5jdGlvbiA9IGNyYWZ0SW52b2tlckZ1bmN0aW9uKGh1bWFuTmFtZSwgYXJnVHlwZXMsIGNsYXNzVHlwZSwgcmF3SW52b2tlciwgY29udGV4dCk7XG4gICBpZiAodW5kZWZpbmVkID09PSBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlKSB7XG4gICAgbWVtYmVyRnVuY3Rpb24uYXJnQ291bnQgPSBhcmdDb3VudCAtIDI7XG4gICAgcHJvdG9bbWV0aG9kTmFtZV0gPSBtZW1iZXJGdW5jdGlvbjtcbiAgIH0gZWxzZSB7XG4gICAgcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVthcmdDb3VudCAtIDJdID0gbWVtYmVyRnVuY3Rpb247XG4gICB9XG4gICByZXR1cm4gW107XG4gIH0pO1xuICByZXR1cm4gW107XG4gfSk7XG59XG5cbmZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX3Byb3BlcnR5KGNsYXNzVHlwZSwgZmllbGROYW1lLCBnZXR0ZXJSZXR1cm5UeXBlLCBnZXR0ZXJTaWduYXR1cmUsIGdldHRlciwgZ2V0dGVyQ29udGV4dCwgc2V0dGVyQXJndW1lbnRUeXBlLCBzZXR0ZXJTaWduYXR1cmUsIHNldHRlciwgc2V0dGVyQ29udGV4dCkge1xuIGZpZWxkTmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcoZmllbGROYW1lKTtcbiBnZXR0ZXIgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihnZXR0ZXJTaWduYXR1cmUsIGdldHRlcik7XG4gd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIFsgY2xhc3NUeXBlIF0sIGZ1bmN0aW9uKGNsYXNzVHlwZSkge1xuICBjbGFzc1R5cGUgPSBjbGFzc1R5cGVbMF07XG4gIHZhciBodW1hbk5hbWUgPSBjbGFzc1R5cGUubmFtZSArIFwiLlwiICsgZmllbGROYW1lO1xuICB2YXIgZGVzYyA9IHtcbiAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3dVbmJvdW5kVHlwZUVycm9yKFwiQ2Fubm90IGFjY2VzcyBcIiArIGh1bWFuTmFtZSArIFwiIGR1ZSB0byB1bmJvdW5kIHR5cGVzXCIsIFsgZ2V0dGVyUmV0dXJuVHlwZSwgc2V0dGVyQXJndW1lbnRUeXBlIF0pO1xuICAgfSxcbiAgIGVudW1lcmFibGU6IHRydWUsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfTtcbiAgaWYgKHNldHRlcikge1xuICAgZGVzYy5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvd1VuYm91bmRUeXBlRXJyb3IoXCJDYW5ub3QgYWNjZXNzIFwiICsgaHVtYW5OYW1lICsgXCIgZHVlIHRvIHVuYm91bmQgdHlwZXNcIiwgWyBnZXR0ZXJSZXR1cm5UeXBlLCBzZXR0ZXJBcmd1bWVudFR5cGUgXSk7XG4gICB9O1xuICB9IGVsc2Uge1xuICAgZGVzYy5zZXQgPSBmdW5jdGlvbih2KSB7XG4gICAgdGhyb3dCaW5kaW5nRXJyb3IoaHVtYW5OYW1lICsgXCIgaXMgYSByZWFkLW9ubHkgcHJvcGVydHlcIik7XG4gICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCBmaWVsZE5hbWUsIGRlc2MpO1xuICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgc2V0dGVyID8gWyBnZXR0ZXJSZXR1cm5UeXBlLCBzZXR0ZXJBcmd1bWVudFR5cGUgXSA6IFsgZ2V0dGVyUmV0dXJuVHlwZSBdLCBmdW5jdGlvbih0eXBlcykge1xuICAgdmFyIGdldHRlclJldHVyblR5cGUgPSB0eXBlc1swXTtcbiAgIHZhciBkZXNjID0ge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgIHZhciBwdHIgPSB2YWxpZGF0ZVRoaXModGhpcywgY2xhc3NUeXBlLCBodW1hbk5hbWUgKyBcIiBnZXR0ZXJcIik7XG4gICAgIHJldHVybiBnZXR0ZXJSZXR1cm5UeXBlW1wiZnJvbVdpcmVUeXBlXCJdKGdldHRlcihnZXR0ZXJDb250ZXh0LCBwdHIpKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgIH07XG4gICBpZiAoc2V0dGVyKSB7XG4gICAgc2V0dGVyID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oc2V0dGVyU2lnbmF0dXJlLCBzZXR0ZXIpO1xuICAgIHZhciBzZXR0ZXJBcmd1bWVudFR5cGUgPSB0eXBlc1sxXTtcbiAgICBkZXNjLnNldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgdmFyIHB0ciA9IHZhbGlkYXRlVGhpcyh0aGlzLCBjbGFzc1R5cGUsIGh1bWFuTmFtZSArIFwiIHNldHRlclwiKTtcbiAgICAgdmFyIGRlc3RydWN0b3JzID0gW107XG4gICAgIHNldHRlcihzZXR0ZXJDb250ZXh0LCBwdHIsIHNldHRlckFyZ3VtZW50VHlwZVtcInRvV2lyZVR5cGVcIl0oZGVzdHJ1Y3RvcnMsIHYpKTtcbiAgICAgcnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpO1xuICAgIH07XG4gICB9XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwgZmllbGROYW1lLCBkZXNjKTtcbiAgIHJldHVybiBbXTtcbiAgfSk7XG4gIHJldHVybiBbXTtcbiB9KTtcbn1cblxuZnVuY3Rpb24gX19lbXZhbF9kZWNyZWYoaGFuZGxlKSB7XG4gaWYgKGhhbmRsZSA+IDQgJiYgMCA9PT0gLS1lbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXS5yZWZjb3VudCkge1xuICBlbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXSA9IHVuZGVmaW5lZDtcbiAgZW12YWxfZnJlZV9saXN0LnB1c2goaGFuZGxlKTtcbiB9XG59XG5cbmZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsKHJhd1R5cGUsIG5hbWUpIHtcbiBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTtcbiByZWdpc3RlclR5cGUocmF3VHlwZSwge1xuICBuYW1lOiBuYW1lLFxuICBcImZyb21XaXJlVHlwZVwiOiBmdW5jdGlvbihoYW5kbGUpIHtcbiAgIHZhciBydiA9IGVtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdLnZhbHVlO1xuICAgX19lbXZhbF9kZWNyZWYoaGFuZGxlKTtcbiAgIHJldHVybiBydjtcbiAgfSxcbiAgXCJ0b1dpcmVUeXBlXCI6IGZ1bmN0aW9uKGRlc3RydWN0b3JzLCB2YWx1ZSkge1xuICAgcmV0dXJuIF9fZW12YWxfcmVnaXN0ZXIodmFsdWUpO1xuICB9LFxuICBcImFyZ1BhY2tBZHZhbmNlXCI6IDgsXG4gIFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjogc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsXG4gIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbFxuIH0pO1xufVxuXG5mdW5jdGlvbiBlbnVtUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSwgc2hpZnQsIHNpZ25lZCkge1xuIHN3aXRjaCAoc2hpZnQpIHtcbiBjYXNlIDA6XG4gIHJldHVybiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICB2YXIgaGVhcCA9IHNpZ25lZCA/IEhFQVA4IDogSEVBUFU4O1xuICAgcmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oaGVhcFtwb2ludGVyXSk7XG4gIH07XG5cbiBjYXNlIDE6XG4gIHJldHVybiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICB2YXIgaGVhcCA9IHNpZ25lZCA/IEhFQVAxNiA6IEhFQVBVMTY7XG4gICByZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShoZWFwW3BvaW50ZXIgPj4gMV0pO1xuICB9O1xuXG4gY2FzZSAyOlxuICByZXR1cm4gZnVuY3Rpb24ocG9pbnRlcikge1xuICAgdmFyIGhlYXAgPSBzaWduZWQgPyBIRUFQMzIgOiBIRUFQVTMyO1xuICAgcmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oaGVhcFtwb2ludGVyID4+IDJdKTtcbiAgfTtcblxuIGRlZmF1bHQ6XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGludGVnZXIgdHlwZTogXCIgKyBuYW1lKTtcbiB9XG59XG5cbmZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2VudW0ocmF3VHlwZSwgbmFtZSwgc2l6ZSwgaXNTaWduZWQpIHtcbiB2YXIgc2hpZnQgPSBnZXRTaGlmdEZyb21TaXplKHNpemUpO1xuIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpO1xuIGZ1bmN0aW9uIGN0b3IoKSB7fVxuIGN0b3IudmFsdWVzID0ge307XG4gcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHtcbiAgbmFtZTogbmFtZSxcbiAgY29uc3RydWN0b3I6IGN0b3IsXG4gIFwiZnJvbVdpcmVUeXBlXCI6IGZ1bmN0aW9uKGMpIHtcbiAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnZhbHVlc1tjXTtcbiAgfSxcbiAgXCJ0b1dpcmVUeXBlXCI6IGZ1bmN0aW9uKGRlc3RydWN0b3JzLCBjKSB7XG4gICByZXR1cm4gYy52YWx1ZTtcbiAgfSxcbiAgXCJhcmdQYWNrQWR2YW5jZVwiOiA4LFxuICBcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6IGVudW1SZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCwgaXNTaWduZWQpLFxuICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGxcbiB9KTtcbiBleHBvc2VQdWJsaWNTeW1ib2wobmFtZSwgY3Rvcik7XG59XG5cbmZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2VudW1fdmFsdWUocmF3RW51bVR5cGUsIG5hbWUsIGVudW1WYWx1ZSkge1xuIHZhciBlbnVtVHlwZSA9IHJlcXVpcmVSZWdpc3RlcmVkVHlwZShyYXdFbnVtVHlwZSwgXCJlbnVtXCIpO1xuIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpO1xuIHZhciBFbnVtID0gZW51bVR5cGUuY29uc3RydWN0b3I7XG4gdmFyIFZhbHVlID0gT2JqZWN0LmNyZWF0ZShlbnVtVHlwZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgdmFsdWU6IHtcbiAgIHZhbHVlOiBlbnVtVmFsdWVcbiAgfSxcbiAgY29uc3RydWN0b3I6IHtcbiAgIHZhbHVlOiBjcmVhdGVOYW1lZEZ1bmN0aW9uKGVudW1UeXBlLm5hbWUgKyBcIl9cIiArIG5hbWUsIGZ1bmN0aW9uKCkge30pXG4gIH1cbiB9KTtcbiBFbnVtLnZhbHVlc1tlbnVtVmFsdWVdID0gVmFsdWU7XG4gRW51bVtuYW1lXSA9IFZhbHVlO1xufVxuXG5mdW5jdGlvbiBfZW1iaW5kX3JlcHIodikge1xuIGlmICh2ID09PSBudWxsKSB7XG4gIHJldHVybiBcIm51bGxcIjtcbiB9XG4gdmFyIHQgPSB0eXBlb2YgdjtcbiBpZiAodCA9PT0gXCJvYmplY3RcIiB8fCB0ID09PSBcImFycmF5XCIgfHwgdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIHJldHVybiB2LnRvU3RyaW5nKCk7XG4gfSBlbHNlIHtcbiAgcmV0dXJuIFwiXCIgKyB2O1xuIH1cbn1cblxuZnVuY3Rpb24gZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCkge1xuIHN3aXRjaCAoc2hpZnQpIHtcbiBjYXNlIDI6XG4gIHJldHVybiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICByZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQRjMyW3BvaW50ZXIgPj4gMl0pO1xuICB9O1xuXG4gY2FzZSAzOlxuICByZXR1cm4gZnVuY3Rpb24ocG9pbnRlcikge1xuICAgcmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oSEVBUEY2NFtwb2ludGVyID4+IDNdKTtcbiAgfTtcblxuIGRlZmF1bHQ6XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGZsb2F0IHR5cGU6IFwiICsgbmFtZSk7XG4gfVxufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdChyYXdUeXBlLCBuYW1lLCBzaXplKSB7XG4gdmFyIHNoaWZ0ID0gZ2V0U2hpZnRGcm9tU2l6ZShzaXplKTtcbiBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTtcbiByZWdpc3RlclR5cGUocmF3VHlwZSwge1xuICBuYW1lOiBuYW1lLFxuICBcImZyb21XaXJlVHlwZVwiOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBcInRvV2lyZVR5cGVcIjogZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsIHZhbHVlKSB7XG4gICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBcIicgKyBfZW1iaW5kX3JlcHIodmFsdWUpICsgJ1wiIHRvICcgKyB0aGlzLm5hbWUpO1xuICAgfVxuICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBcImFyZ1BhY2tBZHZhbmNlXCI6IDgsXG4gIFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjogZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCksXG4gIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbFxuIH0pO1xufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbihuYW1lLCBhcmdDb3VudCwgcmF3QXJnVHlwZXNBZGRyLCBzaWduYXR1cmUsIHJhd0ludm9rZXIsIGZuKSB7XG4gdmFyIGFyZ1R5cGVzID0gaGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCwgcmF3QXJnVHlwZXNBZGRyKTtcbiBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTtcbiByYXdJbnZva2VyID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oc2lnbmF0dXJlLCByYXdJbnZva2VyKTtcbiBleHBvc2VQdWJsaWNTeW1ib2wobmFtZSwgZnVuY3Rpb24oKSB7XG4gIHRocm93VW5ib3VuZFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIFwiICsgbmFtZSArIFwiIGR1ZSB0byB1bmJvdW5kIHR5cGVzXCIsIGFyZ1R5cGVzKTtcbiB9LCBhcmdDb3VudCAtIDEpO1xuIHdoZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtdLCBhcmdUeXBlcywgZnVuY3Rpb24oYXJnVHlwZXMpIHtcbiAgdmFyIGludm9rZXJBcmdzQXJyYXkgPSBbIGFyZ1R5cGVzWzBdLCBudWxsIF0uY29uY2F0KGFyZ1R5cGVzLnNsaWNlKDEpKTtcbiAgcmVwbGFjZVB1YmxpY1N5bWJvbChuYW1lLCBjcmFmdEludm9rZXJGdW5jdGlvbihuYW1lLCBpbnZva2VyQXJnc0FycmF5LCBudWxsLCByYXdJbnZva2VyLCBmbiksIGFyZ0NvdW50IC0gMSk7XG4gIHJldHVybiBbXTtcbiB9KTtcbn1cblxuZnVuY3Rpb24gaW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsIHNoaWZ0LCBzaWduZWQpIHtcbiBzd2l0Y2ggKHNoaWZ0KSB7XG4gY2FzZSAwOlxuICByZXR1cm4gc2lnbmVkID8gZnVuY3Rpb24gcmVhZFM4RnJvbVBvaW50ZXIocG9pbnRlcikge1xuICAgcmV0dXJuIEhFQVA4W3BvaW50ZXJdO1xuICB9IDogZnVuY3Rpb24gcmVhZFU4RnJvbVBvaW50ZXIocG9pbnRlcikge1xuICAgcmV0dXJuIEhFQVBVOFtwb2ludGVyXTtcbiAgfTtcblxuIGNhc2UgMTpcbiAgcmV0dXJuIHNpZ25lZCA/IGZ1bmN0aW9uIHJlYWRTMTZGcm9tUG9pbnRlcihwb2ludGVyKSB7XG4gICByZXR1cm4gSEVBUDE2W3BvaW50ZXIgPj4gMV07XG4gIH0gOiBmdW5jdGlvbiByZWFkVTE2RnJvbVBvaW50ZXIocG9pbnRlcikge1xuICAgcmV0dXJuIEhFQVBVMTZbcG9pbnRlciA+PiAxXTtcbiAgfTtcblxuIGNhc2UgMjpcbiAgcmV0dXJuIHNpZ25lZCA/IGZ1bmN0aW9uIHJlYWRTMzJGcm9tUG9pbnRlcihwb2ludGVyKSB7XG4gICByZXR1cm4gSEVBUDMyW3BvaW50ZXIgPj4gMl07XG4gIH0gOiBmdW5jdGlvbiByZWFkVTMyRnJvbVBvaW50ZXIocG9pbnRlcikge1xuICAgcmV0dXJuIEhFQVBVMzJbcG9pbnRlciA+PiAyXTtcbiAgfTtcblxuIGRlZmF1bHQ6XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGludGVnZXIgdHlwZTogXCIgKyBuYW1lKTtcbiB9XG59XG5cbmZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIocHJpbWl0aXZlVHlwZSwgbmFtZSwgc2l6ZSwgbWluUmFuZ2UsIG1heFJhbmdlKSB7XG4gbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7XG4gaWYgKG1heFJhbmdlID09PSAtMSkge1xuICBtYXhSYW5nZSA9IDQyOTQ5NjcyOTU7XG4gfVxuIHZhciBzaGlmdCA9IGdldFNoaWZ0RnJvbVNpemUoc2l6ZSk7XG4gdmFyIGZyb21XaXJlVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbiB9O1xuIGlmIChtaW5SYW5nZSA9PT0gMCkge1xuICB2YXIgYml0c2hpZnQgPSAzMiAtIDggKiBzaXplO1xuICBmcm9tV2lyZVR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgcmV0dXJuIHZhbHVlIDw8IGJpdHNoaWZ0ID4+PiBiaXRzaGlmdDtcbiAgfTtcbiB9XG4gdmFyIGlzVW5zaWduZWRUeXBlID0gbmFtZS5pbmRleE9mKFwidW5zaWduZWRcIikgIT0gLTE7XG4gcmVnaXN0ZXJUeXBlKHByaW1pdGl2ZVR5cGUsIHtcbiAgbmFtZTogbmFtZSxcbiAgXCJmcm9tV2lyZVR5cGVcIjogZnJvbVdpcmVUeXBlLFxuICBcInRvV2lyZVR5cGVcIjogZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsIHZhbHVlKSB7XG4gICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBcIicgKyBfZW1iaW5kX3JlcHIodmFsdWUpICsgJ1wiIHRvICcgKyB0aGlzLm5hbWUpO1xuICAgfVxuICAgaWYgKHZhbHVlIDwgbWluUmFuZ2UgfHwgdmFsdWUgPiBtYXhSYW5nZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Bhc3NpbmcgYSBudW1iZXIgXCInICsgX2VtYmluZF9yZXByKHZhbHVlKSArICdcIiBmcm9tIEpTIHNpZGUgdG8gQy9DKysgc2lkZSB0byBhbiBhcmd1bWVudCBvZiB0eXBlIFwiJyArIG5hbWUgKyAnXCIsIHdoaWNoIGlzIG91dHNpZGUgdGhlIHZhbGlkIHJhbmdlIFsnICsgbWluUmFuZ2UgKyBcIiwgXCIgKyBtYXhSYW5nZSArIFwiXSFcIik7XG4gICB9XG4gICByZXR1cm4gaXNVbnNpZ25lZFR5cGUgPyB2YWx1ZSA+Pj4gMCA6IHZhbHVlIHwgMDtcbiAgfSxcbiAgXCJhcmdQYWNrQWR2YW5jZVwiOiA4LFxuICBcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6IGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCwgbWluUmFuZ2UgIT09IDApLFxuICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGxcbiB9KTtcbn1cblxuZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcocmF3VHlwZSwgZGF0YVR5cGVJbmRleCwgbmFtZSkge1xuIHZhciB0eXBlTWFwcGluZyA9IFsgSW50OEFycmF5LCBVaW50OEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSwgSW50MzJBcnJheSwgVWludDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQ2NEFycmF5IF07XG4gdmFyIFRBID0gdHlwZU1hcHBpbmdbZGF0YVR5cGVJbmRleF07XG4gZnVuY3Rpb24gZGVjb2RlTWVtb3J5VmlldyhoYW5kbGUpIHtcbiAgaGFuZGxlID0gaGFuZGxlID4+IDI7XG4gIHZhciBoZWFwID0gSEVBUFUzMjtcbiAgdmFyIHNpemUgPSBoZWFwW2hhbmRsZV07XG4gIHZhciBkYXRhID0gaGVhcFtoYW5kbGUgKyAxXTtcbiAgcmV0dXJuIG5ldyBUQShidWZmZXIsIGRhdGEsIHNpemUpO1xuIH1cbiBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTtcbiByZWdpc3RlclR5cGUocmF3VHlwZSwge1xuICBuYW1lOiBuYW1lLFxuICBcImZyb21XaXJlVHlwZVwiOiBkZWNvZGVNZW1vcnlWaWV3LFxuICBcImFyZ1BhY2tBZHZhbmNlXCI6IDgsXG4gIFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjogZGVjb2RlTWVtb3J5Vmlld1xuIH0sIHtcbiAgaWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9uczogdHJ1ZVxuIH0pO1xufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nKHJhd1R5cGUsIG5hbWUpIHtcbiBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTtcbiB2YXIgc3RkU3RyaW5nSXNVVEY4ID0gbmFtZSA9PT0gXCJzdGQ6OnN0cmluZ1wiO1xuIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCB7XG4gIG5hbWU6IG5hbWUsXG4gIFwiZnJvbVdpcmVUeXBlXCI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICB2YXIgbGVuZ3RoID0gSEVBUFUzMlt2YWx1ZSA+PiAyXTtcbiAgIHZhciBzdHI7XG4gICBpZiAoc3RkU3RyaW5nSXNVVEY4KSB7XG4gICAgdmFyIGRlY29kZVN0YXJ0UHRyID0gdmFsdWUgKyA0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxlbmd0aDsgKytpKSB7XG4gICAgIHZhciBjdXJyZW50Qnl0ZVB0ciA9IHZhbHVlICsgNCArIGk7XG4gICAgIGlmIChpID09IGxlbmd0aCB8fCBIRUFQVThbY3VycmVudEJ5dGVQdHJdID09IDApIHtcbiAgICAgIHZhciBtYXhSZWFkID0gY3VycmVudEJ5dGVQdHIgLSBkZWNvZGVTdGFydFB0cjtcbiAgICAgIHZhciBzdHJpbmdTZWdtZW50ID0gVVRGOFRvU3RyaW5nKGRlY29kZVN0YXJ0UHRyLCBtYXhSZWFkKTtcbiAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgIHN0ciA9IHN0cmluZ1NlZ21lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDApO1xuICAgICAgIHN0ciArPSBzdHJpbmdTZWdtZW50O1xuICAgICAgfVxuICAgICAgZGVjb2RlU3RhcnRQdHIgPSBjdXJyZW50Qnl0ZVB0ciArIDE7XG4gICAgIH1cbiAgICB9XG4gICB9IGVsc2Uge1xuICAgIHZhciBhID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICBhW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShIRUFQVThbdmFsdWUgKyA0ICsgaV0pO1xuICAgIH1cbiAgICBzdHIgPSBhLmpvaW4oXCJcIik7XG4gICB9XG4gICBfZnJlZSh2YWx1ZSk7XG4gICByZXR1cm4gc3RyO1xuICB9LFxuICBcInRvV2lyZVR5cGVcIjogZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsIHZhbHVlKSB7XG4gICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgfVxuICAgdmFyIGdldExlbmd0aDtcbiAgIHZhciB2YWx1ZUlzT2ZUeXBlU3RyaW5nID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xuICAgaWYgKCEodmFsdWVJc09mVHlwZVN0cmluZyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSkpIHtcbiAgICB0aHJvd0JpbmRpbmdFcnJvcihcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmdcIik7XG4gICB9XG4gICBpZiAoc3RkU3RyaW5nSXNVVEY4ICYmIHZhbHVlSXNPZlR5cGVTdHJpbmcpIHtcbiAgICBnZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgcmV0dXJuIGxlbmd0aEJ5dGVzVVRGOCh2YWx1ZSk7XG4gICAgfTtcbiAgIH0gZWxzZSB7XG4gICAgZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgfTtcbiAgIH1cbiAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoKTtcbiAgIHZhciBwdHIgPSBfbWFsbG9jKDQgKyBsZW5ndGggKyAxKTtcbiAgIEhFQVBVMzJbcHRyID4+IDJdID0gbGVuZ3RoO1xuICAgaWYgKHN0ZFN0cmluZ0lzVVRGOCAmJiB2YWx1ZUlzT2ZUeXBlU3RyaW5nKSB7XG4gICAgc3RyaW5nVG9VVEY4KHZhbHVlLCBwdHIgKyA0LCBsZW5ndGggKyAxKTtcbiAgIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlSXNPZlR5cGVTdHJpbmcpIHtcbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDI1NSkge1xuICAgICAgIF9mcmVlKHB0cik7XG4gICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoXCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHNcIik7XG4gICAgICB9XG4gICAgICBIRUFQVThbcHRyICsgNCArIGldID0gY2hhckNvZGU7XG4gICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBIRUFQVThbcHRyICsgNCArIGldID0gdmFsdWVbaV07XG4gICAgIH1cbiAgICB9XG4gICB9XG4gICBpZiAoZGVzdHJ1Y3RvcnMgIT09IG51bGwpIHtcbiAgICBkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLCBwdHIpO1xuICAgfVxuICAgcmV0dXJuIHB0cjtcbiAgfSxcbiAgXCJhcmdQYWNrQWR2YW5jZVwiOiA4LFxuICBcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6IHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLFxuICBkZXN0cnVjdG9yRnVuY3Rpb246IGZ1bmN0aW9uKHB0cikge1xuICAgX2ZyZWUocHRyKTtcbiAgfVxuIH0pO1xufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZyhyYXdUeXBlLCBjaGFyU2l6ZSwgbmFtZSkge1xuIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpO1xuIHZhciBkZWNvZGVTdHJpbmcsIGVuY29kZVN0cmluZywgZ2V0SGVhcCwgbGVuZ3RoQnl0ZXNVVEYsIHNoaWZ0O1xuIGlmIChjaGFyU2l6ZSA9PT0gMikge1xuICBkZWNvZGVTdHJpbmcgPSBVVEYxNlRvU3RyaW5nO1xuICBlbmNvZGVTdHJpbmcgPSBzdHJpbmdUb1VURjE2O1xuICBsZW5ndGhCeXRlc1VURiA9IGxlbmd0aEJ5dGVzVVRGMTY7XG4gIGdldEhlYXAgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBIRUFQVTE2O1xuICB9O1xuICBzaGlmdCA9IDE7XG4gfSBlbHNlIGlmIChjaGFyU2l6ZSA9PT0gNCkge1xuICBkZWNvZGVTdHJpbmcgPSBVVEYzMlRvU3RyaW5nO1xuICBlbmNvZGVTdHJpbmcgPSBzdHJpbmdUb1VURjMyO1xuICBsZW5ndGhCeXRlc1VURiA9IGxlbmd0aEJ5dGVzVVRGMzI7XG4gIGdldEhlYXAgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBIRUFQVTMyO1xuICB9O1xuICBzaGlmdCA9IDI7XG4gfVxuIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCB7XG4gIG5hbWU6IG5hbWUsXG4gIFwiZnJvbVdpcmVUeXBlXCI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICB2YXIgbGVuZ3RoID0gSEVBUFUzMlt2YWx1ZSA+PiAyXTtcbiAgIHZhciBIRUFQID0gZ2V0SGVhcCgpO1xuICAgdmFyIHN0cjtcbiAgIHZhciBkZWNvZGVTdGFydFB0ciA9IHZhbHVlICsgNDtcbiAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGN1cnJlbnRCeXRlUHRyID0gdmFsdWUgKyA0ICsgaSAqIGNoYXJTaXplO1xuICAgIGlmIChpID09IGxlbmd0aCB8fCBIRUFQW2N1cnJlbnRCeXRlUHRyID4+IHNoaWZ0XSA9PSAwKSB7XG4gICAgIHZhciBtYXhSZWFkQnl0ZXMgPSBjdXJyZW50Qnl0ZVB0ciAtIGRlY29kZVN0YXJ0UHRyO1xuICAgICB2YXIgc3RyaW5nU2VnbWVudCA9IGRlY29kZVN0cmluZyhkZWNvZGVTdGFydFB0ciwgbWF4UmVhZEJ5dGVzKTtcbiAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHIgPSBzdHJpbmdTZWdtZW50O1xuICAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7XG4gICAgICBzdHIgKz0gc3RyaW5nU2VnbWVudDtcbiAgICAgfVxuICAgICBkZWNvZGVTdGFydFB0ciA9IGN1cnJlbnRCeXRlUHRyICsgY2hhclNpemU7XG4gICAgfVxuICAgfVxuICAgX2ZyZWUodmFsdWUpO1xuICAgcmV0dXJuIHN0cjtcbiAgfSxcbiAgXCJ0b1dpcmVUeXBlXCI6IGZ1bmN0aW9uKGRlc3RydWN0b3JzLCB2YWx1ZSkge1xuICAgaWYgKCEodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSkge1xuICAgIHRocm93QmluZGluZ0Vycm9yKFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgXCIgKyBuYW1lKTtcbiAgIH1cbiAgIHZhciBsZW5ndGggPSBsZW5ndGhCeXRlc1VURih2YWx1ZSk7XG4gICB2YXIgcHRyID0gX21hbGxvYyg0ICsgbGVuZ3RoICsgY2hhclNpemUpO1xuICAgSEVBUFUzMltwdHIgPj4gMl0gPSBsZW5ndGggPj4gc2hpZnQ7XG4gICBlbmNvZGVTdHJpbmcodmFsdWUsIHB0ciArIDQsIGxlbmd0aCArIGNoYXJTaXplKTtcbiAgIGlmIChkZXN0cnVjdG9ycyAhPT0gbnVsbCkge1xuICAgIGRlc3RydWN0b3JzLnB1c2goX2ZyZWUsIHB0cik7XG4gICB9XG4gICByZXR1cm4gcHRyO1xuICB9LFxuICBcImFyZ1BhY2tBZHZhbmNlXCI6IDgsXG4gIFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjogc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsXG4gIGRlc3RydWN0b3JGdW5jdGlvbjogZnVuY3Rpb24ocHRyKSB7XG4gICBfZnJlZShwdHIpO1xuICB9XG4gfSk7XG59XG5cbmZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdChyYXdUeXBlLCBuYW1lLCBjb25zdHJ1Y3RvclNpZ25hdHVyZSwgcmF3Q29uc3RydWN0b3IsIGRlc3RydWN0b3JTaWduYXR1cmUsIHJhd0Rlc3RydWN0b3IpIHtcbiBzdHJ1Y3RSZWdpc3RyYXRpb25zW3Jhd1R5cGVdID0ge1xuICBuYW1lOiByZWFkTGF0aW4xU3RyaW5nKG5hbWUpLFxuICByYXdDb25zdHJ1Y3RvcjogZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oY29uc3RydWN0b3JTaWduYXR1cmUsIHJhd0NvbnN0cnVjdG9yKSxcbiAgcmF3RGVzdHJ1Y3RvcjogZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZGVzdHJ1Y3RvclNpZ25hdHVyZSwgcmF3RGVzdHJ1Y3RvciksXG4gIGZpZWxkczogW11cbiB9O1xufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGQoc3RydWN0VHlwZSwgZmllbGROYW1lLCBnZXR0ZXJSZXR1cm5UeXBlLCBnZXR0ZXJTaWduYXR1cmUsIGdldHRlciwgZ2V0dGVyQ29udGV4dCwgc2V0dGVyQXJndW1lbnRUeXBlLCBzZXR0ZXJTaWduYXR1cmUsIHNldHRlciwgc2V0dGVyQ29udGV4dCkge1xuIHN0cnVjdFJlZ2lzdHJhdGlvbnNbc3RydWN0VHlwZV0uZmllbGRzLnB1c2goe1xuICBmaWVsZE5hbWU6IHJlYWRMYXRpbjFTdHJpbmcoZmllbGROYW1lKSxcbiAgZ2V0dGVyUmV0dXJuVHlwZTogZ2V0dGVyUmV0dXJuVHlwZSxcbiAgZ2V0dGVyOiBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihnZXR0ZXJTaWduYXR1cmUsIGdldHRlciksXG4gIGdldHRlckNvbnRleHQ6IGdldHRlckNvbnRleHQsXG4gIHNldHRlckFyZ3VtZW50VHlwZTogc2V0dGVyQXJndW1lbnRUeXBlLFxuICBzZXR0ZXI6IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNldHRlclNpZ25hdHVyZSwgc2V0dGVyKSxcbiAgc2V0dGVyQ29udGV4dDogc2V0dGVyQ29udGV4dFxuIH0pO1xufVxuXG5mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl92b2lkKHJhd1R5cGUsIG5hbWUpIHtcbiBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTtcbiByZWdpc3RlclR5cGUocmF3VHlwZSwge1xuICBpc1ZvaWQ6IHRydWUsXG4gIG5hbWU6IG5hbWUsXG4gIFwiYXJnUGFja0FkdmFuY2VcIjogMCxcbiAgXCJmcm9tV2lyZVR5cGVcIjogZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuICBcInRvV2lyZVR5cGVcIjogZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsIG8pIHtcbiAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiB9KTtcbn1cblxuZnVuY3Rpb24gX19lbXZhbF9hcyhoYW5kbGUsIHJldHVyblR5cGUsIGRlc3RydWN0b3JzUmVmKSB7XG4gaGFuZGxlID0gcmVxdWlyZUhhbmRsZShoYW5kbGUpO1xuIHJldHVyblR5cGUgPSByZXF1aXJlUmVnaXN0ZXJlZFR5cGUocmV0dXJuVHlwZSwgXCJlbXZhbDo6YXNcIik7XG4gdmFyIGRlc3RydWN0b3JzID0gW107XG4gdmFyIHJkID0gX19lbXZhbF9yZWdpc3RlcihkZXN0cnVjdG9ycyk7XG4gSEVBUDMyW2Rlc3RydWN0b3JzUmVmID4+IDJdID0gcmQ7XG4gcmV0dXJuIHJldHVyblR5cGVbXCJ0b1dpcmVUeXBlXCJdKGRlc3RydWN0b3JzLCBoYW5kbGUpO1xufVxuXG5mdW5jdGlvbiBfX2VtdmFsX2FsbG9jYXRlRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnNSZWYpIHtcbiB2YXIgZGVzdHJ1Y3RvcnMgPSBbXTtcbiBIRUFQMzJbZGVzdHJ1Y3RvcnNSZWYgPj4gMl0gPSBfX2VtdmFsX3JlZ2lzdGVyKGRlc3RydWN0b3JzKTtcbiByZXR1cm4gZGVzdHJ1Y3RvcnM7XG59XG5cbnZhciBlbXZhbF9zeW1ib2xzID0ge307XG5cbmZ1bmN0aW9uIGdldFN0cmluZ09yU3ltYm9sKGFkZHJlc3MpIHtcbiB2YXIgc3ltYm9sID0gZW12YWxfc3ltYm9sc1thZGRyZXNzXTtcbiBpZiAoc3ltYm9sID09PSB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIHJlYWRMYXRpbjFTdHJpbmcoYWRkcmVzcyk7XG4gfSBlbHNlIHtcbiAgcmV0dXJuIHN5bWJvbDtcbiB9XG59XG5cbnZhciBlbXZhbF9tZXRob2RDYWxsZXJzID0gW107XG5cbmZ1bmN0aW9uIF9fZW12YWxfY2FsbF9tZXRob2QoY2FsbGVyLCBoYW5kbGUsIG1ldGhvZE5hbWUsIGRlc3RydWN0b3JzUmVmLCBhcmdzKSB7XG4gY2FsbGVyID0gZW12YWxfbWV0aG9kQ2FsbGVyc1tjYWxsZXJdO1xuIGhhbmRsZSA9IHJlcXVpcmVIYW5kbGUoaGFuZGxlKTtcbiBtZXRob2ROYW1lID0gZ2V0U3RyaW5nT3JTeW1ib2wobWV0aG9kTmFtZSk7XG4gcmV0dXJuIGNhbGxlcihoYW5kbGUsIG1ldGhvZE5hbWUsIF9fZW12YWxfYWxsb2NhdGVEZXN0cnVjdG9ycyhkZXN0cnVjdG9yc1JlZiksIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBfX2VtdmFsX2NhbGxfdm9pZF9tZXRob2QoY2FsbGVyLCBoYW5kbGUsIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiBjYWxsZXIgPSBlbXZhbF9tZXRob2RDYWxsZXJzW2NhbGxlcl07XG4gaGFuZGxlID0gcmVxdWlyZUhhbmRsZShoYW5kbGUpO1xuIG1ldGhvZE5hbWUgPSBnZXRTdHJpbmdPclN5bWJvbChtZXRob2ROYW1lKTtcbiBjYWxsZXIoaGFuZGxlLCBtZXRob2ROYW1lLCBudWxsLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gX19lbXZhbF9hZGRNZXRob2RDYWxsZXIoY2FsbGVyKSB7XG4gdmFyIGlkID0gZW12YWxfbWV0aG9kQ2FsbGVycy5sZW5ndGg7XG4gZW12YWxfbWV0aG9kQ2FsbGVycy5wdXNoKGNhbGxlcik7XG4gcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBfX2VtdmFsX2xvb2t1cFR5cGVzKGFyZ0NvdW50LCBhcmdUeXBlcykge1xuIHZhciBhID0gbmV3IEFycmF5KGFyZ0NvdW50KTtcbiBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0NvdW50OyArK2kpIHtcbiAgYVtpXSA9IHJlcXVpcmVSZWdpc3RlcmVkVHlwZShIRUFQMzJbKGFyZ1R5cGVzID4+IDIpICsgaV0sIFwicGFyYW1ldGVyIFwiICsgaSk7XG4gfVxuIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBfX2VtdmFsX2dldF9tZXRob2RfY2FsbGVyKGFyZ0NvdW50LCBhcmdUeXBlcykge1xuIHZhciB0eXBlcyA9IF9fZW12YWxfbG9va3VwVHlwZXMoYXJnQ291bnQsIGFyZ1R5cGVzKTtcbiB2YXIgcmV0VHlwZSA9IHR5cGVzWzBdO1xuIHZhciBzaWduYXR1cmVOYW1lID0gcmV0VHlwZS5uYW1lICsgXCJfJFwiICsgdHlwZXMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQubmFtZTtcbiB9KS5qb2luKFwiX1wiKSArIFwiJFwiO1xuIHZhciBwYXJhbXMgPSBbIFwicmV0VHlwZVwiIF07XG4gdmFyIGFyZ3MgPSBbIHJldFR5cGUgXTtcbiB2YXIgYXJnc0xpc3QgPSBcIlwiO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQgLSAxOyArK2kpIHtcbiAgYXJnc0xpc3QgKz0gKGkgIT09IDAgPyBcIiwgXCIgOiBcIlwiKSArIFwiYXJnXCIgKyBpO1xuICBwYXJhbXMucHVzaChcImFyZ1R5cGVcIiArIGkpO1xuICBhcmdzLnB1c2godHlwZXNbMSArIGldKTtcbiB9XG4gdmFyIGZ1bmN0aW9uTmFtZSA9IG1ha2VMZWdhbEZ1bmN0aW9uTmFtZShcIm1ldGhvZENhbGxlcl9cIiArIHNpZ25hdHVyZU5hbWUpO1xuIHZhciBmdW5jdGlvbkJvZHkgPSBcInJldHVybiBmdW5jdGlvbiBcIiArIGZ1bmN0aW9uTmFtZSArIFwiKGhhbmRsZSwgbmFtZSwgZGVzdHJ1Y3RvcnMsIGFyZ3MpIHtcXG5cIjtcbiB2YXIgb2Zmc2V0ID0gMDtcbiBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0NvdW50IC0gMTsgKytpKSB7XG4gIGZ1bmN0aW9uQm9keSArPSBcIiAgICB2YXIgYXJnXCIgKyBpICsgXCIgPSBhcmdUeXBlXCIgKyBpICsgXCIucmVhZFZhbHVlRnJvbVBvaW50ZXIoYXJnc1wiICsgKG9mZnNldCA/IFwiK1wiICsgb2Zmc2V0IDogXCJcIikgKyBcIik7XFxuXCI7XG4gIG9mZnNldCArPSB0eXBlc1tpICsgMV1bXCJhcmdQYWNrQWR2YW5jZVwiXTtcbiB9XG4gZnVuY3Rpb25Cb2R5ICs9IFwiICAgIHZhciBydiA9IGhhbmRsZVtuYW1lXShcIiArIGFyZ3NMaXN0ICsgXCIpO1xcblwiO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQgLSAxOyArK2kpIHtcbiAgaWYgKHR5cGVzW2kgKyAxXVtcImRlbGV0ZU9iamVjdFwiXSkge1xuICAgZnVuY3Rpb25Cb2R5ICs9IFwiICAgIGFyZ1R5cGVcIiArIGkgKyBcIi5kZWxldGVPYmplY3QoYXJnXCIgKyBpICsgXCIpO1xcblwiO1xuICB9XG4gfVxuIGlmICghcmV0VHlwZS5pc1ZvaWQpIHtcbiAgZnVuY3Rpb25Cb2R5ICs9IFwiICAgIHJldHVybiByZXRUeXBlLnRvV2lyZVR5cGUoZGVzdHJ1Y3RvcnMsIHJ2KTtcXG5cIjtcbiB9XG4gZnVuY3Rpb25Cb2R5ICs9IFwifTtcXG5cIjtcbiBwYXJhbXMucHVzaChmdW5jdGlvbkJvZHkpO1xuIHZhciBpbnZva2VyRnVuY3Rpb24gPSBuZXdfKEZ1bmN0aW9uLCBwYXJhbXMpLmFwcGx5KG51bGwsIGFyZ3MpO1xuIHJldHVybiBfX2VtdmFsX2FkZE1ldGhvZENhbGxlcihpbnZva2VyRnVuY3Rpb24pO1xufVxuXG5mdW5jdGlvbiBfX2VtdmFsX2dldF9tb2R1bGVfcHJvcGVydHkobmFtZSkge1xuIG5hbWUgPSBnZXRTdHJpbmdPclN5bWJvbChuYW1lKTtcbiByZXR1cm4gX19lbXZhbF9yZWdpc3RlcihNb2R1bGVbbmFtZV0pO1xufVxuXG5mdW5jdGlvbiBfX2VtdmFsX2dldF9wcm9wZXJ0eShoYW5kbGUsIGtleSkge1xuIGhhbmRsZSA9IHJlcXVpcmVIYW5kbGUoaGFuZGxlKTtcbiBrZXkgPSByZXF1aXJlSGFuZGxlKGtleSk7XG4gcmV0dXJuIF9fZW12YWxfcmVnaXN0ZXIoaGFuZGxlW2tleV0pO1xufVxuXG5mdW5jdGlvbiBfX2VtdmFsX2luY3JlZihoYW5kbGUpIHtcbiBpZiAoaGFuZGxlID4gNCkge1xuICBlbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXS5yZWZjb3VudCArPSAxO1xuIH1cbn1cblxuZnVuY3Rpb24gX19lbXZhbF9uZXdfY3N0cmluZyh2KSB7XG4gcmV0dXJuIF9fZW12YWxfcmVnaXN0ZXIoZ2V0U3RyaW5nT3JTeW1ib2wodikpO1xufVxuXG5mdW5jdGlvbiBfX2VtdmFsX3J1bl9kZXN0cnVjdG9ycyhoYW5kbGUpIHtcbiB2YXIgZGVzdHJ1Y3RvcnMgPSBlbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXS52YWx1ZTtcbiBydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4gX19lbXZhbF9kZWNyZWYoaGFuZGxlKTtcbn1cblxuZnVuY3Rpb24gX19lbXZhbF90YWtlX3ZhbHVlKHR5cGUsIGFyZ3YpIHtcbiB0eXBlID0gcmVxdWlyZVJlZ2lzdGVyZWRUeXBlKHR5cGUsIFwiX2VtdmFsX3Rha2VfdmFsdWVcIik7XG4gdmFyIHYgPSB0eXBlW1wicmVhZFZhbHVlRnJvbVBvaW50ZXJcIl0oYXJndik7XG4gcmV0dXJuIF9fZW12YWxfcmVnaXN0ZXIodik7XG59XG5cbmZ1bmN0aW9uIF9hYm9ydCgpIHtcbiBhYm9ydCgpO1xufVxuXG5mdW5jdGlvbiBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKHNpemUpIHtcbiB0cnkge1xuICB3YXNtTWVtb3J5Lmdyb3coc2l6ZSAtIGJ1ZmZlci5ieXRlTGVuZ3RoICsgNjU1MzUgPj4+IDE2KTtcbiAgdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3Mod2FzbU1lbW9yeS5idWZmZXIpO1xuICByZXR1cm4gMTtcbiB9IGNhdGNoIChlKSB7fVxufVxuXG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcChyZXF1ZXN0ZWRTaXplKSB7XG4gdmFyIG9sZFNpemUgPSBIRUFQVTgubGVuZ3RoO1xuIHJlcXVlc3RlZFNpemUgPSByZXF1ZXN0ZWRTaXplID4+PiAwO1xuIHZhciBtYXhIZWFwU2l6ZSA9IDIxNDc0ODM2NDg7XG4gaWYgKHJlcXVlc3RlZFNpemUgPiBtYXhIZWFwU2l6ZSkge1xuICByZXR1cm4gZmFsc2U7XG4gfVxuIGZvciAodmFyIGN1dERvd24gPSAxOyBjdXREb3duIDw9IDQ7IGN1dERvd24gKj0gMikge1xuICB2YXIgb3Zlckdyb3duSGVhcFNpemUgPSBvbGRTaXplICogKDEgKyAuMiAvIGN1dERvd24pO1xuICBvdmVyR3Jvd25IZWFwU2l6ZSA9IE1hdGgubWluKG92ZXJHcm93bkhlYXBTaXplLCByZXF1ZXN0ZWRTaXplICsgMTAwNjYzMjk2KTtcbiAgdmFyIG5ld1NpemUgPSBNYXRoLm1pbihtYXhIZWFwU2l6ZSwgYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLCBvdmVyR3Jvd25IZWFwU2l6ZSksIDY1NTM2KSk7XG4gIHZhciByZXBsYWNlbWVudCA9IGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIobmV3U2l6ZSk7XG4gIGlmIChyZXBsYWNlbWVudCkge1xuICAgcmV0dXJuIHRydWU7XG4gIH1cbiB9XG4gcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgU1lTQ0FMTFMgPSB7XG4gbWFwcGluZ3M6IHt9LFxuIGJ1ZmZlcnM6IFsgbnVsbCwgW10sIFtdIF0sXG4gcHJpbnRDaGFyOiBmdW5jdGlvbihzdHJlYW0sIGN1cnIpIHtcbiAgdmFyIGJ1ZmZlciA9IFNZU0NBTExTLmJ1ZmZlcnNbc3RyZWFtXTtcbiAgaWYgKGN1cnIgPT09IDAgfHwgY3VyciA9PT0gMTApIHtcbiAgIChzdHJlYW0gPT09IDEgPyBvdXQgOiBlcnIpKFVURjhBcnJheVRvU3RyaW5nKGJ1ZmZlciwgMCkpO1xuICAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICBidWZmZXIucHVzaChjdXJyKTtcbiAgfVxuIH0sXG4gdmFyYXJnczogdW5kZWZpbmVkLFxuIGdldDogZnVuY3Rpb24oKSB7XG4gIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDtcbiAgdmFyIHJldCA9IEhFQVAzMltTWVNDQUxMUy52YXJhcmdzIC0gNCA+PiAyXTtcbiAgcmV0dXJuIHJldDtcbiB9LFxuIGdldFN0cjogZnVuY3Rpb24ocHRyKSB7XG4gIHZhciByZXQgPSBVVEY4VG9TdHJpbmcocHRyKTtcbiAgcmV0dXJuIHJldDtcbiB9LFxuIGdldDY0OiBmdW5jdGlvbihsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIGxvdztcbiB9XG59O1xuXG5mdW5jdGlvbiBfZmRfY2xvc2UoZmQpIHtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX2ZkX3NlZWsoZmQsIG9mZnNldF9sb3csIG9mZnNldF9oaWdoLCB3aGVuY2UsIG5ld09mZnNldCkge31cblxuZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuIHZhciBudW0gPSAwO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgdmFyIHB0ciA9IEhFQVAzMltpb3YgKyBpICogOCA+PiAyXTtcbiAgdmFyIGxlbiA9IEhFQVAzMltpb3YgKyAoaSAqIDggKyA0KSA+PiAyXTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgU1lTQ0FMTFMucHJpbnRDaGFyKGZkLCBIRUFQVThbcHRyICsgal0pO1xuICB9XG4gIG51bSArPSBsZW47XG4gfVxuIEhFQVAzMltwbnVtID4+IDJdID0gbnVtO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfc2V0VGVtcFJldDAoJGkpIHtcbiBzZXRUZW1wUmV0MCgkaSB8IDApO1xufVxuXG5pbml0X2VtdmFsKCk7XG5cblB1cmVWaXJ0dWFsRXJyb3IgPSBNb2R1bGVbXCJQdXJlVmlydHVhbEVycm9yXCJdID0gZXh0ZW5kRXJyb3IoRXJyb3IsIFwiUHVyZVZpcnR1YWxFcnJvclwiKTtcblxuZW1iaW5kX2luaXRfY2hhckNvZGVzKCk7XG5cbmluaXRfZW1iaW5kKCk7XG5cbkJpbmRpbmdFcnJvciA9IE1vZHVsZVtcIkJpbmRpbmdFcnJvclwiXSA9IGV4dGVuZEVycm9yKEVycm9yLCBcIkJpbmRpbmdFcnJvclwiKTtcblxuSW50ZXJuYWxFcnJvciA9IE1vZHVsZVtcIkludGVybmFsRXJyb3JcIl0gPSBleHRlbmRFcnJvcihFcnJvciwgXCJJbnRlcm5hbEVycm9yXCIpO1xuXG5pbml0X0NsYXNzSGFuZGxlKCk7XG5cbmluaXRfUmVnaXN0ZXJlZFBvaW50ZXIoKTtcblxuVW5ib3VuZFR5cGVFcnJvciA9IE1vZHVsZVtcIlVuYm91bmRUeXBlRXJyb3JcIl0gPSBleHRlbmRFcnJvcihFcnJvciwgXCJVbmJvdW5kVHlwZUVycm9yXCIpO1xuXG52YXIgQVNTRVJUSU9OUyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbnRBcnJheVRvU3RyaW5nKGFycmF5KSB7XG4gdmFyIHJldCA9IFtdO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgdmFyIGNociA9IGFycmF5W2ldO1xuICBpZiAoY2hyID4gMjU1KSB7XG4gICBpZiAoQVNTRVJUSU9OUykge1xuICAgIGFzc2VydChmYWxzZSwgXCJDaGFyYWN0ZXIgY29kZSBcIiArIGNociArIFwiIChcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArIFwiKSAgYXQgb2Zmc2V0IFwiICsgaSArIFwiIG5vdCBpbiAweDAwLTB4RkYuXCIpO1xuICAgfVxuICAgY2hyICY9IDI1NTtcbiAgfVxuICByZXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikpO1xuIH1cbiByZXR1cm4gcmV0LmpvaW4oXCJcIik7XG59XG5cbnZhciBkZWNvZGVCYXNlNjQgPSB0eXBlb2YgYXRvYiA9PT0gXCJmdW5jdGlvblwiID8gYXRvYiA6IGZ1bmN0aW9uKGlucHV0KSB7XG4gdmFyIGtleVN0ciA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiB2YXIgb3V0cHV0ID0gXCJcIjtcbiB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiB2YXIgaSA9IDA7XG4gaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG4gZG8ge1xuICBlbmMxID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICBlbmMyID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICBlbmMzID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICBlbmM0ID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICBjaHIxID0gZW5jMSA8PCAyIHwgZW5jMiA+PiA0O1xuICBjaHIyID0gKGVuYzIgJiAxNSkgPDwgNCB8IGVuYzMgPj4gMjtcbiAgY2hyMyA9IChlbmMzICYgMykgPDwgNiB8IGVuYzQ7XG4gIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMSk7XG4gIGlmIChlbmMzICE9PSA2NCkge1xuICAgb3V0cHV0ID0gb3V0cHV0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcbiAgfVxuICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMyk7XG4gIH1cbiB9IHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKTtcbiByZXR1cm4gb3V0cHV0O1xufTtcblxuZnVuY3Rpb24gaW50QXJyYXlGcm9tQmFzZTY0KHMpIHtcbiBpZiAodHlwZW9mIEVOVklST05NRU5UX0lTX05PREUgPT09IFwiYm9vbGVhblwiICYmIEVOVklST05NRU5UX0lTX05PREUpIHtcbiAgdmFyIGJ1ZjtcbiAgdHJ5IHtcbiAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKHMsIFwiYmFzZTY0XCIpO1xuICB9IGNhdGNoIChfKSB7XG4gICBidWYgPSBuZXcgQnVmZmVyKHMsIFwiYmFzZTY0XCIpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShidWZbXCJidWZmZXJcIl0sIGJ1ZltcImJ5dGVPZmZzZXRcIl0sIGJ1ZltcImJ5dGVMZW5ndGhcIl0pO1xuIH1cbiB0cnkge1xuICB2YXIgZGVjb2RlZCA9IGRlY29kZUJhc2U2NChzKTtcbiAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZC5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyArK2kpIHtcbiAgIGJ5dGVzW2ldID0gZGVjb2RlZC5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBieXRlcztcbiB9IGNhdGNoIChfKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIkNvbnZlcnRpbmcgYmFzZTY0IHN0cmluZyB0byBieXRlcyBmYWlsZWQuXCIpO1xuIH1cbn1cblxuZnVuY3Rpb24gdHJ5UGFyc2VBc0RhdGFVUkkoZmlsZW5hbWUpIHtcbiBpZiAoIWlzRGF0YVVSSShmaWxlbmFtZSkpIHtcbiAgcmV0dXJuO1xuIH1cbiByZXR1cm4gaW50QXJyYXlGcm9tQmFzZTY0KGZpbGVuYW1lLnNsaWNlKGRhdGFVUklQcmVmaXgubGVuZ3RoKSk7XG59XG5cbnZhciBhc21MaWJyYXJ5QXJnID0ge1xuIFwiblwiOiBfX2VtYmluZF9jcmVhdGVfaW5oZXJpdGluZ19jb25zdHJ1Y3RvcixcbiBcIkhcIjogX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0LFxuIFwiQVwiOiBfX2VtYmluZF9yZWdpc3Rlcl9ib29sLFxuIFwiY1wiOiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzcyxcbiBcImlcIjogX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY2xhc3NfZnVuY3Rpb24sXG4gXCJmXCI6IF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NsYXNzX3Byb3BlcnR5LFxuIFwiclwiOiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcixcbiBcImFcIjogX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24sXG4gXCJiXCI6IF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX3Byb3BlcnR5LFxuIFwielwiOiBfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbCxcbiBcImtcIjogX19lbWJpbmRfcmVnaXN0ZXJfZW51bSxcbiBcImpcIjogX19lbWJpbmRfcmVnaXN0ZXJfZW51bV92YWx1ZSxcbiBcInBcIjogX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQsXG4gXCJLXCI6IF9fZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uLFxuIFwiaFwiOiBfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyLFxuIFwiZ1wiOiBfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldyxcbiBcInFcIjogX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZyxcbiBcIm1cIjogX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcsXG4gXCJKXCI6IF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdCxcbiBcIklcIjogX19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0X2ZpZWxkLFxuIFwiQlwiOiBfX2VtYmluZF9yZWdpc3Rlcl92b2lkLFxuIFwibFwiOiBfX2VtdmFsX2FzLFxuIFwiR1wiOiBfX2VtdmFsX2NhbGxfbWV0aG9kLFxuIFwiZVwiOiBfX2VtdmFsX2NhbGxfdm9pZF9tZXRob2QsXG4gXCJEXCI6IF9fZW12YWxfZGVjcmVmLFxuIFwiZFwiOiBfX2VtdmFsX2dldF9tZXRob2RfY2FsbGVyLFxuIFwiTFwiOiBfX2VtdmFsX2dldF9tb2R1bGVfcHJvcGVydHksXG4gXCJ1XCI6IF9fZW12YWxfZ2V0X3Byb3BlcnR5LFxuIFwiQ1wiOiBfX2VtdmFsX2luY3JlZixcbiBcIkVcIjogX19lbXZhbF9uZXdfY3N0cmluZyxcbiBcIkZcIjogX19lbXZhbF9ydW5fZGVzdHJ1Y3RvcnMsXG4gXCJ0XCI6IF9fZW12YWxfdGFrZV92YWx1ZSxcbiBcInNcIjogX2Fib3J0LFxuIFwieFwiOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiBcInlcIjogX2ZkX2Nsb3NlLFxuIFwidlwiOiBfZmRfc2VlayxcbiBcIm9cIjogX2ZkX3dyaXRlLFxuIFwid1wiOiBfc2V0VGVtcFJldDBcbn07XG5cbnZhciBhc20gPSBjcmVhdGVXYXNtKCk7XG5cbnZhciBfX193YXNtX2NhbGxfY3RvcnMgPSBNb2R1bGVbXCJfX193YXNtX2NhbGxfY3RvcnNcIl0gPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9fX3dhc21fY2FsbF9jdG9ycyA9IE1vZHVsZVtcIl9fX3dhc21fY2FsbF9jdG9yc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcIk5cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgX21hbGxvYyA9IE1vZHVsZVtcIl9tYWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9tYWxsb2MgPSBNb2R1bGVbXCJfbWFsbG9jXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiUFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBfX19nZXRUeXBlTmFtZSA9IE1vZHVsZVtcIl9fX2dldFR5cGVOYW1lXCJdID0gZnVuY3Rpb24oKSB7XG4gcmV0dXJuIChfX19nZXRUeXBlTmFtZSA9IE1vZHVsZVtcIl9fX2dldFR5cGVOYW1lXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiUVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBfX19lbWJpbmRfcmVnaXN0ZXJfbmF0aXZlX2FuZF9idWlsdGluX3R5cGVzID0gTW9kdWxlW1wiX19fZW1iaW5kX3JlZ2lzdGVyX25hdGl2ZV9hbmRfYnVpbHRpbl90eXBlc1wiXSA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX19fZW1iaW5kX3JlZ2lzdGVyX25hdGl2ZV9hbmRfYnVpbHRpbl90eXBlcyA9IE1vZHVsZVtcIl9fX2VtYmluZF9yZWdpc3Rlcl9uYXRpdmVfYW5kX2J1aWx0aW5fdHlwZXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJSXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIF9mcmVlID0gTW9kdWxlW1wiX2ZyZWVcIl0gPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9mcmVlID0gTW9kdWxlW1wiX2ZyZWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJTXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIGR5bkNhbGxfamlqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlqaVwiXSA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoZHluQ2FsbF9qaWppID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiVFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBjYWxsZWRSdW47XG5cbmZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gdGhpcy5uYW1lID0gXCJFeGl0U3RhdHVzXCI7XG4gdGhpcy5tZXNzYWdlID0gXCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiICsgc3RhdHVzICsgXCIpXCI7XG4gdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG59XG5cbmRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uIHJ1bkNhbGxlcigpIHtcbiBpZiAoIWNhbGxlZFJ1bikgcnVuKCk7XG4gaWYgKCFjYWxsZWRSdW4pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjtcbn07XG5cbmZ1bmN0aW9uIHJ1bihhcmdzKSB7XG4gYXJncyA9IGFyZ3MgfHwgYXJndW1lbnRzXztcbiBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICByZXR1cm47XG4gfVxuIHByZVJ1bigpO1xuIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gIHJldHVybjtcbiB9XG4gZnVuY3Rpb24gZG9SdW4oKSB7XG4gIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgY2FsbGVkUnVuID0gdHJ1ZTtcbiAgTW9kdWxlW1wiY2FsbGVkUnVuXCJdID0gdHJ1ZTtcbiAgaWYgKEFCT1JUKSByZXR1cm47XG4gIGluaXRSdW50aW1lKCk7XG4gIHByZU1haW4oKTtcbiAgcmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO1xuICBpZiAoTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0pIE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKCk7XG4gIHBvc3RSdW4oKTtcbiB9XG4gaWYgKE1vZHVsZVtcInNldFN0YXR1c1wiXSkge1xuICBNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJSdW5uaW5nLi4uXCIpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJcIik7XG4gICB9LCAxKTtcbiAgIGRvUnVuKCk7XG4gIH0sIDEpO1xuIH0gZWxzZSB7XG4gIGRvUnVuKCk7XG4gfVxufVxuXG5Nb2R1bGVbXCJydW5cIl0gPSBydW47XG5cbmlmIChNb2R1bGVbXCJwcmVJbml0XCJdKSB7XG4gaWYgKHR5cGVvZiBNb2R1bGVbXCJwcmVJbml0XCJdID09IFwiZnVuY3Rpb25cIikgTW9kdWxlW1wicHJlSW5pdFwiXSA9IFsgTW9kdWxlW1wicHJlSW5pdFwiXSBdO1xuIHdoaWxlIChNb2R1bGVbXCJwcmVJbml0XCJdLmxlbmd0aCA+IDApIHtcbiAgTW9kdWxlW1wicHJlSW5pdFwiXS5wb3AoKSgpO1xuIH1cbn1cblxucnVuKCk7XG5cbmZ1bmN0aW9uIG1ha2VNYXRyaXgobTJkKSB7XG4gICAgY29uc3QgbSA9IG5ldyBET01NYXRyaXgoKTtcbiAgICBtLmEgPSBtMmQueHg7XG4gICAgbS5iID0gbTJkLnh5O1xuICAgIG0uYyA9IG0yZC55eDtcbiAgICBtLmQgPSBtMmQueXk7XG4gICAgbS5lID0gbTJkLnR4O1xuICAgIG0uZiA9IG0yZC50eTtcbiAgICByZXR1cm4gbTtcbn1cblxuTW9kdWxlLm9uUnVudGltZUluaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgUmVuZGVyUGFpbnRTdHlsZSxcbiAgICAgICAgRmlsbFJ1bGUsXG4gICAgICAgIFJlbmRlclBhdGgsXG4gICAgICAgIFJlbmRlclBhaW50LFxuICAgICAgICBSZW5kZXJlcixcbiAgICAgICAgU3Ryb2tlQ2FwLFxuICAgICAgICBTdHJva2VKb2luLFxuICAgICAgICBCbGVuZE1vZGVcbiAgICB9ID0gTW9kdWxlO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBmaWxsLFxuICAgICAgICBzdHJva2VcbiAgICB9ID0gUmVuZGVyUGFpbnRTdHlsZTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgZXZlbk9kZCxcbiAgICAgICAgbm9uWmVyb1xuICAgIH0gPSBGaWxsUnVsZTtcblxuICAgIHZhciBDYW52YXNSZW5kZXJQYXRoID0gUmVuZGVyUGF0aC5leHRlbmQoXCJDYW52YXNSZW5kZXJQYXRoXCIsIHtcbiAgICAgICAgX19jb25zdHJ1Y3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19wYXJlbnQuX19jb25zdHJ1Y3QuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3BhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkUGF0aDogZnVuY3Rpb24gKHBhdGgsIG0yZCkge1xuICAgICAgICAgICAgdGhpcy5fcGF0aDJELmFkZFBhdGgocGF0aC5fcGF0aDJELCBtYWtlTWF0cml4KG0yZCkpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxsUnVsZTogZnVuY3Rpb24oZmlsbFJ1bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxSdWxlID0gZmlsbFJ1bGU7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdGgyRC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdGgyRC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0sXG4gICAgICAgIGN1YmljVG86IGZ1bmN0aW9uIChveCwgb3ksIGl4LCBpeSwgeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5fcGF0aDJELmJlemllckN1cnZlVG8ob3gsIG95LCBpeCwgaXksIHgsIHkpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcGF0aDJELmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBfY29sb3JTdHlsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJ3JnYmEoJyArICgoMHgwMGZmMDAwMCAmIHZhbHVlKSA+Pj5cbiAgICAgICAgICAgICAgICAxNikgKyAnLCcgKyAoKDB4MDAwMGZmMDAgJlxuICAgICAgICAgICAgICAgIHZhbHVlKSA+Pj4gOCkgKyAnLCcgKyAoKDB4MDAwMDAwZmYgJiB2YWx1ZSkgPj4+IDApICsgJywnICtcbiAgICAgICAgICAgICgoKDB4ZmYwMDAwMDAgJiB2YWx1ZSkgPj4+IDI0KSAvIDB4RkYpICsgJyknXG4gICAgfVxuICAgIHZhciBDYW52YXNSZW5kZXJQYWludCA9IFJlbmRlclBhaW50LmV4dGVuZChcIkNhbnZhc1JlbmRlclBhaW50XCIsIHtcbiAgICAgICAgY29sb3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfY29sb3JTdHlsZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRoaWNrbmVzczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl90aGlja25lc3MgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgam9pbjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTdHJva2VKb2luLm1pdGVyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qb2luID0gJ21pdGVyJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdHJva2VKb2luLnJvdW5kOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qb2luID0gJ3JvdW5kJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdHJva2VKb2luLmJldmVsOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qb2luID0gJ2JldmVsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhcDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTdHJva2VDYXAuYnV0dDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FwID0gJ2J1dHQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0cm9rZUNhcC5yb3VuZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FwID0gJ3JvdW5kJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdHJva2VDYXAuc3F1YXJlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXAgPSAnc3F1YXJlJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGJsZW5kTW9kZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBCbGVuZE1vZGUuc3JjT3ZlcjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxlbmQgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJsZW5kTW9kZS5zY3JlZW46XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kID0gJ3NjcmVlbic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLm92ZXJsYXk6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kID0gJ292ZXJsYXknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJsZW5kTW9kZS5kYXJrZW46XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kID0gJ2Rhcmtlbic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLmxpZ2h0ZW46XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kID0gJ2xpZ2h0ZW4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJsZW5kTW9kZS5jb2xvckRvZGdlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibGVuZCA9ICdjb2xvci1kb2RnZSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLmNvbG9yQnVybjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxlbmQgPSAnY29sb3ItYnVybic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLmhhcmRMaWdodDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxlbmQgPSAnaGFyZC1saWdodCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLnNvZnRMaWdodDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxlbmQgPSAnc29mdC1saWdodCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLmRpZmZlcmVuY2U6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kID0gJ2RpZmZlcmVuY2UnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJsZW5kTW9kZS5leGNsdXNpb246XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kID0gJ2V4Y2x1c2lvbic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLm11bHRpcGx5OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibGVuZCA9ICdtdWx0aXBseSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLmh1ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxlbmQgPSAnaHVlJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCbGVuZE1vZGUuc2F0dXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxlbmQgPSAnc2F0dXJhdGlvbic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLmNvbG9yOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibGVuZCA9ICdjb2xvcic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLmx1bWlub3NpdHk6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JsZW5kID0gJ2x1bWlub3NpdHknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyR3JhZGllbnQ6IGZ1bmN0aW9uIChzeCwgc3ksIGV4LCBleSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JhZGllbnQgPSB7XG4gICAgICAgICAgICAgICAgc3gsXG4gICAgICAgICAgICAgICAgc3ksXG4gICAgICAgICAgICAgICAgZXgsXG4gICAgICAgICAgICAgICAgZXksXG4gICAgICAgICAgICAgICAgc3RvcHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByYWRpYWxHcmFkaWVudDogZnVuY3Rpb24gKHN4LCBzeSwgZXgsIGV5KSB7XG4gICAgICAgICAgICB0aGlzLl9ncmFkaWVudCA9IHtcbiAgICAgICAgICAgICAgICBzeCxcbiAgICAgICAgICAgICAgICBzeSxcbiAgICAgICAgICAgICAgICBleCxcbiAgICAgICAgICAgICAgICBleSxcbiAgICAgICAgICAgICAgICBzdG9wczogW10sXG4gICAgICAgICAgICAgICAgaXNSYWRpYWw6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFN0b3A6IGZ1bmN0aW9uIChjb2xvciwgc3RvcCkge1xuICAgICAgICAgICAgdGhpcy5fZ3JhZGllbnQuc3RvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgc3RvcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcGxldGVHcmFkaWVudDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhdzogZnVuY3Rpb24gKGN0eCwgcGF0aCkge1xuICAgICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgICAgICBfc3R5bGUsXG4gICAgICAgICAgICAgICAgX3ZhbHVlLFxuICAgICAgICAgICAgICAgIF9ncmFkaWVudCxcbiAgICAgICAgICAgICAgICBfYmxlbmRcbiAgICAgICAgICAgIH0gPSB0aGlzO1xuXG4gICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gX2JsZW5kO1xuXG4gICAgICAgICAgICBpZiAoX2dyYWRpZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgIHN4LFxuICAgICAgICAgICAgICAgICAgICBzeSxcbiAgICAgICAgICAgICAgICAgICAgZXgsXG4gICAgICAgICAgICAgICAgICAgIGV5LFxuICAgICAgICAgICAgICAgICAgICBzdG9wcyxcbiAgICAgICAgICAgICAgICAgICAgaXNSYWRpYWxcbiAgICAgICAgICAgICAgICB9ID0gX2dyYWRpZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmFkaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IGV4IC0gc3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IGV5IC0gc3k7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWUgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoc3gsIHN5LCAwLCBzeCwgc3ksIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHN4LCBzeSwgZXgsIGV5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvclxuICAgICAgICAgICAgICAgICAgICB9IG9mIHN0b3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZS5hZGRDb2xvclN0b3Aoc3RvcCwgX2NvbG9yU3R5bGUoY29sb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhZGllbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChfc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHN0cm9rZTpcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gX3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5fdGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZUNhcCA9IHRoaXMuX2NhcDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5fam9pbjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZShwYXRoLl9wYXRoMkQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGZpbGw6XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBfdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKHBhdGguX3BhdGgyRCwgcGF0aC5fZmlsbFJ1bGUgPT09IGV2ZW5PZGQgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgTW9kdWxlLkNhbnZhc1JlbmRlcmVyID0gUmVuZGVyZXIuZXh0ZW5kKFwiUmVuZGVyZXJcIiwge1xuICAgICAgICBfX2NvbnN0cnVjdDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdGhpcy5fX3BhcmVudC5fX2NvbnN0cnVjdC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICB9LFxuICAgICAgICBzYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHguc2F2ZSgpO1xuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHgucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC50cmFuc2Zvcm0obWF0cml4Lnh4LCBtYXRyaXgueHksIG1hdHJpeC55eCwgbWF0cml4Lnl5LCBtYXRyaXgudHgsXG4gICAgICAgICAgICAgICAgbWF0cml4LnR5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd1BhdGg6IGZ1bmN0aW9uIChwYXRoLCBwYWludCkge1xuICAgICAgICAgICAgcGFpbnQuZHJhdyh0aGlzLl9jdHgsIHBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICBjbGlwUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC5jbGlwKHBhdGguX3BhdGgyRCwgcGF0aC5fZmlsbFJ1bGUgPT09IGV2ZW5PZGQgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBNb2R1bGUucmVuZGVyRmFjdG9yeSA9IHtcbiAgICAgICAgbWFrZVJlbmRlclBhaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbnZhc1JlbmRlclBhaW50KCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1ha2VSZW5kZXJQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbnZhc1JlbmRlclBhdGgoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5cbiAgcmV0dXJuIFJpdmUucmVhZHlcbn1cbik7XG59KSgpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChSaXZlKTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovICgoKSA9PiB7XG5cbi8qIChpZ25vcmVkKSAqL1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovICgoKSA9PiB7XG5cbi8qIChpZ25vcmVkKSAqL1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXHRdKTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGluIHN0cmljdCBtb2RlLlxuKCgpID0+IHtcblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJGaXRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRml0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJBbGlnbm1lbnRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQWxpZ25tZW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJMYXlvdXRcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTGF5b3V0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJSdW50aW1lTG9hZGVyXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFJ1bnRpbWVMb2FkZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIlN0YXRlTWFjaGluZUlucHV0VHlwZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBTdGF0ZU1hY2hpbmVJbnB1dFR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIlN0YXRlTWFjaGluZUlucHV0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFN0YXRlTWFjaGluZUlucHV0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJFdmVudFR5cGVcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRXZlbnRUeXBlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJMb29wVHlwZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBMb29wVHlwZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiUml2ZVwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBSaXZlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJUZXN0aW5nXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFRlc3RpbmcpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcml2ZV9jYW52YXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5cbi8vIFRyYWNrcyBwbGF5YmFjayBzdGF0ZXM7IG51bWJlcnMgbWFwIHRvIHRoZSBydW50aW1lJ3MgbnVtZXJpY2FsIHZhbHVlc1xuLy8gaS5lLiBwbGF5OiAwLCBwYXVzZTogMSwgc3RvcDogMlxudmFyIFBsYXliYWNrU3RhdGU7XG4oZnVuY3Rpb24gKFBsYXliYWNrU3RhdGUpIHtcbiAgICBQbGF5YmFja1N0YXRlW1BsYXliYWNrU3RhdGVbXCJQbGF5XCJdID0gMF0gPSBcIlBsYXlcIjtcbiAgICBQbGF5YmFja1N0YXRlW1BsYXliYWNrU3RhdGVbXCJQYXVzZVwiXSA9IDFdID0gXCJQYXVzZVwiO1xuICAgIFBsYXliYWNrU3RhdGVbUGxheWJhY2tTdGF0ZVtcIlN0b3BcIl0gPSAyXSA9IFwiU3RvcFwiO1xufSkoUGxheWJhY2tTdGF0ZSB8fCAoUGxheWJhY2tTdGF0ZSA9IHt9KSk7XG4vLyAjcmVnaW9uIGxheW91dFxuLy8gRml0IG9wdGlvbnMgZm9yIHRoZSBjYW52YXNcbnZhciBGaXQ7XG4oZnVuY3Rpb24gKEZpdCkge1xuICAgIEZpdFtcIkNvdmVyXCJdID0gXCJjb3ZlclwiO1xuICAgIEZpdFtcIkNvbnRhaW5cIl0gPSBcImNvbnRhaW5cIjtcbiAgICBGaXRbXCJGaWxsXCJdID0gXCJmaWxsXCI7XG4gICAgRml0W1wiRml0V2lkdGhcIl0gPSBcImZpdFdpZHRoXCI7XG4gICAgRml0W1wiRml0SGVpZ2h0XCJdID0gXCJmaXRIZWlnaHRcIjtcbiAgICBGaXRbXCJOb25lXCJdID0gXCJub25lXCI7XG4gICAgRml0W1wiU2NhbGVEb3duXCJdID0gXCJzY2FsZURvd25cIjtcbn0pKEZpdCB8fCAoRml0ID0ge30pKTtcbi8vIEFsaWdubWVudCBvcHRpb25zIGZvciB0aGUgY2FudmFzXG52YXIgQWxpZ25tZW50O1xuKGZ1bmN0aW9uIChBbGlnbm1lbnQpIHtcbiAgICBBbGlnbm1lbnRbXCJDZW50ZXJcIl0gPSBcImNlbnRlclwiO1xuICAgIEFsaWdubWVudFtcIlRvcExlZnRcIl0gPSBcInRvcExlZnRcIjtcbiAgICBBbGlnbm1lbnRbXCJUb3BDZW50ZXJcIl0gPSBcInRvcENlbnRlclwiO1xuICAgIEFsaWdubWVudFtcIlRvcFJpZ2h0XCJdID0gXCJ0b3BSaWdodFwiO1xuICAgIEFsaWdubWVudFtcIkNlbnRlckxlZnRcIl0gPSBcImNlbnRlckxlZnRcIjtcbiAgICBBbGlnbm1lbnRbXCJDZW50ZXJSaWdodFwiXSA9IFwiY2VudGVyUmlnaHRcIjtcbiAgICBBbGlnbm1lbnRbXCJCb3R0b21MZWZ0XCJdID0gXCJib3R0b21MZWZ0XCI7XG4gICAgQWxpZ25tZW50W1wiQm90dG9tQ2VudGVyXCJdID0gXCJib3R0b21DZW50ZXJcIjtcbiAgICBBbGlnbm1lbnRbXCJCb3R0b21SaWdodFwiXSA9IFwiYm90dG9tUmlnaHRcIjtcbn0pKEFsaWdubWVudCB8fCAoQWxpZ25tZW50ID0ge30pKTtcbi8vIEFsaWdubWVudCBvcHRpb25zIGZvciBSaXZlIGFuaW1hdGlvbnMgaW4gYSBIVE1MIGNhbnZhc1xudmFyIExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXlvdXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB0aGlzLmZpdCA9IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5maXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEZpdC5Db250YWluO1xuICAgICAgICB0aGlzLmFsaWdubWVudCA9IChfYiA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5hbGlnbm1lbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEFsaWdubWVudC5DZW50ZXI7XG4gICAgICAgIHRoaXMubWluWCA9IChfYyA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5taW5YKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xuICAgICAgICB0aGlzLm1pblkgPSAoX2QgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMubWluWSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMDtcbiAgICAgICAgdGhpcy5tYXhYID0gKF9lID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLm1heFgpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgIHRoaXMubWF4WSA9IChfZiA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5tYXhZKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAwO1xuICAgIH1cbiAgICAvLyBBbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciB0byBidWlsZCBhIExheW91dCBmcm9tIGFuIGludGVyZmFjZS9vYmplY3RcbiAgICBMYXlvdXQubmV3ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBmaXQgPSBfYS5maXQsIGFsaWdubWVudCA9IF9hLmFsaWdubWVudCwgbWluWCA9IF9hLm1pblgsIG1pblkgPSBfYS5taW5ZLCBtYXhYID0gX2EubWF4WCwgbWF4WSA9IF9hLm1heFk7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkOiBwbGVhc2UgdXNlIGBuZXcgTGF5b3V0KHt9KWAgaW5zdGVhZCcpO1xuICAgICAgICByZXR1cm4gbmV3IExheW91dCh7IGZpdDogZml0LCBhbGlnbm1lbnQ6IGFsaWdubWVudCwgbWluWDogbWluWCwgbWluWTogbWluWSwgbWF4WDogbWF4WCwgbWF4WTogbWF4WSB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgY29weSBvZiB0aGUgbGF5b3V0LCByZXBsYWNpbmcgYW55IHNwZWNpZmllZCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgTGF5b3V0LnByb3RvdHlwZS5jb3B5V2l0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZml0ID0gX2EuZml0LCBhbGlnbm1lbnQgPSBfYS5hbGlnbm1lbnQsIG1pblggPSBfYS5taW5YLCBtaW5ZID0gX2EubWluWSwgbWF4WCA9IF9hLm1heFgsIG1heFkgPSBfYS5tYXhZO1xuICAgICAgICByZXR1cm4gbmV3IExheW91dCh7XG4gICAgICAgICAgICBmaXQ6IGZpdCAhPT0gbnVsbCAmJiBmaXQgIT09IHZvaWQgMCA/IGZpdCA6IHRoaXMuZml0LFxuICAgICAgICAgICAgYWxpZ25tZW50OiBhbGlnbm1lbnQgIT09IG51bGwgJiYgYWxpZ25tZW50ICE9PSB2b2lkIDAgPyBhbGlnbm1lbnQgOiB0aGlzLmFsaWdubWVudCxcbiAgICAgICAgICAgIG1pblg6IG1pblggIT09IG51bGwgJiYgbWluWCAhPT0gdm9pZCAwID8gbWluWCA6IHRoaXMubWluWCxcbiAgICAgICAgICAgIG1pblk6IG1pblkgIT09IG51bGwgJiYgbWluWSAhPT0gdm9pZCAwID8gbWluWSA6IHRoaXMubWluWSxcbiAgICAgICAgICAgIG1heFg6IG1heFggIT09IG51bGwgJiYgbWF4WCAhPT0gdm9pZCAwID8gbWF4WCA6IHRoaXMubWF4WCxcbiAgICAgICAgICAgIG1heFk6IG1heFkgIT09IG51bGwgJiYgbWF4WSAhPT0gdm9pZCAwID8gbWF4WSA6IHRoaXMubWF4WVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgZml0IGZvciB0aGUgV2FzbSBydW50aW1lIGZvcm1hdFxuICAgIExheW91dC5wcm90b3R5cGUucnVudGltZUZpdCA9IGZ1bmN0aW9uIChyaXZlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFJ1bnRpbWVGaXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRSdW50aW1lRml0O1xuICAgICAgICB2YXIgZml0O1xuICAgICAgICBpZiAodGhpcy5maXQgPT09IEZpdC5Db3ZlcilcbiAgICAgICAgICAgIGZpdCA9IHJpdmUuRml0LmNvdmVyO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmZpdCA9PT0gRml0LkNvbnRhaW4pXG4gICAgICAgICAgICBmaXQgPSByaXZlLkZpdC5jb250YWluO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmZpdCA9PT0gRml0LkZpbGwpXG4gICAgICAgICAgICBmaXQgPSByaXZlLkZpdC5maWxsO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmZpdCA9PT0gRml0LkZpdFdpZHRoKVxuICAgICAgICAgICAgZml0ID0gcml2ZS5GaXQuZml0V2lkdGg7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZml0ID09PSBGaXQuRml0SGVpZ2h0KVxuICAgICAgICAgICAgZml0ID0gcml2ZS5GaXQuZml0SGVpZ2h0O1xuICAgICAgICBlbHNlIGlmICh0aGlzLmZpdCA9PT0gRml0LlNjYWxlRG93bilcbiAgICAgICAgICAgIGZpdCA9IHJpdmUuRml0LnNjYWxlRG93bjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZml0ID0gcml2ZS5GaXQubm9uZTtcbiAgICAgICAgdGhpcy5jYWNoZWRSdW50aW1lRml0ID0gZml0O1xuICAgICAgICByZXR1cm4gZml0O1xuICAgIH07XG4gICAgLy8gUmV0dXJucyBhbGlnbm1lbnQgZm9yIHRoZSBXYXNtIHJ1bnRpbWUgZm9ybWF0XG4gICAgTGF5b3V0LnByb3RvdHlwZS5ydW50aW1lQWxpZ25tZW50ID0gZnVuY3Rpb24gKHJpdmUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkUnVudGltZUFsaWdubWVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFJ1bnRpbWVBbGlnbm1lbnQ7XG4gICAgICAgIHZhciBhbGlnbm1lbnQ7XG4gICAgICAgIGlmICh0aGlzLmFsaWdubWVudCA9PT0gQWxpZ25tZW50LlRvcExlZnQpXG4gICAgICAgICAgICBhbGlnbm1lbnQgPSByaXZlLkFsaWdubWVudC50b3BMZWZ0O1xuICAgICAgICBlbHNlIGlmICh0aGlzLmFsaWdubWVudCA9PT0gQWxpZ25tZW50LlRvcENlbnRlcilcbiAgICAgICAgICAgIGFsaWdubWVudCA9IHJpdmUuQWxpZ25tZW50LnRvcENlbnRlcjtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hbGlnbm1lbnQgPT09IEFsaWdubWVudC5Ub3BSaWdodClcbiAgICAgICAgICAgIGFsaWdubWVudCA9IHJpdmUuQWxpZ25tZW50LnRvcFJpZ2h0O1xuICAgICAgICBlbHNlIGlmICh0aGlzLmFsaWdubWVudCA9PT0gQWxpZ25tZW50LkNlbnRlckxlZnQpXG4gICAgICAgICAgICBhbGlnbm1lbnQgPSByaXZlLkFsaWdubWVudC5jZW50ZXJMZWZ0O1xuICAgICAgICBlbHNlIGlmICh0aGlzLmFsaWdubWVudCA9PT0gQWxpZ25tZW50LkNlbnRlclJpZ2h0KVxuICAgICAgICAgICAgYWxpZ25tZW50ID0gcml2ZS5BbGlnbm1lbnQuY2VudGVyUmlnaHQ7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWxpZ25tZW50ID09PSBBbGlnbm1lbnQuQm90dG9tTGVmdClcbiAgICAgICAgICAgIGFsaWdubWVudCA9IHJpdmUuQWxpZ25tZW50LmJvdHRvbUxlZnQ7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWxpZ25tZW50ID09PSBBbGlnbm1lbnQuQm90dG9tQ2VudGVyKVxuICAgICAgICAgICAgYWxpZ25tZW50ID0gcml2ZS5BbGlnbm1lbnQuYm90dG9tQ2VudGVyO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmFsaWdubWVudCA9PT0gQWxpZ25tZW50LkJvdHRvbVJpZ2h0KVxuICAgICAgICAgICAgYWxpZ25tZW50ID0gcml2ZS5BbGlnbm1lbnQuYm90dG9tUmlnaHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFsaWdubWVudCA9IHJpdmUuQWxpZ25tZW50LmNlbnRlcjtcbiAgICAgICAgdGhpcy5jYWNoZWRSdW50aW1lQWxpZ25tZW50ID0gYWxpZ25tZW50O1xuICAgICAgICByZXR1cm4gYWxpZ25tZW50O1xuICAgIH07XG4gICAgcmV0dXJuIExheW91dDtcbn0oKSk7XG5cbi8vIFJ1bnRpbWUgc2luZ2xldG9uOyB1c2UgZ2V0SW5zdGFuY2UgdG8gcHJvdmlkZSBhIGNhbGxiYWNrIHRoYXQgcmV0dXJucyB0aGVcbi8vIFJpdmUgcnVudGltZVxudmFyIFJ1bnRpbWVMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2xhc3MgaXMgbmV2ZXIgaW5zdGFudGlhdGVkXG4gICAgZnVuY3Rpb24gUnVudGltZUxvYWRlcigpIHtcbiAgICB9XG4gICAgLy8gTG9hZHMgdGhlIHJ1bnRpbWVcbiAgICBSdW50aW1lTG9hZGVyLmxvYWRSdW50aW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfcml2ZV9jYW52YXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0KHtcbiAgICAgICAgICAgIC8vIExvYWRzIFdhc20gYnVuZGxlXG4gICAgICAgICAgICBsb2NhdGVGaWxlOiBmdW5jdGlvbiAoXykgeyByZXR1cm4gUnVudGltZUxvYWRlci53YXNtVVJMOyB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJpdmUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIFJ1bnRpbWVMb2FkZXIucnVudGltZSA9IHJpdmU7XG4gICAgICAgICAgICAvLyBGaXJlIGFsbCB0aGUgY2FsbGJhY2tzXG4gICAgICAgICAgICB3aGlsZSAoUnVudGltZUxvYWRlci5jYWxsQmFja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAoX2EgPSBSdW50aW1lTG9hZGVyLmNhbGxCYWNrUXVldWUuc2hpZnQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKFJ1bnRpbWVMb2FkZXIucnVudGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gUHJvdmlkZXMgYSBydW50aW1lIGluc3RhbmNlIHZpYSBhIGNhbGxiYWNrXG4gICAgUnVudGltZUxvYWRlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAvLyBJZiBpdCdzIG5vdCBsb2FkaW5nLCBzdGFydCBsb2FkaW5nIHJ1bnRpbWVcbiAgICAgICAgaWYgKCFSdW50aW1lTG9hZGVyLmlzTG9hZGluZykge1xuICAgICAgICAgICAgUnVudGltZUxvYWRlci5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgUnVudGltZUxvYWRlci5sb2FkUnVudGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghUnVudGltZUxvYWRlci5ydW50aW1lKSB7XG4gICAgICAgICAgICBSdW50aW1lTG9hZGVyLmNhbGxCYWNrUXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhSdW50aW1lTG9hZGVyLnJ1bnRpbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBQcm92aWRlcyBhIHJ1bnRpbWUgaW5zdGFuY2UgdmlhIGEgcHJvbWlzZVxuICAgIFJ1bnRpbWVMb2FkZXIuYXdhaXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBSdW50aW1lTG9hZGVyLmdldEluc3RhbmNlKGZ1bmN0aW9uIChyaXZlKSB7IHJldHVybiByZXNvbHZlKHJpdmUpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBNYW51YWxseSBzZXRzIHRoZSB3YXNtIHVybFxuICAgIFJ1bnRpbWVMb2FkZXIuc2V0V2FzbVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgUnVudGltZUxvYWRlci53YXNtVVJMID0gdXJsO1xuICAgIH07XG4gICAgLy8gRmxhZyB0byBpbmRpY2F0ZSB0aGF0IGxvYWRpbmcgaGFzIHN0YXJ0ZWQvY29tcGxldGVkXG4gICAgUnVudGltZUxvYWRlci5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAvLyBMaXN0IG9mIGNhbGxiYWNrcyBmb3IgdGhlIHJ1bnRpbWUgdGhhdCBjb21lIGluIHdoaWxlIGxvYWRpbmdcbiAgICBSdW50aW1lTG9hZGVyLmNhbGxCYWNrUXVldWUgPSBbXTtcbiAgICAvLyBQYXRoIHRvIHRoZSBXYXNtIGZpbGU7IGRlZmF1bHQgcGF0aCB3b3JrcyBmb3IgdGVzdGluZyBvbmx5O1xuICAgIC8vIGlmIGVtYmVkZGVkIHdhc20gaXMgdXNlZCB0aGVuIHRoaXMgaXMgbmV2ZXIgdXNlZC5cbiAgICBSdW50aW1lTG9hZGVyLndhc21VUkwgPSAnZGlzdC9yaXZlLndhc20nO1xuICAgIHJldHVybiBSdW50aW1lTG9hZGVyO1xufSgpKTtcblxuLy8gI2VuZHJlZ2lvblxuLy8gI3JlZ2lvbiBhbmltYXRpb25zXG4vLyBXcmFwcyBhbmltYXRpb25zIGFuZCBpbnN0YW5jZXMgZnJvbSB0aGUgcnVudGltZSBhbmQga2VlcHMgdHJhY2sgb2YgcGxheWJhY2tcbi8vIHN0YXRlXG52YXIgQW5pbWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgYW5pbWF0aW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHthbnl9IGFuaW1hdGlvbjogcnVudGltZSBhbmltYXRpb24gb2JqZWN0XG4gICAgICogQHBhcmFtIHthbnl9IGluc3RhbmNlOiBydW50aW1lIGFuaW1hdGlvbiBpbnN0YW5jZSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb24oYW5pbWF0aW9uLCBydW50aW1lLCBwbGF5aW5nKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICB0aGlzLnBsYXlpbmcgPSBwbGF5aW5nO1xuICAgICAgICB0aGlzLmxvb3BDb3VudCA9IDA7XG4gICAgICAgIC8vIFRpbWUgdG8gd2hpY2ggdGhlIGFuaW1hdGlvbiBzaG91bGQgbW92ZSB0byBvbiB0aGUgbmV4dCByZW5kZXJcbiAgICAgICAgdGhpcy5zY3J1YlRvID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBydW50aW1lLkxpbmVhckFuaW1hdGlvbkluc3RhbmNlKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb24ucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvLyBSZXR1cm5zIHRoZSBhbmltYXRpb24ncyBuYW1lXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uLnByb3RvdHlwZSwgXCJ0aW1lXCIsIHtcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgYW5pbWF0aW9uJ3MgY3VycmVudCB0aW1lXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UudGltZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2V0cyB0aGUgYW5pbWF0aW9uJ3MgY3VycmVudCB0aW1lXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnRpbWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb24ucHJvdG90eXBlLCBcImxvb3BWYWx1ZVwiLCB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIGFuaW1hdGlvbidzIGxvb3AgdHlwZVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbi5sb29wVmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgYW5pbWF0aW9uIGJ5IHRoZSBnaXZlIHRpbWUuIElmIHRoZSBhbmltYXRpb24gbmVlZHMgc2NydWJiaW5nLFxuICAgICAqIHRpbWUgaXMgaWdub3JlZCBhbmQgdGhlIHN0b3JlZCBzY3J1YiB2YWx1ZSBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB0aW1lIHRoZSB0aW1lIHRvIGFkdmFuY2UgdGhlIGFuaW1hdGlvbiBieSBpZiBubyBzY3J1YmJpbmcgcmVxdWlyZWRcbiAgICAgKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGhpcy5zY3J1YlRvID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmFkdmFuY2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5hZHZhbmNlKHRoaXMuc2NydWJUbyk7XG4gICAgICAgICAgICB0aGlzLnNjcnViVG8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uLnByb3RvdHlwZSwgXCJuZWVkc1NjcnViXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY3J1YlRvICE9PSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgYmFja2luZyBXYXNtIGFuaW1hdGlvbiBpbnN0YW5jZTsgb25jZSB0aGlzIGlzIGNhbGxlZCwgdGhpc1xuICAgICAqIGFuaW1hdGlvbiBpcyBubyBtb3JlLlxuICAgICAqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5kZWxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb247XG59KCkpO1xuLy8gI2VuZHJlZ2lvblxuLy8gI3JlZ2lvbiBzdGF0ZSBtYWNoaW5lc1xudmFyIFN0YXRlTWFjaGluZUlucHV0VHlwZTtcbihmdW5jdGlvbiAoU3RhdGVNYWNoaW5lSW5wdXRUeXBlKSB7XG4gICAgU3RhdGVNYWNoaW5lSW5wdXRUeXBlW1N0YXRlTWFjaGluZUlucHV0VHlwZVtcIk51bWJlclwiXSA9IDU2XSA9IFwiTnVtYmVyXCI7XG4gICAgU3RhdGVNYWNoaW5lSW5wdXRUeXBlW1N0YXRlTWFjaGluZUlucHV0VHlwZVtcIlRyaWdnZXJcIl0gPSA1OF0gPSBcIlRyaWdnZXJcIjtcbiAgICBTdGF0ZU1hY2hpbmVJbnB1dFR5cGVbU3RhdGVNYWNoaW5lSW5wdXRUeXBlW1wiQm9vbGVhblwiXSA9IDU5XSA9IFwiQm9vbGVhblwiO1xufSkoU3RhdGVNYWNoaW5lSW5wdXRUeXBlIHx8IChTdGF0ZU1hY2hpbmVJbnB1dFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBbiBpbnB1dCBmb3IgYSBzdGF0ZSBtYWNoaW5lXG4gKi9cbnZhciBTdGF0ZU1hY2hpbmVJbnB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZU1hY2hpbmVJbnB1dCh0eXBlLCBydW50aW1lSW5wdXQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5ydW50aW1lSW5wdXQgPSBydW50aW1lSW5wdXQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU1hY2hpbmVJbnB1dC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lSW5wdXQubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU1hY2hpbmVJbnB1dC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVudGltZUlucHV0LnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5ydW50aW1lSW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGEgdHJpZ2dlcjsgZG9lcyBub3RoaW5nIG9uIE51bWJlciBvciBCb29sZWFuIGlucHV0IHR5cGVzXG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lSW5wdXQucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFN0YXRlTWFjaGluZUlucHV0VHlwZS5UcmlnZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bnRpbWVJbnB1dC5maXJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZU1hY2hpbmVJbnB1dDtcbn0oKSk7XG5cbnZhciBTdGF0ZU1hY2hpbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHN0YXRlTWFjaGluZSBydW50aW1lIHN0YXRlIG1hY2hpbmUgb2JqZWN0XG4gICAgICogQHBhcmFtIGluc3RhbmNlIHJ1bnRpbWUgc3RhdGUgbWFjaGluZSBpbnN0YW5jZSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZU1hY2hpbmUoc3RhdGVNYWNoaW5lLCBydW50aW1lLCBwbGF5aW5nKSB7XG4gICAgICAgIHRoaXMuc3RhdGVNYWNoaW5lID0gc3RhdGVNYWNoaW5lO1xuICAgICAgICB0aGlzLnBsYXlpbmcgPSBwbGF5aW5nO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGVzIHRoZSBpbnB1dHMgZnJvbSB0aGUgcnVudGltZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBydW50aW1lLlN0YXRlTWFjaGluZUluc3RhbmNlKHN0YXRlTWFjaGluZSk7XG4gICAgICAgIHRoaXMuaW5pdElucHV0cyhydW50aW1lKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTWFjaGluZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVNYWNoaW5lLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVNYWNoaW5lLnByb3RvdHlwZSwgXCJzdGF0ZXNDaGFuZ2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHN0YXRlIG5hbWVzIHRoYXQgaGF2ZSBjaGFuZ2VkIG9uIHRoaXMgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5zdGFuY2Uuc3RhdGVDaGFuZ2VkQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaCh0aGlzLmluc3RhbmNlLnN0YXRlQ2hhbmdlZE5hbWVCeUluZGV4KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZldGNoZXMgcmVmZXJlbmNlcyB0byB0aGUgc3RhdGUgbWFjaGluZSdzIGlucHV0cyBhbmQgY2FjaGVzIHRoZW1cbiAgICAgKiBAcGFyYW0gcnVudGltZSBhbiBpbnN0YW5jZSBvZiB0aGUgcnVudGltZTsgbmVlZGVkIGZvciB0aGUgU01JSW5wdXQgdHlwZXNcbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLmluaXRJbnB1dHMgPSBmdW5jdGlvbiAocnVudGltZSkge1xuICAgICAgICAvLyBGZXRjaCB0aGUgaW5wdXRzIGZyb20gdGhlIHJ1bnRpbWUgaWYgd2UgZG9uJ3QgaGF2ZSB0aGVtXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnN0YW5jZS5pbnB1dENvdW50KCk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnN0YW5jZS5pbnB1dChpKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzLnB1c2godGhpcy5tYXBSdW50aW1lSW5wdXQoaW5wdXQsIHJ1bnRpbWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFwcyBhIHJ1bnRpbWUgaW5wdXQgdG8gaXQncyBhcHByb3ByaWF0ZSB0eXBlXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5tYXBSdW50aW1lSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQsIHJ1bnRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09IHJ1bnRpbWUuU01JSW5wdXQuYm9vbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmVJbnB1dChTdGF0ZU1hY2hpbmVJbnB1dFR5cGUuQm9vbGVhbiwgaW5wdXQuYXNCb29sKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LnR5cGUgPT09IHJ1bnRpbWUuU01JSW5wdXQubnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YXRlTWFjaGluZUlucHV0KFN0YXRlTWFjaGluZUlucHV0VHlwZS5OdW1iZXIsIGlucHV0LmFzTnVtYmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LnR5cGUgPT09IHJ1bnRpbWUuU01JSW5wdXQudHJpZ2dlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmVJbnB1dChTdGF0ZU1hY2hpbmVJbnB1dFR5cGUuVHJpZ2dlciwgaW5wdXQuYXNUcmlnZ2VyKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBiYWNraW5nIFdhc20gc3RhdGUgbWFjaGluZSBpbnN0YW5jZTsgb25jZSB0aGlzIGlzIGNhbGxlZCwgdGhpc1xuICAgICAqIHN0YXRlIG1hY2hpbmUgaXMgbm8gbW9yZS5cbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZGVsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVNYWNoaW5lO1xufSgpKTtcbi8vICNlbmRyZWdpb25cbi8vICNyZWdpb24gYW5pbWF0b3Jcbi8qKlxuICogTWFuYWdlcyBhbmltYXRpb25cbiAqL1xudmFyIEFuaW1hdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgYW5pbWF0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcnVudGltZSBSaXZlIHJ1bnRpbWU7IG5lZWRlZCB0byBpbnN0YW5jZSBhbmltYXRpb25zICYgc3RhdGUgbWFjaGluZXNcbiAgICAgKiBAcGFyYW0gYXJ0Ym9hcmQgdGhlIGFydGJvYXJkIHRoYXQgaG9sZHMgYWxsIGFuaW1hdGlvbnMgYW5kIHN0YXRlIG1hY2hpbmVzXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbnMgb3B0aW9uYWwgbGlzdCBvZiBhbmltYXRpb25zXG4gICAgICogQHBhcmFtIHN0YXRlTWFjaGluZXMgb3B0aW9uYWwgbGlzdCBvZiBzdGF0ZSBtYWNoaW5lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFuaW1hdG9yKHJ1bnRpbWUsIGFydGJvYXJkLCBldmVudE1hbmFnZXIsIGFuaW1hdGlvbnMsIHN0YXRlTWFjaGluZXMpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbnMgPT09IHZvaWQgMCkgeyBhbmltYXRpb25zID0gW107IH1cbiAgICAgICAgaWYgKHN0YXRlTWFjaGluZXMgPT09IHZvaWQgMCkgeyBzdGF0ZU1hY2hpbmVzID0gW107IH1cbiAgICAgICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgICAgICAgdGhpcy5hcnRib2FyZCA9IGFydGJvYXJkO1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICAgICAgdGhpcy5zdGF0ZU1hY2hpbmVzID0gc3RhdGVNYWNoaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbmltYXRpb25zIGFuZCBzdGF0ZSBtYWNoaW5lcyBieSB0aGVpciBuYW1lcy4gSWYgbmFtZXMgYXJlIHNoYXJlZFxuICAgICAqIGJldHdlZW4gYW5pbWF0aW9ucyAmIHN0YXRlIG1hY2hpbmVzLCB0aGVuIHRoZSBmaXJzdCBvbmUgZm91bmQgd2lsbCBiZVxuICAgICAqIGNyZWF0ZWQuIEJlc3Qgbm90IHRvIHVzZSB0aGUgc2FtZSBuYW1lcyBmb3IgdGhlc2UgaW4geW91ciBSaXZlIGZpbGUuXG4gICAgICogQHBhcmFtIGFuaW1hdGFibGUgdGhlIG5hbWUocykgb2YgYW5pbWF0aW9ucyBhbmQgc3RhdGUgbWFjaGluZXMgdG8gYWRkXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIG5hbWVzIG9mIHRoZSBwbGF5aW5nIGFuaW1hdGlvbnMgYW5kIHN0YXRlIG1hY2hpbmVzXG4gICAgICovXG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhbmltYXRhYmxlcywgcGxheWluZywgZmlyZUV2ZW50KSB7XG4gICAgICAgIGlmIChmaXJlRXZlbnQgPT09IHZvaWQgMCkgeyBmaXJlRXZlbnQgPSB0cnVlOyB9XG4gICAgICAgIGFuaW1hdGFibGVzID0gbWFwVG9TdHJpbmdBcnJheShhbmltYXRhYmxlcyk7XG4gICAgICAgIC8vIElmIGFuaW1hdGFibGVzIGlzIGVtcHR5LCBwbGF5IG9yIHBhdXNlIGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKGFuaW1hdGFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucGxheWluZyA9IHBsYXlpbmc7IH0pO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZU1hY2hpbmVzLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ucGxheWluZyA9IHBsYXlpbmc7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUGxheS9wYXVzZSBhbHJlYWR5IGluc3RhbmNlZCBpdGVtcywgb3IgY3JlYXRlIG5ldyBpbnN0YW5jZXNcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZWRBbmltYXRpb25OYW1lcyA9IHRoaXMuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEubmFtZTsgfSk7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VkTWFjaGluZU5hbWVzID0gdGhpcy5zdGF0ZU1hY2hpbmVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lOyB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYW5pbWF0YWJsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYUluZGV4ID0gaW5zdGFuY2VkQW5pbWF0aW9uTmFtZXMuaW5kZXhPZihhbmltYXRhYmxlc1tpXSk7XG4gICAgICAgICAgICAgICAgdmFyIG1JbmRleCA9IGluc3RhbmNlZE1hY2hpbmVOYW1lcy5pbmRleE9mKGFuaW1hdGFibGVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoYUluZGV4ID49IDAgfHwgbUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmltYXRpb24gaXMgaW5zdGFuY2VkLCBwbGF5L3BhdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYUluZGV4XS5wbGF5aW5nID0gcGxheWluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXRlIG1hY2hpbmUgaXMgaW5zdGFuY2VkLCBwbGF5L3BhdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlTWFjaGluZXNbbUluZGV4XS5wbGF5aW5nID0gcGxheWluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBhIG5ldyBhbmltYXRpb24gaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW0gPSB0aGlzLmFydGJvYXJkLmFuaW1hdGlvbkJ5TmFtZShhbmltYXRhYmxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMucHVzaChuZXcgQW5pbWF0aW9uKGFuaW0sIHRoaXMucnVudGltZSwgcGxheWluZykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBhIG5ldyBzdGF0ZSBtYWNoaW5lIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc20gPSB0aGlzLmFydGJvYXJkLnN0YXRlTWFjaGluZUJ5TmFtZShhbmltYXRhYmxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlTWFjaGluZXMucHVzaChuZXcgU3RhdGVNYWNoaW5lKHNtLCB0aGlzLnJ1bnRpbWUsIHBsYXlpbmcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJlIHBsYXkvcGF1c2VkIGV2ZW50cyBmb3IgYW5pbWF0aW9uc1xuICAgICAgICBpZiAoZmlyZUV2ZW50KSB7XG4gICAgICAgICAgICBpZiAocGxheWluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuUGxheSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5wbGF5aW5nLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5QYXVzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5wYXVzZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYXlpbmcgPyB0aGlzLnBsYXlpbmcgOiB0aGlzLnBhdXNlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBsYXkgdGhlIG5hbWVkIGFuaW1hdGlvbnMvc3RhdGUgbWFjaGluZXNcbiAgICAgKiBAcGFyYW0gYW5pbWF0YWJsZXMgdGhlIG5hbWVzIG9mIHRoZSBhbmltYXRpb25zL21hY2hpbmVzIHRvIHBsYXk7IHBsYXlzIGFsbCBpZiBlbXB0eVxuICAgICAqIEByZXR1cm5zIGEgbGlzdCBvZiB0aGUgcGxheWluZyBpdGVtc1xuICAgICAqL1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKGFuaW1hdGFibGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhbmltYXRhYmxlcywgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICogUGF1c2VzIG5hbWVkIGFuaW1hdGlvbnMgYW5kIHN0YXRlIG1hY2hpbmVzLCBvciBldmVyeXRoaW5nIGlmIG5vdGhpbmcgaXNcbiAgICogc3BlY2lmaWVkXG4gICAqIEBwYXJhbSBhbmltYXRhYmxlcyBuYW1lcyBvZiB0aGUgYW5pbWF0aW9ucyBhbmQgc3RhdGUgbWFjaGluZXMgdG8gcGF1c2VcbiAgICogQHJldHVybnMgYSBsaXN0IG9mIG5hbWVzIG9mIHRoZSBhbmltYXRpb25zIGFuZCBzdGF0ZSBtYWNoaW5lcyBwYXVzZWRcbiAgICovXG4gICAgQW5pbWF0b3IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKGFuaW1hdGFibGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhbmltYXRhYmxlcywgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRpbWUgb2YgbmFtZWQgYW5pbWF0aW9uc1xuICAgICAqIEBwYXJhbSBhbmltYXRpb25zIG5hbWVzIG9mIHRoZSBhbmltYXRpb25zIHRvIHNjcnViXG4gICAgICogQHBhcmFtIHZhbHVlIHRpbWUgc2NydWIgdmFsdWUsIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIHRvIHdoaWNoIHRoZSBwbGF5aGVhZCBpcyBqdW1wZWRcbiAgICAgKiBAcmV0dXJucyBhIGxpc3Qgb2YgbmFtZXMgb2YgdGhlIGFuaW1hdGlvbnMgdGhhdCB3ZXJlIHNjcnViYmVkXG4gICAgICovXG4gICAgQW5pbWF0b3IucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKGFuaW1hdGFibGVzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZm9yU2NydWJiaW5nID0gdGhpcy5hbmltYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gYW5pbWF0YWJsZXMuaW5jbHVkZXMoYS5uYW1lKTsgfSk7XG4gICAgICAgIGZvclNjcnViYmluZy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnNjcnViVG8gPSB2YWx1ZTsgfSk7XG4gICAgICAgIHJldHVybiBmb3JTY3J1YmJpbmcubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdG9yLnByb3RvdHlwZSwgXCJwbGF5aW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5hbWVzIG9mIGFsbCBhbmltYXRpb25zIGFuZCBzdGF0ZSBtYWNoaW5lcyBjdXJyZW50bHlcbiAgICAgICAgICogcGxheWluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5wbGF5aW5nOyB9KS5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEubmFtZTsgfSkuY29uY2F0KHRoaXMuc3RhdGVNYWNoaW5lcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ucGxheWluZzsgfSkubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLm5hbWU7IH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRvci5wcm90b3R5cGUsIFwicGF1c2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5hbWVzIG9mIGFsbCBhbmltYXRpb25zIGFuZCBzdGF0ZSBtYWNoaW5lcyBjdXJyZW50bHlcbiAgICAgICAgICogcGF1c2VkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiAhYS5wbGF5aW5nOyB9KS5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEubmFtZTsgfSkuY29uY2F0KHRoaXMuc3RhdGVNYWNoaW5lcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuICFtLnBsYXlpbmc7IH0pLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lOyB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbmQgcmVtb3ZlcyBhbGwgbmFtZWQgYW5pbWF0aW9ucyBhbmQgc3RhdGUgbWFjaGluZXNcbiAgICAgKiBAcGFyYW0gYW5pbWF0YWJsZXMgYW5pbWF0aW9ucyBhbmQgc3RhdGUgbWFjaGluZXMgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIG5hbWVzIG9mIHJlbW92ZWQgaXRlbXNcbiAgICAgKi9cbiAgICBBbmltYXRvci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChhbmltYXRhYmxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhbmltYXRhYmxlcyA9IG1hcFRvU3RyaW5nQXJyYXkoYW5pbWF0YWJsZXMpO1xuICAgICAgICAvLyBJZiBub3RoaW5nJ3Mgc3BlY2lmaWVkLCB3aXBlIHRoZW0gb3V0LCBhbGwgb2YgdGhlbVxuICAgICAgICB2YXIgcmVtb3ZlZE5hbWVzID0gW107XG4gICAgICAgIC8vIFN0b3AgZXZlcnl0aGluZ1xuICAgICAgICBpZiAoYW5pbWF0YWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZW1vdmVkTmFtZXMgPSB0aGlzLmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pLmNvbmNhdCh0aGlzLnN0YXRlTWFjaGluZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLm5hbWU7IH0pKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGJlZm9yZSBlbXB0eWluZyB0aGUgYXJyYXlzXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5jbGVhbnVwKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZU1hY2hpbmVzLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uY2xlYW51cCgpOyB9KTtcbiAgICAgICAgICAgIC8vIEVtcHR5IG91dCB0aGUgYXJyYXlzXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKDAsIHRoaXMuYW5pbWF0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZU1hY2hpbmVzLnNwbGljZSgwLCB0aGlzLnN0YXRlTWFjaGluZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBvbmx5IHRoZSBuYW1lZCBhbmltYXRpb25zL3N0YXRlIG1hY2hpbmVzXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uc1RvUmVtb3ZlID0gdGhpcy5hbmltYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gYW5pbWF0YWJsZXMuaW5jbHVkZXMoYS5uYW1lKTsgfSk7XG4gICAgICAgICAgICBhbmltYXRpb25zVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvbnMuc3BsaWNlKF90aGlzLmFuaW1hdGlvbnMuaW5kZXhPZihhKSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtYWNoaW5lc1RvUmVtb3ZlID0gdGhpcy5zdGF0ZU1hY2hpbmVzLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gYW5pbWF0YWJsZXMuaW5jbHVkZXMobS5uYW1lKTsgfSk7XG4gICAgICAgICAgICBtYWNoaW5lc1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZU1hY2hpbmVzLnNwbGljZShfdGhpcy5zdGF0ZU1hY2hpbmVzLmluZGV4T2YobSksIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZW1vdmVkTmFtZXMgPSBhbmltYXRpb25zVG9SZW1vdmUubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pLmNvbmNhdChtYWNoaW5lc1RvUmVtb3ZlLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lOyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZSh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuU3RvcCxcbiAgICAgICAgICAgIGRhdGE6IHJlbW92ZWROYW1lcyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgbGlzdCBvZiBhbmltYXRpb25zIHJlbW92ZWRcbiAgICAgICAgcmV0dXJuIHJlbW92ZWROYW1lcztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRvci5wcm90b3R5cGUsIFwiaXNQbGF5aW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgYW5pbWF0aW9uIGlzIGFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXJyKSB7IHJldHVybiBhY2MgfHwgY3Vyci5wbGF5aW5nOyB9LCBmYWxzZSlcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnN0YXRlTWFjaGluZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHsgcmV0dXJuIGFjYyB8fCBjdXJyLnBsYXlpbmc7IH0sIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRvci5wcm90b3R5cGUsIFwiaXNQYXVzZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBhbmltYXRpb25zIGFyZSBwYXVzZWQgYW5kIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNQbGF5aW5nICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPiAwIHx8IHRoaXMuc3RhdGVNYWNoaW5lcy5sZW5ndGggPiAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRvci5wcm90b3R5cGUsIFwiaXNTdG9wcGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gcGxheWluZyBvciBwYXVzZWQgYW5pbWF0aW9ucy9zdGF0ZSBtYWNoaW5lc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnN0YXRlTWFjaGluZXMubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGFuaW1hdGlvbnMgb3Igc3RhdGUgbWFjaGluZXMsIGFkZCB0aGUgZmlyc3Qgb25lIGZvdW5kXG4gICAgICogQHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiBvciBzdGF0ZSBtYWNoaW5lIGluc3RhbmNlZFxuICAgICAqL1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5hdExlYXN0T25lID0gZnVuY3Rpb24gKHBsYXlpbmcsIGZpcmVFdmVudCkge1xuICAgICAgICBpZiAoZmlyZUV2ZW50ID09PSB2b2lkIDApIHsgZmlyZUV2ZW50ID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgaW5zdGFuY2VkTmFtZTtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPT09IDAgJiYgdGhpcy5zdGF0ZU1hY2hpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJ0Ym9hcmQuYW5pbWF0aW9uQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGZpcnN0IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKFtpbnN0YW5jZWROYW1lID0gdGhpcy5hcnRib2FyZC5hbmltYXRpb25CeUluZGV4KDApLm5hbWVdLCBwbGF5aW5nLCBmaXJlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hcnRib2FyZC5zdGF0ZU1hY2hpbmVDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZmlyc3Qgc3RhdGUgbWFjaGluZVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKFtpbnN0YW5jZWROYW1lID0gdGhpcy5hcnRib2FyZC5zdGF0ZU1hY2hpbmVCeUluZGV4KDApLm5hbWVdLCBwbGF5aW5nLCBmaXJlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZWROYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFueSBhbmltYXRpb25zIGhhdmUgbG9vcGVkIGFuZCBpZiBzbywgZmlyZSB0aGUgYXBwcm9wcmlhdGUgZXZlbnRcbiAgICAgKi9cbiAgICBBbmltYXRvci5wcm90b3R5cGUuaGFuZGxlTG9vcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucGxheWluZzsgfSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgLy8gRW1pdCBpZiB0aGUgYW5pbWF0aW9uIGxvb3BlZFxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi5sb29wVmFsdWUgPT09IDAgJiYgYW5pbWF0aW9uLmxvb3BDb3VudCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5sb29wQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBvbmUtc2hvdDsgaWYgaXQgaGFzIGVuZGVkLCBkZWxldGUgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKGFuaW1hdGlvbi5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFuaW1hdGlvbi5sb29wVmFsdWUgPT09IDEgJiYgYW5pbWF0aW9uLmxvb3BDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuTG9vcCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBhbmltYXRpb246IGFuaW1hdGlvbi5uYW1lLCB0eXBlOiBMb29wVHlwZS5Mb29wIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ubG9vcENvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdhc20gaW5kaWNhdGVzIGEgbG9vcCBhdCBlYWNoIHRpbWUgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gY2hhbmdlcyBkaXJlY3Rpb24sIHNvIGEgZnVsbCBsb29wL2xhcCBvY2N1cnMgZXZlcnlcbiAgICAgICAgICAgIC8vIHR3byBsb29wIGNvdW50c1xuICAgICAgICAgICAgZWxzZSBpZiAoYW5pbWF0aW9uLmxvb3BWYWx1ZSA9PT0gMiAmJiBhbmltYXRpb24ubG9vcENvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuTG9vcCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBhbmltYXRpb246IGFuaW1hdGlvbi5uYW1lLCB0eXBlOiBMb29wVHlwZS5QaW5nUG9uZyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLmxvb3BDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBzdGF0ZXMgaGF2ZSBjaGFuZ2VkIGluIHN0YXRlIG1hY2hpbmVzIGFuZCBmaXJlcyBhIHN0YXRlY2hhbmdlXG4gICAgICogZXZlbnRcbiAgICAgKi9cbiAgICBBbmltYXRvci5wcm90b3R5cGUuaGFuZGxlU3RhdGVDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGVzQ2hhbmdlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zdGF0ZU1hY2hpbmVzLmZpbHRlcihmdW5jdGlvbiAoc20pIHsgcmV0dXJuIHNtLnBsYXlpbmc7IH0pOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHN0YXRlTWFjaGluZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHN0YXRlc0NoYW5nZWQucHVzaC5hcHBseShzdGF0ZXNDaGFuZ2VkLCBzdGF0ZU1hY2hpbmUuc3RhdGVzQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlc0NoYW5nZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlN0YXRlQ2hhbmdlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHN0YXRlc0NoYW5nZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdG9yO1xufSgpKTtcbi8vICNlbmRyZWdpb25cbi8vICNyZWdpb24gZXZlbnRzXG4vKipcbiAqIFN1cHBvcnRlZCBldmVudCB0eXBlcyB0cmlnZ2VyZWQgaW4gUml2ZVxuICovXG52YXIgRXZlbnRUeXBlO1xuKGZ1bmN0aW9uIChFdmVudFR5cGUpIHtcbiAgICBFdmVudFR5cGVbXCJMb2FkXCJdID0gXCJsb2FkXCI7XG4gICAgRXZlbnRUeXBlW1wiTG9hZEVycm9yXCJdID0gXCJsb2FkZXJyb3JcIjtcbiAgICBFdmVudFR5cGVbXCJQbGF5XCJdID0gXCJwbGF5XCI7XG4gICAgRXZlbnRUeXBlW1wiUGF1c2VcIl0gPSBcInBhdXNlXCI7XG4gICAgRXZlbnRUeXBlW1wiU3RvcFwiXSA9IFwic3RvcFwiO1xuICAgIEV2ZW50VHlwZVtcIkxvb3BcIl0gPSBcImxvb3BcIjtcbiAgICBFdmVudFR5cGVbXCJEcmF3XCJdID0gXCJkcmF3XCI7XG4gICAgRXZlbnRUeXBlW1wiU3RhdGVDaGFuZ2VcIl0gPSBcInN0YXRlY2hhbmdlXCI7XG59KShFdmVudFR5cGUgfHwgKEV2ZW50VHlwZSA9IHt9KSk7XG4vKipcbiAqIExvb3BpbmcgdHlwZXM6IG9uZS1zaG90LCBsb29wLCBhbmQgcGluZy1wb25nXG4gKi9cbnZhciBMb29wVHlwZTtcbihmdW5jdGlvbiAoTG9vcFR5cGUpIHtcbiAgICBMb29wVHlwZVtcIk9uZVNob3RcIl0gPSBcIm9uZXNob3RcIjtcbiAgICBMb29wVHlwZVtcIkxvb3BcIl0gPSBcImxvb3BcIjtcbiAgICBMb29wVHlwZVtcIlBpbmdQb25nXCJdID0gXCJwaW5ncG9uZ1wiOyAvLyBoYXMgdmFsdWUgMiBpbiBydW50aW1lXG59KShMb29wVHlwZSB8fCAoTG9vcFR5cGUgPSB7fSkpO1xuLy8gTWFuYWdlcyBSaXZlIGV2ZW50cyBhbmQgbGlzdGVuZXJzXG52YXIgRXZlbnRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50TWFuYWdlcihsaXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVycyA9PT0gdm9pZCAwKSB7IGxpc3RlbmVycyA9IFtdOyB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIH1cbiAgICAvLyBHZXRzIGxpc3RlbmVycyBvZiBzcGVjaWZpZWQgdHlwZVxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50eXBlID09PSB0eXBlOyB9KTtcbiAgICB9O1xuICAgIC8vIEFkZHMgYSBsaXN0ZW5lclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnMuaW5jbHVkZXMobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGxpc3RlbmVyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB3aXRoIHRoZSBjYWxsYmFjayB0byBiZSByZW1vdmVkXG4gICAgICovXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc2ltcGx5IGxvb2sgZm9yIHRoZSBsaXN0ZW5lciBhcyBpdCdsbCBiZSBhIGRpZmZlcmVudCBpbnN0YW5jZSB0b1xuICAgICAgICAvLyBvbmUgb3JpZ2luYWxseSBzdWJzY3JpYmVkLiBGaW5kIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoZSByaWdodCB0eXBlIGFuZFxuICAgICAgICAvLyB0aGVuIGNoZWNrIHRoZWlyIGNhbGxiYWNrcyB3aGljaCBzaG91bGQgbWF0Y2guXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGlzdGVuZXIudHlwZSA9PT0gbGlzdGVuZXIudHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGlzdGVuZXIuY2FsbGJhY2sgPT09IGxpc3RlbmVyLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGxpc3RlbmVycyBvZiBzcGVjaWZpZWQgdHlwZSwgb3IgZXZlcnkgbGlzdGVuZXIgaWYgbm8gdHlwZSBpc1xuICAgICAqIHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIGxpc3RlbmVycyB0byBjbGVhciwgb3IgYWxsIGxpc3RlbmVycyBpZiBub3RcbiAgICAgKiBzcGVjaWZpZWRcbiAgICAgKi9cbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKDAsIHRoaXMubGlzdGVuZXJzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwudHlwZSA9PT0gdHlwZTsgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobCkgeyByZXR1cm4gX3RoaXMucmVtb3ZlKGwpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRmlyZXMgYW4gZXZlbnRcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnMoZXZlbnQudHlwZSk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lci5jYWxsYmFjayhldmVudCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50TWFuYWdlcjtcbn0oKSk7XG4vLyBNYW5hZ2VzIGEgcXVldWUgb2YgdGFza3NcbnZhciBUYXNrUXVldWVNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhc2tRdWV1ZU1hbmFnZXIoZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgfVxuICAgIC8vIEFkZHMgYSB0YXNrIHRvcCB0aGUgcXVldWVcbiAgICBUYXNrUXVldWVNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFzayk7XG4gICAgfTtcbiAgICAvLyBQcm9jZXNzZXMgYWxsIHRhc2tzIGluIHRoZSBxdWV1ZVxuICAgIFRhc2tRdWV1ZU1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgdGFzayA9PT0gbnVsbCB8fCB0YXNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXNrLmFjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRhc2sgPT09IG51bGwgfHwgdGFzayA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFzay5ldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUodGFzay5ldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUYXNrUXVldWVNYW5hZ2VyO1xufSgpKTtcbnZhciBSaXZlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJpdmUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgbGF5b3V0IGhhcyBjaGFuZ2VkOyB1c2VkIGJ5IHRoZSByZW5kZXJlciB0byBrbm93XG4gICAgICAgIC8vIHdoZW4gdG8gYWxpZ25cbiAgICAgICAgdGhpcy5fdXBkYXRlTGF5b3V0ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgdG8gYWN0aXZlL2RlYWN0aXZhdGUgcmVuZGVyZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNSZW5kZXJlckFjdGl2ZSA9IHRydWU7XG4gICAgICAgIC8vIFRyYWNrcyBpZiBhIFJpdmUgZmlsZSBpcyBsb2FkZWRcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyBpZiBhIFJpdmUgZmlsZSBpcyBsb2FkZWQ7IHdlIG5lZWQgdGhpcyBpbiBhZGRpdGlvbiB0byBsb2FkZWQgYXMgc29tZVxuICAgICAgICAgKiBjb21tYW5kcyAoZS5nLiBjb250ZW50cykgY2FuIGJlIGNhbGxlZCBhcyBzb29uIGFzIHRoZSBmaWxlIGlzIGxvYWRlZC5cbiAgICAgICAgICogSG93ZXZlciwgcGxheWJhY2sgY29tbWFuZHMgbmVlZCB0byBiZSBxdWV1ZWQgYW5kIHJ1biBpbiBvcmRlciBvbmNlIGluaXRpYWxcbiAgICAgICAgICogYW5pbWF0aW9ucyBhbmQgYXV0b3BsYXkgaGFzIGJlZW4gc29ydGVkIG91dC4gVGhpcyBhcHBsaWVzIHRvIHBsYXksIHBhdXNlLFxuICAgICAgICAgKiBhbmQgc3RhcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWR5Rm9yUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAvLyBSdW50aW1lIGFydGJvYXJkXG4gICAgICAgIHRoaXMuYXJ0Ym9hcmQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBiZSBkcmF3IHRvIHRyYWNrIHdoZW4gYSBzZWNvbmQgb2YgYWN0aXZlIHJlbmRlcmluZyB0aW1lIGhhcyBwYXNzZWQuIFVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJTZWNvbmRUaW1lciA9IDA7XG4gICAgICAgIHRoaXMuY2FudmFzID0gcGFyYW1zLmNhbnZhcztcbiAgICAgICAgdGhpcy5zcmMgPSBwYXJhbXMuc3JjO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHBhcmFtcy5idWZmZXI7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gKF9hID0gcGFyYW1zLmxheW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IExheW91dCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVMYXlvdXQgPSB0cnVlO1xuICAgICAgICAvLyBGZXRjaCB0aGUgMmQgY29udGV4dCBmcm9tIHRoZSBjYW52YXNcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAvLyBOZXcgZXZlbnQgbWFuYWdlbWVudCBzeXN0ZW1cbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKCk7XG4gICAgICAgIGlmIChwYXJhbXMub25sb2FkKVxuICAgICAgICAgICAgdGhpcy5vbihFdmVudFR5cGUuTG9hZCwgcGFyYW1zLm9ubG9hZCk7XG4gICAgICAgIGlmIChwYXJhbXMub25sb2FkZXJyb3IpXG4gICAgICAgICAgICB0aGlzLm9uKEV2ZW50VHlwZS5Mb2FkRXJyb3IsIHBhcmFtcy5vbmxvYWRlcnJvcik7XG4gICAgICAgIGlmIChwYXJhbXMub25wbGF5KVxuICAgICAgICAgICAgdGhpcy5vbihFdmVudFR5cGUuUGxheSwgcGFyYW1zLm9ucGxheSk7XG4gICAgICAgIGlmIChwYXJhbXMub25wYXVzZSlcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLlBhdXNlLCBwYXJhbXMub25wYXVzZSk7XG4gICAgICAgIGlmIChwYXJhbXMub25zdG9wKVxuICAgICAgICAgICAgdGhpcy5vbihFdmVudFR5cGUuU3RvcCwgcGFyYW1zLm9uc3RvcCk7XG4gICAgICAgIGlmIChwYXJhbXMub25sb29wKVxuICAgICAgICAgICAgdGhpcy5vbihFdmVudFR5cGUuTG9vcCwgcGFyYW1zLm9ubG9vcCk7XG4gICAgICAgIGlmIChwYXJhbXMub25zdGF0ZWNoYW5nZSlcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLlN0YXRlQ2hhbmdlLCBwYXJhbXMub25zdGF0ZWNoYW5nZSk7XG4gICAgICAgIC8vIEhvb2sgdXAgdGhlIHRhc2sgcXVldWVcbiAgICAgICAgdGhpcy50YXNrUXVldWUgPSBuZXcgVGFza1F1ZXVlTWFuYWdlcih0aGlzLmV2ZW50TWFuYWdlcik7XG4gICAgICAgIHRoaXMuaW5pdCh7XG4gICAgICAgICAgICBzcmM6IHRoaXMuc3JjLFxuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLmJ1ZmZlcixcbiAgICAgICAgICAgIGF1dG9wbGF5OiBwYXJhbXMuYXV0b3BsYXksXG4gICAgICAgICAgICBhbmltYXRpb25zOiBwYXJhbXMuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgIHN0YXRlTWFjaGluZXM6IHBhcmFtcy5zdGF0ZU1hY2hpbmVzLFxuICAgICAgICAgICAgYXJ0Ym9hcmQ6IHBhcmFtcy5hcnRib2FyZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgdG8gYnVpbGQgYSBSaXZlIGluc3RhbmNlIGZyb20gYW4gaW50ZXJmYWNlL29iamVjdFxuICAgIFJpdmUubmV3ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZDogcGxlYXNlIHVzZSBgbmV3IFJpdmUoe30pYCBpbnN0ZWFkJyk7XG4gICAgICAgIHJldHVybiBuZXcgUml2ZShwYXJhbXMpO1xuICAgIH07XG4gICAgLy8gSW5pdGlhbGl6ZXMgdGhlIFJpdmUgb2JqZWN0IGVpdGhlciBmcm9tIGNvbnN0cnVjdG9yIG9yIGxvYWQoKVxuICAgIFJpdmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNyYyA9IF9hLnNyYywgYnVmZmVyID0gX2EuYnVmZmVyLCBhbmltYXRpb25zID0gX2EuYW5pbWF0aW9ucywgc3RhdGVNYWNoaW5lcyA9IF9hLnN0YXRlTWFjaGluZXMsIGFydGJvYXJkID0gX2EuYXJ0Ym9hcmQsIF9iID0gX2EuYXV0b3BsYXksIGF1dG9wbGF5ID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgICAgIHRoaXMuc3JjID0gc3JjO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgLy8gSWYgbm8gc291cmNlIGZpbGUgdXJsIHNwZWNpZmllZCwgaXQncyBhIGJ1c3RcbiAgICAgICAgaWYgKCF0aGlzLnNyYyAmJiAhdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihSaXZlLm1pc3NpbmdFcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExpc3Qgb2YgYW5pbWF0aW9ucyB0aGF0IHNob3VsZCBiZSBpbml0aWFsaXplZC5cbiAgICAgICAgdmFyIHN0YXJ0aW5nQW5pbWF0aW9uTmFtZXMgPSBtYXBUb1N0cmluZ0FycmF5KGFuaW1hdGlvbnMpO1xuICAgICAgICAvLyBMaXN0IG9mIHN0YXRlIG1hY2hpbmVzIHRoYXQgc2hvdWxkIGJlIGluaXRpYWxpemVkXG4gICAgICAgIHZhciBzdGFydGluZ1N0YXRlTWFjaGluZU5hbWVzID0gbWFwVG9TdHJpbmdBcnJheShzdGF0ZU1hY2hpbmVzKTtcbiAgICAgICAgLy8gRW5zdXJlIGxvYWRlZCBpcyBtYXJrZWQgYXMgZmFsc2UgaWYgbG9hZGluZyBuZXcgZmlsZVxuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWR5Rm9yUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIHJ1bnRpbWUgaXMgbG9hZGVkXG4gICAgICAgIFJ1bnRpbWVMb2FkZXIuYXdhaXRJbnN0YW5jZSgpLnRoZW4oZnVuY3Rpb24gKHJ1bnRpbWUpIHtcbiAgICAgICAgICAgIF90aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICAgICAgICAgICAgLy8gTG9hZCBSaXZlIGRhdGEgZnJvbSBhIHNvdXJjZSB1cmkgb3IgYSBkYXRhIGJ1ZmZlclxuICAgICAgICAgICAgX3RoaXMuaW5pdERhdGEoYXJ0Ym9hcmQsIHN0YXJ0aW5nQW5pbWF0aW9uTmFtZXMsIHN0YXJ0aW5nU3RhdGVNYWNoaW5lTmFtZXMsIGF1dG9wbGF5KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gSW5pdGlhbGl6ZXMgcnVudGltZSB3aXRoIFJpdmUgZGF0YSBhbmQgcHJlcHMgZm9yIHBsYXlpbmdcbiAgICBSaXZlLnByb3RvdHlwZS5pbml0RGF0YSA9IGZ1bmN0aW9uIChhcnRib2FyZE5hbWUsIGFuaW1hdGlvbk5hbWVzLCBzdGF0ZU1hY2hpbmVOYW1lcywgYXV0b3BsYXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2IsIF9jLCBtc2c7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3JjKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxvYWRSaXZlRmlsZSh0aGlzLnNyYyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5idWZmZXIgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIFJpdmUgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5ydW50aW1lLmxvYWQobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIFJpdmUgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgX2MuZmlsZSA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIGFuZCBkcmF3IGZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0QXJ0Ym9hcmQoYXJ0Ym9hcmROYW1lLCBhbmltYXRpb25OYW1lcywgc3RhdGVNYWNoaW5lTmFtZXMsIGF1dG9wbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nJ3Mgc2V0IHVwLCBlbWl0IGEgbG9hZCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYSA9IHRoaXMuc3JjKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnYnVmZmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsYWcgcmVhZHkgZm9yIHBsYXliYWNrIGNvbW1hbmRzIGFuZCBjbGVhciB0aGUgdGFzayBxdWV1ZTsgdGhpcyBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGltcG9ydGFudCBvciBpdCBtYXkgaW5maW5pdGVseSByZWN1cnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkeUZvclBsYXlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFza1F1ZXVlLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdGcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlc29sdmUoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSAnUHJvYmxlbSBsb2FkaW5nIGZpbGU7IG1heSBiZSBjb3JydXB0ISc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZSh7IHR5cGU6IEV2ZW50VHlwZS5Mb2FkRXJyb3IsIGRhdGE6IG1zZyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZWplY3QobXNnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gSW5pdGlhbGl6ZSBmb3IgcGxheWJhY2tcbiAgICBSaXZlLnByb3RvdHlwZS5pbml0QXJ0Ym9hcmQgPSBmdW5jdGlvbiAoYXJ0Ym9hcmROYW1lLCBhbmltYXRpb25OYW1lcywgc3RhdGVNYWNoaW5lTmFtZXMsIGF1dG9wbGF5KSB7XG4gICAgICAgIC8vIEZldGNoIHRoZSBhcnRib2FyZFxuICAgICAgICB2YXIgcm9vdEFydGJvYXJkID0gYXJ0Ym9hcmROYW1lID9cbiAgICAgICAgICAgIHRoaXMuZmlsZS5hcnRib2FyZEJ5TmFtZShhcnRib2FyZE5hbWUpIDpcbiAgICAgICAgICAgIHRoaXMuZmlsZS5kZWZhdWx0QXJ0Ym9hcmQoKTtcbiAgICAgICAgLy8gQ2hlY2sgd2UgaGF2ZSBhIHdvcmtpbmcgYXJ0Ym9hcmRcbiAgICAgICAgaWYgKCFyb290QXJ0Ym9hcmQpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnSW52YWxpZCBhcnRib2FyZCBuYW1lIG9yIG5vIGRlZmF1bHQgYXJ0Ym9hcmQnO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHsgdHlwZTogRXZlbnRUeXBlLkxvYWRFcnJvciwgZGF0YTogbXNnIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluc3RhbmNlIHRoZSBhcnRib2FyZFxuICAgICAgICB0aGlzLmFydGJvYXJkID0gcm9vdEFydGJvYXJkLmluc3RhbmNlKCk7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGFydGJvYXJkIGhhcyBhdCBsZWFzdCAxIGFuaW1hdGlvblxuICAgICAgICBpZiAodGhpcy5hcnRib2FyZC5hbmltYXRpb25Db3VudCgpIDwgMSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdBcnRib2FyZCBoYXMgbm8gYW5pbWF0aW9ucyc7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHsgdHlwZTogRXZlbnRUeXBlLkxvYWRFcnJvciwgZGF0YTogbXNnIH0pO1xuICAgICAgICAgICAgdGhyb3cgbXNnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGFuaW1hdG9yXG4gICAgICAgIHRoaXMuYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGhpcy5ydW50aW1lLCB0aGlzLmFydGJvYXJkLCB0aGlzLmV2ZW50TWFuYWdlcik7XG4gICAgICAgIC8vIEdldCB0aGUgY2FudmFzIHdoZXJlIHlvdSB3YW50IHRvIHJlbmRlciB0aGUgYW5pbWF0aW9uIGFuZCBjcmVhdGUgYSByZW5kZXJlclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IHRoaXMucnVudGltZS5DYW52YXNSZW5kZXJlcih0aGlzLmN0eCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGFuaW1hdGlvbnM7IGFzIGxvYWRlZCBoYXNuJ3QgaGFwcGVuZWQgeWV0LCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHN1cHByZXNzIGZpcmluZyB0aGUgcGxheS9wYXVzZSBldmVudHMgdW50aWwgdGhlIGxvYWQgZXZlbnQgaGFzIGZpcmVkLiBUb1xuICAgICAgICAvLyBkbyB0aGlzIHdlIHRlbGwgdGhlIGFuaW1hdG9yIHRvIHN1cHByZXNzIGZpcmluZyBldmVudHMsIGFuZCBhZGQgZXZlbnRcbiAgICAgICAgLy8gZmlyaW5nIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgICB2YXIgaW5zdGFuY2VOYW1lcztcbiAgICAgICAgaWYgKGFuaW1hdGlvbk5hbWVzLmxlbmd0aCA+IDAgfHwgc3RhdGVNYWNoaW5lTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5zdGFuY2VOYW1lcyA9IGFuaW1hdGlvbk5hbWVzLmNvbmNhdChzdGF0ZU1hY2hpbmVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdG9yLmFkZChpbnN0YW5jZU5hbWVzLCBhdXRvcGxheSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2VOYW1lcyA9IFt0aGlzLmFuaW1hdG9yLmF0TGVhc3RPbmUoYXV0b3BsYXksIGZhbHNlKV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUXVldWUgdXAgZmlyaW5nIHRoZSBwbGF5YmFjayBldmVudHNcbiAgICAgICAgdGhpcy50YXNrUXVldWUuYWRkKHtcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhdXRvcGxheSA/IEV2ZW50VHlwZS5QbGF5IDogRXZlbnRUeXBlLlBhdXNlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGluc3RhbmNlTmFtZXMsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gRHJhd3MgdGhlIGN1cnJlbnQgYXJ0Ym9hcmQgZnJhbWVcbiAgICBSaXZlLnByb3RvdHlwZS5kcmF3RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRSZW5kZXJpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgcmVuZGVyaW5nIGxvb3A7IHJlbmRlcnMgYW5pbWF0aW9uIGZyYW1lcyBhdCB0aGUgY29ycmVjdCB0aW1lIGludGVydmFsLlxuICAgICAqIEBwYXJhbSB0aW1lIHRoZSB0aW1lIGF0IHdoaWNoIHRvIHJlbmRlciBhIGZyYW1lXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICh0aW1lLCBvblNlY29uZCkge1xuICAgICAgICAvLyBDbGVhciB0aGUgZnJhbWVSZXF1ZXN0SWQsIGFzIHdlJ3JlIG5vdyByZW5kZXJpbmcgYSBmcmVzaCBmcmFtZVxuICAgICAgICB0aGlzLmZyYW1lUmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgLy8gT24gdGhlIGZpcnN0IHBhc3MsIG1ha2Ugc3VyZSBsYXN0VGltZSBoYXMgYSB2YWxpZCB2YWx1ZVxuICAgICAgICBpZiAoIXRoaXMubGFzdFJlbmRlclRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgb25TZWNvbmQgY2FsbGJhY2tcbiAgICAgICAgdGhpcy5yZW5kZXJTZWNvbmRUaW1lciArPSAodGltZSAtIHRoaXMubGFzdFJlbmRlclRpbWUpO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJTZWNvbmRUaW1lciA+IDUwMDApIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2Vjb25kVGltZXIgPSAwO1xuICAgICAgICAgICAgb25TZWNvbmQgPT09IG51bGwgfHwgb25TZWNvbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uU2Vjb25kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBlbGFwc2VkIHRpbWUgYmV0d2VlbiBmcmFtZXMgaW4gc2Vjb25kc1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSAodGltZSAtIHRoaXMubGFzdFJlbmRlclRpbWUpIC8gMTAwMDtcbiAgICAgICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIEFkdmFuY2Ugbm9uLXBhdXNlZCBhbmltYXRpb25zIGJ5IHRoZSBlbGFwc2VkIG51bWJlciBvZiBzZWNvbmRzXG4gICAgICAgIC8vIEFsc28gYWR2YW5jZSBhbnkgYW5pbWF0aW9ucyB0aGF0IHJlcXVpcmUgc2NydWJiaW5nXG4gICAgICAgIHZhciBhY3RpdmVBbmltYXRpb25zID0gdGhpcy5hbmltYXRvci5hbmltYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5wbGF5aW5nIHx8IGEubmVlZHNTY3J1YjsgfSlcbiAgICAgICAgICAgIC8vIFRoZSBzY3J1YmJlZCBhbmltYXRpb25zIG11c3QgYmUgYXBwbGllZCBmaXJzdCB0byBwcmV2ZW50IHdlaXJkIGFydGlmYWN0c1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBsYXlpbmcgYW5pbWF0aW9ucyBjb25mbGljdCB3aXRoIHRoZSBzY3J1YmJlZCBhbmltYXRpbmcgYXR0cmlidWF0ZXMuXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkgeyByZXR1cm4gZmlyc3QubmVlZHNTY3J1YiA/IC0xIDogMTsgfSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYWN0aXZlQW5pbWF0aW9uc18xID0gYWN0aXZlQW5pbWF0aW9uczsgX2kgPCBhY3RpdmVBbmltYXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gYWN0aXZlQW5pbWF0aW9uc18xW19pXTtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5hZHZhbmNlKGVsYXBzZWRUaW1lKTtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb24uaW5zdGFuY2UuZGlkTG9vcCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5sb29wQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdGlvbi5pbnN0YW5jZS5hcHBseSh0aGlzLmFydGJvYXJkLCAxLjApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkdmFuY2Ugbm9uLXBhdXNlZCBzdGF0ZSBtYWNoaW5lcyBieSB0aGUgZWxhcHNlZCBudW1iZXIgb2Ygc2Vjb25kc1xuICAgICAgICB2YXIgYWN0aXZlU3RhdGVNYWNoaW5lcyA9IHRoaXMuYW5pbWF0b3Iuc3RhdGVNYWNoaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucGxheWluZzsgfSk7XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgYWN0aXZlU3RhdGVNYWNoaW5lc18xID0gYWN0aXZlU3RhdGVNYWNoaW5lczsgX2EgPCBhY3RpdmVTdGF0ZU1hY2hpbmVzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVNYWNoaW5lID0gYWN0aXZlU3RhdGVNYWNoaW5lc18xW19hXTtcbiAgICAgICAgICAgIHN0YXRlTWFjaGluZS5pbnN0YW5jZS5hZHZhbmNlKHRoaXMuYXJ0Ym9hcmQsIGVsYXBzZWRUaW1lKTtcbiAgICAgICAgICAgIC8vIHN0YXRlTWFjaGluZS5pbnN0YW5jZS5hcHBseSh0aGlzLmFydGJvYXJkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmNlIHRoZSBhbmltYXRpb25zIGhhdmUgYmVlbiBhcHBsaWVkIHRvIHRoZSBhcnRib2FyZCwgYWR2YW5jZSBpdFxuICAgICAgICAvLyBieSB0aGUgZWxhcHNlZCB0aW1lLlxuICAgICAgICB0aGlzLmFydGJvYXJkLmFkdmFuY2UoZWxhcHNlZFRpbWUpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbmRlcmVyIGFsaWdubWVudCBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGhpcy5hbGlnblJlbmRlcmVyKCk7XG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmFydGJvYXJkLmJvdW5kcztcbiAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KGJvdW5kcy5taW5YLCBib3VuZHMubWluWSwgYm91bmRzLm1heFgsIGJvdW5kcy5tYXhZKTtcbiAgICAgICAgdGhpcy5hcnRib2FyZC5kcmF3KHRoaXMucmVuZGVyZXIpO1xuICAgICAgICAvLyBDaGVjayBmb3IgYW55IGFuaW1hdGlvbnMgdGhhdCBsb29wZWRcbiAgICAgICAgdGhpcy5hbmltYXRvci5oYW5kbGVMb29waW5nKCk7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbnkgc3RhdGUgbWFjaGluZXMgdGhhdCBoYWQgYSBzdGF0ZSBjaGFuZ2VcbiAgICAgICAgdGhpcy5hbmltYXRvci5oYW5kbGVTdGF0ZUNoYW5nZXMoKTtcbiAgICAgICAgLy8gQ2FsbGluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2lsbCByZXJ1biBkcmF3KCkgYXQgdGhlIGNvcnJlY3QgcmF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkvVHV0b3JpYWwvQmFzaWNfYW5pbWF0aW9uc1xuICAgICAgICBpZiAodGhpcy5hbmltYXRvci5pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgYSBuZXcgcmVuZGVyaW5nIGZyYW1lXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hbmltYXRvci5pc1BhdXNlZCkge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVuZCB0aW1lIHNvIG9uIHBsYXliYWNrIGl0IHN0YXJ0cyBhdCB0aGUgY29ycmVjdCBmcmFtZVxuICAgICAgICAgICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hbmltYXRvci5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGFuaW1hdGlvbiBpbnN0YW5jZXMsIGFydGJvYXJkIGFuZCB0aW1lXG4gICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdGhpcyBwcm9wZXJseSB3aGVuIHdlIGhhdmUgaW5zdGFuY2luZ1xuICAgICAgICAgICAgLy8gdGhpcy5pbml0QXJ0Ym9hcmQoKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZHJhd0ZyYW1lKCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxpZ24gdGhlIHJlbmRlcmVyXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuYWxpZ25SZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW5kZXJlciBhbGlnbm1lbnQgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVMYXlvdXQpIHtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgZnJvbSBwcmV2aW91cyBzYXZlIGluIGNhc2UgYSBwcmV2aW91cyBhbGlnbiBvY2N1cnJlZFxuICAgICAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgLy8gQ2FudmFzIG11c3QgYmUgd2lwZWQgdG8gcHJldmVudCBhcnRpZmFjdHNcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIE5vdyBzYXZlIHNvIHRoYXQgZnV0dXJlIGNoYW5nZXMgdG8gYWxpZ24gY2FuIHJlc3RvcmVcbiAgICAgICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIC8vIEFsaWduIHRoaW5ncyB1cCBzYWZlIGluIHRoZSBrbm93bGVkZ2Ugd2UgY2FuIHJlc3RvcmUgaWYgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hbGlnbih0aGlzLl9sYXlvdXQucnVudGltZUZpdCh0aGlzLnJ1bnRpbWUpLCB0aGlzLl9sYXlvdXQucnVudGltZUFsaWdubWVudCh0aGlzLnJ1bnRpbWUpLCB7XG4gICAgICAgICAgICAgICAgbWluWDogdGhpcy5fbGF5b3V0Lm1pblgsXG4gICAgICAgICAgICAgICAgbWluWTogdGhpcy5fbGF5b3V0Lm1pblksXG4gICAgICAgICAgICAgICAgbWF4WDogdGhpcy5fbGF5b3V0Lm1heFgsXG4gICAgICAgICAgICAgICAgbWF4WTogdGhpcy5fbGF5b3V0Lm1heFlcbiAgICAgICAgICAgIH0sIHRoaXMuYXJ0Ym9hcmQuYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheW91dCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYW55IFdhc20tZ2VuZXJhdGVkIG9iamVjdHMgdGhhdCBuZWVkIHRvIGJlIG1hbnVhbGx5IGRlc3Ryb3llZDpcbiAgICAgKiBhcnRib2FyZCBpbnN0YW5jZXMsIGFuaW1hdGlvbiBpbnN0YW5jZXMsIHN0YXRlIG1hY2hpbmUgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogT25jZSB0aGlzIGlzIGNhbGxlZCwgdGhpbmdzIHdpbGwgbmVlZCB0byBiZSByZWluaXRpYWxpemVkIG9yIGJhZCB0aGluZ3NcbiAgICAgKiBtaWdodCBoYXBwZW4uXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hcnRib2FyZC5kZWxldGUoKTtcbiAgICAgICAgLy8gVE9ETzogZGVsZXRlIGFuaW1hdGlvbiBhbmQgc3RhdGUgbWFjaGluZSBpbnN0YW5jZXNcbiAgICB9O1xuICAgIC8vIFBsYXlzIHNwZWNpZmllZCBhbmltYXRpb25zOyBpZiBub25lIHNwZWNpZmllZCwgaXQgdW5wYXVzZXMgZXZlcnl0aGluZy5cbiAgICBSaXZlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWVzLCBhdXRvcGxheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhbmltYXRpb25OYW1lcyA9IG1hcFRvU3RyaW5nQXJyYXkoYW5pbWF0aW9uTmFtZXMpO1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSdzIG5vdCBsb2FkZWQsIHF1ZXVlIHVwIHRoZSBwbGF5XG4gICAgICAgIGlmICghdGhpcy5yZWFkeUZvclBsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudGFza1F1ZXVlLmFkZCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wbGF5KGFuaW1hdGlvbk5hbWVzLCBhdXRvcGxheSk7IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdG9yLnBsYXkoYW5pbWF0aW9uTmFtZXMpO1xuICAgICAgICB0aGlzLnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgfTtcbiAgICAvLyBQYXVzZXMgc3BlY2lmaWVkIGFuaW1hdGlvbnM7IGlmIG5vbmUgc3BlY2lmaWVkLCBwYXVzZXMgYWxsLlxuICAgIFJpdmUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFuaW1hdGlvbk5hbWVzID0gbWFwVG9TdHJpbmdBcnJheShhbmltYXRpb25OYW1lcyk7XG4gICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgZWFybHkgb3V0LCBub3RoaW5nIHRvIHBhdXNlXG4gICAgICAgIGlmICghdGhpcy5yZWFkeUZvclBsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudGFza1F1ZXVlLmFkZCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wYXVzZShhbmltYXRpb25OYW1lcyk7IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdG9yLnBhdXNlKGFuaW1hdGlvbk5hbWVzKTtcbiAgICB9O1xuICAgIFJpdmUucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWVzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhbmltYXRpb25OYW1lcyA9IG1hcFRvU3RyaW5nQXJyYXkoYW5pbWF0aW9uTmFtZXMpO1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSdzIG5vdCBsb2FkZWQsIGVhcmx5IG91dCwgbm90aGluZyB0byBwYXVzZVxuICAgICAgICBpZiAoIXRoaXMucmVhZHlGb3JQbGF5aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2tRdWV1ZS5hZGQoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NydWIoYW5pbWF0aW9uTmFtZXMsIHZhbHVlKTsgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjcnViIHRoZSBhbmltYXRpb24gdGltZTsgd2UgZHJhdyBhIHNpbmdsZSBmcmFtZSBoZXJlIHNvIHRoYXQgaWZcbiAgICAgICAgLy8gbm90aGluZydzIGN1cnJlbnRseSBwbGF5aW5nLCB0aGUgc2NydWJiZWQgYW5pbWF0aW9uIGlzIHN0aWxsIHJlbmRlcmVkL1xuICAgICAgICB0aGlzLmFuaW1hdG9yLnNjcnViKGFuaW1hdGlvbk5hbWVzLCB2YWx1ZSB8fCAwKTtcbiAgICAgICAgdGhpcy5kcmF3RnJhbWUoKTtcbiAgICB9O1xuICAgIC8vIFN0b3BzIHNwZWNpZmllZCBhbmltYXRpb25zOyBpZiBub25lIHNwZWNpZmllcywgc3RvcHMgdGhlbSBhbGwuXG4gICAgUml2ZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChhbmltYXRpb25OYW1lcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhbmltYXRpb25OYW1lcyA9IG1hcFRvU3RyaW5nQXJyYXkoYW5pbWF0aW9uTmFtZXMpO1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSdzIG5vdCBsb2FkZWQsIGVhcmx5IG91dCwgbm90aGluZyB0byBwYXVzZVxuICAgICAgICBpZiAoIXRoaXMucmVhZHlGb3JQbGF5aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2tRdWV1ZS5hZGQoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3RvcChhbmltYXRpb25OYW1lcyk7IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdG9yLnN0b3AoYW5pbWF0aW9uTmFtZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gYXJ0Ym9hcmQgdGhlIG5hbWUgb2YgdGhlIGFydGJvYXJkLCBvciBkZWZhdWx0IGlmIG5vbmUgZ2l2ZW5cbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9ucyB0aGUgbmFtZXMgb2YgYW5pbWF0aW9ucyBmb3IgcGxheWJhY2tcbiAgICAgKiBAcGFyYW0gc3RhdGVNYWNoaW5lcyB0aGUgbmFtZXMgb2Ygc3RhdGUgbWFjaGluZXMgZm9yIHBsYXliYWNrXG4gICAgICogQHBhcmFtIGF1dG9wbGF5IHdoZXRoZXIgdG8gYXV0b3BsYXkgd2hlbiByZXNldCwgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICAgKlxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhcnRib2FyZCwgYW5pbWF0aW9ucywgc3RhdGUgbWFjaGluZXMsIGFuZCBwbGF5YmFjayBzdGF0ZXNcbiAgICAgICAgdmFyIGFydEJvYXJkTmFtZSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5hcnRib2FyZDtcbiAgICAgICAgdmFyIGFuaW1hdGlvbk5hbWVzID0gbWFwVG9TdHJpbmdBcnJheShwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYW5pbWF0aW9ucyk7XG4gICAgICAgIHZhciBzdGF0ZU1hY2hpbmVOYW1lcyA9IG1hcFRvU3RyaW5nQXJyYXkocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnN0YXRlTWFjaGluZXMpO1xuICAgICAgICB2YXIgYXV0b3BsYXkgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXV0b3BsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICAvLyBTdG9wIGV2ZXJ5dGhpbmcgYW5kIGNsZWFuIHVwXG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgLy8gUmVpbml0aWFsaXplIGFuIGFydGJvYXJkIGluc3RhbmNlIHdpdGggdGhlIHN0YXRlXG4gICAgICAgIHRoaXMuaW5pdEFydGJvYXJkKGFydEJvYXJkTmFtZSwgYW5pbWF0aW9uTmFtZXMsIHN0YXRlTWFjaGluZU5hbWVzLCBhdXRvcGxheSk7XG4gICAgfTtcbiAgICAvLyBMb2FkcyBhIG5ldyBSaXZlIGZpbGUsIGtlZXBpbmcgbGlzdGVuZXJzIGluIHBsYWNlXG4gICAgUml2ZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgLy8gU3RvcCBhbGwgYW5pbWF0aW9uc1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXlvdXQgdG8gYWNjb3VudCBmb3IgbmV3IHJlbmRlcmVyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheW91dCA9IHRydWU7XG4gICAgICAgIC8vIFJlaW5pdGlhbGl6ZVxuICAgICAgICB0aGlzLmluaXQocGFyYW1zKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJsYXlvdXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBsYXlvdXQuIE5vdGUgdGhhdCBsYXlvdXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAgICAgICAgICogaW1tdXRhYmxlLiBJZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGxheW91dCwgY3JlYXRlIGEgbmV3IG9uZSB1c2UgdGhlXG4gICAgICAgICAqIGxheW91dCBzZXR0ZXJcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2V0cyBhIG5ldyBsYXlvdXRcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG1heFggb3IgbWF4WSBhcmUgMCwgdGhlbiBzZXQgdGhlbSB0byB0aGUgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgIGlmICghbGF5b3V0Lm1heFggfHwgIWxheW91dC5tYXhZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUb0NhbnZhcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVkICYmICF0aGlzLmFuaW1hdG9yLmlzUGxheWluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0ZyYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsYXlvdXQgYm91bmRzIHRvIHRoZSBjdXJyZW50IGNhbnZhcyBzaXplOyB0aGlzIGlzIHR5cGljYWxseSBjYWxsZWRcbiAgICAgKiB3aGVuIHRoZSBjYW52YXMgaXMgcmVzaXplZFxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLnJlc2l6ZVRvQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSB0aGlzLmxheW91dC5jb3B5V2l0aCh7XG4gICAgICAgICAgICBtaW5YOiAwLFxuICAgICAgICAgICAgbWluWTogMCxcbiAgICAgICAgICAgIG1heFg6IHRoaXMuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgbWF4WTogdGhpcy5jYW52YXMuaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl91cGRhdGVMYXlvdXQgPSB0cnVlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIGFuaW1hdGlvbiBzb3VyY2UsIHdoaWNoIG1heSBiZSB1bmRlZmluZWRcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcmM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUml2ZS5wcm90b3R5cGUsIFwiYWN0aXZlQXJ0Ym9hcmRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgYWN0aXZlIGFydGJvYXJkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFydGJvYXJkLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUml2ZS5wcm90b3R5cGUsIFwiYW5pbWF0aW9uTmFtZXNcIiwge1xuICAgICAgICAvLyBSZXR1cm5zIGEgbGlzdCBvZiBhbmltYXRpb24gbmFtZXMgb24gdGhlIGNob3NlbiBhcnRib2FyZFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgd2UgZ290IG5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk5hbWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJ0Ym9hcmQuYW5pbWF0aW9uQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uTmFtZXMucHVzaCh0aGlzLmFydGJvYXJkLmFuaW1hdGlvbkJ5SW5kZXgoaSkubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uTmFtZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUml2ZS5wcm90b3R5cGUsIFwic3RhdGVNYWNoaW5lTmFtZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygc3RhdGUgbWFjaGluZSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGFydGJvYXJkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgd2UgZ290IG5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXRlTWFjaGluZU5hbWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJ0Ym9hcmQuc3RhdGVNYWNoaW5lQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVNYWNoaW5lTmFtZXMucHVzaCh0aGlzLmFydGJvYXJkLnN0YXRlTWFjaGluZUJ5SW5kZXgoaSkubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVNYWNoaW5lTmFtZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnB1dHMgZm9yIHRoZSBzcGVjaWZpZWQgaW5zdGFuY2VkIHN0YXRlIG1hY2hpbmUsIG9yIGFuIGVtcHR5XG4gICAgICogbGlzdCBpZiB0aGUgbmFtZSBpcyBpbnZhbGlkIG9yIHRoZSBzdGF0ZSBtYWNoaW5lIGlzIG5vdCBpbnN0YW5jZWRcbiAgICAgKiBAcGFyYW0gbmFtZSB0aGUgc3RhdGUgbWFjaGluZSBuYW1lXG4gICAgICogQHJldHVybnMgdGhlIGlucHV0cyBmb3IgdGhlIG5hbWVkIHN0YXRlIG1hY2hpbmVcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5zdGF0ZU1hY2hpbmVJbnB1dHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSdzIG5vdCBsb2FkZWQsIGVhcmx5IG91dCwgbm90aGluZyB0byBwYXVzZVxuICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlTWFjaGluZSA9IHRoaXMuYW5pbWF0b3Iuc3RhdGVNYWNoaW5lcy5maW5kKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLm5hbWUgPT09IG5hbWU7IH0pO1xuICAgICAgICByZXR1cm4gc3RhdGVNYWNoaW5lID09PSBudWxsIHx8IHN0YXRlTWFjaGluZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGVNYWNoaW5lLmlucHV0cztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJwbGF5aW5nU3RhdGVNYWNoaW5lTmFtZXNcIiwge1xuICAgICAgICAvLyBSZXR1cm5zIGEgbGlzdCBvZiBwbGF5aW5nIG1hY2hpbmUgbmFtZXNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlsZSdzIG5vdCBsb2FkZWQsIHdlIGdvdCBub3RoaW5nIHRvIHJldHVyblxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdG9yLnN0YXRlTWFjaGluZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnBsYXlpbmc7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJwbGF5aW5nQW5pbWF0aW9uTmFtZXNcIiwge1xuICAgICAgICAvLyBSZXR1cm5zIGEgbGlzdCBvZiBwbGF5aW5nIGFuaW1hdGlvbiBuYW1lc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgd2UgZ290IG5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucGxheWluZzsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcInBhdXNlZEFuaW1hdGlvbk5hbWVzXCIsIHtcbiAgICAgICAgLy8gUmV0dXJucyBhIGxpc3Qgb2YgcGF1c2VkIGFuaW1hdGlvbiBuYW1lc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgd2UgZ290IG5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICFhLnBsYXlpbmc7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5uYW1lOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJwYXVzZWRTdGF0ZU1hY2hpbmVOYW1lc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUmV0dXJucyBhIGxpc3Qgb2YgcGF1c2VkIG1hY2hpbmUgbmFtZXNcbiAgICAgICAgICogQHJldHVybnMgYSBsaXN0IG9mIHN0YXRlIG1hY2hpbmUgbmFtZXMgdGhhdCBhcmUgcGF1c2VkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgd2UgZ290IG5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3Iuc3RhdGVNYWNoaW5lc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuICFtLnBsYXlpbmc7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJpc1BsYXlpbmdcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgdHJ1ZSBpZiBhbnkgYW5pbWF0aW9uIGlzIHBsYXlpbmdcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuaXNQbGF5aW5nO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcImlzUGF1c2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHRydWUgaWYgYWxsIGluc3RhbmNlZCBhbmltYXRpb25zIGFyZSBwYXVzZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuaXNQYXVzZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUml2ZS5wcm90b3R5cGUsIFwiaXNTdG9wcGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHRydWUgaWYgbm8gYW5pbWF0aW9ucyBhcmUgcGxheWluZyBvciBwYXVzZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuaXNTdG9wcGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcImJvdW5kc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IGFydGJvYXJkLCBvciB1bmRlZmluZWQgaWYgdGhlIGFydGJvYXJkXG4gICAgICAgICAqIGlzbid0IGxvYWRlZCB5ZXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFydGJvYXJkID8gdGhpcy5hcnRib2FyZC5ib3VuZHMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gUml2ZS1nZW5lcmF0ZWQgZXZlbnRzXG4gICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gYSBSaXZlLWdlbmVyYXRlZCBldmVudFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgdG8gdW5zdWJzY3JpYmUgZnJvbVxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlbW92ZSh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbGwgbGlzdGVuZXJzIGZyb20gYW4gZXZlbnQgdHlwZSwgb3IgZXZlcnl0aGluZyBpZiBubyB0eXBlIGlzXG4gICAgICogZ2l2ZW5cbiAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiBldmVudCB0byB1bnN1YnNjcmliZSBmcm9tLCBvciBhbGwgdHlwZXMgaWZcbiAgICAgKiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS51bnN1YnNjcmliZUFsbCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlbW92ZUFsbCh0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSByZW5kZXJpbmcgbG9vcDsgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBwYXVzaW5nIGluIHRoYXQgaXQgZG9lc24ndFxuICAgICAqIGNoYW5nZSB0aGUgc3RhdGUgb2YgYW55IGFuaW1hdGlvbi4gSXQgc3RvcHMgcmVuZGVyaW5nIGZyb20gb2NjdXJyaW5nLiBUaGlzXG4gICAgICogaXMgZGVzaWduZWQgZm9yIHNpdHVhdGlvbnMgc3VjaCBhcyB3aGVuIFJpdmUgaXNuJ3QgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIFRoZSBvbmx5IHdheSB0byBzdGFydCByZW5kZXJpbmcgYWdhaW4gaXMgdG8gY2FsbCBgc3RhcnRSZW5kZXJpbmdgLlxuICAgICAqIEFuaW1hdGlvbnMgdGhhdCBhcmUgbWFya2VkIGFzIHBsYXlpbmcgd2lsbCBzdGFydCBmcm9tIHRoZSBwb3NpdGlvbiB0aGF0XG4gICAgICogdGhleSB3b3VsZCBoYXZlIGJlZW4gYXQgaWYgcmVuZGVyaW5nIGhhZCBub3QgYmVlbiBzdG9wcGVkLlxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLnN0b3BSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCAmJiB0aGlzLmZyYW1lUmVxdWVzdElkKSB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lUmVxdWVzdElkKTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVSZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHJlbmRlcmluZyBsb29wIGlmIGl0IGhhcyBiZWVuIHByZXZpb3VzbHkgc3RvcHBlZC4gSWYgdGhlXG4gICAgICogcmVuZGVyZXIgaXMgYWxyZWFkeSBhY3RpdmUsIHRoZW4gdGhpcyB3aWxsIGhhdmUgemVybyBlZmZlY3QuXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuc3RhcnRSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCAmJiAhdGhpcy5mcmFtZVJlcXVlc3RJZCkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZVJlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRyYXcuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJjb250ZW50c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiBhIFJpdmUgZmlsZTogdGhlIGFydGJvYXJkcywgYW5pbWF0aW9ucywgYW5kIHN0YXRlIG1hY2hpbmVzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJpdmVDb250ZW50cyA9IHtcbiAgICAgICAgICAgICAgICBhcnRib2FyZHM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWxlLmFydGJvYXJkQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFydGJvYXJkID0gdGhpcy5maWxlLmFydGJvYXJkQnlJbmRleChpKTtcbiAgICAgICAgICAgICAgICB2YXIgYXJ0Ym9hcmRDb250ZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYXJ0Ym9hcmQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW10sXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTWFjaGluZXM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnRib2FyZC5hbmltYXRpb25Db3VudCgpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFydGJvYXJkLmFuaW1hdGlvbkJ5SW5kZXgoaik7XG4gICAgICAgICAgICAgICAgICAgIGFydGJvYXJkQ29udGVudHMuYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcnRib2FyZC5zdGF0ZU1hY2hpbmVDb3VudCgpOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlTWFjaGluZSA9IGFydGJvYXJkLnN0YXRlTWFjaGluZUJ5SW5kZXgoayk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBzdGF0ZU1hY2hpbmUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IHRoaXMucnVudGltZS5TdGF0ZU1hY2hpbmVJbnN0YW5jZShzdGF0ZU1hY2hpbmUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRDb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGluc3RhbmNlLmlucHV0Q291bnQoKTsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnN0YW5jZS5pbnB1dChsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Q29udGVudHMucHVzaCh7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGlucHV0LnR5cGUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJ0Ym9hcmRDb250ZW50cy5zdGF0ZU1hY2hpbmVzLnB1c2goeyBuYW1lOiBuYW1lXzEsIGlucHV0czogaW5wdXRDb250ZW50cyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcml2ZUNvbnRlbnRzLmFydGJvYXJkcy5wdXNoKGFydGJvYXJkQ29udGVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJpdmVDb250ZW50cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIEVycm9yIG1lc3NhZ2UgZm9yIG1pc3Npbmcgc291cmNlIG9yIGJ1ZmZlclxuICAgIFJpdmUubWlzc2luZ0Vycm9yTWVzc2FnZSA9ICdSaXZlIHNvdXJjZSBmaWxlIG9yIGRhdGEgYnVmZmVyIHJlcXVpcmVkJztcbiAgICByZXR1cm4gUml2ZTtcbn0oKSk7XG5cbi8vIExvYWRzIFJpdmUgZGF0YSBmcm9tIGEgVVJJIHZpYSBmZXRjaC5cbnZhciBsb2FkUml2ZUZpbGUgPSBmdW5jdGlvbiAoc3JjKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXEsIHJlcywgYnVmZmVyO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJlcSA9IG5ldyBSZXF1ZXN0KHNyYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2gocmVxKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy5hcnJheUJ1ZmZlcigpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJ1ZmZlcl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuLy8gI2VuZHJlZ2lvblxuLy8gI3JlZ2lvbiB1dGlsaXR5IGZ1bmN0aW9uc1xuLypcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZW5zdXJlIGFuIG9iamVjdCBpcyBhIHN0cmluZyBhcnJheVxuICovXG52YXIgbWFwVG9TdHJpbmdBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtvYmpdO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvLyBJZiBvYmogaXMgdW5kZWZpbmVkLCByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICByZXR1cm4gW107XG59O1xuLy8gI2VuZHJlZ2lvblxuLy8gI3JlZ2lvbiB0ZXN0aW5nIHV0aWxpdGllc1xuLy8gRXhwb3J0cyB0byBvbmx5IGJlIHVzZWQgZm9yIHRlc3RzXG52YXIgVGVzdGluZyA9IHtcbiAgICBFdmVudE1hbmFnZXI6IEV2ZW50TWFuYWdlcixcbiAgICBUYXNrUXVldWVNYW5hZ2VyOiBUYXNrUXVldWVNYW5hZ2VyLFxufTtcbi8vICNlbmRyZWdpb25cblxufSkoKTtcblxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cml2ZS5kZXYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/rive-js/dist/rive.dev.js\n");

/***/ }),

/***/ "./src/assets/earth/pipe-bot-empty.svg":
/*!*********************************************!*\
  !*** ./src/assets/earth/pipe-bot-empty.svg ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PCEtLUdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMjYuMC4yLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKS0tPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCA0MDMuNiA2NDIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMy42IDY0MiIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc29kaXBvZGk6ZG9jbmFtZT0icGlwZS1ib3QtZW1wdHkuc3ZnIiBpbmtzY2FwZTp2ZXJzaW9uPSIxLjEuMiAoYjhlMjViZTgzMywgMjAyMi0wMi0wNSkiIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIiB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxkZWZzIGlkPSJkZWZzMTYwNyI+PGNsaXBQYXRoIGlkPSJTVkdJRF8wMDAwMDEzMjA1ODY3MjAxODAzNzQ5NjEwMDAwMDAwMDI4NTg1OTUzODQ0MzQ3MTgwM18iPjx1c2UgeGxpbms6aHJlZj0iI1NWR0lEXzFfLTIiIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIiBpZD0idXNlMjEwMCIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIvPjwvY2xpcFBhdGg+PHJlY3QgaWQ9IlNWR0lEXzFfLTIiIHg9IjE3Ni4zIiB5PSIyODQuMzk5OTkiIHdpZHRoPSI1Ny4wOTk5OTgiIGhlaWdodD0iNTkuMjk5OTk5Ii8+PGNsaXBQYXRoIGlkPSJTVkdJRF8wMDAwMDEzMjA1ODY3MjAxODAzNzQ5NjEwMDAwMDAwMDI4NTg1OTUzODQ0MzQ3MTgwM18tMCI+PHVzZSB4bGluazpocmVmPSIjU1ZHSURfMV8iIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIiBpZD0idXNlMjEwMC0zIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIi8+PC9jbGlwUGF0aD48cmVjdCBpZD0iU1ZHSURfMV8iIHg9IjE3Ni4zIiB5PSIyODQuMzk5OTkiIHdpZHRoPSI1Ny4wOTk5OTgiIGhlaWdodD0iNTkuMjk5OTk5Ii8+PC9kZWZzPjxzb2RpcG9kaTpuYW1lZHZpZXcgaWQ9Im5hbWVkdmlldzE2MDUiIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIgYm9yZGVyY29sb3I9IiM2NjY2NjYiIGJvcmRlcm9wYWNpdHk9IjEuMCIgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIgaW5rc2NhcGU6cGFnZWNoZWNrZXJib2FyZD0iMCIgc2hvd2dyaWQ9ImZhbHNlIiBpbmtzY2FwZTp6b29tPSIxLjIwNDA0OTgiIGlua3NjYXBlOmN4PSIyMDEuNDAzNjIiIGlua3NjYXBlOmN5PSIzMjEiIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTkyMCIgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAwMSIgaW5rc2NhcGU6d2luZG93LXg9Ii05IiBpbmtzY2FwZTp3aW5kb3cteT0iLTkiIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjEiIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTUzIi8+PHN0eWxlIHR5cGU9InRleHQvY3NzIiBpZD0ic3R5bGUxNDc0Ij4uc3Qwe2ZpbGw6I0RENUU3Qzt9DQoJLnN0MXtvcGFjaXR5OjAuMTU7ZmlsbDojNkI2QjZCO2VuYWJsZS1iYWNrZ3JvdW5kOm5ldyAgICA7fQ0KCS5zdDJ7ZmlsbDojNUU2MTYzO30NCgkuc3Qze2ZpbGw6I0MwQ0VEODt9DQoJLnN0NHtmaWxsOiNDNDU4NzI7fQ0KCS5zdDV7ZmlsbDojRUY3NTkyO30NCgkuc3Q2e2Rpc3BsYXk6bm9uZTt9DQoJLnN0N3tkaXNwbGF5OmlubGluZTt9DQoJLnN0OHtjbGlwLXBhdGg6dXJsKCNTVkdJRF8wMDAwMDEzMjc4ODExMTc5MTQ1NjA3ODU4MDAwMDAwMDMxNDgxODYyMjM1NjAyNjc1Ml8pO30NCgkuc3Q5e2ZpbGw6IzQzNDA3MDt9DQoJLnN0MTB7ZmlsbDojMzMzMzMzO30NCgkuc3QxMXtmaWxsOiNEMjMyNEI7fQ0KCS5zdDEye2ZpbGw6Izc0RkYzMzt9DQoJLnN0MTN7ZmlsbDojODVEMUZGO30NCgkuc3QxNHtmaWxsOiM5RTBFMzg7fQ0KCS5zdDE1e29wYWNpdHk6MC4zO2ZpbGw6IzAzOThGNDtlbmFibGUtYmFja2dyb3VuZDpuZXcgICAgO30NCgkuc3QxNntvcGFjaXR5OjAuMztmaWxsOiNGRkZGRkY7ZW5hYmxlLWJhY2tncm91bmQ6bmV3ICAgIDt9DQoJLnN0MTd7b3BhY2l0eTowLjU7ZmlsbDojNUU2MTYzO2VuYWJsZS1iYWNrZ3JvdW5kOm5ldyAgICA7fTwvc3R5bGU+PGcgaWQ9ImcyNTUzIj48cGF0aCBjbGFzcz0ic3QwIiBkPSJNIDM0NiwyNjguNiBIIDE1My44IGMgLTcuNSwwIC0xMy41LC02LjIgLTEzLjQsLTEzLjcgbCAwLjQsLTE1LjYgYyAwLC05IDcuMywtMTYuMiAxNi4yLC0xNi4yIGggNzIuNyBjIDExLjksMCAyMS42LC05LjcgMjEuNiwtMjEuNiB2IC03MSBMIDI0OS44LDE3LjIgSCAxNTEgdiA5NSBjIDAsNSAtMi4xLDkuNiAtNS40LDEyLjkgLTMuMywzLjQgLTcuOSw1LjQgLTEyLjksNS40IGggLTYyIGMgLTE2LjUsMCAtMjkuOSwxMy40IC0yOS45LDI5LjkgViAzNDIgYyAwLDEyLjYgMTAuMywyMi45IDIyLjksMjIuOSBoIDE5MS4yIGMgOC4yLDAgMTQuNyw2LjcgMTQuNiwxNC44IGwgLTAuNSwzMSBjIDAsOSAtNy4zLDE2LjIgLTE2LjIsMTYuMiBoIC04Mi43IGMgLTExLjksMCAtMjEuNiw5LjcgLTIxLjYsMjEuNiB2IDYzIGwgMS41LDk5LjUgOTguNywxMy44IHYgLTk1IGMgMCwtNSAyLjEsLTkuNiA1LjQsLTEyLjkgMy4zLC0zLjQgNy45LC01LjQgMTIuOSwtNS40IGggNzIgYyAxNi41LDAgMjkuOSwtMTMuNCAyOS45LC0yOS45IFYgMjkxLjQgYyAwLC0xMi43IC0xMC4yLC0yMi45IC0yMi45LC0yMi44IHogbSAtMTQxLjIsODcuNiBjIC0yMi4xLDAgLTQwLjEsLTE3LjkgLTQwLjEsLTQwLjEgMCwtMjIuMSAxNy45LC00MC4xIDQwLjEsLTQwLjEgMjIuMSwwIDQwLjEsMTcuOSA0MC4xLDQwLjEgMCwyMi4xIC0xNy45LDQwLjEgLTQwLjEsNDAuMSB6IiBpZD0icGF0aDIwNTMiLz48Y2lyY2xlIGNsYXNzPSJzdDEzIiBjeD0iMjA0LjgiIGN5PSIzMTYiIHI9IjMyLjI5OTk5OSIgaWQ9ImNpcmNsZTIxNDkiIHN0eWxlPSJvcGFjaXR5OjAuMztmaWxsOiMwMzk4ZjQ7ZW5hYmxlLWJhY2tncm91bmQ6bmV3Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0ibSAyMC45LDI4OS4xIC0wLjEsMjcgdiAtMjQuOCBjIDAsLTAuNyAwLC0xLjUgMC4xLC0yLjIgeiIgaWQ9InBhdGgyMDU1Ii8+PGcgaWQ9ImcyMDY1Ij48cGF0aCBjbGFzcz0ic3QyIiBkPSJNIDEyOS41LDE4LjcgViA5LjQgYyAwLC01LjIgNC42LC05LjQgMTAuMywtOS40IGggMTIyLjEgYyA1LjcsMCAxMC4zLDQuMiAxMC4zLDkuNCB2IDkuMiBjIDAsNS4yIC00LjYsOS40IC0xMC4zLDkuNCBIIDEzOS44IGMgLTUuNywwLjEgLTEwLjMsLTQuMSAtMTAuMywtOS4zIHoiIGlkPSJwYXRoMjA1NyIvPjxjaXJjbGUgY2xhc3M9InN0MyIgY3g9IjE1Ny4xMDAwMSIgY3k9IjE0IiByPSIzLjIiIGlkPSJjaXJjbGUyMDU5Ii8+PGNpcmNsZSBjbGFzcz0ic3QzIiBjeD0iMjAwLjgiIGN5PSIxNCIgcj0iMy4yIiBpZD0iY2lyY2xlMjA2MSIvPjxjaXJjbGUgY2xhc3M9InN0MyIgY3g9IjI0MS41IiBjeT0iMTQiIHI9IjMuMiIgaWQ9ImNpcmNsZTIwNjMiLz48L2c+PGcgaWQ9ImcyMDcxIj48cGF0aCBjbGFzcz0ic3Q0IiBkPSJtIDE0MS40LDI1OC40IGMgLTQwLjEsMCAtNjAuMiwwIC0xMDAuMywwIHYgLTE3IGMgNDAuMSwwIDYwLjIsMCAxMDAuMywwIDAsNS43IDAsMTEuNCAwLDE3IHoiIGlkPSJwYXRoMjA2NyIvPjxwYXRoIGNsYXNzPSJzdDUiIGQ9Im0gMjYuMSwyNDAuNCB2IDAgYyAwLC01LjMgNC4zLC05LjUgOS41LC05LjUgaCAxMTIuNSBjIDUuMywwIDkuNSw0LjMgOS41LDkuNSB2IDAgYyAwLDUuMyAtNC4zLDkuNSAtOS41LDkuNSBIIDM1LjYgYyAtNS4yLDAgLTkuNSwtNC4yIC05LjUsLTkuNSB6IiBpZD0icGF0aDIwNjkiLz48L2c+PHJlY3QgeD0iMTQ1LjgiIHk9IjU1Mi40MDAwMiIgY2xhc3M9InN0NCIgd2lkdGg9IjEwMC4yIiBoZWlnaHQ9IjE3IiBpZD0icmVjdDIwNzMiLz48ZyBpZD0iZzIwODMiPjxwYXRoIGNsYXNzPSJzdDIiIGQ9Im0gMjY5LjMsNjIxLjMgdiAxMC4zIGMgMCw1LjggLTQuNywxMC41IC0xMC41LDEwLjUgSCAxMzQuNyBjIC01LjgsMCAtMTAuNSwtNC43IC0xMC41LC0xMC41IHYgLTEwLjMgYyAwLC01LjggNC43LC0xMC41IDEwLjUsLTEwLjUgaCAxMjQuMiBjIDUuOCwwIDEwLjQsNC43IDEwLjQsMTAuNSB6IiBpZD0icGF0aDIwNzUiLz48Y2lyY2xlIGNsYXNzPSJzdDMiIGN4PSIyNDUuMyIgY3k9IjYyNi40MDAwMiIgcj0iMy41IiBpZD0iY2lyY2xlMjA3NyIvPjxjaXJjbGUgY2xhc3M9InN0MyIgY3g9IjE5Ni44IiBjeT0iNjI2LjQwMDAyIiByPSIzLjUiIGlkPSJjaXJjbGUyMDc5Ii8+PGNpcmNsZSBjbGFzcz0ic3QzIiBjeD0iMTUxLjYwMDAxIiBjeT0iNjI2LjQwMDAyIiByPSIzLjUiIGlkPSJjaXJjbGUyMDgxIi8+PC9nPjxwYXRoIGNsYXNzPSJzdDUiIGQ9Im0gMjU2LjQsNTUxIHYgMCBjIDAsNS4zIC00LjMsOS41IC05LjUsOS41IEggMTQ2LjYgYyAtNS4zLDAgLTkuNSwtNC4zIC05LjUsLTkuNSB2IDAgYyAwLC01LjMgNC4zLC05LjUgOS41LC05LjUgaCAxMDAuMyBjIDUuMywwIDkuNSw0LjIgOS41LDkuNSB6IiBpZD0icGF0aDIwODUiLz48ZyBpZD0iZzIwOTEiPjxwYXRoIGNsYXNzPSJzdDQiIGQ9Im0gMjY3LjcsNDE3LjMgYyAwLjYsLTIuNCAwLjYsLTEwLjkgMC42LC0xMC45IGggMTAwLjMgdiAxNyBIIDI2NC4zIGMgMCwwIDIuOSwtNC4yIDMuNCwtNi4xIHoiIGlkPSJwYXRoMjA4NyIvPjxwYXRoIGNsYXNzPSJzdDUiIGQ9Im0gMzgzLjYsNDAxLjYgdiAwIGMgMCw1LjMgLTQuMyw5LjUgLTkuNSw5LjUgSCAyNjEuNiBjIC01LjMsMCAtOS41LC00LjMgLTkuNSwtOS41IHYgMCBjIDAsLTUuMyA0LjMsLTkuNSA5LjUsLTkuNSBoIDExMi41IGMgNS4zLC0wLjEgOS41LDQuMiA5LjUsOS41IHoiIGlkPSJwYXRoMjA4OSIvPjwvZz48cG9seWdvbiBjbGFzcz0ic3Q0IiBwb2ludHM9IjE1MS4yLDc3LjMgMjUwLjQsNzcuMyAyNTQuNSw4OC41IDE0Ni43LDg4LjUgIiBpZD0icG9seWdvbjIwOTMiLz48cGF0aCBjbGFzcz0ic3Q1IiBkPSJtIDEzOC4zLDkwIHYgMCBjIDAsLTQuNiA0LjQsLTguMyA5LjgsLTguMyBoIDEwMyBjIDUuNCwwIDkuOCwzLjggOS44LDguMyB2IDAgYyAwLDQuNiAtNC40LDguMyAtOS44LDguMyBoIC0xMDMgYyAtNS41LDAgLTkuOCwtMy43IC05LjgsLTguMyB6IiBpZD0icGF0aDIwOTUiLz48ZyBpZD0iZzIxNzUiPjxwYXRoIGNsYXNzPSJzdDE1IiBkPSJtIDIwNC44LDI3NC4xIGMgLTI0LjQsMCAtNDQuMSwxOS44IC00NC4xLDQ0LjEgMCwyNC40IDE5LjgsNDQuMSA0NC4xLDQ0LjEgMjQuNCwwIDQ0LjEsLTE5LjggNDQuMSwtNDQuMSAwLjEsLTI0LjQgLTE5LjcsLTQ0LjEgLTQ0LjEsLTQ0LjEgeiBtIDAsNzYuNCBjIC0xNy44LDAgLTMyLjMsLTE0LjQgLTMyLjMsLTMyLjMgMCwtMTcuOCA3LjksLTM1LjMgMzIuMywtMzUuMyAyNiwwIDMyLjMsMTcuNCAzMi4zLDM1LjMgMCwxNy44IC0xNC40LDMyLjMgLTMyLjMsMzIuMyB6IiBpZD0icGF0aDIxNTUiLz48cGF0aCBjbGFzcz0ic3QyIiBkPSJtIDIwNC44LDI3MS44IGMgLTI0LjQsMCAtNDQuMSwxOS44IC00NC4xLDQ0LjEgMCwyNC40IDE5LjgsNDQuMSA0NC4xLDQ0LjEgMjQuNCwwIDQ0LjEsLTE5LjggNDQuMSwtNDQuMSAwLjEsLTI0LjMgLTE5LjcsLTQ0LjEgLTQ0LjEsLTQ0LjEgeiBtIDAsNzYuNCBjIC0xNy44LDAgLTMyLjMsLTE0LjQgLTMyLjMsLTMyLjMgMCwtMTcuOCAxNC40LC0zMi4zIDMyLjMsLTMyLjMgMTcuOCwwIDMyLjMsMTQuNCAzMi4zLDMyLjMgMCwxNy45IC0xNC40LDMyLjMgLTMyLjMsMzIuMyB6IiBpZD0icGF0aDIxNTciLz48Y2lyY2xlIGNsYXNzPSJzdDMiIGN4PSIyNDMiIGN5PSIzMTYiIHI9IjMuNSIgaWQ9ImNpcmNsZTIxNTkiLz48Y2lyY2xlIGNsYXNzPSJzdDMiIGN4PSIyMzEuOCIgY3k9IjI4OSIgcj0iMy41IiBpZD0iY2lyY2xlMjE2MSIvPjxjaXJjbGUgY2xhc3M9InN0MyIgY3g9IjIwNC44IiBjeT0iMjc3Ljg5OTk5IiByPSIzLjUiIGlkPSJjaXJjbGUyMTYzIi8+PGNpcmNsZSBjbGFzcz0ic3QzIiBjeD0iMTc3Ljg5OTk5IiBjeT0iMjg5IiByPSIzLjUiIGlkPSJjaXJjbGUyMTY1Ii8+PGNpcmNsZSBjbGFzcz0ic3QzIiBjeD0iMTY2LjciIGN5PSIzMTYiIHI9IjMuNSIgaWQ9ImNpcmNsZTIxNjciLz48Y2lyY2xlIGNsYXNzPSJzdDMiIGN4PSIxNzcuODk5OTkiIGN5PSIzNDMiIHI9IjMuNSIgaWQ9ImNpcmNsZTIxNjkiLz48Y2lyY2xlIGNsYXNzPSJzdDMiIGN4PSIyMDQuOCIgY3k9IjM1NC4xMDAwMSIgcj0iMy41IiBpZD0iY2lyY2xlMjE3MSIvPjxjaXJjbGUgY2xhc3M9InN0MyIgY3g9IjIzMS44IiBjeT0iMzQzIiByPSIzLjUiIGlkPSJjaXJjbGUyMTczIi8+PC9nPjwvZz48L3N2Zz4=";

/***/ }),

/***/ "./src/assets/earth/pipe-bot-filled.svg":
/*!**********************************************!*\
  !*** ./src/assets/earth/pipe-bot-filled.svg ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "images/design/pipe-bot-filled.d26b88.svg";

/***/ }),

/***/ "./src/assets/medow/spaceship.svg":
/*!****************************************!*\
  !*** ./src/assets/medow/spaceship.svg ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "images/design/spaceship.ffba8b.svg";

/***/ }),

/***/ "./src/assets/medow/submarine.svg":
/*!****************************************!*\
  !*** ./src/assets/medow/submarine.svg ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTg5LjM3IDI5MyI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOm5vbmU7fS5jbHMtMntmaWxsOiMzYTNhM2E7fS5jbHMtM3tmaWxsOiM1ZWJhZTE7fS5jbHMtNHtmaWxsOiNlNWJhMDM7fS5jbHMtNXtjbGlwLXBhdGg6dXJsKCNjbGlwLXBhdGgpO30uY2xzLTZ7ZmlsbDojZmZkYTAzO30uY2xzLTd7ZmlsbDojYzdjM2I4O308L3N0eWxlPjxjbGlwUGF0aCBpZD0iY2xpcC1wYXRoIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSI+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNjYuNjQsMjI2LjM2QzM4LjM5LDIyNi4zNiwwLDE5MC4yLDAsMTExLDAsNDkuNywyNS42MiwwLDY5Ljg5LDBjNDAuMTgsMCw2Ni43NCw0OS43LDY2Ljc0LDExMVM5NSwyMjYuMzYsNjYuNjQsMjI2LjM2WiIvPjwvY2xpcFBhdGg+PC9kZWZzPjxnIGlkPSJMYXllcl8yIiBkYXRhLW5hbWU9IkxheWVyIDIiPjxnIGlkPSJzdWJtYXJpbmUiPjxnIGlkPSJGYW4iPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTYxLjgyLDI1Mi43M2MtNy42NC0yLjQtMjAuODMtNi44NC0yNS4xNy00LjI4cy0zLjQ5LDExLC4xNiwxMi4zOGM1LjU0LDIuMDksMjAuNy0zLjExLDI1LjA2LTQuNDFDNjEuODMsMjUzLjY5LDYxLjgyLDI1Mi43Myw2MS44MiwyNTIuNzNaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTY4LjI1LDI1NS42M2M3LjY0LDIuNCwyMC44Myw2Ljg0LDI1LjE3LDQuMjhzMy40OS0xMS0uMTYtMTIuMzhjLTUuNTUtMi4wOS0yMC43LDMuMS0yNS4wNiw0LjQxQzY4LjI0LDI1NC42Nyw2OC4yNSwyNTUuNjMsNjguMjUsMjU1LjYzWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAzMC41NSkiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik02NS4zLDI2MC4yNEE0LjI3LDQuMjcsMCwwLDEsNjEsMjU2bC0uMjctMjAuNDFhNC4yOCw0LjI4LDAsMCwxLDQuMjItNC4zM2gwYTQuMjcsNC4yNywwLDAsMSw0LjMyLDQuMjJsLjI2LDIwLjRhNC4yNyw0LjI3LDAsMCwxLTQuMjEsNC4zM1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMzAuNTUpIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNzguNTksMjIzLjc5czEuNTEsMTQuNTUtMi40NCwxNi4xNS0xOS43LDIuNDctMjMuODUtLjhDNDguNjQsMjM2LjI2LDUxLDIyMi44Myw1MSwyMjIuODNaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTczLDI0OGMuMDgsMy41Ni42LDExLjA1LTEuMTgsMTNzLTExLjUsMi4xNi0xMy44OS0uODNjLTEuNTktMi0xLjI3LTguNzctMS0xMS45MmExLjcyLDEuNzIsMCwwLDEsMS44MS0xLjY3bDEyLjcyLS4xNkExLjQzLDEuNDMsMCwwLDEsNzMsMjQ4WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAzMC41NSkiLz48L2c+PHJlY3QgY2xhc3M9ImNscy00IiB4PSIxNjUuOTgiIHk9IjExMC41NiIgd2lkdGg9IjQuOSIgaGVpZ2h0PSIyMC41OCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjg5LjI5IC0xNy4wMikgcm90YXRlKDkwKSIvPjxjaXJjbGUgY2xhc3M9ImNscy0yIiBjeD0iMTgxLjUyIiBjeT0iMTUxLjQxIiByPSI1LjE3Ii8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNMTgyLjEsOTJoLTcuNjFhMy43OSwzLjc5LDAsMCwwLTMuNzksMy43OXYyLjY5YTEuOSwxLjksMCwwLDEtMS44OSwxLjlIMTU4LjE0djkuOTRoMjEuNjVhNi4wOSw2LjA5LDAsMCwwLDYuMDktNi4wOVY5NS43OUEzLjc5LDMuNzksMCwwLDAsMTgyLjEsOTJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSIvPjxyZWN0IGNsYXNzPSJjbHMtMiIgeD0iMTc1LjI1IiB5PSI4MS41NCIgd2lkdGg9IjYuOTQiIGhlaWdodD0iMjEuMyIgcng9IjIuOTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3MC45MSAtNTUuOTgpIHJvdGF0ZSg5MCkiLz48ZyBjbGFzcz0iY2xzLTUiPjxwYXRoIGNsYXNzPSJjbHMtNiIgZD0iTTY2LjY0LDIyNi4zNkMzOC4zOSwyMjYuMzYsMCwxOTAuMiwwLDExMSwwLDQ5LjcsMjUuNjIsMCw2OS44OSwwYzQwLjE4LDAsNjYuNzQsNDkuNyw2Ni43NCwxMTFTOTUsMjI2LjM2LDY2LjY0LDIyNi4zNloiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMzAuNTUpIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNMTI0LjY3LDIwLjI5cy01MC44NSwyMy44MS0xMDkuNDIsMGwzOC01MC44NFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMzAuNTUpIi8+PC9nPjxjaXJjbGUgY2xhc3M9ImNscy0yIiBjeD0iNjguMzIiIGN5PSIxMTEuNyIgcj0iMjguMDMiLz48Y2lyY2xlIGNsYXNzPSJjbHMtMyIgY3g9IjY4LjMyIiBjeT0iMTExLjciIHI9IjE2LjIyIi8+PGNpcmNsZSBjbGFzcz0iY2xzLTciIGN4PSI5MC4yOSIgY3k9IjExMS43IiByPSIxLjg0Ii8+PGNpcmNsZSBjbGFzcz0iY2xzLTciIGN4PSI2OC4zMiIgY3k9Ijg5Ljg1IiByPSIxLjg0Ii8+PGNpcmNsZSBjbGFzcz0iY2xzLTciIGN4PSI2OC4zMiIgY3k9IjEzMy41NiIgcj0iMS44NCIvPjxjaXJjbGUgY2xhc3M9ImNscy03IiBjeD0iNDYuMzUiIGN5PSIxMTEuNyIgcj0iMS44NCIvPjxjaXJjbGUgY2xhc3M9ImNscy0yIiBjeD0iNjguMzIiIGN5PSIxNzcuNzMiIHI9IjI4LjAzIi8+PGNpcmNsZSBjbGFzcz0iY2xzLTMiIGN4PSI2OC4zMiIgY3k9IjE3Ny43MyIgcj0iMTYuMjIiLz48Y2lyY2xlIGNsYXNzPSJjbHMtNyIgY3g9IjkwLjI5IiBjeT0iMTc3LjczIiByPSIxLjg0Ii8+PGNpcmNsZSBjbGFzcz0iY2xzLTciIGN4PSI2OC4zMiIgY3k9IjE1NS44OCIgcj0iMS44NCIvPjxjaXJjbGUgY2xhc3M9ImNscy03IiBjeD0iNjguMzIiIGN5PSIxOTkuNTkiIHI9IjEuODQiLz48Y2lyY2xlIGNsYXNzPSJjbHMtNyIgY3g9IjQ2LjM1IiBjeT0iMTc3LjczIiByPSIxLjg0Ii8+PHBhdGggY2xhc3M9ImNscy02IiBkPSJNMTI2LjYsNjcuOTRzMzEuMTUsOS45MSwzMy4xMywxOC40OWMxLjQ0LDYuMjMuNzksMzYuMzYuMzMsNTIuNDRBMTAuNDUsMTAuNDUsMCwwLDEsMTQ5LjYxLDE0OUgxMjMuNDJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSIvPjxjaXJjbGUgY2xhc3M9ImNscy0zIiBjeD0iMTQyLjAyIiBjeT0iMTE5LjI3IiByPSI2LjEyIi8+PGNpcmNsZSBjbGFzcz0iY2xzLTMiIGN4PSIxNDIuMDIiIGN5PSIxNDAuODgiIHI9IjYuMTIiLz48Y2lyY2xlIGNsYXNzPSJjbHMtMyIgY3g9IjE0Mi4wMiIgY3k9IjE2My44NCIgcj0iNi4xMiIvPjxwYXRoIGNsYXNzPSJjbHMtNiIgZD0iTTEwMC41NSwyMDUuMjJjNS42NywzLjYsMTYuMSw5LjQ2LDIzLjQ3LDEzLjc1LDQuNjQsMi42OSw1LjMxLDYsNC44NCw4LjQ3LTEuMDYsNS40My0zLjA5LDE1Ljg2LTQuMDgsMjAuOTEtMS4yOCw2LjYxLTQuNjksNS05LjE4LDMuNzlhNjAuNTgsNjAuNTgsMCwwLDEtOS44NC0zLjU1Yy0zLjMyLTEuNjktNC43OS00LjMyLTMuOC05LjRsMi4yMi0xMS4zN2MuODUtNC4zNy0xLjY2LTUtNC41NS03LTMuNDEtMi4yOS03LjgtNC0xMC01LjA2QzkzLjg1LDIxMiwxMDAuNTUsMjA1LjIyLDEwMC41NSwyMDUuMjJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTExOS4xMywyMjEuNDRjNC42NCwyLjcsNS4zMSw2LjA1LDQuODQsOC40Ny0xLjA2LDUuNDQtMy4wOSwxNS44Ny00LjA4LDIwLjkxYTExLjY3LDExLjY3LDAsMCwxLS42MywyLjI1YzIuNjUuNDksNC42MS0uMDYsNS41Mi00LjcyLDEtNSwzLTE1LjQ4LDQuMDgtMjAuOTEuNDctMi40My0uMi01Ljc4LTQuODQtOC40Ny03LjM3LTQuMjktMTcuOC0xMC4xNS0yMy40Ny0xMy43NSwwLDAtMS40NCwxLjQ3LTMuNCwzLjQxQzEwMywyMTIuMjUsMTEyLjM2LDIxNy41MSwxMTkuMTMsMjIxLjQ0WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAzMC41NSkiLz48cGF0aCBjbGFzcz0iY2xzLTYiIGQ9Ik0yOC40MywyMDUuMjJDMjIuNzYsMjA4LjgyLDEyLjMzLDIxNC42OCw1LDIxOWMtNC42NCwyLjY5LTUuMyw2LTQuODMsOC40NywxLjA2LDUuNDMsMy4wOSwxNS44Niw0LjA3LDIwLjkxLDEuMjksNi42MSw0LjcsNSw5LjE4LDMuNzlhNjAuMjQsNjAuMjQsMCwwLDAsOS44NC0zLjU1YzMuMzMtMS42OSw0Ljc5LTQuMzIsMy44LTkuNC0uNzEtMy42OS0xLjQ0LTcuNDItMi4yMS0xMS4zNy0uODUtNC4zNywxLjY1LTUsNC41NS03LDMuNC0yLjI5LDcuOC00LDEwLTUuMDZDMzUuMTQsMjEyLDI4LjQzLDIwNS4yMiwyOC40MywyMDUuMjJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTkuODUsMjIxLjQ0Yy00LjY0LDIuNy01LjMsNi4wNS00LjgzLDguNDdsNC4wNywyMC45MWExMi4zOCwxMi4zOCwwLDAsMCwuNjQsMi4yNWMtMi42NS40OS00LjYyLS4wNi01LjUzLTQuNzItMS01LTMtMTUuNDgtNC4wNy0yMC45MUMtLjM0LDIyNSwuMzIsMjIxLjY2LDUsMjE5YzcuMzctNC4yOSwxNy44LTEwLjE1LDIzLjQ3LTEzLjc1LDAsMCwxLjQ0LDEuNDcsMy40MSwzLjQxQzI2LDIxMi4yNSwxNi42MiwyMTcuNTEsOS44NSwyMjEuNDRaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSIvPjxnIGlkPSJfMSIgZGF0YS1uYW1lPSIxIj48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0xMTIuNjksMjYuMjljMS44OC0xLjM1LTEuNjItOC45LTQtNy42MUM5Ni44LDI3LjExLDY3LjQ5LDM4LjU2LDI2LDI0Yy0zLjYyLTEuMjYtNy40OCw1LjkyLTQuODEsNy4xMkM2NCw0NS44OSw5NS44NCwzNi4zMywxMTIuNjksMjYuMjlaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSIvPjxwYXRoIGNsYXNzPSJjbHMtNyIgZD0iTTEwNS4zOSwyN0ExLjY2LDEuNjYsMCwxLDEsMTA3LDI1LjM1LDEuNjYsMS42NiwwLDAsMSwxMDUuMzksMjdaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDMwLjU1KSIvPjxwYXRoIGNsYXNzPSJjbHMtNyIgZD0iTTkwLjIzLDMzLjE1YTEuNjUsMS42NSwwLDAsMS0xLjY3LTEuNjMsMS42NiwxLjY2LDAsMSwxLDEuNjcsMS42M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMzAuNTUpIi8+PHBhdGggY2xhc3M9ImNscy03IiBkPSJNNzAuMiwzNi41OWExLjY2LDEuNjYsMCwxLDEsMS42My0xLjY3QTEuNjYsMS42NiwwLDAsMSw3MC4yLDM2LjU5WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAzMC41NSkiLz48cGF0aCBjbGFzcz0iY2xzLTciIGQ9Ik01MC4yNywzNS43M2ExLjY2LDEuNjYsMCwxLDEsMS42My0xLjY4QTEuNjUsMS42NSwwLDAsMSw1MC4yNywzNS43M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMzAuNTUpIi8+PHBhdGggY2xhc3M9ImNscy03IiBkPSJNMzIuMTksMzEuNDdhMS42NiwxLjY2LDAsMCwxLDAtMy4zMSwxLjY2LDEuNjYsMCwxLDEsMCwzLjMxWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAzMC41NSkiLz48L2c+PC9nPjwvZz48L3N2Zz4=";

/***/ }),

/***/ "./src/assets/sky/star-grey.svg":
/*!**************************************!*\
  !*** ./src/assets/sky/star-grey.svg ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgNDEuNzggMzkuODEiPjxkZWZzPjxzdHlsZT4uY2xzLTF7b3BhY2l0eTowLjQ7fS5jbHMtMnttYXNrOnVybCgjbWFzayk7fS5jbHMtM3tmaWxsOiNlNmZiZmY7fS5jbHMtNHtmaWx0ZXI6dXJsKCNsdW1pbm9zaXR5LW5vY2xpcCk7fTwvc3R5bGU+PGZpbHRlciBpZD0ibHVtaW5vc2l0eS1ub2NsaXAiIHg9Ii0yLjY2IiB5PSItMi41NyIgd2lkdGg9IjQ3IiBoZWlnaHQ9IjQ1IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+PGZlRmxvb2QgZmxvb2QtY29sb3I9IiNmZmYiIHJlc3VsdD0iYmciLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJiZyIvPjwvZmlsdGVyPjxtYXNrIGlkPSJtYXNrIiB4PSItMi42NiIgeT0iLTIuNTciIHdpZHRoPSI0NyIgaGVpZ2h0PSI0NSIgbWFza1VuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PGcgY2xhc3M9ImNscy00Ij48aW1hZ2Ugd2lkdGg9IjQ3IiBoZWlnaHQ9IjQ1IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMi42NiAtMi41NykiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQzhBQUFBdENBWUFBQUErN3pLbkFBQUFDWEJJV1hNQUFBc1NBQUFMRWdIUzNYNzhBQUFHT1VsRVFWUm9ROVdaYTAvYlNCU0dIOTl2Y1dJSWwxWkVxRlhWRC8zL1A2YWdDZ29DSkZCRFNHekg5dmk2SDZxWmtpM1VNUXVyM1ZlS0NNSm4vTXpNdWMyZ0FSMy9VK2w5RC95WHRUVzhwbWxvbXRiMzJMK3FyZUhoNXdSMGZaREoxdEoxSFYzWEJ5MlEyZmVBVk5kMUdJYUJZUmgwWFVmYnR0UjEzV2UybFI2UE8yVE1yZUdsTE12Q05FMjZycU1vQ29RUWZTWi9sR1ZaT0k0RGdCQ0NydHMrZnd5R053d0R6L1BVenppT3liS3N6K3czdWE2TDY3bzRqb09tYVFnaEtNdXl6MnhEZytEcnVxWnRXMHpUeFBkOU5FMGpERVBXNnpWSmtwQWtTZDhRQUVSUlJCUkZPSTVEMTNWVVZVVlZWYlJ0MjJlNm9VSHc4TlAzVGRQRTh6dzh6MFBYZGVxNkpzc3lmdno0d2UzdDdiTzIwK21VS0lxWVRDYTRyZ3RBV1piRWNmeWlHQm9NWDljMVhkZmhPQTVoR09MN1BvWmhVTmMxQndjSHpHWXo4anhudFZweGZYME53R3cyWTNkM2wrbDBpdS83Q2x3SVFaSWs1SGsreU5lbEJzTVhSVUZkMXhpR1FSQUVSRkdrSnRBMERVSUloQkJrV2NhWEwxOEFtRXdtakVZalBNL0RzaXdBcXFvaWptT3FxbEsvRDlWZ2VJQ21hZEIxSGMvemxCdDRub2RwbXVydjBvOEJiTnZHc2l5VkRxdXFJazFUQU9JNHBxNXIxdXYxcys5N1RpK0NMNHFDdG0yeGJadlJhTVIwT2xVdVpKb21tcWFwV2dDbzRpUDlPazFUTE10Q0NJSHJ1b01LMDJPOUNQN2g0WUd5TERGTmt5QUltRXdtVEtkVFJxTVJydXRpbXVaR0plNjZqcTdyS011U29paVV6NmRwaXVNNGFzZUc2bVZXL0Z4TjEzVVYvTTdPam5JZjI3WTNTbjNYZFNvZXNpeEQxM1dFRU9wWnd6QjYzdmEwWGd6dit6Nis3ek1halFqRGtQRjR6R1F5d2ZkOVZZVWx2SFFYSVFTV1pkRTBEV21hRWdTQjJxbVg2RVZXeDhmSEhCd2NFRVVSNC9GWVRTQUlBdVgzZjIvZ21xWlJrRVZSS0hEWGRWVUdHcW9Yd1I4ZUhySzN0MGNVUllSaHFOS2dUSVZQQmFCaEdOaTJUVjNYNmxrNVdkLzNuM2hMdndiM3Q3UFpqUGZ2M3pPZFRwbE1KbW9GWmVEOUtYUElDZGkyamV1NmVKNUhHSWJzN2UxeGZIejhyTjF6R2d4L2NIREEvdjQrVVJReEdvMVV4WlI1dkUrNnJtT2FKclp0NC9zK1lSaXl1N3ZMNGVGaG4rbHZHZ1IvZkh6TTBkRVIwK21VOFhpTTcvdll0bzFwbWx1Qnc2OERqWnhBRUFUczdlMXhkSFRFaHc4ZitzdzN0SlhQeTYzOStQR2pDbFFKYmhqR2k0cU1wbW1xd1F2RGtNUERRejU5K29TdTY4em5jK0k0N2h1aUh6NE1ROTY5ZTZlQ2RES1piQlNXdG0xcG1vYW1hZWk2N284VGtTZWx4OC9MZWhHR0lmdjcrMVJWcGRxSXZoYjdXWGpMc2dpQ2dOM2RYWFoyZHBTYnlLQ3M2NXF5TEJGQ2tPZTVLa3kyYlQ4NUFkblRGRVZCbnVmcUZGWlYxVWFiSFlZaGVaNnJzOE9mZXA0bjRTM0xJZ3hEbFFabElaRXJsK2M1YVpwdUJLcGNyYTdyc0N4cm84STJUYk5oRjhjeHE5V0sxV3BGa2lSa1dhWW1ZUmdHanVPb2poVit0czVQOWZxL3dSdUdnZXU2S2hBQlZSMnpMRk9CS1lFZWY4cXlwSzVyTlNsZDE5V0tDeUZJMDVUVmFzVmlzV0ErbnpPZnoxa3NGaXdXQzFhckZldjFHaUVFVGRPZ2FacmFmZmpWWWp5V2dwZjNNbzk5dVN4TDFTSEtMVStTaERpT2VYaDRZTGxjcXBYTDgxeWRRNE1nd0hFY0JWK1dKZXYxV29IZjNkMnB6OFBEQTJtYWtxWXBXWmFSWlJsRlVaQmxtWW9QbWFIYXR0MDR0UHkyOHJLQnFxb0swelF4VFZQMUt2SzdiZHQ0bnNkNFBHWTJtN0ZjTGxtdjF4UkZRVkVVS3Y4YmhrSGJ0bXJTOS9mMzNOM2RjWE56dytYbEpWZFhWK29BWDFXVjJybXlMTldaUUFiM1UrZGJCUy85ZGVnaCtQUG56eVJKb2s1UVFnaWlLQ0lJQWdVdlYvMzI5cGFibXh2T3pzNzQrdlVycDZlbmZjUC9VYjJwc2svZnZuMVRMaWJoMStzMVlSaGltcWJxSU9mek9UYzNONXlmbjNOeWNzTDUrWG5mMEwzNngvQUFaMmRuS3JWSnR3dkRFTnUyS2N1U0pFbTR1N3ZqKy9mdm5KNmVjbkZ4MFRma1Zub1ZlSURMeTBzVjlGVlZzYk96ZzJWWlZGWEZjcm5rK3ZxYWs1TVRMaTh2KzRiYVdxOEdEM0J4Y2FFQ3RTeExCWDkvZjgvVjFkV3Jnc01ydzhQUDgrMW9OS0p0V3dXL1dDeFlMcGQ5cG9QMTZ2Q3lCc2dpSTkxbW0wWnJxRjRkWHFaRlhkZHhISWV5TEZrdWwrcWU1algxNnZBQVdaWmgyN2E2ZUhySkxmSTJlaE40bWV0bDFmeW5kL2pQU2VPTi9oc29telBaRTcyRjNtVGw0ZGR0OHQ4N3dkZlVtOEZMNktHOTBoQzltZHNBcXAxK0s3MHAvRnRyME5YSGYwMy9hL2kvQUEyd28zY2JFb3I5QUFBQUFFbEZUa1N1UW1DQyIvPjwvZz48L21hc2s+PC9kZWZzPjxnIGlkPSJMYXllcl8yIiBkYXRhLW5hbWU9IkxheWVyIDIiPjxnIGlkPSJ3aGl0ZV9zdGFycyIgZGF0YS1uYW1lPSJ3aGl0ZSBzdGFycyI+PGcgY2xhc3M9ImNscy0xIj48ZyBjbGFzcz0iY2xzLTIiPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTM0LC4xNSwzMC43Miw5Ljg5YTcuODUsNy44NSwwLDAsMCwyLjgsOC43OWw4LjI2LDYuMDhMMzEuNTIsMjQuN0E3Ljg0LDcuODQsMCwwLDAsMjQsMzAuMDdMMjAuOCwzOS44MSwxNy42OSwzMGE3Ljg1LDcuODUsMCwwLDAtNy40My01LjQ3TDAsMjQuNTFsOC4zMy02YTcuODUsNy44NSwwLDAsMCwyLjkxLTguNzZMOC4xMiwwbDguMjcsNi4wOGE3Ljg1LDcuODUsMCwwLDAsOS4yMiwwWiIvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=";

/***/ }),

/***/ "./src/assets/sky/star-white.svg":
/*!***************************************!*\
  !*** ./src/assets/sky/star-white.svg ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMi43OSAxMi4xNiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiNlNmZiZmY7fTwvc3R5bGU+PC9kZWZzPjxnIGlkPSJMYXllcl8yIiBkYXRhLW5hbWU9IkxheWVyIDIiPjxnIGlkPSJ3aGl0ZV9zdGFycyIgZGF0YS1uYW1lPSJ3aGl0ZSBzdGFycyI+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNi4zOSwwbDEsM0EyLjQyLDIuNDIsMCwwLDAsOS42NSw0LjY1aDMuMTRMMTAuMjUsNi40OWEyLjQyLDIuNDIsMCwwLDAtLjg4LDIuNjlsMSwzTDcuOCwxMC4zMmEyLjM3LDIuMzcsMCwwLDAtMi44MiwwTDIuNDQsMTIuMTZsMS0zYTIuNDEsMi40MSwwLDAsMC0uODctMi42OUwwLDQuNjVIMy4xNEEyLjQsMi40LDAsMCwwLDUuNDIsM1oiLz48L2c+PC9nPjwvc3ZnPg==";

/***/ }),

/***/ "./src/assets/sky/star-yellow.svg":
/*!****************************************!*\
  !*** ./src/assets/sky/star-yellow.svg ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNC44OCAxNC44MiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiNmY2JkMDA7fTwvc3R5bGU+PC9kZWZzPjxnIGlkPSJMYXllcl8yIiBkYXRhLW5hbWU9IkxheWVyIDIiPjxnIGlkPSJ5ZWxsb3dfc3RhcnMiIGRhdGEtbmFtZT0ieWVsbG93IHN0YXJzIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik01LjE4LjI3LDUuOTQsMWE0LjQ5LDQuNDksMCwwLDAsNS4yMy43NWwuOTQtLjQ5QS45NC45NCwwLDAsMSwxMy40LDIuNTFsLS40NywxYTQuNDksNC40OSwwLDAsMCwuOSw1LjIxbC43Ni43NEEuOTQuOTQsMCwwLDEsMTMuOCwxMWwtMS4wNS0uMTVhNC41MSw0LjUxLDAsMCwwLTQuNjgsMi40N2wtLjQ2Ljk1QTEsMSwwLDAsMSw1LjgzLDE0bC0uMTgtMUE0LjQ5LDQuNDksMCwwLDAsMS44Niw5LjMxbC0xLS4xNUExLDEsMCwwLDEsLjUsNy4zOWwuOTQtLjQ5QTQuNDgsNC40OCwwLDAsMCwzLjc3LDIuMTVsLS4xOC0xQTEsMSwwLDAsMSw1LjE4LjI3WiIvPjwvZz48L2c+PC9zdmc+";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;